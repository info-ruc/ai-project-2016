D-SCRIPT:  A  COMPUTATIONAL  THEORY  OF  DESCRIPTIONS 

Session  8  Formalisms  for 
A r t i f i c i al  Intelligence 

Robert  C.  Moore 

M a s s a c h u s e t ts 

I n s t i t u te  of  T e c h n o l o gy 

C a m b r i d g e,  M a s s a c h u s e t ts 

Abstract 

language 

in  a r t i f i c i al 

This  paper  describes  D-SCRIPT,  a 
representing  knowledge 

the  representation  of  statements 

formalism  for  d e s c r i p t i o n s,  which 

f or 
I n t e l l i g e n ce  programs.  D-SCRIPT  contains  a 
powerful 
permits 
are  problematical 
P a r t i c u l ar  a t t e n t i on 
opaque  contexts, 
about  knowledge. 
system  f or 

time  c o n t e x t s,  and  knowledge 
The  design  of  a  deductive 
is  also  considered. 

for  other  systems. 

to  problems  of 

language 

is  paid 

that 

t h is 

1.2  Problems 

In  Representing  Knowledge 

Before  presenting  the  d e t a i ls  of  D-

t ry 
It 
Is 

to  give  some 
Idea  of  the 
to  solve.  A 
Is  designed 
that  of  representing  opaque 
is  one  which  does 

SCRIPT,  we  w i ll 
type  of  problem 
c l a s s ic  problem 
contexts.  An  opaque  context 
not  allow  s u b s t i t u t i on  of 
equivalent  expressions  or  does  not  allow 
e x i s t e n t i al  q u a n t i f i c a t i o n. 
For  example 
verb  "want"  creates  an  opaque  c o n t e x t: 

r e f e r e n t i a l ly 

the 

1. 

Int roduction 

(1.1)  John  wants 

to  marry 

the  p r e t t i e st  g i r l. 

1.1  Ways  of  Representing;  Knowledge 

is 

to 

I s, 

Methods  advocated 
in  a r t i f i c i a ll 

representing 

for 
i n t e l l i g e n ce  programs 

But 

t h is 

that 

that 

from  the 

That 

Included 

( Q u i l l i a n, 

(McCarthy, 

the  notion  of 

the  basic  data 

In  each  system 

logical  statements 

knowledge 
have 
Sandewall),  semantic  networks 
Schank),  and  procedures  (Hewitt,  Sussman  and 
McDermott),  All 
these  approaches  shpre  one 
fundamental  concept, 
p r e d i c a t i o n. 
s t r u c t u re 
representation  of  a  predicate  applied 
In 
o b j e c t s. 
are  more  or 
t h is  basic 
idea  must  be  extended  to  handle  problems  of 
q u a n t i f i c a t i on  and  knowledge  about  knowledge. 
Mere  the  systems  do  d i f f e r.  We  w i ll  argue, 
though, 
d e s c r i p t i ve  apparatus  used 
the  p a r t i c u l ar 
systems  being  compared, 
than 
from  an 
inherent  advantage  o f,  say,  procedures  over 
d e c l a r a t i v es  or  vice  versa. 

t h is 
less  equivalent. 

these  d i f f e r e n c es  r e s u lt 

the  various  systems 

in 
rather 

respect, 

Is  some 

Advocates  of PLANNER ( e . g.  Winograd,  p. 
the  predicate  calculus 

represent  how  a  piece  of  knowledge 
true  only  of 

2153  have  argued 
cannot 
the 
should  be  used.  But 
In  a  higher-
f i r s t - o r d er  predicate  c a l c u l u s. 
order  or  non-ordered  d e c l a r a t i ve 
language, 
statements  could  be  made  which  would  t e ll  a 
theorem  prover  how  other  statements  are  to  be 
used.  PLANNER,  on  the  other  hand,  has  no  way 
of  d i r e c t ly  s t a t i ng  an  e x i s t e n t i al 
q u a n t i f i c a t i o n,  but 
procedural 
of  handling 

languages  are  necessarily 
that  problem. 
Is 

t h is  does  not  mean 

Our  b e l i e f, 

then. 

type  of 
Is 

the 
to  represent  knowledge 

long  as 

feature  of  D-SCRIPT 

to  represent  statements 

formalism  f or  d e s c r i p t i o n s,  which 
it 
that  are 

It  has  s u f f i c i e nt 
This  paper  presents  an 
language  D-
the  most 
I ts 

system  used 
unimportant,  so 
expressive  power. 
attempt  at  such  a  system, 
the 
SCRIPT.  As  the  name  i m p l i e s, 
I n t e r e s t i ng 
powerful 
enables 
problematical 
w i ll  be 
SCRIPT 
questions  by  making  deductions 
thought  of  as  a 
base, 
theorem 
it  can  be 
it  operates  by  comparing 
prover.  Since 
expressions 
PLANNER  and  CONNIVER, 
a  pattern-matching  language. 
Turing  universal  and. 
lambda  c a l c u l u s. 
programming 

in  other  systems.  No  p o s i t i on 
language  D-
to  answer 
from  a  data 

It 
the 
thought  of  as  a 

to  what  kind  of 
intended 

taken  as 
i s.  Since 

And  since 
includes 

the  data-base 

languages  of 

It  can  be 

It  can  be 

language. 

f a c t, 

thought  of  as 
Is 

that 

that 

l i ke 

It 

is 

In 

is 

Incapable 

This  sentence 
e i t h e r: 

is  ambiguous. 

it 

can  mean 

(1.2)  John  wants 

also  happens 

to  merry  a  s p e c i f ic  g i rl  who 

to  bp  the  p r e t t i e s t. 

or: 

(1.3)  John  wants 

to  marry  whoever 

is  the 

that 
f i r st 

p r e t t i e st  g i r l,  although  he  may  not  know 
who 
the 

is. 
i n t e r p r e t a t i on  we  can 
to 
That 

Under 
s u b s t i t u te  any  phrase  which  refers 
person 
the  p r e t t i e st  g i rl 
from  (1.2)  we  can 

if 
is  named  " S a l ly  Sunshine", 
i n f e r: 

for  "the  p r e t t i e st  g i r l ". 

the  same 
i s, 

U.I*)  John  wants 

also  happens 

to  marry  a  s p e c i f ic  g i rl  who 

to  be  named  S a l ly  Sunshine. 

We  cannot  make  the  corresponding 
from  ( 1 . 3 ). 

It  w i ll  not  be 

true 

t h a t: 

inference 

(1.5)  John  wants 

to  marry  whoever 

is  named 

S a l ly  Sunshine,  although  he  may  not  know 
who 

that 

i s. 

t h is  property, 
reading  of 

is  c a l l ed 
is 
Is  almost 
the  opaque  reading. 
the  case  that  sentences  having  an 

Because  of 
transparent 
c a l l ed 
always 
opaque  reading  are  ambiguous  with 
reading  being 

transparent. 

(1.1)  and 

(1.3) 

(1.2) 

It 

To 

i l l u s t r a te  blocking  of  e x i s t e n t i al 

the  other 

the 

q u a n t i f i c a t i o n,  consider: 
(1.6)  John  wants 

to  marry  a  blonde. 

Is  ambiguous,  meaning 

the  sentence 

Again 
e i t h e r: 
(1.7)  John  wants 

to  marry  a  s p e c i f ic  g i r l,  who 

also  happens  to  be  a  blonde. 

o r: 
(1.8)  John  has  no  p a r t i c u l ar  g i rl 

In  mind,  but 
he  wants  whoever  he  does  marry  to  be  a 
blonde. 

We  can  e x i s t e n t i a l ly  q u a n t i fy  over 
reading  but  not  the  second.  We  can 

the  f i r st 
I n f e r: 

(1.9)  There  e x i s ts  someone  whom  John  wants 

marry. 

to 

223 

from  ( 1 . 7 ),  but  not 

from  ( I . 8 ). 

Another  problem 

is 

the  occurrence  of 

d e s c r i p t i ve  phrases 
time 
In 
(1.10)  The  President  has  been  married  since 

In  sentences 
the  sentence: 

reference. 

i nvolvlng 

1945. 

The  rules 

f or  e v a l u a t i ng 
l a r g e ly  adapted  from  LISP. 

t h e ir  arguments. 
expressions  are 
f a c t,  D-SCRIPT  variables  and 
j u st 
Rather  than 
use  constants  and 
defined 

l i ke  LISP  atoms  and 

Items. 

l i s ts 

r e s p e c t i v e l y. 
introducing  "QUOTE",  however,  we 

l i s t s, 

to  represent  pre­

To  s t a te  our  rules 

f o r m a l l y: 

forms  are 

In 
treated 

the  phrase  "the  President"  r e f e rs 
I n d i v i d u a l. 

the  sentence: 

In 

to  an 

1.  A  constant  evaluates 

to 

I t s e l f. 

(1.11)  The  President  has 
Mouse  since  1800. 

l i v ed 

in 

the  White 

"the  President"  refers 
t u r n. 

to  each  President 

In 

Another 

type  of  sentence  where 

reference  of  a  phrase  depends  on 
Illustrated 

by: 

the 
Is 

time 

(1.12)  John  met 

the  President 

In  1960. 

This  sentence 
each 
The  ambiguity 
refers 
asserted,  or 

to 

I n t e r p r e t a t i on  refers 

is  ambiguous,  but  u n l i ke  ( 1 . 1 1 ), 
to  only  one  person. 

Is  whether  "the  President" 

the  President  at 
the  President 

time  (1.12) 

the 
in  19C0. 

is 

representing  knowledge  about  knowledge 

i n t e r e s t i ng 

issues. 

For 

Instance, 

raises  some 
in: 

(1.13)  John  knows  B i l l 's  phone  numher. 
how 
John's  mind 

is  John's  knowledge  to  be  represented? 

It  might  be  something 

l i k e: 

In 

(1.14)  (PHONE-NUM  BILL  987-651(3) 
So, 

(1.13)  might  be: 

(1,15)  (KNOWS  JOHN  (PHOMF-NUM  BILL  987-6543)) 

I n f o r m a t i o n.  Not  only  does 

(1.15) 

trouble  w i th 

The 
too  much 
what 
La- 
Information  without  s t a t i ng 

(1.13)  says, 
The  d i f f i c u l ty 

is 

is 

to  r e f er 
i t. 

that 

It 

it  also  says  what 

the  number 

to  a  piece  of 

includes 
It  say 

For  a ll 

these 

types  of  sentences,  D-

SCRIPT  provides 
the  correct  deductions 
it  provides  separate 
meaning  of 
representations  are  related 
explains 

the  ambiguity. 

representations  which  allow 
Further, 
for  each 
these 

representations 

to  be  made. 

the  ambiguous  sentences,  and 

In  a  way 

that 

2.  A  v a r i a b le  evaluates 

to 

the  expression 

which 

It  has  been  assigned. 

3.  The  value  of  a 

form 

Is 

the  r e s u lt  of 

Is 

to 

I ts 

f or 

in  D-SCRIPT  by  a 

the  values  of 

f i r st  element 

is  represented 

This  w i ll  not  be 

l i st  of  v a r i a b l e s, 

remaining  elements. 

In  general,  but  only 

the  constant  "LAMBDA", 

lambda-expressions.  A 

those 
represent  meaningful 
In  D-SCRIPT.  One  such  case 
lambda-

applying 
I ts 
defined 
expressions  which 
operations 
that  of 
expression 
form  containing 
followed  by  a 
by  an  expression  ( e . g.  "<LAMBDA  (?X  ?Y) 
<TIMES  ?X  ?Y>>").  A  form  whose  f i r st 
element 
in  the  same  way  as  a  corresponding  LISP 
the  value  of 
expression. 
the 
body  of 
the 
values  of 
the 
corresponding  variab  les. 
Instance, 
assuming  " +"  has 
"<<LAMBDA  (?X)  <+  2  ?X>>  3>"  has  the  same 
value  as  "<+  2  3>",  which 
Is  " 5 ".  We  w i ll 
forms  whose  value 
introduce  other 
is  defined  when  we  e xplain  the 
representation  of  statements. 

The  r e s u lt 
lambda-expression,  w i th 
to 

the  arguments  assigned 

the  usual  meaning, 

lambda-expression 

followed 

types  of 

Is  a 

For 

is 

the 

is  evaluated 

4.  A 

l i st  evaluates 

to  a 
that 

form  with 
I d e n t i c al 
free  v a r i a b l es  are 

s t r u c t u r e,  except 
replaced  by 
t h e ir  values. 
previously  been  assigned 
then  "(LAMBDA  (?Y)  CFOO  ?X  ?Y))  w i ll 
evaluate  to  "<LAMBDA  C?Y)  CFOO  A  ?Y)>". 

If  "?X"  has 
the  value  "A", 

It 

is  worth  n o t i ng  that 

the  way 

lambda-

forms. 

to  w r i te 

l i s ts  are  defined  makes 

functions  which  construct 

expressions  and 
very  easy 
complex 
C?X) 
applying  t h is 
Z ) ) > ".  A  comparable  LISP  f u n c t i on  would  have 
to  be  b u i lt  up  w i th  "C0MS"  's  to  achieve 
r e s u l t. 

For  example,  consider  "<LAMBDA 
The  r e s u lt  of 

(F00  (BAR  (GRITCH  ? X ) ) ) > ". 

is  "<F00  (BAR  (GRITCII 

to  "Z" 

t h is 

it 

2.  The  D-SCRIPT  Language 

2.2  Representing  Knowledge 

in  D-SCRIPT 

2.1  P-SCRIPT  Expressions 

the 

f o l l o w i ng 

types  of 

D-SCRIPT  contains 

expressions: 
1.  constants 
2.  v a r i a b l es 
3. 
4. 

forms 
l i s ts 

Is  any  alpha-numeric 

A  constant 
( I . e.  only 
l e t t e rs  or  numbers)  character  s t r i ng  ( e . g. 
"F00",  "BL0CK5").  A  v a r i a b le 
Is  any  alpha­
numeric  character  s t r i ng  p r e f i x ed  by  " ?"  ( e . g. 
" ? X " ).  A  form 
Is  any  sequence  of  expressions 
In  angle-brackets  ( e . g.  "<X  Y  ?Z>"). 
enclosed 
A 
Is  any  sequence  of  expressions  enclosed 
In  parentheses  ( e . g.  "(F00  A  <BAR  B  C > ) " ). 

D-SCRIPT  observes 

that  a ll 
f u n c t i o n s,  p r e d i c a t e s,  and  operators  evaluate 

the  convention 

l i st 

The  most  basic  statements  are 

those  which 

Is  represented 

express  simple  p r e d i c a t i o n.  A  statement  of 
t h is  kind 
whose 
the  predicate  and  whose  other  elements  are 
constants 
p r e d i c a t e. 

In  D-SCRIPT  by  a  form 
representing 

the  objects  of 

Is  a  constant 

f i r st  element 

For  example: 

representing 

the 

(2.1)  The  sun 
C2.2)  BlockA 
could  be  represented  as: 

is  a  s t a r. 
is  on  BlockB. 

(2.3)  <STAR  SUN> 
(2.It)  <0N  BLOCKA  BL0CKB> 
A  simple  statement  about  a  statement,  such  as: 

224 

( 2 . 5)  John  b e l i e v es 

t he  sun 

Is  a  s t a r. 

w o u ld  b e: 

( 2 . 5)  <BEL1EVE  JOHN 

(STAR  SUN)> 

to  n o t i ce  about 

I m p o r t a nt 
t he  embedded  s t a t e m e nt 

l i s t. 

t h i ng 

The 
t h at 
a 
whose  v a l ue 
c o n v e n t i on 
" b e l i e v e ")  e v a l u a te 

T h is 

Is 

r e p r e s e n t ed  by 
Is  because  we  need  an  e x p r e s s i on 
t he 

to  be  c o n s i s t e nt  w i th 
t h is  c a s e, 

t h at  p r e d i c a t es 

( 2 . 3) 

( In 

Is 

t h e ir  a r g u m e n t s. 

( 2 . 6) 

Is 

To 

r e p r e s e nt  more  complex  s t a t e m e n t s/ 

two 

is 

t h e se 

t he  a d d i t i on  of 

t y p es  of  e x t e n s i o ns  are  needed. 
of 
c o n n e c t i v e s. 
"NOT",  and 
l o g i c al  o p e r a t i o n s. 
In 
s t a t e m e n ts  a re  e x p r e s s ed  as 

l o g i c al 
D-SCR1PT  uses  "OR", 
f or 

to  s t a nd 
As 

( 2 . 6) 
l i s t s. 

" I M P U F S" 

The  s i m p l er 

"AND", 
t he  o b v i o us 
t he  embedded 

So: 

( 2 . 1 3)  Every  boy  e i t h er 

h a t es  h i m. 

l o v es  Santa  Claus  or 

t he  p h r a se 
" l o v e s"  and  " h a t e s ".  We  cannot  use 
f o l l o w i ng 

r e p r e s e n t a t i on 

" e v e ry  b o y" 

t h o u g h: 

is 

t he  s u b j e ct  of  b o th 

t he 

( 2 . 1 4)  <OR  (LOVE  <EVERY  <?X> 

(HATE  <FVERY 

(?X) 

(BOY  7X>>  SANTA) 
(BOY  ?X)>  SANTA)> 

because 

t h is  means: 

( 2 . 1 5)  E i t h er  every  boy 

l o v es  Santa  Claus  or 

e v e ry  boy  hates  Santa  C l a u s. 

w h i c h,  of  c o u r s e, 
overcome 
e x p r e s s i o n s.  We  w i ll 

is  q u i te  d i f f e r e n t.  We  can 

t h is  d i f f i c u l ty  by  u s i ng 

lambda-

r e p r e s e nt 

( 2 . 1 3)  b y: 

( 2 . 7) 

If 

t he  sun 

is  a  s t a r, 

then  BlockA 

is  on 

( 2 . 1 6)  <<LAMBDA 

(?X> 

(OR  (LOVE  ?X  SANTA) 

(HATE  ?X  SANTA))> 

<FVFRY 

(?Y)  CBOY  ?Y)>> 

read  as  s o m e t h i ng 
is 
is 

t r ue  of  e v e ry  b o y ,"  where 
" l o v es  Santa  Claus  or  h a t es 

" t he 

l i ke 

t he 

B l o c k B. 

w o u ld  be 

r e p r e s e n t ed  b y: 

l o g i c al  c o n n e c t i v es  o p e r a te  on 

(STAR  SUN) 
t he 

r e f l e c ts 

( 2 . 8)  < IMPUFS 
T h is  n o t a t i on 
SCP.tPT, 
s t a t e m e n ts 
t r u t h - v a l u e s. 
computed  as  a  Boolean 
computed  by  a s s e r t i ng 
Is 
a r g u m e n t. 

t h e m s e l v es 

t r u e,  and  a t t e m p t i ng 

" I M P L I E S ", 

(ON  BLOCKA  BL0CKB)> 
f a ct 

in  D-

t h at 

t he 
t h e ir 

r a t h er 

than  on 

t h e n, 

is  not 

f u n c t i o n,  but 
t h at 

is 
f i r st  argument 

r a t h er 

i ts 

to  prove 

i ts  second 

f or  complex 
I m p o r t a nt 

r e q u i r ed 

The  o t h er  e x t e n s i on 
t he  one 

is 

t h at 

t h r ee 

is  most 

t h e o r y, 

t y p es  of  d e s c r i p t i o ns 

t he  use  of  d e s c r i p t i o n s. 
in  D-

s t a t e m e n t s,  and 
to  our 
There  are 
SCRIPT;  e x i s t e n t i al  d e s c r i p t i o n s,  u n i v e r s al 
d e s c r i p t i o ns  and  d e f i n i te  d e s c r i p t i o n s. 
A 
d e s c r i p t i on 
"SOME" 
"THE" 
( d e f i n i t e );  whose  second  element 
l i st  c o n t a i n i ng  a  v a r i a b l e;  and  whose 
e l e m e nt 
s t a t e m e n t. 
c o r r e s p o n d i ng 
d e s c r i p t i ve  p h r a s e s: 

Is  an  e x p r e s s i on  whose  v a l ue 

t y p es  of  n a t u r al 

t he 
language 

( e x i s t e n t i a l ), 

f i r st  element 

D e s c r i p t i o ns 

f o rm  whose 

r e p r e s e nt 

is  a 
t h i rd 

"EVERY" 

is  a 

is  a 

is 

( u n i v e r s a l ),  or 

( 2 . 9)  a  b l o ck 

e v e ry  number 
t he  T a b le 

<S0ME 

<FVFRY 
<TIIF 

(?X) 

(?X) 
(?Y) 

(CLOCK  ?X)> 
(HUM  ?Y)> 

(TABLE  ?X)>  , 

Some  examples  of  s e n t e n c es  c o n t a i n i ng 
d e s c r i p t i ve  phrases  and 
a r e: 

t h e ir 

r e p r e s e n t a t i o ns 

( 2 . 1 0)  The  k i ng 

<FAT  <THE 

(KING  ?Xl>> 

Is 

f a t. 
(?X) 

( 2 . 1 1)  John  owns  a  d o g. 

<0WN  JOHN  <S0ME  (?X) 

(DOG  ?X)>> 

( 2 . 1 2)  Every  boy 

l i k es  Santa  C l a u s. 

<LIKE  <EVERY 

(?X) 

(BOY  ?X)>  SANTA> 

l e ft  as 

t h ey  a re 

t h at  when  d e s c r i p t i o ns  appear 

N o t i ce 
s t a t e m e n t s, 
Is 
b e c a u s e,  u n l i ke  embedded  s t a t e m e n t s,  we  a re 
t a l k i ng  about 
d e s c r i p t i o ns 
t h an 

to  which 
t he 
t h e ir  v a l u e s) 

t he  o b j e c ts 
r e f er 

t he  d e s c r i p t i o ns 
t h e m s e l v e s. 
The  n o t a t i on  we  have  used  so 

Is  not 
to  e x p r e ss  s t a t e m e n ts  c o n t a i n i ng 

in 
T h is 

f o r m s. 

( i . e. 

f ar 

r a t h er 

t h an  one  o c c u r r e n ce  of 

the  same 

s u f f i c i e nt 
more 
d e s c r i p t i o n. 

In 

t he  s e n t e n c e: 

T h is  can  be 
p r e d i c a te  X 
p r e d i c a te  X 
h i m ." 

to 
w h e t h e r: 

Vie  have  a  s i m i l ar  s i t u a t i on  w i th 

t he  scope  of  q u a n t i f i e r s. 

it 

r e s p e ct 
Is  not  c l e ar 

( 2 . 1 7)  <GRFATER  <S0ME  <?X) 
(?Y) 

<EVERY 

(NUM  ?X)> 
(NUM  ?Y)>> 

r e p r e s e n t s: 

( 2 . 1 &)  For  every  number 

number. 

t h e re 

is  some 

l a r g er 

o r: 

( 2 . 1 8)  There 

Is  some  number  w h i ch 

than  e v e ry  number. 

is 

l a r g er 

We  w i ll  have 
d i s a m b i g u a te 
e x p r e s s i o ns  we  can  a v o id 
( 2 , 1 8)  can  be 

to  a r b i t r a r i ly  choose  a 
( 2 , 1 7 ),  b ut  by  u s i ng 

r u le 
lambda-
t he  d i f f i c u l t y. 

r e p r e s e n t ed  b y: 

to 

( 2 . 2 0)  <<LAMBDA 

(?X) 

(CRFATER  <S0ME 

(?Y) 
(HUM  ?Z)>> 

<FVERY 

(?Z) 

(MUM  ?Y)>  ?X)> 

and 

( 2 . 1 9)  can  be 

r e p r e s e n t ed  b y: 

( 2 . 2 1)  <<LAMBDA 

(?X) 

(GREATER  ?X  <EVERY 
(NUM  ?Z)>> 

(?Z) 

<S0ME 

(?Y) 

(MUM  ?Y)>)> 

A n a l y z i ng 
( 2 . 1 C)  w i ll  show 
m e a n l n g. 

t h e se  e x p r e s s i o ns 

In 
t h ey  have 

t he  same  way  as 

t he  c o r r e ct 

t h at 

t he  same 

in  v i ew  of 

f u n c t i on  as 

t he  p r e d i c a te  c a l c u l u s. 

t h at  e x i s t e n t i al 
In  D-SCRIPT  s e r ve 
t he  q u a n t i f i e rs 
t h i s. 

It  s h o u ld  be  a p p a r e nt 
and  u n i v e r s al  d e s c r i p t i o ns 
e x a c t ly 
of 
It  may  be  asked  why  we  have  used  a  d i f f e r e nt 
n o t a t i o n, 
makes 
s t r u c t u re  more  c t o s e ly 
t h ey 
more 
t h o u g h, 
a  d e s c r i p t i on  makes 
i n t e r p r e t er 

t h at  h a v i ng  a  s i n g le  e x p r e s s i on 

to  w r i te  e x p r e s s i o ns  v/hose 

r e p r e s e n t. 
I n t e l l i g i b l e. 

t h at  our  n o t a t i on 

It  e a s i er 
I t. 

to  m a n i p u l a te 

it  p o s s i b le 

t h is  makes 

resembles 

H o p e f u l ly 

i m p o r t a nt 

The  more 

reason 

f or  an 

them 

one 

Is 

is 

t he  s e n t e n c es 

r e a s o n, 
f or 

2.3  Formal  Semantics  of  P-SCRIPT 

The  previous 

two  sections  o u t l i n ed 

the 
informal  semantics  of  D-SCRIPT. 
to  show  how  a  program 

t h e ir 

that  would 

In  accord  w i th 
The  d e t a i ls  of 
f or 

syntax  and 
This  section  attempts 
could  be  w r i t t en 
statements 
meaning. 
sketchy.  One  reason 
proof  s t r a t e g i es  and  using  h e u r i s t ic 
Information  are  complicated  problems 
cannot  c l a im  to  have  solved. 
c r e a t i ng  a 
g o a l.  What  we  are  t r y i ng  to  do 
sort  of  d e s c r i p t i ve  system  necessary 
represent 
i n f o r m a t i on  contained 
language  statements. 
section 
that  system 

to  e s t a b l i sh 
is  " w e l l - f o u n d e d ". 

theorem  prover 

the 

is 

is 

I n t e r p r et  D-SCRIPT 

I n t u i t i ve 

t h is  will  be  somewhat 
t h is 
t h at  choosing 

Is 

that  we 

Secondly, 

is  not  our  main 

to  show  the 

to 
in  natural 

The  purpose  of 

t h is 
that  our  n o t a t i on 

for 

is 

in 

in 

the 

the 

from 

t r u e. 

t r u th 

looks 

f i r st  statement. 

is  being  determined 

The  program  we  have 

f or  another  statement 

in  mind  would  take  a 
I ts 
For 
the 

Input  and  determine 
the  statement 

the  " t e st  statement"; 
the  data  base  to  which 

statement  as 
i ts 
data  base  whether 
statements  which  are  simple  p r e d i c a t i o n s/ 
program 
data  base  which  matches 
The  statement  whose 
w i ll  be  c a l l ed 
statement 
being  compared  w i ll  be  c a l l ed 
statement". 
program  would  break 
components  and  process  them  according 
semantics  of 
S i m i l a r l y,  a  complex  t a r g et  statenent  must  be 
broken  down 
f or  processing, 
in 
but 
So, 
e x p l a i n i ng 
the  semantics  of  complex 
expressions,  analyses  w i ll  be  given 
use  both 
In 
in 
statements. 

To  prove  a  complex  statement, 

the  rules  are  d i f f e r e n t. 

is 
the  " t a r r et 

test  statements  and 

its  components 

the  operators 

f or 
target 

involved. 

It  down 

the 
it 

t h e ir 

into 

the 

its 

to 

to 

the 

Two  basic  statements  match 

If 

t h e ir 

for 

I d e n t i c a l,  A 

t h e ir  values  are 

corresponding  elements  match. 
In  general, 
expressions  whtch  are  not  statements  match 
whenever 
v a r i a b le  which  has  not  been  assigned  a  value 
matches  any  expression,  and 
that 
expression's  v a l u e. 
t e st  statements  and 
example,  suppose  " 5"  has  been  assigned 
"?X",  "?Y" 
usual  meaning.  Then  "<FOD  5  ?Y>"  w i ll  match 
"<F00  ?X  <+  3  4>>"  and  " 7"  w i ll  be  assigned  to 
"?Y". 

to  both 
t a r g et  statements.  As  an 

Is  unassigned,  and  " +"  has 

These  rules  apply 

Is  assigned 

to 
I ts 

in 
But 

Is  not  of  primary 

these  expressions 

test  statements  and 

l o g i c al  connectives. 

the  d i s t i n c t i on 
target  statements 

We  w i ll  not  give  a  complete  deductive 
Is  a 

the  phenomena  we  wish 
to  suggest 

the  kind  of  procedure 
In  mind,  consider  "AND"  and  "IMPLIES". 

procedure 
well  understood  problem  and 
Importance 
e x p l a i n. 
we  have 
In  handling 
between 
comes  through.  To  prove  "<AND  X  Y"  both  X 
and  x  must  be  proved;  but 
something  against  "<AMD  X  Y>",  the  match 
succeeds 
X  Y>"  Is 
X  is  asserted,  Y  can  be  proved.  A  t e st 
statement  w i ll  match  a 
t a r g et  statement 
"<IMPLIES  X  Y>" 
test  statement  matches 
the 
X  and  X  can  be  proved. 
"OR"  and  "NOT"  are 
somewhat  more  complicated  but  can  be  handled 
In  much 
the  same  way. 
The 

"<MPLIES 
In  a  h y p o t h e t i c al  s t a te  where 

if  e i t h er  X  or  V  matches. 

Important  part  of  our 

in  matchin 

r e a l ly 

t r ue 

to 

If 

It 

if 

deductive  procedure 
d e s c r i p t i o n s. 
simplest. 
to 

Is 

treatment  of 
D e f i n i te  d e s c r i p t i o ns  are 

the 
"<THE  <?X)  < . . . ? X . . . ) >"  evaluates 

the 

the  constant  which  when  assigned 

to  "?X" 

makes  " < . . . ? X . . . >" 
a  constant  or 
value  of 
example. 
t h a n ", 

If 

t r u e. 

If 

there 

is  not  such 

there 

is  more 

than  one, 

the 

the  d e s c r i p t i on 
If  "LESS"  means  " a r i t h m e t i c a l ly 

Is  undefined. 

For 

less 

then  "<F00  3>"  matches: 

(2.22)  <F00  <THE  (?X) 

(AND  (LESS  ?X  4) 

(LESS  2  ?X))>> 

r u le 

This 
applies 
statements. 

f or  e v a l u a t i ng  d e f i n i te  d e s c r i p t i o ns 

test  statements  and 

t a r g et 

to  both 

For  e x i s t e n t i al  and  universal 

if 

If 

is 

is 

is 

in 

the 

the 

That 

there 

i s,  "<FO0 

that  makes 

the  case  of  a 

true  when  "?X" 

If  we  know  that 

the  d e s c r i p t i on 

Is  assigned  "A". 

t a r g et  statement, 

t a r g et  statements. 

t e st  statements  and 

is  again  a  d i f f e r e n ce 

that  we  know  which  bar 

f o o ,"  we  could  simply  give 

test  statement,  an  e x i s t e n t i al 

is  more  d i f f i c u l t. 
is 

(BAR  ?X)>>"  matches  "<F00  A>" 
Is 

Instead  we  can  create  a  name  and 
the  new  name  were 
is  asserted 

d e s c r i p t i o n s, 
between 
In  a 
d e s c r i p t i on  matches  anything 
body  of 
t r u e. 
<S0ME  (?X) 
"<BAR  ?X>" 
For 
evaluation 
"Some  bar 
It  a 
name  and  c o n t i n u e.  But  g i v i ng  a  name  would 
imply 
not 
t r u e. 
say  that 
object 
to  e x i s t, 
anything  which  we  can  prove  about 
Is 
a  h y p o t h e t i c al  s t a te  of 
which. 
the  new  name 
"<BAR  G999>". 
becomes  "<F00  G999>". 
t h is 
to  "G999",  w i th 
h y p o t h e t i c al  s t a te  of 
"<BAR  3999>" 
is  discharged, 
and  we  are  not 
know  v/hat 
The 

Another  way  of  p u t t i ng 
that  "<SOME  (?X>  (BAR  ?X)>"  evaluates 
the  side  e f f e ct  of  c r e a t i ng  a 
In  which 

is  asserted.  When  the  hypothesis 
the  new  name  becomes  undefined, 
in  danger  of  supposing 
i s. 

the  name  of 
treatment  of  universal  d e s c r i p t i o ns 

then 
the  new  name 
this  by  c r e a t i ng 

the  data  base 
is  "G999",  we  assert 

true  of  the  o b j e c t.  We  do 

t a r g et  statement 

the  data  base 

the  name  of 

f o o,  which 

the  object 

that  we 

if 
t h at 

then 

The 

the 

true 

f or  e x i s t e n t i al 

the  exact  dual  of 
In  a 

t h at 
test  statement,  we  know 

Is 
d e s c r i p t i o n s. 
that  whatever  we  can  prove  about  an 
a r b i t r a r i ly  selected  member  of  a  class 
the  c l a s s.  So  j u st  as  we 
of  every  member  of 
did 
target  statements,  we  set 
for  e x i s t e n t i al 
up  a  hypothetJcal  s t a t e,  produce  an  a r b i t r a ry 
unique  name,  and  assert 
is  a  member  of 
the  c l a s s.  Analogously 
b e f o r e,  "<EVERY  (?X) 
say,  "G111l"  w i th 
h y p o t h e t i c al  s t a te 
asserted. 
d e s c r i p t i o n s. 
universal  d e s c r i p t i on  matches  anything  which 
makes 
For  example,  "<F00  A>" 
matches  "<F00  <EVERY  (?X) 
?X>" 

t o, 
the  side  e f f e ct  of  c r e a t i ng  a 

is 
in  d u a l i ty  w i th  e x i s t e n t i al 

(BAR  ?X)>>" 
is  assigned  "A". 

t h at 
to  what  we  said 

In  which  "<F00  G l l l >" 

(FOO  ?X)>"  evaluates 

t a r g et  statement  a 

its  body  t r u e. 

In  a 

Also 

is 

It 

true  when  "?X" 

Is 
Now  we  can  see  why 

lambda-expressions  are 

If  "<BAR 

in  0-

Information 

representing 

Later  we  w i ll 

the  data  base. 

If  we  have  other  d e s c r i p t i o ns 

f or 
Evaluating  e x i s t e n t i al  and  universal 
the  side  e f f e ct  of 

Important 
SCRIPT. 
d e s c r i p t i o ns  sometimes  has 
changing 
Introduce  other  expressions  which  also  do 
t h i s. 
statement,  we  need 
whether 
base  or  the  new.  By  " l a m b d a - f y l n g"  a 
statement  we  can  b r i ng  one  or  another 
d e s c r i p t i on 
evaluated  f i r s t. 
the  order 
A  d e t a i l ed  example  of 
s e c t i on  3.5. 

In  which  expressions  are  evaluated. 

In 
to  c o n t r ol 
the  o ld  data 

In  t h is  way  we  can  control 

they  are  evaluated 

t h is  w i ll  be  given 

to  be  able 
In 

the  outside  and 

to  be 

force 

the 

to 

in 

It 

In 

t h is  b r i ef  summary,  we  have  given  the 

b a r e st  o u t l i n es  of  a  d e d u c t i ve  p r o c e d u r e.  We 
have  n ot  d i s c u s s ed  any  of 
I n t e r a c t i o ns  among 
these 
But  h o p e f u l ly  we  have 
f o u n d a t i on 
t he 

t he  complex 
l o g i c al  o p e r a t o r s. 

t he 
t h is  p a p e r. 

l a id  a  s u f f i c i e nt 

r e al  p o i nt  of 

t a lk  about 

t h at  are 

Issues 

to 

d e s c r i p t i o n s. 

The 

two 

r e a d i n gs  o f: 

( 3 . 8)  John  wants 

to  m a r ry  a  b l o n d e, 

can  be 

r e p r e s e n t ed  b y: 

3.  S o l u t i on 

to  R e p r e s e n t a t i on 

Problems  Using  D-SCRIPT 

3 .1  D e s c r i p t i o ns 

In  Opaque  Contex  6 

In  opaque 

to  more 

to  normal 

F u r t h e r m o r e,  at 

In  g e n e r a l,  d e s c r i p t i ve  phrases 
t h an  one 

I n t e r p r e t a t i o ns  seems  not 

c o n t e x ts  a re  s u b j e ct 
I n t e r p r e t a t i o n. 
t he 
a c c o r d i ng 
m a n i p u l a t i o n. 
c o n t e x ts  p r i m a r i ly  o c c ur 
c o n s t r u c t i o ns  of  v e r bs 
" k n o w ",  e t c. 
p r o p e r ty  of  d e s c r i b i ng  somebody's  model  of 
w o r l d.  When  we  s a y: 

t he  complement 
" w a n t ", 
These  v e r bs  a ll  have 

L o o k i ng  more  c l o s e l y,  opaoue 

to  behave 

r u l es  of 

In 
l i ke 

l o g i c al 

t he 

l e a st  one  of 

" b e l i e v e ", 

t he 

( 3 . 1)  John  wants 

to  m a r ry  S a l l y. 

what  we  mean 
w o r l d, 

t he  s t a t e: 

Is 

t h at 

in  J o h n 's  model  of 

t he 

( 3 . 2)  John 

is  m a r r i ed 

to  S a l l y. 

Is  c o n s i d e r ed  d e s i r a b l e. 
d e s c r i p t i ve  p h r a s es  a r i s es 
of  w h e t h er 
e v a l u a t ed 
model  of 
I l l u s t r a te 

t he  s u b j e ct  of 
r e c a ll 

t he  d e s c r i p t i ve  phrase 
In  our  model  of 

t h i s, 

t he  s e n t e n c e. 
the  s e n t e n c e: 

t he  w o r ld  or 

Is 

The  a m b i g u i ty  of 
f r om 

the  q u e s t i on 

to  be 
t he 
To 

( 3 . 3)  John  wants 

to  m a r ry 

t he  p r e t t i e st  g i r l. 

In  D-SCR1PT, 
b y: 

t he  opaque 

r e a d i ng 

is 

r e p r e s e n t ed 

( 3 . 4)  <WANT  JOHN  (MARRY  JOHN 

<THE 

(?X) 

(PRETTIFST  ?X)>)> 

t h at 

reason 

The 
s u b s t i t u t i ng  o t h er  e x p r e s s i o ns 
(PRETTIEST  ? X ) >" 
a c t u a l ly  c o n t a i ns 

is 
t h is  d e s c r i p t i o n, 

r e s t r i c t i o ns  on 
"<THE 

(?X) 
t he  s t a t e m e nt  w h i ch 

t h e re  a re 

I . e .: 

t h at 

f or 

( 3 . 5)  <MARRY  JOHN  <THE 

(?X) 

(PRETTIEST  ?X)>> 

r e p r e s e nt  J o h n 's  w o r ld  model  by  a 

If 

in  our 

Is  p a rt  of  J o h n 's  w o r ld  m o d e l. 
p r o g r am  we 
s e p a r a te  d a ta  b a s e, 
may  be  s u b s t i t u t ed  are 
e q u i v a l e nt 
d a ta  base  w h i ch 

then 

In 

t h at  data  b a s e,  not 

t he  e x p r e s s i o ns  w h i ch 

t h o se  w h i ch  are 

In 

the  main 

r e p r e s e n ts  our  w o r ld  m o d e l. 

To 

r e p r e s e nt 

t he 

t r a n s p a r e nt 

r e a d i ng  of 

( 3 . 3 ),  we  must 
t he  scope  of  J o h n 's  m o d e l.  We  can  do 
w i th  a 

l a m b d a - e x p r e s s i o n: 

t he  d e s c r i p t i on  o u t s i de 

t a ke 

t h is 

( 3 . 6)  <<LAMBDA 

(?X) 

(WANT  JOHN  (MARRY  JOHN  ?X))> 

<THE 

(?Y) 

(PRFTTIFST  ?Y)>> 

t h at 

T h is  says 
e v a l u a t i ng 
s u b s t i t u t i ng 

t he  s t a t e m e nt  we  g et  by 

t he  d e s c r i p t i on 
f or 

t h at  v a l ue 

In  o ur  model  and 
" ? X" 

I n: 

( 3 . 9)  <WANT  JOHN  (MARRY  JOHN 

<S0ME 

(?X) 

(BLONDE  ?X)>)> 

f or 

t he  opaque 

r e a d i n g,  and  b y: 

( 3 . 1 0)  <<LAMBDA  (?X) 

(WANT  JOHN  (MARRY  JOHN  ?X))> 

<S0ME 

(?Y> 

(BLONDE  ?Y)>> 

f or 

t he 

t r a n s p a r e nt 

r e a d i n g. 

( 3 . 9)  means: 

( 3 . 1 1)  John,  wants 

m a r r i e s. 

and 

( 3 . 1 0)  means: 

t h e re 

to  be  a  b l o n de 

t h at  he 

( 3 . 1 2)  There 
m a r r y. 

Is  a  b l o n de 

t h at  John  wants 

to 

t he  reason  we  c a n 't  make  a  " t h e re 

So 
p a r a p h r a se  of 
an  e x i s t e n t i al  s t a t e m e n t. 
abqut  an  e x i s t e n t i al  s t a t e m e n t. 

t h at 
It 

( 3 . 9) 

Is 

r a t h er 
Is  an  a s s e r t i on 

t h an  b e i ng 

I s . . ." 

3.2  D e s c r i p t i o ns 

in 

t i me  c o n t e x ts 

In  o r d er 

to  d i s c u ss 
e x a m p l e s,  we  need  a  way 
The  b a s ic 
be  made 
choose 
depend  on 

f a ct  here 
to  v a ry  w i th 

t i m e,  e . g .: 

to  c o n s i d er  e t e r n al  can  be  a l l e g ed 

Is 
t i m e.  Even 

t h at  any  p r e d i c a te  can 
t h at  we 
to 

t h o se 

t he  n e xt  s et  of 
to 

r e p r e s e nt 

t i m e. 

( 3 . 1 3)  Two  used 

to  be  g r e a t er 

t h an 

t h r e e. 

By 

l o g i c,  we 

f i r s t - o r d er 

( M c D e r m o t t ). 

t h is  we  mean 

f or 
t h is 
to  make 

in 
t i me  an  e x p l i c it  p a r a m e t er 

I n s t e a d,  we  w i ll 
t i me  by  a  coptext-STRUCTURED.c.tu.red  d a ta 
t he 

To  account 
w o u ld  have 
of  e v e ry  p r e d i c a te  s y m b o l. 
r e p r e s e nt 
base 
d a ta  base  w i ll  be  b r o k en  down 
s u b - d a ta  b a s e s,  or  c o n t e x t s,  each  of  w h i ch 
t he  s t a te  of 
r e p r e s e n ts 
p a r t i c u l ar 
t i m e. 
I m p l e m e n t e d,  as 
McDermott)  by  s p e c i f y i ng  each  c o n t e xt  by 
r e c o r d i ng 
It  and 
p r e d e c e s s o r. 
To  use 

t he  w o r ld  at  some 
T h is  can  be  e f f i c i e n t ly 

t he  d i f f e r e n c es  between 

in  CONNIVER 

I n to  a  s e r i es  of 

t h at 

I ts 

is 

It 

t h is  k i nd  of  d a ta  b a s e,  we  need  a 
I ts 
t i me 

t a k es  as 
t he  name  of  a 
t>"  means  s t a t e m e nt  s. 

" T - A - T"  w h i ch 

Is 

(Sussman  and 

s p e c i al  p r e d i c a te 
p a r a m e t e rs  a  s t a t e m e nt  and 
" < T - A -T  S 
c o n t e x t. 
True  At  Time  T.  The 
T"  a re 
t i me  c o n t e xt  named  by 
a b le 
For 

to  g e n e r a te 
I n s t a n c e, 

it  a t t e m p ts 

t he  p h r a s e: 

r e f e r e n c es 

t h at 

f o r m al  s e m a n t i cs  of  " T - A-

to  deduce  S, 

in 
t.,  We  a l so  need 

t he 
to  be 
t i me  c o n t e x t s. 

to 

( 3 . 1 4)  when  Washington  was  P r e s i d e nt 

w o u ld  be 

r e p r e s e n t ed  by 

the  d e s c r i p t i o n: 

( 3 . 1 5)  <THE 

(?T) 

( T - A -T 

(PRES  WASHINGTON)  ?T)> 

F i n a l ly  we  need 
to  make  q u a n t i f i ed  s t a t e m e n ts  about 
would 

t he  o n e - p l a ce  p r e d i c a te 

r e p r e s e n t: 

" T I M E" 
t i m e.  We 

( 3 . 7)  <MARRY  JOHN  ?X> 

Is  marked  as  a  d e s i r a b le  s t a te 
m o d e l. 

The  a n a l y s is 

is  a n a l o g o us 

In  J o l i n 's  w o r ld 

f or  e x i s t e n t i al 

227 

( 3 . 1 6)  Three 

Is  a l w a ys  g r e a t er 

t h an 

t w o. 

b y: 

C3.17)  <T-A-T 

(HRFATF.R  3  2) 
<FVFRY 

(?T) 

(TIT'F  ?T)>> 

in 

As 

f or 

t i m e,  we  can 

t h is  n o t a t i on 

Given 
t he  a s s o c i a t ed  problems  w h i ch  wo 

t he  case  of  opaque  c o n t e x t s, 

s o l ve 
e a r l i e r. 
t he  s o l u t i on  depends  on  w h e t h er  a  d e s c r i p t i on 
Is  e v a l u a t ed 
s t a t e m e nt 
s t a t e m e nt 
e x a m p l e s: 

in  w h i ch  a 
t he  c o n t e xt  w h i ch 
R e c a l l i ng 

the 
t he  p r e v i o us 

Is  made  or 
Is  a b o u t. 

t he  c o n t e xt 

r a i s ed 

In 

( 3 . 1 8)  The  P r e s i d e nt  has  been  m a r r i ed  s i n ce 

1945. 

is 

r e p r e s e n t ed  b y: 

( 3 . 1 9)  <<LAMBDA 

(?X) 

<EVERY 
<THE  C?Y) 

(?T) 
(PRES  ?Y)>> 

( T - A -T 

(MARRIED  ?X) 

(AFTER  ?T  1 9 4 5 ) > )> 

( 3 . 1 9) 

In 
p u ts 
o u t s i de 
e v a l u a t ed 
s t a t e m e nt 

t he  use  of 
t he  d e s c r i p t i on 

the 
"<TNIF 

l a m b d a - e x p r e s s i on 

(?Y) 

(PRES  ? Y ) >" 

the 

t i me  c o n s t r u c t i o n,  so 
in  w h i ch 

t he  c o n t e xt 

in 
is  made.  On 

the  o t h er  h a n d: 

it 
t he 

is 

( 3 . 2 0)  The  P r e s i d e nt  has 
Mouse  s i n ce  1800. 

l i v ed 

In 

t he  W h i te 

i  s 

r e p r e s e n t ed  b y: 

( 3 . 2 1)  <T-A-T 

( L I V E - If  <TME 
<EVERY 

(?T) 

(?X) 

(PRES  ?X)>  W-H) 

(AFTER  ?T  1800)>> 

the  d e s c r i p t i on 

H e re 
c o n s t r u c t i on  and 
t i me  d e s c r i p t i on  has  been 
f o r: 
a n a l y s is 

t i me 
is  not  e v a l u a t ed  u n t il 
i n s t a n t i a t e d. 

the.  same 

i n s i de 

t he 

Is 

is 

t he 

The 

( 3 . 2 2)  John  met 

the  P r e s i d e nt 

in  1960. 

e x c e pt 
d e f i n i t e. 

t h at 

in 
One 

t h is  case 
i n t e r p r e t a t i on 

t he 

t i me 

r e f e r e n ce 
is  g i v en  b y: 

is 

C3.23)  <T-A-T 

(MEET  JOHN  <T11E 
19G0> 

(?X) 

(PRES  ?X)> 

and 

t he  o t h er 

is  g i v en  b y: 

( 3 . 2 d)  <<LAHDDA 

(?X) 

( T - A -T  (MEET  JOHN  ?X) 

<THE  (?Y) 

(PRES  ?Y)> 

1960)> 

3.3  Knowledge  about  Knowledge 

One  of 

t he  q u e s t i o ns  we 

r a i s ed 

in 

t he 

b e g i n n i ng  was  how 

to  r e p r e s e n t: 

( 3 . 2 5)  John  knows  D i l i 's  phone  number. 

If  we  knew 
( 3 . 2 5)  b y: 

t he  number  we  c o u ld 

r e p r e s e nt 

( 3 . 2 G)  <KNOW  JOHN 

(PHONE-NUM  BILL  x x x )> 

is 

where  xxx 
d e s c r i p t i on  of 
phone  number". 
( 3 . 2 6 ),  however,  we  p et  a 

t he  number.  We  do  know  one 
" C i U 's 
I n to 

t he  number,  namely 
If  we  s u b s t i t u te 

t r i v i al  s t a t e m e n t: 

t h is 

( 3 . 2 7)  <KN0W  JOHN  (PHOME-NUM  BILL 

<TIIE 

(?X) 

(PHONF-NUM  BILL  ?X)>)> 

228 

w h i ch  means: 

( 3 . 2 8)  John  knows 

t h at  B i l l 's  phone  number 

B i l l 's  phone  number. 

is 

to  do 
t he  d e s c r i p t i on 

What  we  need 
of 
"into  our  w o r ld  m o d e l.  Once  a g a i n,  we  can  do 
t h is  w i th  a 

Is 
f r om  J o h n 's  w o r ld  model 

l a m b d a - e x p r e s s i o n: 

t he  o c c u r r e n ce 

remove 

to 

( 3 . 2 9)  <<LAMBDA 

(?X) 
(KNOW  JOHN 

<T!IF 

(?X) 

(PHONE-NUM  BILL  ?X)>> 

(PHONE-NUM  BILL  ?X))> 

t h at 

If  we  were 

T h is  says 
d e s c r i p t i on 
t he 
d e s c r i be  J o h n 's  k n o w l e d g e. 

r e s u lt 

in 

" B i l l 's  phone  number"  and  s t i ck 

( 3 . 2 6 ),  we  w o u ld  c o r r e c t ly 

to  e v a l u a te 

t he 

To  see 

t he  d i f f e r e n ce  between 

( 3 . 2 9 ),  suppose  we  know 
number,  and  we  know 
has  a  phone  number. 
r e p r e s e n t ed  b y: 

( 3 . 2 7)  and 
t h at  B i ll  has  a  phone 
t h at  B i ll 

t h at  John  knows 
These 
f a c ts  a re 

( 3 . 3 0)  <PH0ME-MUM  BILL  <S0ME 

(?X) 

(MUM  ?X)>> 

( 3 . 3 1)  <KN0W  JOHN  (PHONE-NUM  BILL 
<SOME  (?X)  (NUM  ? X ) > )> 

if 

t h is 

t h at 

f r om 

( 3 . 2 9) 

t h ey  a re 

In  D-SCRIPT 

t h i s,  we  can  p r o ve 

i t s e l f. 
is  n o n - t r v i a l. 

to  see 
in 
t h ey  arc  b r o k en  down 

G i v en 
N o t i ce 
Complex  s t a t e m e n ts  are  never  p r o v ed  by  s i m p ly 
l o o k i ng 
R a t h e r, 
components  and 
a c c o r d i ng 
c o m b i n i ng 
s e m a n t i cs  a re 
base  of 
to  p r o ve  a  s t a t e m e nt 
r e a l ly  have 
s e m a n t i cs 

these  components  are  p r o c e s s ed 

t he  o p e r a t o rs 
t he 

the  k n o w i n g. 
t he 

t he  case  of 
t he  p r o of 

l a te  b a s e. 
t h e ir  b a s ic 

t he  s e m a n t i cs  of 

t he  person  d o i ng 

"KMOW" 
to 

to 
t h e n. 

t he  d a ta 

to  s h i ft 

i t s e l f, 

the 
to 

So  even 

In 

f r om 
to  w o r k. 
( 3 . 2 9) 

t he 
f i r st  e v a l u a te 

lambda-
"(THE 

tn 

t r y i ng 

to  p r o ve 

t h is  by 

f i nd  a  match 

f or  "<PHONE,-NUM  BILL  ? X > ". 

e x p r e s s i on  makes  us 
(PHONE-NUM  DILL  ? X ) > ".  We  do 
to 
we  d o n 't  know  B i l l 's  phone  number  wc  c a n 't  do 
t h is  d i r e c t l y. 
to  c r e a te  a  h y p o t h e t i c al  s t a te 
a r b i t r a ry  c o n s t a n t,  say 
" 0 7 7 7" 
be  D i l l 's  number.  So 
a t t e m pt 

( 3 . 3 0 ),  however,  e n t i t l es  us 
in  w h i ch  some 
is  a s s e r t ed 
to 

(?X) 
t r y i ng 

( 3 . 2 9 ),  wc 

to  p r o v e: 

to  p r o ve 

If 

( 3 . 3 2)  <KN0W  JOHN  (PHONE-NUM  BILL  G777)> 

w i th 

t he  h y p o t h e s i s: 

( 3 . 3 3)  <PI!0NE-NUM  BILL  G777> 

( 3 . 2 9)  we  p r o c e ss 

( 3 . 2 9) 
t i m e,  however, 

t he  same  as  b e f o r e. 
in 

T h is 
t he  d a ta  b a s e;  so 
(PHONE-N'UM  BILL  ? X ) >"  e v a l u a t es 
to 

Our  p r o of 

( 5 . 3 3) 

(?X) 

to 

t h en 
i t s e l f,  w h i ch 

reduces 
reduces 
t he 

in 

f r om 

( 3 . 3 2) 

To  p r o ve 
much 
We  a l r e a dy  have 
"<THE 
" 0 7 7 7"  d i r e c t l y. 
p r o v i ng 
a g a in 
to  p r o v i ng 
d a ta  base  w h i ch 
( 3 . 3 3) 
I n f e r r ed 
e n t i re  p r o of  s u c c e e d s. 

( 3 . 3 2) 

I t s e lf 

f r om 

f r om 

is  a  b a s ic  s t a t e m e n t,  so 

i m m e d i a t e l y,  and 

it  can  be 
t he 

( 3 . 3 3) 
r e p r e s e n ts  J o h n 's  w o r ld  m o d e l. 

i t s e lf 

f r om 

Now  suppose 

( 3 . 2 9) 

t he  same  down 

i n s t e ad 

t h at  we  were 

t r y i ng 
The  p r o of  w o u ld 

( 3 . 2 7 ). 
t he  p o i nt  where  we 

f r om 
to 

t he  subgoal  of  p r o v i ng 
( 3 . 2 7 ),  we  have 
f r om 

( 3 . 3 2 ).  To 
to  p r o ve 

to  p r o ve 
be 
g e n e r a t ed 
p r o ve 
t h is 
( 3 . 3 3) 

f r o m: 

A r t i f i c i al 
p p.  1 2 9 - 1 4 5. 

I n t e l l i g e n c e.  V o l.  2 

( 1 9 7 1 ), 

Schank,  R,  C. 

"A  C o n c e p t u al  Dependency 

R e p r e s e n t a t i on 
S e m a n t i c s ,"  Memo  A l - 8 3,  S t a n f o rd  A . l. 
P r o j e c t,  1969. 

f or  a  C o m p u t e r - O r i e n t ed 

Sussman,  G.  J.  and  D.  V.  McDermott, 

"From 

to  CONNIVER  -  A  g e n e t ic 

PLANNER 
a p p r o a c h ,"  P r o c.  FJCC  41 
1171-1179. 

( 1 9 7 2 ),  p p. 

W i n o g r a d,  T ., 
f or  Data 
N a t u r al  L a n g u a g e ,"  Report  Al  TR-17, 
M . l . T.  A . I.  L a b o r a t o r y,  1 9 7 1. 

" P r o c e d u r es  as  a  R e p r e s e n t a t i on 
In  a  Program 

f or  U n d e r s t a n d i n p; 

-  4.  F u t u re  w o rk 

In 

t he 

t h is  paper  we  have  p r e s e n t ed  a 

f o r m al 
r e p r e s e n t a t i on  of  knowl  edge. 

I n f o r m a t i on  w h i ch 

to  e x p r e ss 
in  our 

L a n g u a ge  f or 
We  have  shown  how 
d i f f i c u lt 
be  e x p r e s s ed 
And  we  have 
s u g g e s t ed  how  a  d e d u c t i ve  program  c o u ld  be 
d e s i g n ed 
C l e a r l y, 
b u i ld 

to  answer  q u e s t i o ns 
t he  n e xt  s t ep 

t h is 
t h at  d e d u c t i ve  p r o g r a m. 
There  a rc  s e v e r al 

in  o t h er 
l a n g u a g e. 

reasons  why 

l a n g u a g e. 
to 

f o r m a l i s ms  can 

r e s e a r ch 

t h is  w o u ld 

in  our 

in 

is 

is 

to 

On 

i n to 

r e s t r i ct 

l a n g u a g e s. 

f i r st  o r d er 

t he  one  hand, 

theorem  p r o v e rs 

For  o n e,  A . I. 
f e ll 
t wo 

be  a  w o r t h w h i le  p r o j e c t. 
d e d u c t i ve  systems  seen 
to 
e x t r e me  c a t e g o r i e s. 
p r e d i c a t e - c a l c u l us 
t h e m s e l v es 
P r o c e d u r al  systems  such  as  PLANNER,  on 
o t h er  h a n d,  use  p a t t e rn  m a t c h i ng  schemes  w h i ch 
a re  g e n e r al  enough 
s t a t e m e n t s,  but 
say  n o t h i ng  about 
s t a t e m e n t s. 
c r e a te  a  system  somewhere 
t h at  w o u ld  embody  s y s t e m a t ic  knowledge  about 
some 

I m p l e m e n t i ng  D - S C R I PT  w o u ld 

to  p r o c e ss  h i g h er  o r d er 

t y p es  of  h i g h er  o r d er  s t a t e m e n t s. 
Beyond 

t h ey  a re  So  g e n e r al 

t he  meaning  of 

In  between 

-  one 

those 

t h ey 

t h at 

t he 

t h i s, 

t he  p a r t i c u l ar 
knowledge  we  have  d i s c u s s ed  seem 
e s p e c i a l ly 
much  work 
d e d u c t i ve  system 
in 
t a k en  a 
w h i ch  can 

i m p o r t a nt 
to  be  done,  b ut 
t r e at 

t h i nk  about 

f i r st  s t ep 

t h i n k i n g. 

f or  A . I. 

to 

t he  way  we  have  p r o p o s e d,  we  w i ll  have 

t o w a r ds  c r e a t i ne  programs 

t y p es  of 
to  be 

There 

is  s t i ll 
if  we  can  program  a 
" T - A - T"  and 
"KNOW" 

Bibilography 

H e w i t t,  C, 

" D e s c r i p t i on  and  T h e o r e t i c al 

( U s i ng  Schemata)  of  PLANNER:  A 
f or  P r o v i ng  Theorems  and 

A n a l y s is 
Language 
M a n i p u l a t i ng  Models 
In  a  R o b o t ,"  Report 
Al  TR-25B,  M . l . T.  A . I.  L a b o r a t o r y,  1972. 

M c C a r t h y,  J ., 
Semantic 
M l n s k y,  e d ,,  p p.  4 0 3 - 4 1 8.  C a m b r i d g e, 
M a s s .:  N.  I  . T.  P r e s s,  1068 . 

"Programs  w i th  Common  S e n s e ," 
I n f o r m a t i on  P r o c e s s i n g.  M a r v in 

in 

M c D e r m o t t,  D,  V ., 

" A s s i m i l a t i on  of 

flew 
I n f o r m a t i on  by  a  N a t u r al  LanGuare-
U n d e r s t a n d l nn  S y s t e m ,"  u n p u b l i s h ed  S.N.. 
t h e s i s,  M . I . T .,  1973. 

Quillian, 

M.  R., 

" S e m a n t ic  Memory,  " 

in 

I n f o r m a t i on  P r o c e s s i n g.  o n.  227-

Semantic 
2 7 0. 

S a n d e w a l l,  F ., 

"Formal  Methods 

in 

t he  Design 

of  Q u e s t i o n - A n s w e r i ng  Systems,11 

Session  8  Formalisms  f or 
A r t i f i c i al 

Intelligence 

CONVERSION  OF  PREDICATE-CALCULUS  AXIOMS,  VIEWED  AS 

NON-DETERMINISTIC  PROGRAMS,  TO  CORRESPONDING  DETERMINISTIC  PROGRAMS 

E r ik  Sandewall 

Computer  Sciences  Department 

Uppsala  u n i v e r s i ty 

in  p r e d i c a te  c a l c u l us 

A b s t r a c t:  The  paper  c o n s i d e rs 
axioms 
which  are 
s o r. 
" o b j e c t s"  must 
ARG-expressions"  which  are 

is  shown 

t h at 

It 

to  be  used  as  " r u l e s"  by  a  GPS-type  s u p e r v i(cid:173)

t h is  can  be  done,  but 

t h at 

the 

then  c o n t a in  procedure  c l o s u r es  or  "FUN-

the  problem  of  c o n v e r t i ng 
to  d e t e r m i n i s t ic  programs, 

l a t er  a p p l i e d. 

Keywords:  d e d u c t i o n, 
t e r m i n i s t i c,  c l o s u r e,  FUNARC-expression. 

t h e o r e m - p r o v i n g, 

r e t r i e v a l,  n o n - d e(cid:173)

I m p l i c it 

i n f o r m a t i on 

r e s o l u t i o n - s t y le 

in  a  sem(cid:173)
to 
theorem-

is  a  k i nd  of  d e d u c t i o n.  One  approach 

r e t r i e v al  has  been 
l a t er  approach  has  been  h i g h - l e v el  program(cid:173)

Background-  R e t r i e v al  of 
a n t ic  data  base 
doing  such 
p r o v i n g;  a 
languages  such  as  Planner1  and  QA42,  where  n o n - d e(cid:173)
ming 
t e r m i n i s t ic  programs  and  p a t t e r n - d i r e c t ed 
i n v o c a t i on  of 
procedures  are  a v a i l a b l e.  The  use  of  u n i f o rm  p r o of  p r o(cid:173)
cedures 
e . g. 
been  w o r r i ed  because 
to  use4,2  and  because 
to  c o n t r o l 4. 

r e p e a t e d ly  c r i t i c i z e d, 
languages  have  a l so 
t h e ir  systems  are  very  expensive 
is  d i f f i c u lt 

t h is  purpose  has  been 
the  h i g h - l e v el 

the  n o n - d e t e r m i n i sm 

In  3.  Users  of 

f or 

to 

r o o ts 

in  A . 1. 

In  each  c y c l e, 

is  a n o t h er  a p p r o a c h,  which  has 

r e(cid:173)
the  General  Problem  S o l v e r 5,  where  one 

There 
search  back 
has  a  s u p e r v i s or  which  a d m i n i s t r a t es  a 
( r e l a t i v e l y) 
xed  set  of  o p e r a t o r s,  and  a  w o r k i ng  set  of  a c t i ve  ob(cid:173)
j e c t s. 
the  s u p e r v i s or  p i c ks  an  o b j e ct 
( u s i ng  any  h e u r i s t ic 
and  an  o p e r a t or 
to 
it  may  h a v e ),  a p p l i es 
o b t a i ns  back  a  number  of  new  o b j e c ts 
more)  which  are  put 
is  c o n t i n u ed  u n t il  some  goal 
j e ct 

the  w o r k i ng  s e t.  T h is  process 
( e . g .,  an  ob(cid:173)

i n f o r m a t i on 
t h at 
the  o b j e c t,  and 
(none,  o n e,  or 

t a r g et  set  appears 

the  o p e r a t or 

is  achieved 

the  w o r k i ng  s e t ). 

is  a  given 

i n to 

in 

f i(cid:173)

l e v e l.  The  n o n - d e t e r m i n i sm 

T h is  approach  has  c e r t a in  advantages 
s t a n d p o i n t,  The  o p e r a t o rs  are 
be  compiled  or  o t h e r w i se 
chine  code 
to 
r e c t ed 
o b j e c ts 
subset  of 
the  n o n - d e t e r m i n i sm 

the  s u p e r v i s o r.  S t i l l, 

I m p l i ed  by 

t h e re 

is 

t r a n s f o r m ed  a ll 

i n v o c a t i o n,  by 
i n to  a  number  of  c l a s s e s,  and  a s s o c i a t i ng  a 

the  s u p e r v i s or  c l a s s i fy 

l e t t i ng 

the  o p e r a t o rs  w i th  each  c l a s s.  There 

is  a l so 

from  an  e f f i c i e n cy 
f i x ed  programs,  which  can 
to  ma(cid:173)
is  c o n c e n t r a t ed 
f or  p a t t e r n - d i(cid:173)

the  way 

room 

the  s e a r c h. 

is 

is 

t h at 

t h e re 

l i t t le 

l e v e l, 

t h is  scheme 
r i g i d.  For  example,  s i n ce  e v e r y t h i ng  happens  on 

The  major  d i s a d v a n t a g e,  of  c o u r s e, 
is  more 
one 
o p e r a t or  c a l ls  a  p r o c e d u r e,  which  c a l ls  a n o t h e r,  which 
is  no  t r i v i al 
wants 
way 
the  " s e a r ch 
l e v e l"  of 
ment  of 
must  be  kept  a v a i l a b le 

f u n c t i on  c a l l s,  v a r i a b le  b i n d i n g s,  e t c. 

t h at  n o n - d e t e r m i n i sm  back  up 

to  be  n o n - d e t e r m i n i s t i c, 

the  s u p e r v i s o r,  w h i le 

in  a ll  branches. 

t h e re 
to 

the  e n v i r o n-

r e c u r s i o n. 

r e t a i n i ng 

to  map 

If  one 

room 

then 

t h at 

f or 

An 
t h is 
the 

I n t e r e s t i ng  q u e s t i on 

is 

r i g i d i t y? 
l i m i t a t i o ns  of  such  a  s y s t e m,  or 

it  very  awkward 

Is 

t h e r e f o r e:  how  harmful 

is 
to  "program  a r o u n d" 

is 

It  easy? 

is  a  s y s t e m a t ic  way 

t h e re 
conclude 
c o n s i d e r ed  as  a  s e r i o us  c a n d i d a te 
tem  a s s o c i a t ed  w i th  a  data  base. 

t h at 

those  problems.  We 
the  search  s u p e r v i s or  approach  s h o u ld  be 

to  handle 

f or 

the  d e d u c t i ve  s y s(cid:173)

the 

t h at 

to  c o n t a in  procedure  c l o s u r e s 6 ' 7,  a l so 

reader  who  might  not  want 
is 

" o b j e c t s" 

Idea.  For 

Basic 
the  whole  paper,  we  d i s c l o se 
the 
c a l l ed  FUNARG-expressIons, 
gether  w i th  an  environment  of  b i n d i n gs 
r i a b l e s.  The 
of  o p e r a t o r s,  and  can 
the  environment 

lambda-expression 

Is  new 

f or  each  o b j e c t. 

lambda-expressions 

t o(cid:173)
f r ee  v a(cid:173)
the  set 
t h e r e f o re  be  c o m p i l e d,  e t c,  but 

i ts 
f i x ed  as 

to 
to  p e r m it 

is  as 

read 

idea 

I . e. 

the 

f or 

thus  h a v i ng  sketched 

A f t er 
r al 
c a l c u l us  e n v i r o n m e n t. 

l et  us  go 

i d e a, 

I n to 

the  background  and 

the  gene-

the  d e t a i ls  of 

the  p r e d i c a t e-

take  a  common-place  axiom  and 
into  a  p r o g r a m - l i ke  o p e r a t o r.  We  choose 

the 

it 

Simplest  case.  Let  us 
c o n v e rt 
t r a n s i t i v i ty  a x i o m, 
A  R ( y , z) 

R ( x , y) 

)  R ( x , z) 

which  goes 

I n to  a 

r u le  of 

the 

form 

On  a  s u b - q u e s t i on  w i th 
l a m b d a ( x , z)  begin 

l o c al  y; 

the  r e l a t i on  R,  use 

from  R ( x , y ); 

determine  y 
r e t u rn  s u b - q u e s t i on  R ( y , z) 
end 

to  y. 

f or  a 

l o o k - up 

" d e t e r m i ne  y 

is  g i v en  back 

from  R ( y , z )"  c a l ls 

" R e t u rn  s u b - q u e s t i o n"  s p e c i f i es 

Here, 
in 
the  data  b a s e,  and  u s u a l ly  a c ts  as  a  n o n - d e t e r m i n i s t ic 
assignment 
i n f o r m a t i on  which 
s i s t i ng  of  a 
l a t t er 
is  a 
does  n ot  need 
b i n d i n gs 
then 
are  a s s o c i a t ed  w i th  R,  and  a p p ly 
gument 

It 
t h e ir 
t h e ir  c u r r e nt  v a l u e s.  The  s u p e r v i s or  w i ll 
( l a m b d a - e x p r e s s i o n s)  which 
the  g i v en  a r(cid:173)
it  chooses. 

the  c u r r e nt  values  of  x  and  yj 

l i s t,  of  course  at  whatever 

the  names  x  and  y,  or 

look  up  a ll  o p e r a t o rs 

(R)  and  an  argument 

the  s u p e r v i s o r,  con(cid:173)

r e l a t i on 
l i st  of 

to  c o n t a in 

l i s t.  The 

them 

time 

the 

to 

to 

to 

if 

to 

the 

the  LISP 

r e l a t i o n s. 

the  search 

It  does  not 

r u le  d e s c r i b es  what  has 

is  executed  by  a  u n i f o rm 

r o u t i ne  c o n t i n u es  search  a c c o r d i ng 

to  be  done  when  any  data 
the 

f u n c t i o ns 
in  a  h i g h e r - l e v el  system, 

T h is 
base  search 
t r a n s i t i v i ty  p r o p e r ty  of 
m a t t er 
theorem-
p r o v e r,  a  P l a n n e r - t y pe  s y s t e m,  or  by  a  h a n d - t a i l o r ed 
proaram  such  as 
However, 
" i n t e r p r e t" 
time  what 
is 
is  extreme 
In 
is 
to 
about 
t i o n)  what  o p e r a t i o ns  w i ll  be  n e c e s s a r y,  so 
w r i te  o ut 
ming  systems 
do  as  many  d e c i s i o ns  as  p o s s i b le  at  c o m p l l e - t i m e. 

to 
f i nd  o ut  at 
r u n(cid:173)
t h e o r e m - p r o v er 
t h is  paper 
i n f o r m a t i on  o n ly 
t he  a c t u al  sub-ques(cid:173)
t h at  we  can 

the  axioms  or 
I . e. 
to  be  done.  A  r e s o l u t i on 

f i nd  o ut  b e f o re  e x e c u t i on 
the  axiom  or 

in 
the  system  has 

r e s p e c t.  Our  concern 

f or  d o i ng  e x a c t ly 

the  SIR  system8. 

the  axioms,  and 

r u l e,  n ot  about 

t e r m s,  we  want 

tn  program(cid:173)

to  compile 

the  code 

r u l e s, 

( w i th 

t h a t, 

t h is 

In 

t ry 

to  answer 

t h is  paper,  we 

In 
i ng  those  o p e r a t o rs  which  c o r r e s p o nd 
t h at  we  have  a  data  base, 
d i c a te  c a l c u l u s.  We  assume 
l a r ge  number  of  ground  u n it  c l a u s e s, 
which 
p l us  a  number  of  o p e r a t o r s,  which  should  c o r r e s p o nd 
the  non-ground  axioms.  We  show 
problems 

t h at  q u e s t i on  by  s t u d y(cid:173)
in  p r e(cid:173)

t h e re  are  c e r t a in 
t h at 

l a t t er  as  o p e r a t o r s , , b ut 

in  p h r a s i ng 

to  axioms 

l i ke  a 

t h at 

the 

Is 

to 

230 

r e s o l u t i on 

If  a 
s i t i v i ty  a x i o m,  and 

the  axiom 

t h e o r e m - p r o v er  c o n t a i ns 

the  above 

t r a n(cid:173)

R(a,b) 

if 

it  asked 

and 
te 
I l l u s t r a t ed 

it  w i ll  genera(cid:173)
the  s u b - q u e s t i on  M l ( a , c ).  T h is  s t ep  can  be  c l e a r ly 
r e w r i t t en  as 

the  " q u e s t i o n"  ^ ( b . c ), 

t r a n s i t i v i ty  axiom 

the 

Is 

If 

rules 

Thus  one  clause  (In  the  resolution  sense)  usually  cor(cid:173)
responds  to  several 
lambda-expressions 
above.  The  number  of  rules  that  correspond  to  a  clause 
Is  f i n i t e. 
then  the  r e s u l t(cid:173)
ing  system  is  not 
a ll 
ness.  We  shall  not  be  concerned  about  t h i s. 

If  some  rules  are  omitted, 

In  general  complete,  but 

is  s t i ll  not  s u f f i c i e nt 

to  insure  complete(cid:173)

inclusion  of 

like  the 

rules 

f i r st  rule  above, 

Going  back  to  the 
the  reader  should 
imagine  that  the  supervisor  contains  one  queue  of  sub-
questions  for  each  relation  symbol,  and  that  every  sub-
question  contains  an  argument 
l i s t.  Every  relation  sym(cid:173)
bol 
is  associated  with  a  set  of  operators,  written  as 
lambda-expressions  like  the  one  above,  which  can  be 
applied 
that  queue  for  that  relation 
symbol.  The  operator  above  returns  a  sub-question,  and 
t e l ls  what  object  -  argument 
and  which  relation 
be  thought  about  as  "demons",  clustered 
a  common  point  of  i n t e r e s t,  which  is  named  by  the  re(cid:173)
lation  symbol. 

it  should  attend.  The  operators  can 
in  groups  with 

it  should  contain, 

to  the  objects 

l i st 

List  of  problems.  This  organization  raises  a  number  of 
questions.  One  problem  is  how  one  should  integrate  heu(cid:173)
r i s t ic  information  into  the  system.  We  shall  not  go  in(cid:173)
to  that  question  here.  Another  question 
l o(cid:173)
is  to  be  handled.  The 
cal  non-determintsm  in  the  rule 
answer 
loop-free), 
non-deterministic  program  into  a 
looping,  deterministic 
program.  Each  branch-point  starts  a  new  loop  inside  the 
loops  of  the  previous  branch-points.  All 
the  end  of  the  rule.  This 

loops  end  at 
is  quite  straight-forward. 

is  simple:  we  map  the 

linear  ( i . e. 

is  how  the 

involves  some  additional  prob(cid:173)

If  the  PC  (predicate  calculus)  axioms  contain  function 
symbols  (not  merely  r e l a t i o n s ),  we  obtain  " u n i f i c a t i o n ", 
or  in  programming 
language  terms:  pattern-matching  and 
pattern-reconstruction.  Then  the  convers ion  to  remove 
the  local  non-determinism 
lems,  which  however  w i ll  be  the  topic  of  a  l a t er  exten(cid:173)
sion  of  this  paper.  Suffice 
function  should  be  associated  with  one  construction  pro(cid:173)
cedure  and  one  or  more  matching  procedures,  and  that 
the  compiled  version  of  the  axiom  must  contain  a  call 
to  one  of  these  procedures. 
"compilation  time"  which  procedure  shall  be  called.  The 
matching  procedure  for  " p l u s"  may  for  example  match  " 1 *" 
against  " p l u s ( x , l )"  and  assign 

It  can  be  determined  at 

it  to  say  that  every  PC 

to  "x"  the  value  3. 

I.e.  Yes/no 

instead  to  the  question  of  how  open  ques(cid:173)
("Closed  questions"  are  questions 

Let  us  turn 
tions  are  handled. 
which  can  be  answered  with  a  truth-value, 
questions;  "open  questions"  are  questions  which  have  an 
I n d i v i d u a l,  or  n-tuple  of 
wer.)  We  decide  immediately  that  "closed  questions  with 
the  r e l a t i on  R"  shall  be  one  class  of  object  and 
inter(cid:173)
est-point 
for  operators,  and  "open  questions  with  the 
relation  R  and  an  asked-for  second  argument,  R(x,?)" 
shall  be  another  class  of  objects, 
set  of  operators.  We  shall  provisionally  denote 
it  as 
R2(X).  For  example,  the  same  t r a n s i t i v i ty  axiom  for  R 
also  c a l ls 

individuals  as  possible  ans(cid:173)

treated  with  another 

following  operator: 

the 

for 

On  a  sub-question  with  R2,  use 
lambda  (x)  begin 

local  y; 

determine  y  from  R(x,y); 
return  sub-question  Ra(y) 

end 

231 

determine  z  from  Q(y,z).; 
return  answer 
end 

f ( x , z) 

Each  of  these  operators  contains  a  main  block,  where 
each  statement  except  the 
last  one  makes  an  access  to 
the  data  base, 
for  e i t h er  a  closed  or  an  open  question, 
(Every  such  statement  corresponds  to  a  l i t e r al 
in  the 
original  axiom).  We  have  t a c i t ly  assumed  that  thosere-
i . e.  only  use  facts 
references  should  be  "immediate", 
that  are  e x p l i c i t ly  in  the  data  base.  However, 
Is 
intermediate  statements  make 
also  possible  to 
the  ope(cid:173)
t h e ir  own  search. 
rators  should  be  deterministic  programs,  and  a ll  search 
then  the  search 
should  be  managed  by  the  supervisor, 
In 
Intermediate  statement  must  be  brought  to  an  end 
the 
before 
It 
follows  that  in  an  intermediate  statement  we  can  only 
make  a  search  which 
search  done  by  the  supervisor. 

the  execution  of  the  operator  can  continue. 

is  " s h o r t"  compared  to  the  main 

If  we  maintain 

idea  that 

let  such 

the 

it 

the 

latest 

to  use 

it  possible 

it  is7  All  search  would  then  be  done 

intermediate  statements  (both  "look  up  y"  and  "look 

Is 
operator  as 
the 
up  z"  in  the  t r a n s i t i v i ty  axiom,  e t c .)  and  the  opera(cid:173)
tor  can  return  a  f i n al  answer,  rather  than  a  sub-ques(cid:173)
tion 
is  correct,  but  clearly 
the  supervisor 

formulation  of  the 
In 

further  search.  This 

is  not  used  at  a ll 

in  t h is  case. 

for 

the 

last 

In  the  f i r st 

In  the  second  axiom,  our  previous 

intermediate  statement  and  decide  that  that 

However,  given 
formulation  of  the  operators, 
we  can  come  back  to  the  previous  formulation  by  p i c k' 
Ing  out  one 
is  where  the  main  search  shall  be  done. 
the  main  search  Is  most  n a t u r a l ly  done  for  "de(cid:173)
axiom, 
formula(cid:173)
termine  z". 
tion  does  the  main  search  for  "determine  y ",  although 
In  principle 
It  would  also  be  possible  to  determine  y 
In  the  shallow  search  of  an 
then  ask  the  supervisor  to  do  main  search 
prove  Q(x,y) 
for  the  selected  y. 
our  previous 
formulation  does  main  search  to  determine 
z,  although  It  would  also  be  possible  to  do  main  search 
for  y,  and  to  determine  z  and  f ( x , z) 
procedure. 

intermediate  statement,  and 

In  the  t h i rd  axiom, 

the  remainder 

in  order  to 

in 

Conclusion  from  the  discussion.  We  conclude  that  the 
general  method  to  convert  a  pred'cate-calculus  axiom 
to  an  operator  should  be: 

(3)  Decide  which  of  the  statements 

in  the  operator 

shall  be  handled  by  the  extensive,  top-level  search 
Is  called 
which 
a  controlled  statement.  Let  the  statements 
in  the 
operator  be 

is  managed  by  the  supervisor.  This 

H,  s 2 . . . . . . . . . . . . Sk - 1,  Sk, Sk +r  - ..  Sn 

where  s. 

Is  the  controlled  statement. 

{*))  Construct  a  new  operator  where  the  statements  are 

232 

It 

is  easily  seen  that 
in  four  steps  can  be  generalized  to  the 

Multiple  controlled  statements. 
the  above  rule 
cases  where  there  are  several  controlled  statements, 
and  top-level  search 
example, 
search  both 
in  order  to  determine  y  from  P ( x , y ),  and  in 
order  to  prove  Q(x,y).  We  must  then  have  two  nested  re(cid:173)
mainder  procedures.  The  resulting  operator  should  have 
the  form: 

in  axiom  2  we  might  wish  to  make  extensive 

is  performed  for  each  of  them.  For 

On  a  sub-question  with  R2,  use 
lambda  (x)  begin 

return  sub-question  P2(x),  with  remain(cid:173)
der  procedure 
lambda  (y)  begin 

return  sub-question  Q(x,y) 
/a  closed  sub-question/  with 
the  remainder  prodedure 
lambda  ()  return  answer  y 
end 

end 

We  realize  that  "every  answer"  to  a  closed  sub-question 
must  be  a f f i r m a t i v e, 
Q(x,y), 

i.e.  as  soon  as  it  has  proved 

the  above  operator  returns  y. 

the  f i r st 

Chains  of  sub-guestions.  The  operators  as  formulated 
above  return  sub-questions  consisting  of  a  relation 
symbol,  an  argument  l i s t,  and  a  remainder  function,  but 
they  only  accept 
the  supervisor 
responsible 
remainder  procedures.  However, 
where  procedures  are  permitted  as  arguments  (to  other 
procedures), 
the  responsibility  can  easily  be  taken  by 
the  operators  and  the  programming  system.  We  shall  now 
describe  how  this  can  be  done. 

two  items.  This  means 
for  administrating 
in  a  programming  system 

that 
the 

is 

In  closed  and  open  questions,  we  add  one  more  argument 
9,  which 
gument 
objects  which  our  supervisor  shall  handle. 

is  the  remainder  procedure.  The  resulting  ar(cid:173)
for  R2,  e t c .,  are  the 

(x,y,g) 

for  R, 

(x,g) 

l i s ts 

We  then  modify  the  examples  so  that  g  is  introduced  as 
an  argument  and  applied  to  the  returned  answer.  Thus 
the  d e f i n i te  version  of  the  rule 

for  axiom  3 

i a: 

On  a  sub-question  with  R2,  use 
lambda  (x,g)  begin 

local  y; 

determine  y  from  P(x.y); 
return  sub-question 

Q2(y, 

function(lambda 

(z)  g ( f ( x , z )) )) 

end 

The  other  rules  are  modified  s i m i l a r l y.  We  notice  that 
the  sub-questions 
two 
transfer  variables:  x  and  g.  The  bindings  of  these  must 
be  saved  in  the  closure,  and  retained  u n t il 
the  remain(cid:173)
der  procedure 

that  t h is  rule  returns,  contain 

is  used. 

i t s e lf  pfesumably 

is  generated,  where  each  one  refers  to 

Let  g'  be  the  second  argument  of  0.2 
in  one  p a r t i c u l ar 
use  of  the  above  operator.  Clearly  g1  contains  a  refer(cid:173)
ence  to  g,  which 
is  a  procedure  c l o(cid:173)
sure,  which  was  set  up  by  a  previous  sub-question.  As 
one  sub-question  generates  another,  a  chain  of  closu(cid:173)
res 
its  prede(cid:173)
cessor.  When 
in  a 
question, 
the 
its  predecessor  by 
return-answer  statement; 
using  a  procedure  variable,  as  seen  in  the  example, 
predecessor  c a l ls 
its  predecessor,  and  so  on  up  the 
chain. 
as  "return  aeswer". 

f i n a l ly  an  answer 
last  procedure  closure  is  applied 

(top-level)  q j e s t i o n,  q  is  given 

In  the  o r i g i n al 

is  found  to  the  last  sub-

it  calls 

the 

Discussion  of  a p p l i c a b i l i ty  of_the  method.  This  proce(cid:173)
dure  works 
interrupt  points 

In  a ll  cases  where  the  non-determinlstic 

(where  another,  parallel  branch 

is  per(cid:173)

in  recursion, 

in  p r i n c i p l e,  the  t r i ck 

mitted  to  a t t r a ct  attention)  can  be  brought 
to  the  top-
level  block  of  the  "operators",  and  not  be  hidden  deep(cid:173)
er  down 
the  control  stack  (the  stack  of  function  c a l l s) 
one  element  deep  at 
the  c a ll 
the  control  stack 
how  far  we  have  gotten,  can  be  put 
transfer  variable.  With  this  method,  we  have  no  control 
stack  environment,  but  merely  a  variable-binding  envi(cid:173)
ronment  at  the 
what  FUNARG  (or  procedure  closures)  can  handle. 

from  the  supervisor  to  the  operator),  and  then 
information  of 

interrupt  points  (containing 

interrupt  points,  and  t h is 

information,  plus  the 

in  one  additional 

is  exactly 

is  only 

is  that 

the 

We  believe  that  this  method 
is  s u f f i c i e n t ly  powerful 
handle  e.g.  a ll  cases  which  may  occur  when  PC  axioms 
are  mapped  into  rules,  and  probab  1y  also  a  broader  app-
lication. 

to 

A  questionable  feature  of  this  method 
that  one  must 
in  principle  decide  at  "compile-time"  which  retrievals 
are  to  be  done  by  " b i g"  search,  and  which  are  to  be  done 
by  " s h o r t"  intermediate  statement 
(•  non-controlled  sta(cid:173)
tement)  search. 
In  some  applications  t h is  is  OK,  since 
some  relations  are  only  stored  e x p l i c i t ly  or  almost  ex(cid:173)
p l i c i t l y; 

it  may  not  be  acceptable. 

In  others 

is 

is 

If  the  conver-

Requirements  on  the  programming  language. 
sion  from  PC  axiom  to  operator  is  to  be  done  automati(cid:173)
then  the  selected  programming  language  must  of 
c a l l y, 
course  be  able  to  generate  and  manipulate  programs 
in 
the  same  language.  LISP  Is  then  an  obvious  choice.  How(cid:173)
ever,  during  the  execution  of  the  search,  our  require(cid:173)
ment 
instead  that  we  must  be  able  to  create  a  proce(cid:173)
dure  closure,  and  send  it  around  as  data.  Some  simula(cid:173)
tion 
this  f a c i l i t y, 
as  well  as  POP-211  and  ECL12.  LISP1.5  systems  ( a - l i st 
through  the  FUNARG  feature.  Later 
systems)  provide 
LISP  systems 
(LISP  1.6,  original  BBN-LISP)  do  not  pro(cid:173)
vide  i t7.  A  method  for  providing  FUNARG  in  BBN-LISP'type 
systems  without  undue 
posed  I n9. 

languages,  notably  Simula  6710  have 

loss  of  efficiency  has  been  pro(cid:173)

it 

It  has  been  suggested  that  the  notion  of  a  "remainder 
procedure",  as  used 
connected  w i th  the  notion  of  "continuation",  which  has 
recently  proved  helpful 
in  discussing  the  denotational 
languages13. 
semantics  of  programming 

is  rather  closely 

in  t h is  paper, 

Implementation.  The  author  has  participated  in  the  deve(cid:173)
lopment  of  a  program,  called  PCDB  (Predicate  Calculus 
Is  organized  according  to  the  search 
Data  Base),  which 
supervisor  p r i n c i p l e.  This  program  was  described 
in  re(cid:173)
ference  14,  and  contains  a  compiler  which  accepts  PC 
axioms  and  generates  corresponding  LISP  programs. 
so  contains  a  simple  supervisor,  elaborate  data  base 
handling  f a c i l i t i e s,  etc.  which  are  needed.  The  present 
(1972)  version  of  PCDB 
the  supervisor  administrate 
lets 
the  remainder  procedures 
in  an  ad  hoc  and  not  completely 
general  way.  A  new  compiler  is  being  w r i t t e n,  which  w i ll 
administrate  them  with  FUNARG  expressions  as 
indicated 
in 
the  conference. 

this  paper.  We  hope  to  have 

it  working  at  the  time  of 

It  a l(cid:173)

Acknowledgements.  The  following  people 
helped  with  the  PCDB  work:  Lennart  Drugge,  Anders  Harald-
son,  Rene"  Reboh. 

in  Uppsala  have 

Sponsor:  This  research  was  supported  by  IBM  Svenska  AB. 

233 

References 

1 .C  H e w i tt 

D e s c r i p t i on  and 
of  PLANNER,  a 
p u l a t i ng  models 
Ph.D. 
Mass. 

t h e o r e t i c al  a n a l y s is 

language 

f or  p r o v i ng 

( u s i ng  schemata) 
theorems  and  mani-

In  a  robot 

t h e s i s,  Dept.  of  m a t h e m a t i c s,  MIT,  Cambridge, 
(1972) 

2.  J . F.  R u l I f s on  et  a l. 

QA4:  a  p r o c e d u r al  b a s is 
f or 
Al  C e n t e r,  S t a n f o rd  Research 

i n t u i t i ve 
I n s t i t u te 

r e a s o n i ng 

(1972) 

3.  D.B.  Anderson  and  P . J.  Hayes 

l o g i c i a n 's 

The 
in 
S o c i e t y,  1972 

the 

f o l ly 

(European)  AlSB  B u l l e t i n,  B r i t i sh  Computer 

4.  G . J.  Sussman 

Why  c o n n i v i ng 
MIT  Al 

is  b e t t er 
l a b o r a t o r y,  1972 

than  p l a n n i ng 

5.  A.  Newell  et  a l. 

Report  on  a  general  p r o b l e m - s o l v i ng  program 
Proc. 

IFIP  Congress  1959,  p.  256 

6.  P . J.  Landin 

The  mechanical  e v a l u a t i on  of  e x p r e s s i o ns 
Computer  J o u r n a l,  V o l.  6 

( 1 9 6 4 ),  pp.  308-320 

7.  J.  Moses 

The  F u n c t i on  of  FUNCTION 
problem  should  be  c a l l ed 
ACM  SIGSAM  b u l l e t in  No.  15 

(1970) 

in  LISP,  or  why 
the  environment  problem 

the  FUNARG 

9.  B.  Raphe1 

SIR:  a  computer  program 
t r i e v al 
in  M i n s k y,  e d .:  Semantic 
MIT  p r e s s,  1968 

9.  E.  Sandewall 

f or  semantic 

I n f o r m a t i on 

r e(cid:173)

i n f o r m a t i on  p r o c e s s i ng 

A  proposed  s o l u t i on 
ACM  SIGSAM  b u l l e t in  No.  17 

to 

(1971) 

the  FUNARG  problem 

10.  Ole-Johan  Dahl  et  a t. 
Common  Base  Language 
Norwegian  Computing  C e n t e r,  O s l o,  1970 

1.  R.M.  B u r s t a ll  et  a l. 

Programming 
Edlnburhg  Univ.  P r e s s,  1971 

in  POP-2 

2.  B.  Wegbreit  et  a l. 

ECL  Programmer's  Manual 
Harvard  U n i v e r s i t y,  Cambridge,  Mass.  1972 

3.  J.  Reynolds 
D e f i n i t i o n al 
ming 
Proceedings  of  an  ACM  Conference,  Boston,  Mass.,1972 

f or  h i g h er  o r d er  program­

i n t e r p r e t e rs 

languages 

4.  E.  Sandewall 
A  programming 
c a l c u l u s - o r i e n t ed  data  base 
in  Proceedings  of 
the  second 
c o n f e r e n ce  on  A r t i f i c i al 
p u t er  S o c i e t y,  London,  1971 

t o ol 

f or  management  of  a  p r e d i c a t e-

I n t e r n a t i o n al 

j o i nt 

i n t e l l i g e n c e,  B r i t i sh  Com(cid:173)

234 

A  Universal  Modular  ACTOR  Formalism 

for  Artificial 

Intelligence 

Carl  Hewitt 
Peter  Bishop 
Richard  Steiger 

Abstract 

A r t i f i c i al 

Intelligence 

This  paper  proposes  a  modular  ACTOR  architecture  and  definitional  method  for  a r t i f i c i al 

intelligence  that  is  conceptually  based  on  a  single  kind  of  object:  actors  [or,  if  you  w i l l, 
virtual  processors,  activation  frames,  or  streams].  The  formalism  makes  no  presuppositions 
about  the  representation  of  primitive  data  structures  and  control  structures.  Such  structures 
can  be  programmed,  micro-coded,  or  hard  wired  1n  a  uniform  modular  fashion. 
impossible  to  determine  whether  a  given  object  is  "really"  represented  as  a  l i s t,  a  vector,  a 
hash  table,  a  function,  or  a  process.  The  architecture  will  efficiently  run  the  coming 
generation  of  PLANNER-like  a r t i f i c i al  intelligence  languages  including  those  requiring  a  high 
degree  of  parallelism.  The  efficiency  is  gained  without  loss  of  programming  generality  because 
it  only  makes  certain  actors  more  efficient;  it  does  not  change  their  behavioral 
characteristics.  The  architecture  is  general  with  respect  to  control  structure  and 
does  not  have  or  need  goto,  interrupt,  or  semaphore  primitives.  The  formalism  achieves  the  goals  that 
the  disallowed  constructs  are  intended  to  achieve  by  other  more  structured  methods. 

In  fact  it  is 

PLANNER Progress 

"Programs  should  not  only  work, 

but  they  should  appear  to  work  as  well." 

PDP-1X Dogma 

The  PLANNER  project  is  continuing  research  in  natural  and  effective  means  for  embedding 

In  the  course  of  this  work  we  have  succeeded  in  unifying  the 

knowledge  in  procedures. 
formalism  around  one  fundamental  concept: 
which  plays  a  role  on  cue  according  to  a  script"  we" use  the  ACTOR  metaphor  to  emphasize  the 
inseparability  of  control  and  data  flow  in  our  model.  Data  structures,  functions,  semaphores, 
monitors,  ports,  descriptions,  Quillian  nets,  logical  formulae,  numbers,  identifiers,  demons, 
processes,  contexts,  and  data  bases  can  all  be  shown  to  be  special  cases  of  actors.  All  of  the 
above  are  objects  with  certain  useful  modes  of  behavior.  Our  formalism  shows  how  all  of  the 
modes  of  behavior  can  be  defined  in  terms  of  one  kind  of  behavior:  sending  messages  to  actors. 
An  actor  is  always  invoked  uniformly  in  exactly  the  same  way  regardless  of  whether  1t  behaves 
as  a  recursive  function,  data  structure,  or  process. 

Intuitively,  an  ACTOR  is  an  active  agent 

the  ACTOR. 

" It  is  vain  to  multiply  Entities  beyond  need." 

William  of  Occam 

"Monotheism  is  the  Answer." 

The  unification  and  simplification  of  the  formalisms  for  the  procedural  embedding  of 

knowledge  has  a  great  many  benefits  for  us: 

FOUNDATIONS:  The  concept  puts  procedural  semantics  [the  theory  of  how  things 

operate]  on  a  firmer  basis. 
It  will  now  be  possible  to  do  cleaner  theoretical  studies  of  the 
relation  between  procedural  semantics  and  set-theoretic  semantics  such  as  model  theories  of 
the  quantificational  calculus  and  the  lambda  calculus. 

LOGICAL  CALCULAE:  A  procedural  semantics  is  developed  for  the  quantificational 

calculus.  The  logical  constants  FOR-ALL,  THERE-EXISTS,  AND,  OR,  NOT,  and  IMPLIES 
are  defined  as  actors. 

KNOWLEDGE  BASED  PROGRAMMING  is  programming  in  an  environment  which  has  a 

substantial  knowledge  base  in  the  application  area  for  which  the  programs  are  intended. 
The  actor  formalism  aids  knowledge  based  programming  in  the  following  ways-.  PROCEDURAL 
EMBEDDING  of  KNOWLEDGE,  TRACING  BEHAVIORAL  DEPENDENCIES,  and  SUBSTANTIATING  that  ACTORS 
SATISFY  their  INTENTIONS. 

INTENTIONS:  Furthermore  the  confirmation  of  properties  of  procedures  is  made 

easier  and  more  uniform.  Every  actor  has  an  INTENTION  which  checks  that  the  prerequisites 
and  the  context  of  the  actor  being  sent  the  message  are  satisfied.  The  intention  is  the 
CONTRACT  that  the  actor  has  with  the  outside  world.  How  an  actor  f u l l f l l ls  its  contract  is 
its  own  business.  By  a  SIMPLE  BUG  we  mean  an  actor  which  does  not  satisfy  its  intention. 
We  would  like  to  eliminate  simpTedebugging  of  actors  by  the  META-EVALUATION  of  actors  to  show 
that  they  satisfy  their  Intentions.  Suppose  that  there  is  an  external  audience  of  actors  E 
which  satisfy  the  intentions  of  the  actors  to  which  they  send  messages. 
principle  of  ACTOR  INDUCTION  states  that  the  intentions  of  all  actions  caused  by  E  are 
in  turn  satisfied  provided  that  the  following  condition  holds: 

Intuitively,  the 

If  for  each  actor  A 

the  intention  of  A  is  satisfied  => 
that  the  intentions  of  all  actors  sent  messages  by  A  are  satisfied. 

Computational  induction  [Manna],  structural  induction  [Burstall],  and  Peano  induction 
are  all  special  cases  of  ACTOR  induction.  Actor  based  intentions  have  the  following 
advantages:  The  intention  is  decoupled  from  the  actors  it  describes. 
Intentions  of 
concurrent  actions  are  more  easily  disentangled.  We  can  more  elegantly  write  intentions 
for  dialogues  between  actors.  The  intentions  are  written  1n  the  same  formalism  as  the 
procedures  they  describe.  Thus  for  example  intentions  can  have  intentions.  Because 
protection  is  an  intrinsic  property  of  actors,  we  hope  to  be  able  to  deal  with  protection 
issues  in  the  same  straight  forward  manner  as  more  conventional  intentions. 
Intentions 
of  data  structures  are  handled  by  the  same  machinery  as  for  all  other  actors. 

COMPARATIVE  SCHEHATOLOGY:  The  theory  of  comparative  power  of  control  structures  is 

235 

extended  and  unified.  The  following  hierarchy  of  control  structures  can  be  explicated  by 
incrementally 

Increasing  the  power  of  the  message  sending  primitive: 
iterative---recursive---backtrack---+determinate-  --universal 

EDUCATION:  The  model  is  sufficiently  natural  and  simple  that  it  can  be  made  the 

conceptual  basis  of  the  model  of  computation  for  students. 
the  conceptual  model  for  a  generalization  of  Seymour  Papert's  " l i t t le  man"  model  of  LOGO. 
The  model  becomes  a  cooperating  society  of  " l i t t le  men"  each  of  whom  can  address  others 
with  whom  it  is  acquainted  and  politely  request  that  some  task  be  performed. 

In  particular  it  can  be  used  as 

LEARNING  and  MODULARITY:  Actors  also  enable  us  to  teach  computers  more  easily 

because  they  make  it  possible  to  incrementally  add  knowledge  to  procedures  without  having 
to  rewrite  all  the  knowledge  which  the  computer  already  possesses. 
Incremental  extensions 
can  be  incorporated  and  interfaced  in  a  natural  flexible  manner.  Protocol  abstraction 
[Hewitt  1969;  Hart,  Nilsson,  and  Fixes  1972]  can  be  generalized  to  actors  so  that 
procedures  with  an  arbitrary  control  structure  can  be  abstracted. 

EXTENDABILITY:  The  model  provides  for  only  one  extension  mechanism:  creating 

new  actors.  However,  this  mechanism  is  sufficient  to  obtain  any  semantic  extension  that  might 
be desired. 

PRIVACF  and  PROTECTION:  Actors  enable  us  to  define  effective  and  efficient 

protection  schemes.  Ordinary  protection  falls  out  as  an  efficient  intrinsic  property  of 
actors.  The  protection  is  based  on  the  concept  of  "use".  Actors  can  be  freely  passed 
out  since  they  will  work  only  for  actors  which  have  the  authority  to  use  them.  Mutually 
suspicious  "memoryless"  subsystems  are  easily  and  efficiently  implemented.  ACTORS  are  at 
least  as  powerful  a  protection  mechanism  as  domains  [Schroeder,  Needham,  e t c . ],  access 
control  l i s ts  [MULTICS],  objects  [Wulf  1972],  and  capabilities  [Dennis,  Plummer,  Lampson]. 
Because  actors  are  locally  computationally  universal  and  cannot  be  coerced  there  is  reason 
to  believe  that  they  are  a  universal  protection  mechanism  in  the  sense  that  all  other 
protection  mechanisms  can  be  efficiently  defined  using  actors.  The  most  important  issues 
in  privacy  and  protection  that  remain  unsolved  are  those  involving  intent  and  trust.  We 
are  currently  considering  ways  in  which  our  model  can  be  further  developed  to  address  these 
problems. 

SYNCHRONIZATION: 

It  provides  at  least  as  powerful  a  synchronization  mechanism  as 
the  multiple  semaphore  P  operation  with  no  busy  waiting  and  guaranteed  f i r st  in  f i r st  out 
discipline  on  each  resource.  Synchronization  actors  are  easier  to  use  and  substantiate 
than  semaphores  since  they  are  directly  tied  to  the  control-data  flow. 

SIMULTANEOUS  GOALS:  The  synchronization  problem  is  actually  a  special  case  of  the 

simultaneous  goal  problem.  Each  resource  which  is  seized  is  the  achievement  and 
maintenance  of  one  of  a  number  of  simultaneous  goals.  Recently  Sussman  has  extended  the 
previous  theory  of  goal  protection  by  making  the  protection  guardians  into  a  l i st  of 
predicates  which  must  be  re-evaluated  every  time  anything  changes.  We  have  generalized 
protection  in  our  model  by  endowing  each  actor  with  a  scheduler.  We  thus  retain  the 
advantages  of  local  intentional  semantics.  A  scheduler  actor  allows  us  to 
program  EXCUSES  for  violation  in  case  of  need  and  to  allow  NEGOTIATION  and  re-negotiation 
between  the  actor  which  seeks  to  seize  another  and  its  scheduler.  Richard  Waldinger  has 
pointed  out  that  the  task  of  sorting  three  numbers  is  a  very  elegant  simple  example 
illustrating  the  u t i l i ty  of  incorporating  these  kinds  of  excuses  for  violating  protection. 

RESOURCE  ALLOCATION:  Each  actor  has  a  banker  who  can  keep  track  of  the  resources 

used  by  the  actors  that  are  financed  by  the  banker. 

STRUCTURING:  The  actor  point  of  view  raises  some  interesting  questions  concerning 

the  structure  of  programming. 

STRUCTURED  PROGRAMS:  We  maintain  that  actor  communication  is  well-structured. 

Having  no  goto,  interrupt,  semphore,  etc.  constructs,  they  do  not  violate  "the  letter 
of  the  law."  Some  readers  will  probably  feel  that  some  actors  exhibit  "undisciplined" 
control  flow.  These  distinctions  can  be  formalized  through  the  mathematical  discipline 
of  comparative  schematology  [Patterson  and  Hewitt]. 

STRUCTURED  PROGRAMMING:  Some  authors  have  advocated  top  down  programming.  We 

find  that  our  own  programming  style  can  be  more  accurately  described  as  "middle  out". 
We  typically  start  with  specifications  for  a  large  task  which  we  would  like  to  program. 
We  refine  these  specifications  attempting  to  create  a  program  as  rapidly  as  possible. 
This  i n i t i al  attempt  to  meet  the  specifications  has  the  effect  of  causing  us  to  change 
the  specifications  in  two  ways: 

1:  More  specifications  [features  which  we  originally  did  not  realize  are 

important]  are  added  to  the  definition  of  the  task. 

2:  The  specifications  are  generalized  and  combined  to  produce  a  task  that 

is  easier  to  implement  and  more  suited  to  our  real  needs. 
IMPLEMENTATION:  Actors  provide  a  very  flexible  implementation  language. 

In  fact 

we  are  carrying  out  the  implementation  entirely  in  the  formalism  i t s e l f.  By  so  doing  we 
obtain  an  implementation  that  is  efficient  and  has  an  effective  model  of  itself.  The 
efficiency  is  gained  by  not  having  to  incur  the  interpretive  overhead  of  embedding  the 
implementation  in  some  other  formalism.  The  model  enables  the  formalism  to  answer 
questions  about  itself  and  to  draw  conclusions  as  to  the  impact  of  proposed  changes  in  the 
Implementation. 

ARCHITECTURE:  Actors  can  be  made  the  basis  of  the  architecture  of  a  computer  which 

means  that  all  the  benefits  listed  above  can  be  enforced  and  made  efficient.  Programs 
written  for  the  machine  are  guaranteed  to  be  syntactically  properly  nested.  The  basic  unit 
of  execution  on  an  actor  machine  is  sending  a  message  in  much  the  same  way  that  the  basic 

2 36 

unit  of  execution  on  present  day  machines  is  an  Instruction.  On  a  current  generation 
machine  in  order  to  do  an  addition  an  add  Instruction  must  be  executed;  so  on  an  actor 
machine  a  hardware  actor must  be  sent  the  operands  to  be  added.  There  are  no  goto, 
semaphore,  interrupt,  etc.  instructions  on  an  ACTOR  machine.  An  ACTOR  machine  can  be  built 
using  the  current  hardware  technology  that  is  competitive  with  current  generation  machines. 

"Now!  Now!"  cried  the  Queen. 

"Faster!  Faster!" 

Lewis  Carroll 

Current  developments  in  hardware  technology  are  making  it  economically  attractive 

to  run  many  physical  processors  in  parallel.  This  leads  to  a  "swarm  of  bees"  style  of 
programming.  The  actor  formalism  provides  a  coherent  method  for  organizing  and 
controlling  all  these  processors.  One  way  to  build  an  ACTOR  machine  is  to  put  each  actor 
on  a  chip  and  build  a  decoding  network  so  that  each  actor  chip  can  address  a ll  the  others. 
In  certain  applications  parallel  processing  can  greatly  speed  up  the  processing.  For 
example  with  sufficient  parallelism,  garbage  collection  can  be  done  1n  a  time  which  is 
proportional  to  the  logarithm  of  the  storage  collected  instead  of  a  time  proportional  to 
the  amount  of  storage  collected  which  is  the  best  that  a  serial  processor  can  do.  Also  the 
architecture  looks  very  promising  for  parallel  processing  In  the  lower  levels  of  computer 
audio  and  visual  processing. 

"All  the  world's  a  stage, 
And  all  the  men  and  women  merely  actors. 
They  have  their  exits  and  their  entrances; 
And  one  man  in  his  time  plays  many  parts." 

" If  it  waddles  like  a  duck,  quacks  like  a  duck,  and  otherwise  behaves  like  a  duck;  then 
you  can't  t e ll 

that  it  isn't  a  duck." 

Adding  and  Reorganizing  Knowledge 

Our  aim  is  to  build  a  firm  procedural  foundation  for  problem  solving.  The  foundation 
attempts  to  be  a  matrix  in  which  real  world  problem  solving  knowledge  can  be  efficiently  and 
naturally  embedded.  We  envisage  knowledge  being  embedded  in  a  set  of  knowledge  boxes  with 
interfaces  between  the  boxes. 
knowledge  in  the  model  without  having  to  totally  rewrite  i t.  Certain  kinds  of  additions  can  be 
easily  encompassed  by  declarative  formalisms  such  as  the  quantificational  calculus  by  simply 
adding  more  axioms. 
Imperative  formalisms  such  as  actors  do  not  automatically  extend  so 
easily.  However,  we  are  implementing  mechanisms  that  allow  a  great  deal  of  f l e x i b i l i ty  in 
adding  new  procedural  knowledge.  The  mechanisms  attempt  to  provide  the  following  abilities; 

In  constructing  models  we  need  the  ability  to  embed  more 

PROCEDURAL  EMBEDDING:.  They  provide  the  means  by  which  knowledge  can  easily  and 

naturally  be  embedded  in  processes  so  that  it  will  be  used  as  intended. 

CONSERVATIVE  EXTENSION:  They  enable  new  knowledge  boxes  to  be  added  and 

interfaced  between  knowledge "Foxes. 

between  knowledge  boxes. 

MODULAR  CONNECTIVITY:  They  make  it  possible  to  reorganize  the  interfaces 

MODULAR  EQUIVALENCE:  They  guarantee  that  any  box  can  be  replaced  by  one  which 

satisfies  the  previous  interfaces. 
Actors  must  provide  interfaces  so  that  the  binding  of  interfaces  between  boxes  can  be 

controlled  by  knowledge  of  the  domain  of  the  problem.  The  right  kind  of  interface  promotes 
modularity  because  the  procedures  on  the  other  side  of  the  interface  are  not  affected  so  long 
as  the  conventions  of  the  interface  are  not  changed.  These  interfaces  aid  in  debugging  since 
traps  and  checkpoints  are  conveniently  placed  there.  More  generally,  formal  conditions  can  be 
stated  for  the  interfaces  and  confirmed  once  and  for  a l l. 

Unification 

We  claim  that  there  is  a  common  Intellectual  core  to  the  following  (now  somewhat 

isolated)  fields  that  can  be  characterized  and  investigated:  digital  circuit  designers,  data 
base  designers,  computer  architecture  designers,  programming  language  designers,  computer 
system  architects. 

"Our  primary  thesis  is  that  there  can  and  must  exist  a  single  language  for 

software  engineering  which  is  usable  at  all  stages  of  design  from  the  i n i t i al 
conception  through  to  the  final  stage  in  which  the  last  bit  1s  solidly  1n  place  on 
some  hardware  computing  system." 

Doug Ross 

"Know  thyself". 

The  time  has  come  for  the  unification  and  integration  of  the  f a c i l i t i es  provided  by  the 

above  designers  into  an  intellectually  coherent  manageable  whole.  Current  systems  which 
separate  the  following  intellectual  capabilities  with  arbitrary  boundaries  are  now  obsolete. 

We  intend  that  our  actors  should  have  a  useful  working  knowledge  of  themselves.  That  i s,  they 
should  be  able  to  answer  reasonable  questions  about  themselves  and  be  able  to  trace  the 
implications  of  proposed  changes  in  their  intentions. 
implementation  understand  i t s e lf  is  a  rather  incestuous  a r t i f i c i al  intelligence  domain  but  we 
believe  that  it  is  a  good  one  for  several  reasons.  The  implementation  of  actors  on  a 
conventional  computer  Is  a  relatively  large  complex  useful  program  which  is  not  a  toy.  The 
implementation  must  adapt  i t s e lf  to  a  relatively  unfavorable  environment.  Creating  a  model  of 
itself  should  aid  in  showing  how  to  create  useful  models  of  other  large  knowledge  based  programs 
since  the  implementation  addresses  a  large  number  of  d i f f i c u lt  semantic  issues.  We  have  a 
number  of  experts  on  the  domain  that  are  very  interested  1n  formalizing  and  extending  their 
knowledge.  These  experts  are  good  programmers  and  have  the  time,  motivations,  and  ability  to 

It  might  seem  that  having  the 

237 

embed  their  knowledge  and  intentions  in  the  formalism. 

"The  road  to  hell  is  paved  with  good  intentions." 

Once  the  experts  put  in  some  of  their  intentions  they  find  that  they  have  to  put  in  a  great 
deal  more  to  convince  the  auditor  of  the  consistency  of  their  intentions  and  procedures. 
In 
this  way  we  hope  to  make  explicit  all  the  behavioral  assumptions  that  our  implementation  1s 
relying  upon.  The  domain  is  closed  1n  the "sense""that  the  questions  that  can  reasonably  be 
asked  do  not  lead  to  a  vast  body  of  other  knowledge  which  would  have  to  be  formalized  as  well. 
The  domain  is  limited  in  that  1t  is  possible  to  start  with  a  small  superficial  model  of  actors 
and  build  up  Incrementally.  Any  advance  is  immediately  useful  in  aiding  and  motivating  future 
advances.  There  1s  no  hidden  knowledge  as  the  formalism  is  being  entirely  implemented  in 
itself.  The  task  is  not  complicated  by  unnecessary  bad  software  engineering  practices  such  as 
the  use  of  gotos,  interrupts,  or  semaphores. 

We  are  approaching  the  problem  from  a  behavioral  [procedural]  as  opposed  to  an 

axiomatic  approach.  Our  view  is  that  objects  are  defined  by  their  actors  rather  than  by 
axiomatizing  the  properties  of  the  operations  that  can  be  performed  on  them. 

Intrinsic  Computation 

"Ask  not  what  you  can  do  to  some  actor; 
but  what  the  actor  can  [will?]  do  for  you." 

Alan  Kay  has  called  this  the  INTRINSIC  as  opposed  to  the  EXTRINSIC  approach  to  defining 
objects.  Our  model  follows  the  following  two  fundamental  principles  of  organizing  behavior: 

Control  flow  and  data  flow  are  inseparable. 
Computation  should  be  done  intrinsically  instead  of  extrinsically  i.e.  "Every 

actor  should  act  for  himself  or  delegate  the  responsibility  [pass  the  buck]  to  an  actor 
who  w i l l ." 

Although  the  fundamental  principles  are  very  general  they  have  definite  concrete  consequences. 
For  example  they  rule  out  the  goto  construct  on  the  grounds  that  it  does  not  allow  a  message  to 
be  passed  to  the  place  where  control  is  going.  Thus  it  violates  the  inseparability  of  control 
and  data  flow.  Also  the  goto  defines  a  semantic  object  [the  code  following  the  tag]  which  is 
not  properly  syntactically  delimited  thus  possibly  leading  to  programs  which  are  not  properly 
syntactically  nested.  Similarly  the  classical  interrupt  mechanism  of  present  day  machines 
violates  the  principle  of  intrinsic  computation  since  it  wrenches  control  away  from  whatever 
instruction  is  running  when  the  interrupt  strikes. 

Hierarchies 

The  model  provides  for  the  following  orthogonal  hierarchies: 

SCHEDULING:  Every  actor  has  a  scheduler  which  determines  when  the  actor 
actually  acts  after  it  1s  sent  a  message.  The  scheduler  handles  problems  of 
synchronization.  Another  job  of  the  scheduler  [Rulifson]  is  to  try  to  cause  actors  to 
act  in  an  order  such  that  their  intentions  will  be  satisfied. 

INTENTIONS:  Every  actor  has  an  intention  which  makes  certain  that  the 

prerequisites  and  context  of  the  actor  being  sent  the  message  are  satisfied. 
Intentions  provide  a  certain  amount  of  redundancy  in  the  specifications  of  what  is 
supposed  to  happen. 

MONITORING:  Every  actor  can  have  monitors  which  look  over  each  message  sent  to 

the  actor. 

that  occur  within  1t. 

and  time. 

BINDING:  Every  actor  can  have  a  procedure  for  looking  up  the  values  of  names 

RESOURCE  MANAGEMENT:  Every  actor  has  a  banker  which  monitors  the  use  of  space 

Note  that  every  actor  had  all  of  the  above  abilities  and  that  each  is  done  via  an 

actor! 

"A  slow  sort  of  country!"  said  the  Queen. 

"Now  here,  you  see,  it 

takes  all  the  running  you  can  do,  to  keep  in  the  same  place. 
to  get  somewhere  else,  you  must  run  at  least  twice  as  fast  as  that!" 

If  you  want 

Lewis  Carroll 

The  previous  sentence  may  worry  the  reader  a  bit  as  she  [he]  might  envisage  an  infinite 

chain  of  actions  [such  as  banking]  to  be  necessary  in  order  to  get  anything  done.  We  short 
circuit  this  by  only  requiring  that  it  appear  that  each  of  the  above  activities  1s  done  each 
time  an  actor  is  sent  a  message. 

"There's  no  use  trying,"  she  said:  "one  can't  believe  impossible 

things." 

"I  daresay  you  haven't  had  much  practice,"  said  the  Queen. 
was  your  age,  I  always  did  it  for  half-an-hour  a  day.  Why,  sometimes  I've 
believed  as  many  as  six  impossible  things  before  breakfast." 

"When  I 

Lewis  Carroll 

Each  of  the  activities  is  locally  defined  and  executed  at  the  point  of  invocation. 
This  allows  the  maximum  possible  degree  of  parallelism.  Our  model  contrasts  strongly  with 
extrinsic  quantlficatlonal  calculus  models  which  are  forced  into  global  noneffective  statements 
1n  order  to  characterize  the  semantics. 

"Global  state  considered  harmful." 

We  consider  language  definition  techniques  [such  as  those  used  with  the  Vienna 

Definition  Language]  that  require  the  semantics  be  defined  in  terms  of  the  global  computational 
state  to  be  harmful.  Formal  penalties  [such  as  the  frame  problem  and  the  definition  of 
simultaneity]  must  be  paid  even  if  the  definition  only  effectively  modifies  local  parts  of  the 
state.  Local  intrinsic  models  are  better  suited  for  our  purposes. 

238 

Procedural  embedding  should  be  carried  to  Its  ultimate  level: 

the  architecture  of  the  machine. 

Conceptually,  the  only  objects  in  the  machine  are  actors. 
In  practice  the  machine  recognizes  certain 
actors  as  special  cases  to  save  speed  and  storage.  We  can  easily  reserve  a  portion  of  the  name  space 
for  actors  implemented  in  hardware. 

Hardware 

Syntactic  Sugar 

"What's  the  good  of  Mercator's  North  Poles  and  Equators, 
Tropics,  Zones  and  Meridian  Lines?" 
So  the  Bellman  would  cry:  and  the  crew  would  reply 
"They  are  merely  conventional  signs!" 

Lewis  Carroll 

Thus  far  1n  our  discussion  we  have  discussed  the  semantic  issues  intuitively  but  vaguely. 

We  would  now  like  to  proceed  with  more  precision.  Unfortunately  in  order  to  do  this  it  seems 
necessary  to  introduce  a  formal  language.  The  precise  nature  of  this  language  1s  completely 
unimportant  so  long  as  it  1s  capable  of  expressing  the  semantic  meanings  we  wish  to  convey.  For  some 
years  we  have  been  constructing  a  series  of  languages  to  express  our  evolving  understanding  of  the 
above  semantic 

issues.  The  latest  of  these  is  called  PLANNER-73. 

Meta-syntactic  variables  will  be  underlined.  We  shall  assume  that  the  reader  1s  familiar  with 

advanced  pattern  matching  languages  such  as  SN0B0L4,  CONVERT,  QA4,  and  PLANNER-71. 

We  shall  use (%A M%) to  indicate  sending  the  message  M  to  the  actor  A.  We  shall  use 

[s1  s2  . ..  sn]  to  denote  the  f i n i te  sequence  s1,  s2_,  . ..  sn.  ft  sequence  s  is  an  actor  where  (%s_  i%) 
is  element  i  of  the  sequence  s.  For  example  (%[a  c  b]  2%)  is  c.  We  will  use  (  )  to  delimit  the 
simultaneous  synchronous  transmission  of  more  than  one  message  so  that  (Al  A2...An)  will  be 
defined  to  be  (%A1  [A2  . ..  An]%).  The  expression  [%a1  a2  . ..  an%]  (read  as  ""a]  then  a2  . ..  finally 
send  back  an")  willI  be  evaluated  by  evaluating  a l,  a2,  . . ..  and  an  in  sequence  and  then  sending  back 
["returning"] 

the  value  of  an  as  the  message. 

Identifiers  can  be  created  by  the  prefix  operator  =.  For  example  if  the  pattern  =  x  1s  matched 

with  y,  then  a  new  identifier  is  created  and  bound  to  v. 

"But  'glory'  doesn't  mean  'a  nice  knock-down  argument,"  Alice 

objected. 

"When  I  use  a  word,"  Humpty  Dumpty  said,  in  rather  a  scornful  tone, 

" it  means  just  what  I  choose  1t  to  mean—neither  more  nor  less." 

"The  question  i s ,"  said  Alice,  "whether  you  can  make  words  mean  so 

"The  question  i s ,"  said  Humpty  Dumpty,  "which  is  to  be  master--

many  different  things." 

that's  a l l ." 

Lewis  Carroll 

Humpty  Dumpty  propounds  two  criteria  on  the  rules  for  names: 

Each  actor  has  complete  control  over  the  names  he  uses. 
All  other  actors  must  respect  the  meaning  that  an  actor  has  chosen  for  a  name. 

We  are  encouraged  to  note  that  in  addition  to  satisfying  the  criteria  of  Humpty  Dumpty,  our  names  also 
satisfy  those  subsequently  proposed  by  Bill  Wulf  and  Mary  Shaw:  The  default  is  not  necessarily  to 
extend  the  scope  of  a  name  to  any  other  actor.  The  right  to  access  a  name  is  by  mutual  agreement 
between  the  creating  actor  and  each  accessing  actor.  An  access  right  to  an  actor  and  one  of  its  acquan-
tances  is  decoupled. 
name,  access  to  a  name,  and  allocation  of  storage  are  decoupled.  The  use  of  the  prefix  =  does  not  imply 
the  allocation  of  any  storage. 

It  is  possible  to  distinguish  different  types  of  access.  The  definition  of  a 

One  of  the  simplest  kinds  of  ACTORS  is  a  c e l l.  A  cell  with  i n i t i al  contents  V  can  be  created 

The  pattern  (by-reference  P)  matches  object  E_  1f  the  pattern  Pmatches  (cell  E)  i.e.  a  "cell" 

by  evaluating  (cell  V_).  Given  a  cell  x,  we  can  ask  it  to  send  back  its  contents  by  evaluating 
(contents  xj  which  is  an  abbreviation  for  (x  #contents).  For  example  (contents(cell  3))  evaluates  to  3. 
We  can  ask  it  to  change  its  contents  to  v  by  evaluating  (x-y_).  For  example  if  we  let  x  be  (cell  3)  and 
evaluate  (x--4),  we  will  subsequently  find"  that  (contents  x)  will  evaluate  to  4. 
[see  below]  which  contains  E.  Thus  matching  the  pattern  (by-reference  =x)  against  E  1s  the  same  as 
binding  x  to  (cell  E)  i.e.  a  new  cell  which  contains  the  value  of  the  expression  E.We  shall  use  => 
[read  as  "RECEIVE  MESSAGE"]  to  mean  an  actor  which  is  reminiscent  of  the  actor  LAMBDA  in  the  lambda 
calculus.  For  example  (=>  x  body)  1s  like  (LAMBDA  x  body)  where  x  1s  an  identifier.  An  expression 
(=>  pattern  body)  is  an  abbreviation  for  (receive  {[#message  pattern]}  body)  where  receive  1s  a  more 
general  actor  that  is  capable  of  binding  elements  of  the  action  in  addition  to  the  message. 
Evaluating 

(%(=>  pattern  body)  the-messaqe%),  i.e.  sending 
(=>  pattern  body)  the-message,  will  attempt  to  match  the-message  against  pattern. 
is  not  of  the  form  specified  by  pattern,  then  the  actor  is  NOT  APPLICABLE  to  the-message. 
matches  pattern,  then  body  1s  evaluated. 

If  the-message 
If  the-message 
fn])  arg%)  will  send  fl_  the  message  arg  and  if  it  is  not  applicable 

Evaluating  (%(cases  [f1  f2  ••• 

then  it  will  send  f2  the  message  a r g , . . .,  and  send  fn  the  message  aro 

The  following  abbreviations  will  be  used  to  improve  readability: 

(rules  object  clauses)  for 
((cases  clauses)object) 

(let  object  pattern-for-message  body)  for 

(%(=>  pattern-for-message  body)  objects) 

239 

message  mechanisms  of  the  current  SMALL  TALK  machine  of  Alan  Kay  and  the  port  mechanism  of 
Krutat  and  Balzer.  Being  free  of  side  effects  allows  us  a  maximum  of  parallelism  and  allows  an 
actor  to  be  engaged  in  several  conversations  at  the  same  time  without  becoming  confused. 
4:  Sending  a  message  to  an  actor  makes  no  presupposition  that  the  actor  sent  the 
message  will  ever  send  back  a  message  to  the  continuation.  The  unidirectional  nature  of 
sending  messages  enables  us  to  define  iteration,  monitors,  coroutines,  etc.straight  forwardly, 

5:  The  ACTOR  model  is  nojt  an  [environment-pointer,  instruction-pointer]  model  such  as 

the  CONTOUR  model.  A'continuation  is  a  f u ll  blown  actor  [with  all  the  rights  and  privileges]; 
it  is  not  a  program  counter.  There  are  no  instructions  [in  the  sense  of  present  day  machines] 
in  our  model. 
Instead  of  instructions,  an  actor  machine  has  certain  primitive  actors  built  in 
hardware. 

" It  is  behavior,  not  meaning,  that  counts." 

Logic 

We  would  like  to  show  how  actors  represent  formulas  in  the  quantificational  calculus 

and  how  the  rules  of  natural  deduction  follow  as  special  cases  from  the  mechanism  of  extension 
worlds.  We  assume  the  existence  of  a  function  ANONYMOUS  which  generates  a  new  name  which  has 
never  before  been  encountered.  Consider  a  formula  of  the  form  (every  phi)  which  means  that  for 
every  x  we  have  that  (phi  x)  is  the  case.  The  formula  has  two  important  uses: 
asserted  and  it  can  be  proved.  We  shall  use  an  actor  >=>  [read  as  "ACCEPT  REQUEST"]  with  the 
syntax 

it  can  be 

(>=>  pattern-for-request  body)  for  procedures  to  be  invoked  by  pattern  directed 

invocation  by  a  command  which  matches  pattern-for-request. 

Our  behavioral  definitions  are  reminiscent  of  classical  natural  deduction  except  that 

we  have  four  introduction  and  elimination  rules  [PROVE,  DISPROVE,  ASSERT,  and  DENY]  to  give  us 
more  f l e x i b i l i ty  in  dealing  with  negation. 

"Then  Logic  would  take  you  by  the  throat,  and  force  you  to  do  i t !" 

Lewis  Carroll 

Data  Bases 

Data  bases  are  actors  which  organize  a  set  of  actors  for  efficient  retrieval.  There 

are  two  primitive  operations  on  data  bases:  PUT  and  GET.  A  new  virgin  data  base  can  be 
created  by  evaluating  (virgin). 
If  we  evaluate  (w  +■  (virgin))  then  (contents  w)  will  be  a 
virgin  world.  We  can  put  an  actor  (at  John  airport)  in  the  world  (contents  w)  by  evaluating 
(put(at  John  airport)  {[#world{contents  w)]>).  We  could  add  further  knowledge  by  evaluating 

(put  (at  airport  Boston)  {[#world  (contents  w)]])  to  record  that  the  airport  is  at 
Boston. 
(put  {city  Boston)  {[#world  (contents  w)]))  to  record  that  Boston  is  a  city. 

If  the  constructor  EXTENSION  is  passed  a  message  then  it  will  create  a  world  which  is  an 
extension  of  its  message.  Eor  example 
(put 

[(on  John  (flight  34)) 
(extension-world ■*-  (contents w))]) 

will  set  extension-world  to  a  new  world  in  which  we  have  supposed  that  John  is  on  flight  #34. 
The  world  (contents  w)  is  unaffected  by  this  operation.  On  the  other  hand  the  extension  world 
is  affected  if  we  do  (put  [(hungry  John)  (contents  w)]).  Extension  worlds  are  very  good  for 
modeling  the  following: 

WORLD DIRECTED INVOCATION 

The  extension  world  machinery  provides  a  very  powerful  invocation  and  parameter 
passing  mechanism  for  procedures.  The  idea  is  that  to  invoke  a  procedure,  f i r st  grow  an 
extension  world;  then  do  a  world  directed  invocation  on  the  extension  world.  This 
mechanism  generalizes  the  previous  pattern  directed  invocation  of  PLANNER-67  several  ways. 
Pattern  directed  invocation  is  a  special  case  in  which  there  is  just  one  assertion  in  the 
wish  world.  World  Directed  Invocation  represents  a  formalization  of  the  useful  problem 
solving  technique  known  as  "wishful  thinking"  which  is  invocation  on  the  basis  of  a 
fragment  of  a  micro-world.  Terry  Winograd  uses  restriction  l i s ts  for  the  same  purpose  in 
his  thesis  version  of  the  blocks  world.  Suppose  that  we  want  to  find  a  bridge  with  a  red 
top  which  is  supported  by  its  left-leg  and  its  right-leg  both  of  which  are  of  the  same 
color. 
The  genie  uses  whatever  domain  dependent  knowledge  it  has  to  try  to  realize  the  wish. 
(realize 

In  order  to  accomplish  this  we  can  call  upon  a  genie  with  our  wish  as  its  message. 

(utopia 

{ 

(top  left-leg  right-leg  color-of-legs} 

;"the  variables  in  the  uptopia  are  listed  above" 

(color  top  red) 
(supported-by  top  left-leg) 
'supported-by  top  right-leg) 
;ieft-of  left-leg  right-leg) 
[color  left-leg  color-of-legs) 
kcolor  left-leg  color-of-legs)})) 

LOGICAL  HYPOTHETICALS  are  logically  possible  alternatives  to  a  world. 
By  the  Normalization  Theorem  for  intuitionistic  logic  our  actor  definition  of  the 

logical  constant  IMPLIES  is  sufficient  to  mechanize  logical  implication.  The  rules  of 
natural  deduction  are  a  special  case  of  our  rules  for  extension  worlds  and  our  procedural 
definition  of  the  logical  connectives. 

ALTERNATIVE  WORLDS  are  physically  possible  alternatives  to  a  world. 
PERCEPTUAL  VIEWPOINTS  can  be  mechanized  as  extension  worlds.  For  example  suppose 

241 

rattle-trap  is  the  name  of  a  world  which  describes  my  car.  Then  (front  rattle-trap)  could 
be  a  world  which  describes  my  car  from  the  front  and  (left  rattle-trap)  can  be  the 
description  from  the  left  side.  We  can  also  consider  a  future  historian's  view  of  the 
present  by  (vlew-from-1984  world-of-1972).  Mlnsky  [1973]  considers  these  possibilities  from 
a  somewhat  different  point  of  view. 

The  following  general  principles  hold  for  the  use  of  extension  worlds: 

Each  independent  fact  should  be  a  separate  assertion.  For  example  to  record  that 

"the  banana  banl  is  under  the  table  tabl"  we  would  assert: 

instead  of  conglomerating  [McDermott  1973]  them  Into  one  assertion: 

(banana  banl) 
table  tabl) 
under  banl  tabl) 

(at 

(the  banl  (1s  banl  banana)) 
(place 

(the  tabl  (is  tabl  table)) 
under)) 

[know <= 

(=>  [=  person  =  statement] 

(and 

(believes  person  statement) 
(true  statement)))] 

A  person  knowing  a  statement  can  be  analyzed  into  the  person  believing  the  statement  and 
the  statement  being  true.  So  we  might  make  the  following  definition  of  knowing: 

Thus  the  statement  [Moore  1973]  "John  knows  B i l l 's  phone  number"  can  be  represented  by  the 
assertion: 

(knows  John  (phone-number  Bill  pn0005)) 

where  pn0005  is  a  new  name  and  (phone-number  Bill  pn0005)  is  Intended  to  mean  that  the 
phone  number  of  Bill  1s  pn0005.  The  assertion  can  be  expanded  as  follows: 

(believes  John  (phone-number  Bill  pn0005)) 
(true  (phone-number  Bill  pn0005)) 

However  the  expansion  is  optional  since  the  two  assertions  are  not  independent  of  the 
original  assertion. 

"Whatever  Logic  is  good  enough  to  tell  me  Is  worth  writing  down,"  said 
the  Tortoise. 

"So  enter  it  in  your  book,  please." 

Each  assertion  should  have  justifications[derivations]  which  are  also  assertions 

Lewis  Carroll 

and  which  therefore  . .. 

Extraneous  factors  such  as  time  and  causality  should  not_ be  conglomerated 

In  this  way  we  can  deal  more  naturally  and  uniformly  with 

[McDermott  1973]  into  the  extension  world  mechanism.  Facts  about  time  and  causality  should 
also  be  separate  assertions. 
questions  involving  more  than  one  time.  For  example  we  can  answer  the  question  "How  many 
times  were  there  at  most  two  cannibals  in  the  boat  while  the  missionaries  and  cannibals 
were  crossing  the  river?"  Also  we  can  check  the  consistency  of  two  different  narratives  of 
overlapping  events  such  as  might  be  generated  by  two  people  who  attended  the  same  party. 
Retreival  of  actors  from  data  bases  takes  facts  about  time  and  causality  into  account  1n 
the  retreival.  Thus  we  s t i ll  effectively  avoid  most  of  the  frame  problem  of  McCarthy.  The 
ability  to  do  this  is  enhanced  by  the  way  we  define  data  bases  as  actors. 

A  CONTEXT  mechanism  was  invented  for  QA4  to  generalize  the  property  l i st  structure  of 
LISP.  Rulifson  explained  1t  by  means  of  examples  of  Its  use  to  mechanize  identifiers.  By  use 
of  the  functions  PUSH-CONTEXT  and  POPJONTEXT  and  an  EPAM  discrimination  net  [Feigenbaum  and 
Simon]  the  context  mechanism  can  be  used  to  mechanize  a  version  of  tree-structured  worlds,  The 
tree-structured  worlds  of  PLANNER-71  were  Invented  to  get  around  the  problem  of  having  only  one 
global  data  base  not  realizing  that  a  context  mechanism  could  be  used  to  implement  something 
like  that.  The  tree-structured  worlds  were  defined  directly  in  terms  of  the  hash-coding 
mechanism  of  PLANNER  which  had  the  advantage  of  decoupling  them  from  the  identifier  structure 
of  PLANNER. 
gains  in  efficiency  over  the  context  mechanism  are  possible. 

In  addition  by  not  conceiving  an  extension  world  analogue  of  P0P_C0NTEXT  large 

Worlds  can  ask  the  actors  put  In  them  to  index  themselves  for  rapid  retreival.We  also 
need  to  be  able  to  retrieve  actors  from  worlds.  Simple  retrieval  can  be  done  using  patterns. 
For  example 
(locations  +■  (get  (at  (?)  (?)){[#world  (contents  w)]})) 
will  set  locations  to  an  actor  which  will  retrieve  all  the  actors  stored  in  (contents  w)  which 
match  the  pattern  (at  (?)  {?)).  Now  (next  locations)  will  thus  retrieve  either  (at  airport 
Boston)  or  (at  John  airport).  Actually*  the  above  1s  an  over  simplification.  We  shall  let 
$real1ty  stand  for  the  current  world  at  any  given  point  and  $utopia  stand  for  the  world  as  we 
would  like  to  see  1t.  We  do  not  want  to  have  to  explicity  store  every  piece  of  knowledge 
which  we  have  but  would  like  to  beable  to  derive  conclusions  from  what  is  already  known:  We 
can  distinguish  several  different  classes  of  procedures  for  deriving  conclusions. 

"McCarthy 

1s  at  the  airport." 

(put 

(at  McCarthy  airport)) 

If  a  person  1s  at  the 

airport,  then  the  person  might  take  a  plane  from  the  airport, 

[put-at  <» 

(>«>  (put  (at  =  person  airport)) 

(put  (might  (take-plane-from  person  airport))))] 

"McCarthy  1s  not  at  the  airport." 

(deny  (at  McCarthy  airport)) 

th  airport  then  he  can't  take  a  plane  from  the  airport. 

If  a  person  Is  not  at 

242 

"McCarthy  is  not  at  the  airport."  (deny  (at  McCarthy  airport))  If  a  person  is  not  at 

the  airport  then  he  can't  take  a  plane  from  the  airport. 

[deny-at<= 

(>=>  (deny  (at  =person  airport)) 

(put  (can't  (take—plane—from  person  airport  ) ) ) )] 

" It  is  not  known  whether  McCarthy  is  at  the  airport,"  (erase  (at  McCarthy  airport))  If 

it  is  not  known  whether  a  person  is  at  the  airport  then  erase  whatever  depends  on  previous 
knowledge  that  the  person  is  at  the  airport, 

[erase-at  <= 

(>=>  (erase  (at  -person  airport)) 

(find  (depends—on  =s  (at  person  airport)) 

(erase  s ) ) )] 

"Get  McCarthy  to  the  airport."  (achieve  {(at  McCarthy  airport  )})  To  achieve  a  person  at 

a  place: 

Find  the  present  location  of  the  person. 
Show  that  it  is  walkable  from  the  present  location  to  the  car. 
Show  that  1t  is  drivable  from  the  car  to  the  place, 

[achieve-at  <= 

(achieve 

(>=>  (achieve  [(at  =person  =place  )]) 

(find  [(at  person  -present-location)] 

(show 

{(walkable  present-location  car)} 

(show  {(drivable  car  place)})))))] 

"Show  that  McCarthy  is  at  the  airport." 

(show  {(at  McCarthy  airport)})  To  show  that  a 
thing  is  at  a  place  show  that  the  thing  is  at  some  intermediate  and  the  intermediate  is  at  the 
place. 

[show-at  <= 

(>=>  (show  {(at  =th1ng  =place)}) 

(show  {(at  thing  'intermediate)} 

(show  {(at  intermediate  place)})))] 

The  actor  show-at  is  simply  transitivity  of  at. 

l!  Anything  Really  Better 

Than  Anything  Else? 

CONNIVER can easily  be defined TrTTerms  of P L A W R - 7 3.  We  do this  not because we 

believe  that  the  procedures  of  CONNIVER  are  particularly  well  designed. 
Indeed  we  have  given 
reasons  above  why  these  procedures  are  deficient.  Rather  we  formally  define  these  procedures 
to  show  how  our  model  applies  even  to  rather  baroque  control  structures. 

CONNIVER  is  essentially  the  conglomeration  of  the  following  ideas:  Landin's  non-

hierarchical  goto-71,  the  pattern  directed  construction,  matching,  retrieval,  and  invocation  of 
PLANNER,  Landin's  streams,  the  context  mechanism  of  QAA,  and  Balzer's  and  Krutar's  ports. 
In  most  cases,  two  procedures  in  CONNIVER  do  not  talk  directly  to  each  other  but 

instead  are  required  to  communicate  through  an  intermediary  which  is  called  a  possibilities  l i s t. 
The  concept  of  a  POSSIBILITIES  LIST  is  the  major  original  contribution  of  CONNIVER. 

"What  are  these 
So  wild  and  withered  in  their  a t t i r e, 
That  look  not  like  the  inhabitants 

0'  the  earth, 

and  yet  are  on't?" 

Substitution,  Reduction,  and  Meta-evaluation 

"One  program's  constant  is  another  program's  variable." 

Macbeth:  Act  1,  Scene  111 

Alan  Perils 

"Programming  [or  problem  solving  in  general]  is  the  judicious  postponement  of 
decisions  and  commitments!" 

"Programming  languages  should  be  designed  to  suppress  what  is  constant  and 
emphasize  what  is  variable." 

Edsger  W.  Dijkstra  [1969] 

"Each  constant  will  eventually  be  a  variable!" 

Alan  Perlis 

Corollary  to  Murphy's  Law 

We  never  do  unsubstitution  [or  if  you  wish  decompilation,  unsimpllfication,  or 

unevaluation].  We  always  save  the  higher  level  language  and  resubstltute.  The  metaphor  of 
substitution  followed  by  reduction  gives  us  a  macroscopic  view  of  a  large  number  of 
computational  activities.  We  hope  to  show  more  precisely  how  all  the  following  activities  f it 
within  the  general  scheme  of  substitution  followed  by  reduction: 

EVALUATION  [Church,  McCarthy,  Lnadin]  can  be  done  by  substituting  the  message 

into  the  code  and  reducing  [execution]. 

DEDUCTION  [Herbrand,  Godel,  Heyting.  Prawltz,  Robinson,  Hewitt,  Weyhrauch  and 

Milner]  can  be  done  by  procedural  embedding. 
previous  work  by  defining  the  logical  constants  to  be  certain  actors  thus  providing  a 
procedural  semantics  for  the  quantlficational  calculus  along  the  lines  indicated  by 
natural  deduction. 

In  this  paper  we  have  extended  our 

CONFIRMING  the  CONSISTENCY  of  ACTORS  and  their  INTENTIONS  [Naur,  Floyd,  Hewitt 

243 

1971,  Waldlnger,  Deutsch]  can  be  done  by  substituting  the  code  for  the  actors  Into 
their  intentions  and  then  meta-evaluating  the  code. 

AUTOMATIC  ACTOR  GENERATION.  An  important  corollary  of  the  Thesis  of  Procedural 

Embedding  is  that  the  Fundamental  Technique  of  Artificial 
programming  and  procedural  knowledge  base  construction.  It  can  be  done  by  the 
following'  "methods: 

Intelligence  is  automatic 

PARAMETERIZATION  [Church,  McCarthy,  Landin,  Mcintosh,  Manna  and 

Waldinger,  Hewitt]  of  canned  procedure  templates. 

COMPILATION  [Lombardi,  Elcock,  Fikes,  Daniels,  Wulff,  Reynolds,  and 

Wegbreit]  can  be  done  by  substituting  the  values  of  the  free  variables  in  the 
code  and  then  reducing  [optimizing].  For  examples  we  can  enhance  the  behavior 
of  the  l i s ts  which  were  behaviorally  defined  above  to  vectors  which  will  run 
more  efficiently  on  current  generation  machines. 

ABSTRACT  IMPOSSIBILITIES  REMOVAL  can  be  done  by  binding  the 

alternatives  with  the  code  and  deleting  those  which  can  never  succeed,  What  we 
have  in  mind  are  situations  such  as  having  simultaneous  subgoals  (on  a  b)  and 
(on  b  c)  where  we  can  show  by  meta-evaluation  that  the  order  given  above  can 
never  succeed.  Gerry  Sussman  has  designed  a  program  which  attempts  to  abstract 
this  fact  from  running  on  concrete  examples.  We  believe  that  in  this  case  and 
many  others  it  can  be  abstractly  derived  by  meta-evaluation. 

EXAMPLE  EXPANSION  [Hart,  Nilsson,  and  Fikes  1971;  Sussman  1972;  Hewitt 

1971]  can  be  done  by  binding  the  high  level  goal  oriented  language  to  an 
example  problem  and  then  reducing  [executing  and  expanding  to  the  paths  executed] 
using  world  directed  invocation  [or  some  generalization]  to  create  linkages 
between  the  variablized  special  cases. 

PROTOCOL  ABSTRACTION  [Hewitt  1969,  1971]  can  be  done  by  binding 

together  the  protocols,  reducing  the  resulting  protocol  tree  by  identifying 
indistinguishable  nodes. 

ABSTRACT  CASE  GENERATION  to  distinguish  the  methods  to  achieve  a  goal 
can  be  done  by  determining  the  necessary  pre-conditions  for  each  method  by 
reducing  to  a  decision  tree  which  distinguishes  each  method. 

Acknowledgements 

"Everything  of  importance  has  been  said  before  by  somebody  who  did  not 
discover 

i t ." 

Alfred  North  Whitehead 

This  research  was  sponsored  by  the  MIT  A r t i f i c i al  Intelligence  Laboratory  and  Project 
MAC  under  a  contract  from  the  Office  of  Naval  Research.  We  would  be  very  appreciative  of  any 
comments,  criticisms,  or  suggestions  that  the  reader  might  care  to  offer.  Please  address  them 
to: 

Carl  Hewitt 
Room 813 
545  Technology  Square 
M.I.T.  A r t i f i c i al 
Cambridge,  Massachusetts  02139 

Intelligence  Laboratory 

The  topics  discussed  in  this  paper  have  been  under  intense  investigation  by  a  large 
In  this  paper  we  have  merely  attempted  to  construct  a 

number  of  researchers  for  a  decade. 
coherent  manageable  formalism  that  embraces  the  ideas  that  are  currently  "in  the  air". 

We  would  like  to  acknowledge  the  help  of  the  following  colleagues:  Bill  Gosper  who 
"A  data  structure  is  nothing  but  a  stupid  programming  language." 

knew  the  truth  all  along: 
Alan  Kay  whose  FLEX  and  SMALL  TALK  machines  have  influenced  our  work.  Alan  emphasized  the 
crucial  importance  of  using  intentional  definitions  of  data  structures  and  of  passing  messages 
to  them.  This  paper  explores  the  consequences  of  generalizing  the  message  mechanism  of  SMALL 
TALK  and  SIMULA-67;  the  port  mechanism  of  Krutar,  Balzer,  and  Mitchell;  and  the  previous  CALL 
statement  of  PLANNER-71  to  a  universal  communications  mechanism.  Alan  has  been  extremely 
helpful  in  discussions  both  of  overall  philosophy  and  technical  details.  Nick  Pippenger  for 
his  very  beautiful  ITERATE  statememt  and  for  helping  us  to  find  a  fast  economical  decoding  net 
for  our  ACTOR  machine.  John  McCarthy  for  making  the  f i r st  circular  definition  of  an  effective 
problem  solving  formalism  and  for  emphasizing  the  importance  of  the  epistemological  problem  for 
a r t i f i c i al  intelligence.  Seymour  Papert  for  his  " l i t t le  man"  metaphor  for  computation.  Allen 
Newell  whose  kernel  approach  to  building  software  systems  has  here  perhaps  been  carried  to  near 
its  ultimate  extreme  along  one  dimension.  David  Marr  whose  penetrating  questions  led  us  to 
further  discoveries.  Rudy  Krutar,  Bob  Balzer,  and  Jim  Mitchell  who  introduced  the  notion  of  a 
PORT  which  we  have  generalized  into  an  ACTOR.  Robin  Milner  is  tackling  the  problems  of  L-
values  and  processes  from  the  point  of  view  of  the  lambda  calculus.  He  has  enphasized  the 
practical  as  well  as  the  theoretical  implications  of  fixed  point  operators.  Robin's  puzzlement 
over  the  meaning  of  "equality"  for  processes  led  to  our  definition  of  behavior.  Edsger  Dijkstra 
for  a  pleasant  afternoon  discussion.  Jim  Mitchell  has  patiently  explained  the  systems 
implementation  language  MPS.  Jeff  Rulifson,  Bruce  Anderson,  Gregg  Pfister,  and  Julian  Davies 
showed  us  how  to  clean  up  and  generalize  certain  aspects  of  PLANNER-71.  Peter  Landin  and  John 
Reynolds  for  emphasizing  the  importance  of  continuations  for  defining  control  structures. 
Warren  Teitleman  who  cleaned  up  and  generalized  the  means  of  integrating  editors  and  debuggers 
in  higher  level  languages.  Peter  Landin,  Arthur  Evans,  and  John  Reynolds  for  emphasizing  the 
importance  of  "functional"  data  structures.  Danny  Bobrow  and  Ben  Wegbreit  who  originated  an 
implementation  method  that  cuts  down  on  some  of  the  overhead.  We  have  simplified  their  scheme 

244 

by  eliminating  the  reference  counts  and  a ll  of  their  primitives,  c.  A.  R.  Hoare  1s  Independently 
Investigating  "monitors"  for  data  structures.  Jack  Dennis  for  sharing  many  of  our  same  goals  in  his 
COMMON  BASE  LANGUAGE  and  for  his  emphasis  on  logical  clarity  of  language  definition  and  the  importance  of 
parallelism.  Bill  Wulff  for  our  "."  notation  on  the  conventions  of  the  values  of  cells  and  for  being  a 
strong  advocate  of  exceptional  cleanliness  in  language.  Pitts  Jarvis  and  Richard  Greenblatt  have  given  us 
valuable  help  and  advice  on  systems  aspects.  Todd  Matson,  Brian  Smith,  Irene  Grief,  and  Henry  Baker  are 
aiding  us  1n  the  implementation.  Chris  Reeve»  Bruce  Daniels,  Terry  Winograd,  Jerry  Sussman,  Gene  Charniak, 
Gordon  Benedict,  Gary  Peskin,  and  Drew  McDermott  for  implementing  previous  generations  of  these  ideas  in 
addition  to  their  own.  J.C.R.  Licklider  for  emphasizing  the  importance  of  mediating  procedure  calls.  Butler 
Lampson  for  the  notion  of  a  banker  and  for  the  question  which  led  to  our  criteria  for  separating  an  actor 
from  its  base.  Richard  Weyhrauch  for  pointing  out  that  logicians  are  also  considering  the  possibility  of 
procedural  semantics  for  logic.  He  is  doing  some  very  interesting  research  in  the  much  abused  field  of 
"computational  logic."  Terry  Winograd,  Donald  Eastlake,  Bob  Frankston,  Jerry  Sussman,  Ira  Goldstein,  and 
others  who  made  valuable  suggestions  at  a  seminar  which  we  gave  at  M.l.T.  John  Shockley  for  helping  us  to 
eradicate  an  Infestation  of  bugs  from  this  document.  Greg  Pfister,  Bruce  Daniels,  Seymour  Papert,  Bruce 
Anderson,  Andee  Rubin,  Allen  Brown,  Terry  Winograd,  Dave  Waltz,  Nick  Horn,  Ken  Harrenstien,  David  Marr, 
Ellis  Cohen,  Ira  Goldstein,  Steve  Zilles,  Roger  Hale,  and  Richard  Howell  made  valuable  comments  and  suggestions 
on  previous  versions  of  this  paper. 

Bibliography 

Balzer,  R.M.,  "Ports—A  Method  for  Dynamic  Interprogram  Communication  and  Job  Control"The  Rand  Corp.,  1971. 
Bishop,  Peter,  "Data  Types  for  Programming  Generality"M.S.  June  1972.  M.l.T. 
Bobrow  D.,  and  Wegbreit  Ben.  "A  Model  and  Stack  Implementation  of  Multiple  Environments."  March  1973. 
Davies,  D.J.M.  "POPLER:  A  P0P-2PLANNER"  MIP-89.  School  of  A . I.  University  of  Edinburgh. 
Deutsch  L.P.  "An  Interactive  Program  Verifier"  Phd.  University  of  California  at  Berkeley.  June,  1973 

Earley,  Jay.  "Toward  an  Understanding  of  Data  Structures"  Computer  Science  Department,  University 

Forthcoming. 

of  California,  Berkeley. 

Elcock,  E.W.;  Foster,  J.M.;  Gray,  P.M.D.;  McGregor,  H.H.;  and  Murray A.M.  Abset,  a  Programming 

Language  Based  on  Sets:  Motivation  and  Examples.  Machine  Intelligence  6.  Edinburgh,  University  Press. 

Fisher.  D.A.  "Control  Structures  for  Programming  Languages"  Phd.  Carnegie.  1970 
Gentzen  G.  "Collected  Papers  of  Gerhard  Gentzen".North  Holland.  1969. 
Greif  l.G.  "Induction  in  Proofs  about  Programs"  Project  MAC  Technical  Report  93.  Feb.  1972. 
Hewitt,  C.  and  Patterson  M.  "Comparative  Schematology"  Record  of  Project  MAC  Conference  on  Concurrent 

Systems  and  Parallel  Computation.  June  2-5,  1970.  Available  from  ACM. 

Hewitt,  C.,  Bishop  P.,  and  Steiger  R.  "The  Democratic  Ethos  or  'How  a  Society  of  Noncoercable  ACTORS 

can  be  Incorporated  into  a  Structured  System'"  SIGPLAN-SIGOPS  Interface  Meeting,  Savannah,  Georgia.  April,  1973. 

Hewitt,  C,  and  Greif,I.  "Actor  Induction  and  Meta-Evaluation"ACM  SIGACT-SIGPLAN  Symposium  on  Principles 

of  Programming  Languages.  Boston,  Mass-  Oct,  1973.  Forthcoming. 

Hoare,  C.A.R.  "An  Axiomatic  Definition  of  the  Programming  Language  PASCAL"  Feb.  1972. 
Kay,  Alan  C.  Private  Communication. 
Krutar,  R.  "Conversational  Systems  Programming  (or  Program  Plagiarism  made  Easy)"  First  USA-Japan 

Computer  Conference.  October  1972, 

Lampson,  B.  "An  Overview  of  CAL-TSS".  Computer  Center,  University  of  California,  Berkeley. 
Liskov,  B.H.  "A  Design  Methodology  for  Reliable  Software  Systems"  The  Last  FJCC.  Dec.1972.  Pt.  1,  191-199. 
McDermott  D.V.  "Assimilation  of  New  Information  by  a  Natural  Language-Understanding  System"  M.S.  MIT. 

Forthcoming  1973. 

McDermott,  D.V.  and  Sussman  G.J.  "The  Conniver  Reference  Manual"  A.I.  Memo  no.  259.  1972. 
Milner,  R.  Private  Communication. 
Minsky,  Marvin.  "Frame-Systems:  A  Theory  for  Representation  of  Knowledge"  Forthcoming  1973. 
Mitchell,  J.G.  "A  Unified  Sequential  Control  Structure  Model"  NIC  16816.  Forthcoming. 
Newell,  A.  "Some  Problems  of  Basic  Organization  in  Problem-Solving  Programs."  Self-Organizing  Systems.  1962. 
Papert  S.  and  Solomon  C.  "NIM:  A  Game-Playing  Program"  A . I.  Memo  no.  254. 
Reynolds,  J.C.  "Definitional  Interpreters  for  Higher-Order  Programming  Languages"  Proceedings  of  ACM 

Rulifson  Johns  F.,  Derksen  J.A.,  and  Waldinger  R.J.  "QA4:  A  Procedural  Calculus  for  Intuitive  Reasoning" 

National  Convention  1972. 

Phd.  Stanford.  November  1972. 

Scott,  D.  "Data  Types  as  Lattices"  Notes.  Amsterdam,  June  1972. 
Steiger,  R.  "Actors".  M.S.  1973.  Forthcoming. 
Sussman,  G.J.  "Teaching  of  Procedures-Progress  Report"  Oct.  1972.  A . I.  Memo  no.  270. 
Waldinger  R.  Private  Communication. 
Wang  A.  and  Dahl  0.  "Coroutine  Sequencing  in  a  Block  Structured  Environment"  BIT  11  425-449. 
Weyhrauch,  R.  and  Milner  R.  "Programming  Semantics  and  Correctness  in  a  Mechanized  Logic."  First  USA-Japan 

Computer  Conference.  October  1972. 

Language"  MAC TR-B4.  February  1971. 

Winograd,  T.  "Procedures  as  a  Representation  for  Data  1n  a  Computer  Program  for  Understanding  Natural 

W1rth,  N.  "How  to  Live  without  Interrupts"  or  some  such.  Vol.  1?  No.  9,  pp.  489-498. 
Wulf  W.  and  Shaw  M.  "Global  Variable  Considered  Harmful"  Carnegie-Mellon  University.  Pittsburgh,  Pa. 

SIGPLAN  Bulletin.  1973. 

245 

Session  8  Formalisms  for 
A r t i f i c i al 

Intelligence 

A  MODEL  FOR  CONTROL  STRUCTURES 

FOR  ARTIFICIAL  INTELLIGENCE  PROGRAMMING  LANGUAGES 

by 

Daniel  G.  Bobrow 

Computer  Science  Division 

Xerox  Palo  Alto  Research  Center 

Palo  Alto,  California  94304 

Ben  Wegbreit 

Harvard  University 

Center  for  Research  in  Computing  Technology 

Cambridge,  Massachusetts  02138 

Abstract 

Newer  programming  languages  for  artificial  intel(cid:173)
ligence  extend  the  class  of  available  control  regimes 
beyond  simple  hierarchical  control.  In  so  doing,  a  key 
issue  is  using  a  model  that  clearly  exhibits the  relation 
between  modules,  processes,  access  environments, 
and  control  environments. 
This  paper  presents  a 
model  which  is  applicable  to  diverse  languages  and 
presents  a  set  of  control  primitives  which  provide  a 
concise  basis  on  which  one  can  define  almost  all  known 
regimes  of  control. 

1. 

Introduction 

In  this  paper,  we  present  an 

Newer  programming  languages!  for  artificial 
intelligence  ( e . g .,  PLANNER9^  CONNIVER,18  BBN-
LlSP.ly  QA4.1' 1  extend  the  nature  of  control  regimes 
available  to  the  user. 
information  structure  model20  which  deals  with control 
and  access  contexts  in  a  programming  language;  it  is 
based  on  consideration  of the  form  of  run-time  data 
structures  which  represent  program  control  and  v a r i(cid:173)
able  bindings.  The  model  is  designed  to  help  clarify 
some  relationships  of hierarchical  function  calls, 
backtracking,  co-routines,  and  multiprocess  structure. 
We  present  the  model  and  its  small  set  of  primitive 
operations,  then  define  several  control  regimes  in 
terms  of the  primitives,  and  then  consider  extensions 
to  handle  cooperating  sequential  processes. 

2.  The  Basic  Environment  Structure 

In  a  language  which  has  blocks  and  procedures, 

new  nomenclature  (named  variables)  can  be  introduced 
either  by  declarations  in  block  heads  or  through  named 
parameters  to  procedures.  Since  both  define  access 
environments,  we  call  the  body  of  a  procedure  or block 
a  uniform  access  module.  Upon  entry to  an  access 
module,  certain  storage  is  allocated  for  those  new 
named  items  which  are  defined  at  entry.  We  call  this 
named  allocated  storage  the  basic  frame  of the  module. 
In  addition,  certain  additional  storage  for  the  module 
may be  required  for  temporary  intermediate  results  of 
computation;  this  additional  allocated  storage  we  call 
the  frame  extension.  The  total  storage  is  called  the 
total  frame  for  the  module,  or  usually  just  the  module 
frame. 

A"  frame  contains  other  information,  in addition to 
named  variables  and  temporaries. 
It  is  often  useful  to 
reference  a  frame  by  symbolic  nomenclature.  For  this 
purpose,  each  frame  has  a  framename  (usually  the  pro(cid:173)
cedure  name).  When  a  module  is  entered,  its  frame 
extension  is  initialized  with  two  pointers  (perhaps  i m(cid:173)
plicitly);  one,  called  A  LINK,  is  a  linked  access 
pointer  to  the  frame(s)  which  contains  the  higher  level 
free  variable  and  parameter  bindings  accessible  within 

246 

this  module.  The  other,  called  CLINK,  is  associated 
with  control  and  is  a  generalized  return  which  points to 
the  calling  frame. 
In  Algol,  these  are  called  the static 
and  dynamic  links,  respectively. 
pointers  usually  reference  the  same  frame,  since  bind(cid:173)
ings  for  variables  free  in  a  module  are  found  by 
tracing up  the  call  structure  chain. 
the  use  of functional  arguments,  and  we  illustrate  that 
below.) 

In  L I S pH  the  two 

(An  exception  is 

At  the  time  of  a  call  (entry  to  a  lower  module),  the 

caller  stores  in  his  frame  extension  a  continuation 
point  for  the  computation.  Since  the  continuation  point 
is  stored  in  the  caller,  the  generalized  return  is 
simply  a  pointer  to  the  last  active  frame. 

The  size  of  a  basic  frame  is  fixed  on  module entry. 

It  is  just  large  enough  to  store  the  parameters  and 
associated  information.  However,  during  one  function 
activation,  the  required  size  of  the  frame  extension 
can  vary  widely  (with  a  computable  maximum),  since 
the  amount  of temporary  storage  used  by  this  module 
before  calling  different  lower  modules  is  quite  v a r i(cid:173)
able.  Therefore,  the  allocation  of these  two  frame 
segments  may  sometimes  (advantageously)  be  done 
separately  and  n  on  contiguously.  This  requires  a  link 
(BLINK)  from  the  frame  extension  to  the  basic  frame 
which  contains  the  bindings. 

When  a  frame  is  exited,  either by  a  normal  exit 

or by  a  non-local  goto which  skips  the  frame  (e. g.  , an 
error  condition),  it  is  often  useful  to  perform  clean-up 
action  for  the  frame.  Examples  include:  close  files 
opened  by  the  frame  which  are  no  longer  needed, 
restore  the  state  of more  global  structures  which  have 
been  temporarily  modified  by  the  frame,  etc.  T e r m i(cid:173)
nal  action  for  a  frame  is  carried  out  by  executing  an 
exit  function  for  the  frame,  passing  it  as  argument  the 
nominal  value  which  the  frame  is  returning  as  its 
result;  the  value  returned  by  the  exit  function  is  the 
actual  value  of  the  frame.  The  variable  values  and  the 
exit  function  are  the  only  components  of the  frame 
which  can be  updated by the  user;  all  the  others  are 
fixed  at  the  time  of frame  allocation.  Figure  1  sum(cid:173)
marizes  the  contents  of the  frame. 

Figure  2a  shows  a  sketch  of an  algorithm  pro(cid:173)

grammed  in  a  block  structure  language  such  as  Algol 
60  with  contourslO  drawn  around  access  modules.  Bl 
has  locals  N  and  P,  P  has  parameter N,  and  B3  locals 
Q  and  L.  Figure  2b  is  a  snapshot  of the  environment 
structure  after  the  following  sequence:  Bl  is  entered; 
P  is  called  (just  above  P I,  the  program  continuation 
point  after  this  outer  call);  B3  is  entered;  and  F  is 
called  from  within  B3.  For  each  access  module  there 
are  two  separate  segments  —  one  for  the  basic  frame 
(denoted  by  the  module  name)  and  one  for  the  frame 
extension  (denoted  by  the  module  name*).  Note  that 
the  sequence  of access  links  (shown  with  dotted  lines) 
goes  directly  from  P  to  B l*  and  is  different  from  the 
control  chain  of  calls.  However,  each  points  higher 

( e a r l i e r)  on  the  stack. 

A  point  to  note  about  an  access  module  is  that  it 
If  an  a p p r o(cid:173)

has  no  knowledge  of  any  module  below  i t. 
priate  value  ( i . e .,  one  whose  type  agrees  w i th  the 
stored  r e t u rn  type)  is  provided,  continuation 
in  that 
access  module  can  be  achieved  w i th  only  a  pointer  to 
the  continued  f r a m e.  No  i n f o r m a t i on  stored  outside 
this  f r a me  is  necessary. 

F i g u re  3  shows  two  examples  in  which  m o re  than 
one  independent  environment  s t r u c t u re  is  maintained. 
In  F i g u re  3a,  two  coroutines  are  shown  which  share 
common  access  and  control  environment  A.  Note  that 
the  f r a me  extension  of  A  has  been  copied  so  that 
r e t u r ns  f r om  B  and  Q  may  go  to  different  continuation 
points.  This  is  a  key  point  in  the  model;  whenever  a 
f r a me  extension  is  r e q u i r ed  f or  conflicting  purposes, 
a  copy  is  made.  Since  f r a me  A  is  used  by  two  p r o(cid:173)
cesses, 
if  either  coroutine  were  deleted,  the  basic 
f r a me  f or  A  should  not  be  deleted.  However,  one 
f r a me  extension  A*  could  be  deleted  in  that  case, since 
f r a me  extensions  are  never  referenced  d i r e c t ly  by 
m o re  than  one  process.  Since  the  basic  f r a me  A 
is 
s h a r e d,  either  process  can  update  the  variable  b i n d(cid:173)
ings  in  i t;  such  changes  are  seen  both  by  B  and  Q, 
In 
F i g u re  3b,  coroutine  Q  is  shown  calling  a  function  D 
w i th  external  access  chain  through  B,  but  with  control 
to  r e t u rn  to  Q. 

3.  P r i m i t i ve  Functions 

In  this  model  for  access  module  activation,  each 
f r a me  is  generally  released  upon  exit  of  that  module. 
Only  if  a  f r a me  is  s t i ll  referenced  is  it  retained.  A ll 
non-chained  references  to  a  f r a me  (and  to  the  e n v i r o n(cid:173)
ment  s t r u c t u re  it  heads)  are  made  through  a  special 
protected  data  type  called  an  environment  d e s c r i p t o r, 
abbreviated  ed.  The  heads  of  a ll  environment  chains 
are  referenced  only  f r om  this  space  of  d e s c r i p t o r s. 
(The  one  exception  is  the  i m p l i c it  ed  f or  the  c u r r e n t ly 
active  process.)  The  p r i m i t i ve  functions  create  an  ed 
f or  a  specified  f r a me  and  update  the  contents  of  an  ed; 
create  a  new  f r a me  w i th  specified  contents,  and  allow 
execution  of  a  computation  in  that  context;  and  access 
and  update  the  exit  function  f or  a  f r a m e.  Note  that 
none  of  the  p r i m i t i v es  manipulate  the  links  of  existing 
f r a m e s; 
exist  ( i . e .,  no  r i ng  s t r u c t u r e s ). 
1)  environ(pos)  —  creates  an  environment  d e s c r i p t or 

t h e r e f o r e,  only  w e l l - f o r m ed  f r a me  chains 

f or  the  f r a me  specified  by  pos. 

2)  setenv(olded,  pos)  --  changes  the  contents  of  an 
existing  environment  d e s c r i p t or  olded  to  point  to 
the  f r a me  specified  by  pos.  As  a  side  effect,  it 
releases  storage  referenced  only  through  previous 
contents  of  olded. 

3)  m k f r a m e ( e p o s , a p o s,  epos,bpos,bcopflg)  --  creates 
a  new  f r a me  and  returns  an  ed  f or  that  f r a m e.  The 
f r a me  extension  is  copied  f r om  the  f r a me  specified 
by  epos,  and  the  A L I NK  and  C L I NK  are  specified 
by  apos  and  epos,  respectively.  The  B L I NK  points 
to  the  basic  f r a me  specified  by  bpos,  or  to  a  copy 
of  the  basic  f r a me  if  bcopflg=TRUE. 
In  use,  a r g u(cid:173)
ments  may  be  o m i t t e d;  bcopflg  is  defaulted  to 
F A L S E;  apos,  bpos  and  epos  are  defaulted  to  the 
corresponding  f i e l ds  of  the  f r a me  specified  by epos. 
Thus  mkframe(epos)  creates  a  new  f r a me  extension 
identical  to  that  specified  by  epos. 

4)  enveval(forrA,apos,cpos)  —  creates  a  new  f r a me 
and  initiates  a  computation  w i th  this  environment 
s t r u c t u r e.  A L I NK  and  C L I NK  point  to  f r a m es 
specified  by  apos  and  epos,  respectively;  and  f o rm 
specifies  the  code  to  be  executed,  or  the  ex(cid:173)
pression  to  be  evaluated  in  this  new  environment. 
If  apos  or  cpos  a re  o m i t t e d,  they  are  defaulted  to 
the  A L I NK  or  C L I NK  of  this  invocation  of  enveval. 
T h u s,  enveval(form)  is  the  usual  c a ll 

an 

to 

i n t e r p r e t e r,  and  has  the  same  effect  as  if  the  value  of 
f o rm  had  appeared  in  place  of  the  simple  c a ll  to 
enveval. 
5)  setexfn(pos,fn)  —  places  a  pointer  to  a  user  defined 

function  in  the  exitfn  field  of  the  frame  pos. 
system  is  using  the  e x i t f n,  this  w i ll  create  a  new 
function  which  is  the  composition  of  the  user 
function  (applied  f i r s t)  and  the  system  function.  On 
f r a me  exit,  the  exitfn  w i ll  be  called  w i th  one  a r g u(cid:173)
the 
ment,  the  value  returned  by  the  f r a me  code; 
value  returned  by  fn  w i ll  be  the  actual  value 
r e(cid:173)
turned  to  the  f r a me  specified  by  C L I N K. 

If  the 

6)  getexfn(pos)  —  gets  the  user  set  function  stored  in 
exitfn  of  f r a me  pos.  Returns  N IL  if  none  has  been 
e x p l i c i t ly  stored  there. 
framenm(pos)  --  returns  the  framename  of  f r a me 
pos. 

7) 

A  f r a me  specification  ( i . e.  ,  pos,  apos,  bpos,  epos, 
epos  above}  is  one  of  the  following: 
1.  An  integer  N: 

a.  N=0  specifies  the  f r a me  allocated  on  activation 

of  the  function  e n v i r o n,  setenv,  etc. 
of  e n v i r o n,  setenv  and  m k f r a m e,  the  continu(cid:173)
ation  point  is  set  up  so  that  a  value  returned  to 
this  f r a me  (using  enveval)  is  returned  as  a 
value  of  the  o r i g i n al  c a ll  to  e n v i r o n,  setenv  or 
m k f r a m e. 

In  the  case 

b.  N>0  specifies  the  f r a me  N  links  down  the  control 

l i nk  chain  f r om  the  N=0  f r a m e. 

c.  N<0  specifies  the  f r a me  INI  links  down  the 

access  link  chain  f r om  the  N=0  f r a m e, 

2.  A  l i st  of  two  elements  ( F , N)  where  F  is  a  f r a m e-

name  and  N  is  an  integer.  This  gives  the  Nth 
f r a me  with  name  F,  where  a  positive  (negative) 
value  for  N  specifies  the  control  (access)  chain 
environment. 

3.  The  distinguished  constant  N I L.  As  an  a c c e s s - l i nk 
specification,  N IL  specifies  that  only  global  values 
are  to  be  used  f r e e.  A  process  which  returns 
along  a  N IL  c o n t r o l - l i nk  w i ll  halt. 
setenv(ed,NIL)  releases  f r a me  storage  f o r m e r ly 
referenced  only  through  ed,  without  tying  up  any 
new  storage. 

Doing  a 

4.  An  ed  (environment  d e s c r i p t o r ).  When  given  an  ed 

argument  created  by  a  p r i or  call  on  e n v i r o n, 
environ  creates  a  new  d e s c r i p t or  with 
contents  as  ed;  setenv  copies  the  contents  of  ed 
into  olded. 

the  same 

5.  A  l i st  "(ed)"  consisting  of  exactly  one  ed. 

The 
contents  of  the  listed  ed  are  used  identically  to 
that  of  an  unlisted  ed.  However,  after  this  value 
is  used  in  any  of  the  functions,  setenv(ed.NIL)  is 
done,  thus  releasing  the  f r a me  storage  f o r m e r ly 
referenced  only  through  ed.  This  has  been  c o m(cid:173)
bined  into  an  argument  f o rm  rather  than  allowing 
the  user  to  do  a  setenv  e x p l i c i t ly  because  in  the 
c a ll  to  enveval  the  contents  are  needed,  so  it  can(cid:173)
not  be  done  before  the  c a l l; 
it  cannot  be  done  ex(cid:173)
p l i c i t ly  after  the  enveval  since  control  might  never 
r e t u rn  to  that  point. 

4.  N o n - P r i m i t i ve  C o n t r ol  Functions 

To  i l l u s t r a te  the  use  of  these  p r i m i t i ve  control 

functions,  we  explain  a  number  of  control  regimes 
which  differ  f r om  the  usual  nested  function  c a l l - r e t u rn 
h i e r a r c h i c al  s t r u c t u r e,  and  define  t h e ir  control  s t r u c(cid:173)
ture  routines  in  t e r ms  of  the  p r i m i t i v e s.  We 
include 
stack  j u m p s,  function  c l o s u r e,  and  several  m u l t i p r o(cid:173)
cessing  disciplines. 
In  p r o g r a m m i ng  examples,  we 
use  the  syntax  and  semantics  of  a  L I S P - l i ke  s y s t e m. 
In  an  o r d i n a ry  h i e r a r c h i c al  control  s t r u c t u re 

247 

system,  if module  F  calls  G,  G  calls  H,  and  H  calls  J, 
it  is  impossible  for J  to  return  to  F  without  going  back 
through  G  and  H.  Consider  some  program  in which  a 
search  is  implemented  as  a  series  of  such  nested 
function  calls.  Suppose J  discovered  that the  call to  G 
was  inappropriate  and  wanted  to  return  to  F  with  such 
a  message. 
In  a  hierarchical  control  structure,  H  and 
G  would both  have  to be  prepared  to  pass  such  a  mes(cid:173)
sage back.  However,  in general,  the  function J  should 
not  have  to  know  how  to  force  intermediaries;  it  should 
be  able  to  pass  control  directly to  the  relevant  module. 
Two  functions  may be  defined  to  allow  such  jumpbacks. 
(These  are  implemented  in  BBN-LISP;19  experience 
has  shown  them  to  be  quite  useful.)  The  first  function, 
retfrom(form,pos),  evaluates  form  in  the  current  con(cid:173)
text,  and  returns  its  value  from  the  frame  specified  by 
pos  to  that  frame's  caller;  in  the  above  example,  this 
returns  a  value  to  G's  caller,  i . e .,  P,  The  second 
function,  retevaKform, pos),  evaluates  form  in  the  con(cid:173)
text  of the  caller  of  pos  and  returns  the "value  of the 
form  to  that  caller.  These  are  easily  defined  in  terms 
of  enveval: 

retfrom(form,pos)  =  enveval{form,2,pos) 
retevalform, pos)  = envevalform, pos, pos) 

(The  second  argument  to  retfrom  establishes  that  the 
current  environment  is  to  be  used  for  the  evaluation  of 
form.) 

As  another  example  of  the  use  of  retfrom,  con(cid:173)

sider  an  implementation  of the  LISP  error  protection 
mechanism.  The  programmer  "wraps  a  form  in 
errorset",  i . e .,  errorset(form)  which  is  defined  as 
cons(eval(form),NIL).  This  "wrapping"  indicates  to 
the  system  the  programmer's  intent  that  any  errors 
which  arise  in  the  evaluation  of form  are  to  be  handled 
by the  function  containing the  errorset.  Since  the 
value  of  errorset  in  the  non-error  case  is  always  a 
list  consisting  of  one  element  (the  value  of form),  an 
error  can  be  indicated  by forcing  errorset  to  return 
any  non-list  item.  Hence,  the  system  function  error 
can  be  defined  as  retfrom(NIL,(ERRORSET  1))  where 
uppercase  items  are  literal  objects  in  LISP.  This 
jumps  back  over  all  intermediary  calls  to  return  NIL 
as  the  value  of  the  most  recent  occurrence  of  errorset 
in  the  hierarchical  calling  sequence. 

In  the  following,  we  employ  envapply  which  takes 
as  arguments  a  function  name  and  list  of  (already  eval(cid:173)
uated)  arguments  for that function.  Envapply  simply 
creates  the  appropriate  form  for  enveval. 
envapply(fn,args,aframe, cframe)  = 

enveval(list(APPLY , list(QUOTE, fn), 

list(QUOTE, args)), aframe, cframe) 
A  central  notion  for  control  structures  is  a  pair(cid:173)

ing  of  a  function  with  an  environment  for  its  evaluation. 
Following  LISP,  we  call  such  an  object a  funarg. 
Funargs  are  created  by  the  procedure  function,  defined 

function(fn)=list(FUNARG, fn, environ(2)) 

(The  argument  to  en(cid:173)

That  is,  in  our  implementation,  a  funarg  is  a  list  of 
three  elements: 
the  indicator  FUNARG,  a  function, 
and  an  environment  descriptor. 
viron  makes  it  reference  the  frame  which  called 
function.)  A  funarg  list,  being  a  globally  valid  data 
structure,  can be  passed  as  an argument,  returned  as 
a  result,  or  assigned  as  the  value  of appropriately 
typed  variables.  When  the  language  evaluator  gets  a 
form  (fen  arg1  arg2  . ..  argn)  whose  functional  object 
fen  is  a  funarg,  i. e.  ,  a  list  (FUNARG  fn-name  ed),  it 
creates  a  list,  args,  of  (the  values  of)  a r g l,  arg2,  . . .. 
argn  and  does 

envapply(second(fcn),args,third(fcn), 1) 

The  environment  in  this  case  is  used  exactly  like  the 
original  LISP A-list.  Moses 12  and Weizenbaum25 
have  discussed  the  use  of function  for  preserving  bind(cid:173)
ing  contexts.  Figure  4  illustrates  the  environment 

structure  where  a  functional  has  been  passed  down:  the 
function  foo  with  variables  X  and  L  has  been  called;  foo 
called  mapcar(X,function(fie))  and  fie  has  been  entered. 
Note  that  along  the  access  chain  the  first  free  L  seen 
in  fie  is  bound  in  foo,  although there  is  a  bound  v a r i(cid:173)
able  L  in  mapcar  which  occurs  first  in  the  control 
chain.  Since  frames  are  retained,  a  funarg  can be 
returned  to  higher  contexts  and  still  work. 
(Burge3 
gives  examples  of the  use  of  funargs  passed  up  as 
values.) 

In  the  above  description,  the  environment  pointer 
is  used  only  to  save  the  access  environment. 
In  fact, 
however,  the  pointer  records  the  state  of  a  process  at 
the  instant  of  some  call,  having both  access  and 
control  environments.  Hence,  such an  environment 
pointer  serves  as  part  of a  process  handle. 
It  is  con(cid:173)
venient  to  additionally  specify  an  action  to  take  when 
the  process  is  restarted  and  some  information 
to  be 
passed  to  that  process  from  the  one  restarting  it.  The 
funarg  can  be  reinterpreted  to  provide  these  features. 
The  function  component  specifies  the  first  module  to 
be  run  in  a  restarted  process,  and the  arguments 
(evaluated  in  the  caller)  provided  to  that  function  can 
be  used  to  pass  information.  Hence,  a  funarg  can be 
used  as  a  complete  process  handle. 
venient  for  a  running  process  to  be  able  to  reference 
its  own  process  handle.  To  make  this  simple,  we 
adopt  the  convention  that  the  global  variable  curproc 
is  kept  updated  to  the  current  running  process. 

It  proves  con(cid:173)

With  this  introduction,  we  now  define  the  routines 
start  and  resume,  which  allow  control  to  pass  among  a 
set  of  coordinated  sequential  processes,  i.e.  ,  co(cid:173)
routines,  in  which  each  maintains  its  own  control  and 
access  environment  (with  perhaps  some  sharing).  A 
coroutine  system  consists  of  n  coroutines  each  of 
which  has  a  funarg handle  on  those  other  coroutines  to 
which  it  may  transfer  control.  To  initiate  a  process 
represented  by  the  funarg  fp,  use  start  (we  use 
brackets  below  to  delimit  comments): 

start(fp.args)  =  curproc  —  fp; 

[  curproc  is  a  global  variable  set  to 
the  current  process  funarg ]  ; 
envapply(second(fp),args,third(fp),third(fp)) 
Once  the  variable  curproc  is  initialized,  and  any  co(cid:173)
routine  started,  resume  will  transfer  control  between 
n  coroutines.  The  control  point  saved  is  just  outside 
the  resume,  and  the  user  specifies  a  function  (backfn) 
to  be  called  when  control  returns,  i . e .,  the  process  is 
resumed.  This  function  is  destructively  inserted  in 
the  funarg  list.  The  args  to this  function  are  specified 
by  the  coroutine  transferring  back  to  this  point. 
resume(fnarg,args,backfn)  = 

second( curproc)  — backfn; 

[save  the  specified  backfn  for  a  subsequent 
resume  back  here] 
setenv(third(curproc), 2); 

[environment  saved  is  the  caller  of  resume] 

curproc  —  fnarg; 

[set  up  curproc  for  the  coroutine  to  be 
activated] 

envapply(second(fnarg),args,third(fnarg), 

third (fnarg)) 

[activate  the  specified  coroutine  by  applying 
its  backfn  to  args] 

We  call  a  funarg used  in this  way  a  process 

funarg.  The  state  of a  "process"  is  updated by  de(cid:173)
structively  modifying  a  list  to  change  its  continuation 
function,  and  similarly  directly  modifying  its  environ(cid:173)
ment  descriptor  in  the  list.  A  pseudo-multiprocessing 
capability  can  be  added  to the  system  using these 
process  funargs  if  each  process  takes  responsibility 
for  requesting  additional  time  for  processing  from  a 
supervisor  or  by  explicitly  passing  control  as  in 
CONNIVER,18  A  more  automatic  multiprocessing 
control  regime  using  interrupts  is  discussed  later. 

248 

B a c k t r a c k i ng  is  a  technique  by  which  c e r t a in  e n(cid:173)

v i r o n m e n ts  are  saved  before  a  function  r e t u r n,  and 
l a t er  r e s t o r ed  if  needed.  C o n t r ol  is  r e s t o r ed  in  a 
s t r i c t ly  last  saved, 
f i r st  r e s t o r ed  o r d e r.  As  an  ex(cid:173)
ample  of  its  u s e,  consider  a  function  which  r e t u r ns 
one  (selected)  value  f r om  a  set  of  computed  values  but 
can  effectively  r e t u rn  an  alternative  selection  if  the 
f i r st  selection  was  inadequate.  That  i s,  the  c u r r e nt 
process  can  f a il  back  to  a  previously  specified  f a il set 
point  and  then  redo  the  computation  w i th  a  new 
selection.  A  sequence  of  different  selections  can  lead 
to  a  stack  of  failset  points,  and  successive  fails  can 
r e s t a rt  at  each  in  t u r n.  Backtracking  thus  provides  a 
way  of  doing  a  d e p t h - f i r st  search  of  a  t r ee  with  r e t u rn 
to  previous  branch  points. 

We  define  f a il  and  failset  below.  We  use 

to  the  front  of  L,  and  pop(L) 
p u s h ( L , a)  which  adds  a 
which  removes  one  element  and  r e t u r ns  the  f i r st  e l e(cid:173)
ment  of  L.  F a i l i st 
is  the  stack  of  failset  points.  As 
defined  b e l o w,  f a il  can  reverse  certain  changes  when 
r e t u r n i ng  to  the  previous  failset  point  by  explicit 
d i r e c t i on  at  the  point  of  f a i l u r e. 
(To  automatically  u n(cid:173)
do  certain  side  effects  and  binding  changes,  we  could 
define  "undoable"  functions  which  add  to  f a i l i st  f o r ms 
whose  evaluation  w i ll  reset  appropriate  c e l l s.  F a il 
could  then  eval  a ll  f o r ms  through  the  next  ed  and  then 
call  enveval.) 

failset{  ) =  push(failist,environ(2)) 

[2  means  environment  outside  failset] 

fail(message)  =  enveval(message,list(pop(failist))) 

The  function  select  defined  below  returns  the  f i r st 

element  of  its  argument  set  when  f i r st  called;  upon 
subsequent  f a i ls  back  to  select,  successive  elements 
f r om  set  are  r e t u r n e d. 
If  set  is  exhausted,  f a i l u re  is 
propagated  back.  The  code  uses  the  fact  that  the  b i n d(cid:173)
ing  environment  saved  by  f a i l s et  shares  the  v a r i a b le 
f ig  w i th  the  instance  of  select  which  calls  f a i l s e t.  The 
test  of  f ig  is  reached  in  two  ways:  after  a  c a ll  on  f a i l-
set  (in  which  case  fig  is  false)  and  after  a  f a i l u re  (in 
which  case  f ig  is  t r u e ). 
select(set,undolist)  = 

progt 
if  null(set)  then  fail(undolist)  [leave  here  and 

(fig) 

s1: 

undo  as  specified] 

false; 
f ig  — 
failsetOT 
[ f ig  is  true  i ff  we  have  failed  to  this  point; 

then 

set  has  been  popped] 

if  f ig  then  go(sl); 
f ig  —  t r u e; 
returnTpop(set)); 
end 

Floyd,"7  Hewitt,9  and  Golomb  and  B a u m e r t8  have  d i s(cid:173)
cussed  uses  f or  backtracking  in  p r o b l em  solving. 
S u s s m a nl8  has  discussed  a  number  of  problems  w i th 
b a c k t r a c k i n g. 
In  general,  it  proves  to  be  too  simple 
a  f o rm  of  switching  between  environments.  Use  of  the 
m u l t i p le  process  feature  described  above  provides 
much  m o re  f l e x i b i l i t y. 

5.  Coordinated  Sequential  Processes 

and  P a r a l l el  P r o c e s s i ng 

It  should  be  noted  that  in  the  model  above,  control 

must  be  e x p l i c i t ly  t r a n s f e r r ed  f r om  one  active  e n(cid:173)
v i r o n m e nt  to  another  (by  means  of  enveval  or  resume). 
We  use  the  t e r m,  coordinated  sequential  p r o c e s s,  to 
describe  such  a  control  r e g i m e.  T h e re  are  situations 
in  which  a  p r o b l em  statement  is  s i m p l i f i ed  by  taking  a 
quite  different  point  of  view  -  assuming  p a r a l l el  (co-
operating  sequential)  processes  which  synchronize  only 
when  r e q u i r ed  (e. g.  ,  by  means  of  D i j k s t r a ' s4  P  and  V 
operations).  Using  our  coordinated  sequential  p r o(cid:173)
cesses  w i th  i n t e r r u p t s,  we  can  define  such  a  control 
r e g i m e. 

249 

In  our  model  of  environment  s t r u c t u r e s,  there  is 

a  t r ee  f o r m ed  by  the  control  l i n k s,  a  dendrarchy_  of 
f r a m e s.  One  t e r m i n al  node  is  m a r k ed  f or  a c t i v i ty  by 
the  c u r r e nt  control  bubble  (the  point  where  the 
language  evaluator  is  operating).  A ll  other  t e r m i n al 
nodes  are  referenced  by  environment  d e s c r i p t o rs  or 
by  an  access  l i nk  pointer  of  a  frame  in  the  t r e e.  To 
extend  the  model  to  m u l t i p le  p a r a l l el  processes 
in  a 
single  processor  s y s t e m,  k  branches  of  the  t r ee  must 
be  simultaneously  m a r k ed  active.  Then  the  control 
bubble  of  the  processor  must  be  switched  f r om  one 
active  node  to  another  according  to  some  scheduling 
a l g o r i t h m. 

To  implement  cooperating  sequential  processes  in 

it  is  simplest  to  think  of  adjoining  to  the 

our  m o d e l, 
set  of  processes  a  distinguished  process,  PS,  which 
acts  as  a  s u p e r v i s or  or  m o n i t o r. 
ules  processes  f or  service  and  maintains  several 
p r i v i l e g ed  data  s t r u c t u r es  ( e . g.  ,  queues  for  sema(cid:173)
phores  and  active  processes). 
used  by  P r e m i e r ,14  ) 

(A  related  technique  is 

This  m o n i t or  sched(cid:173)

The  basic  functions  necessary  to  manipulate 

p a r a l l el  processes  allow  process  a c t i v a t i o n,  stopping, 
continuing,  synchronization  and  status  querying. 
In  a 
single  processor  coordinated  sequential  process 
m o d e l,  these  can  all  be  defined  by  calls  (through 
enveval)  to  the  m o n i t or  PS.  Specifications  f or  these 
functions  a r e; 
1) 

process(form ,apos,  cpos)  --  this  is  s i m i l ar  to 
enveval  except  that  it  creates  a  new  active  p r o-
cess  P'  f or  the  evaluation  of  f o r m,  and  returns 
to  the  creating  process  a  process  d e s c r i p t or  (pd) 
which  acts  as  a  handle  on  P '. 

In  this  m o d e l,  the  pd  could  be  a  pointer  to  a  l i st  which 
has  been  placed  on  a  " r u n n a b l e"  queue  in  PS,  and 
which  is  i n t e r p r e t ed  by  PS  when  the  scheduler  in  PS 
gives  this  process  a  t i me  quantum.  One  element  of 
the  process  d e s c r i p t or  gives  the  status  of  the  p r o c e s s, 
e . g.  ,  RUNNING  or  STOPPED.  Process  is  defined 
using  environ  (to  obtain  an  environment  d e s c r i p t or 
used  as  part  of  the  pd)  and  enveval  (to  call  PS), 
2) 

stop(pd)  —  halts  the  execution  of  the  process 
specified  by  pd  —  PS  removes  the  process  f r om 
runnable  queue.  The  value  returned  is  an  ed  of 
the  c u r r e nt  environment  of  pd. 
continue(pd)  --  returns  pd  to  the  runnable  queues. 
status(pd)  —  value  is  an  indication  of  status  of  pd. 
obtain(semaphore)  —  this  D i j k s t ra  P  operator 
t r a n s f e rs  control  to  PS  (by  enveval)  which  de(cid:173)
t e r m i n es  if  a  resource  is  available  ( i.  e ,,  s e m a(cid:173)
phore  count  positive).  PS  either  hands  control 
back  to  PI  (with  enveval)  having  decremented  the 
the  semaphore  count,  or  enters  P1  on  that  sema(cid:173)
phore's  queue  in  PS's  environment  and  switches 
control  to  a  runnable  process. 
release(semaphore) 
i n c r e m e n ts  the  semaphore  count; 
if  the  count 
goes  positive,  one  process  is  moved  f r om  the 
semaphore  queue  (if  any  exist)  onto  the  runnable 
queue  and  the  count  is  decremented. 
hands  control  back  to  the  calling  p r o c e s s. 

this  Dijkstra  V  operator 

It  then 

-- 

3) 
4) 
5) 

6) 

We  emphasize  that  these  six  functions  can  be  d e(cid:173)
fined  in  t e r ms  of  the  control  p r i m i t i v es  of  section  3. 

Scheduling  of  runnable  processes  could  be  done  by 

i . e .,  obtain(time),  at  appropriate  i n t e r v a l s. 

having  each  process  by  agreement  ask  f or  a  t i me 
r e s o u r c e, 
In  this  scheduling  m o d e l,  control  never  leaves  a  p r o(cid:173)
cess  without  its  knowledge,  and  the  m o n i t or  s i m p ly 
acts  as  a  bookkeeping  m e c h a n i s m.  A l t e r n a t i v e l y, 
o r d i n a ry  t i m e - s h a r i ng  among  processes  on  a  t i me 
quantum  basis  could  be  implemented  through  a  t i m er 
i n t e r r u pt  m e c h a n i s m. 

I n t e r r u p ts  are  treated  as  forced 

calls  to  environ  (to  obtain  an  ed  for  the  current  state), 
and  then  an  enveval  to the  monitor  process.  The  only 
problem  which  must  be  handled  by  the  system  in  forc(cid:173)
ing  the  call  to  environ  is  making  sure  the  interrupted 
process  is  in  a  clean  state;  that  is,  one  in which  basic 
communication  assumptions  about  states  of  pointers, 
queues,  buffers,  etc.  are  true  ( e . g .,  no  pointers  in 
machine  registers  which  should  be  traced  during  gar(cid:173)
bage  collection).  This  can  be  ensured  if asynchronous 
hardware  interrupts  perform  only  minimal  necessary 
operations,  and  set  a  software  interrupt  flag.  Soft(cid:173)
ware  checks  made  before  procedure  calls,  returns  and 
backward  jumps  within  program  will  ensure  that  a 
timely  response  in  a  clean  state  will  occur. 

The  ed  of the  interrupted  process  is  sufficient  to 

restart  it,  and  can be  saved  on  the  runnable  queue 
within  a  process  descriptor.  Because  timer  inter(cid:173)
rupts  are  asynchronous  with  other  processing  in  such 
a  simulated  multiprocessor  system,  evaluation  of 
forms  in  the  dynamic  environment  of  another  running 
process  cannot  be  done  consistently;  however,  the  ed 
obtained  from  stopping a  process  provides  a  consistent 
environment.  Because  of this  interrupt  asynchrony,  in 
order  to  ensure  system  integrity,  queue  and  sema(cid:173)
phore  management  must  be  uninterruptible,  e . g .,  at 
the  highest  priority  level. 

Obtaining  a  system  of  cooperating  sequential  pro(cid:173)
cesses  as  an  extension  of the  primitives  has  a  number 
of desirable  attributes.  Most  important,  perhaps,  it 
allows  the  scheduler  to  be  defined  by  the  user.  When 
parallel  processes  are  used  to  realize  a  breadth-first 
search  of an  or-graph,  there  is  a  significant  issue  of 
how  the  competing  processes  are  to  be  allotted  time. 
Provision  for  a  user  supplied  scheduler  establishes  a 
framework  in  which  an  intelligent  allocation  algorithm 
can be  employed. 

Once  a  multi-process  supervisor  is  defined,  a 

variety  of additional  control  structures  may  be  readily 
created.  As  an  example,  consider  multiple  parallel 
returns  — the  ability  to  return  from  a  single  activation 
of a  module  G  several  times  with  several  (different) 
values.  For  G  to  return  to  its  caller  with  value  given 
by  val  and  still  continue  to  run,  G  simply  calls 
process(val, 1,2).  Then the  current  G  and  the  new 
process  proceed  in  parallel. 

6.  Conclusion 

In  providing  linguistic  facilities  more  complex 

than  hierarchical  control,  a  key  problem  is  finding  a 
model  that  clearly  exhibits  the  relation  between  pro(cid:173)
cesses,  access  modules,  and  their  environment.  This 
paper has  presented  a  model  which  is  applicable  to 
languages  as  diverse  as  LISP,  APL  and P L /I  and  can 
be  used  for  the  essential  aspects  of  control  and  access 
in  each.  The  control  primitives  provide  a  small  basis 
on  which  one  can  define  almost  all  known  regimes  of 
control. 

Although  not  stressed  in  this  paper,  there  is  an 

implementation  for  the  model  which  is  perfectly 
general,  yet  for  several  subcases  ( e . g .,  simple  re(cid:173)
cursion  and  backtracking)  this  implementation  is  as 
efficient  as  existing  special  techniques.  The  main 
ideas  of the  implementation are  as  follows  (cf.  [2]  for 
details).  The  basic  frame  and  frame  extension  are 
treated  as  potentially  discontiguous  segments.  When 
a  frame  extension  is  to be  used  for  running,  it  is 
copied  to  an  open  stack  end  if  not  there  already,  so 
that  ordinary  nested  calls  can  use  simple  stack  disci(cid:173)
pline  for  storage  management.  Reference  counts  are 
combined  with  a  count  propagation  technique  to  ensure 
that  only  those  frames  are  kept  which  are  still  in use. 
Thus,  the  model  provides  both  a  linguistic  frame-
work  for  expressing  control  regimes,  and  a  practical 
basis  for  an  implementation. 
It  is  being  incorporated 
intoBBN-LISP.19 

7.  Acknowledgments 

This  work  was  supported  in  part  by the  Advanced 
Research  Projects  Agency  under  Contracts  DAHC  15-
71-00088  and  F19628-68-0-0379,  and  by  the  U.S.  A ir 
Force  Electronics  Systems  Division  under  Contract 
F19628-71-C-0173.  Daniel  Bobrow  was  at  Bolt 
Beranek  and  Newman,  Cambridge,  Massachusetts, 
when  many  of the  ideas  in  this  paper  were  first  de(cid:173)
veloped. 

[l] 

[2l 

[3] 

[41 

[5] 

[6] 

[7] 

[8t 

[9! 

References 

Bobrow,  D . G .,  "Requirements  for  Advanced 

Programming  Systems  for  List  Processing," 
CACM,  Vol.  15,  No.  6,  June  1972. 

Bobrow,  D.G.  and  Wegbreit,  B. 

"A  Model  and 

Stack  Implementation  of  Multiple  Environ(cid:173)
ments,"  BBN  Report No.  2334,  Cambridge, 
Mass.,  March  1972,  to appear  in  CACM. 

Burge,  W.H. 

"Some  Examples  of the  Use  of 

Function  Producing  Functions,"  Second  Sym(cid:173)
posium  on  Symbolic  and  Algebraic  Manipu(cid:173)
lation,  AC:M,  1971. 

Dijkstra,  E.W. 

"Co-operating Sequential  Pro(cid:173)

cesses,"  in  Genuys  (Ed.),  Programming 
Languages,  Academic  Press,  1967. 

Dijkstra,  E.W. 

"Recursive  Programming," 

Numerische  Mathematik  2  (I960),  312-318. 
Also  in  Programming  Systems  and  Languages, 
S.  Rosen  (Ed.),  McGraw-Hill,  New York,  1967. 

Fenichel,  R. 

"On Implementation  of  Label  Vari(cid:173)

ables,  CACM,  Vol.  14,  No.  5 (May  1971), 
pp.  349-350. 

Floyd,  R.W. 

"Non-deterministic  Algorithms," 

J_.  ACM,  14  (October  1967),  pp.  638-644. 

Golomb,  S.W.  and  Baumert,  L.D. 

"Backtrack 
Programming,"  J.  ACM,  12  (October  1965), 
pp.  516-524. 

Hewitt,  C. 
lating  Models  and  Proving  Theorems  in  a 
Robot," 
Washington,  D.C.,  May  1969. 

"PLANNER:  A  Language  for Manipu(cid:173)
in  Artificial  Intelligence, 

[10]  Johnston,  J . B. 

"The  Contour  Model  of  Block 

Structured  Processes,"  in  Tou  and  Wegner, 
Proc.  Symposium  on  Data  Structures  in 
Programming  Languages.  SIGPLAN  Notices, 
Vol.  6,  No.  2,  pp.  55-82. 

[11]  McCarthy,  J .,  et  al.  Lisp  1. 5  Programmer's 

Manual,  T h e M . I . T.  Press,  Cambridge, 
Massachusetts  (1962). 

[12]  Moses,  J. 

"The  Function  of  FUNCTION  in 

LISP,"  SIGSAM  Bulletin,  No.  15,  (July  1970), 
pp.  13-27. 

[13j  Prenner,  C ,,  Spitzen,  J.  and  Wegbreit,  B. 

"An  Implementation  of  Backtracking  for  Pro(cid:173)
gramming  Languages,"  submitted  for  publi(cid:173)
cation,  ACM-72. 

[14J  Prenner,  C. 

"Multi-path  Control  Structures  for 

Programming  Languages,"  Ph.D.  Thesis, 
Harvard  University,  May  1972. 

[151  Quam,  L.  LISP  1. 6 Reference Manual,  Stanford 

AI  Laboratory. 

250 

[16]  Reynolds,  J. 

"GEDANKEN  - A  Simple  TypelesS 
Language  Based  on  the  Principle  of Complete(cid:173)
ness  and  the  Reference  Concept,"  CACM, 
Vol.  13,  No.  5  (May  1970),  pp.  308-319. 

[17]  Rulifson,  J.  et  al. 

" Q A 4- A  Language for 

Writing  Problem-Solving  Programs,"  SRI 
Technical  Note  48,  November  1970. 

[18]  Sussman,  G.J. 

"Why  Conniving  is  Better  than 

Planning,"  FJCC  1972,  pp.  1171-1179. 

[19]  Teitelman,  W.,  Bobrow,  D.  ,  Murphy,  D.,  and 

Hartley,  A.  BBN-LISP  Manual.  BBN, 
July  1971. 

[20]  Tou,  J,  andWegner,  P.  (Eds.),  SIGFLAN 

Notices — Proc. Symposium on  Data 
Structures  in  Programming  languages. 
Vol.  6,  No.  2  (February 1971) 

[ 2 ll  van  Wijngaarden,  A.  (Ed.).  Report on the 

Algorithmic  Language  ALGOL  68,  MR  101, 
Mathematisch  Centrum,  Amsterdam 
(February  1969). 

[22]  Wegbreit,  B, 

"Studies  in  Extensible  Program(cid:173)

ming  Languages" Ph.D.  Thesis,  Harvard 
University,  May  1970. 

[23]  Wegbreit,  B, 

"The  ECL  Programming  System," 

Proc.  AFIPS  1971  FJCC,  Vol.  39,  AFIPS 
Press,  Montvale,  N . J .,  pp.  253-262. 

[24]  Wegner,  P. 

"Data  Structure  Models  for  Pro-

gramming  Languages,"  in  Tou  and  Wegner, 
pp.  55-82. 

[25]  Weizenbaum,  J. 

"The  Funarg  Problem 

Explained,"  M . I . T .,  Cambridge,  Mass., 
March  1968. 

251 

252 

253 

