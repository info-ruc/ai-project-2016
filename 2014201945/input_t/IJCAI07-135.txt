 Real Boosting      a la Carte   with an Application to Boosting Oblique Decision Trees

          Claudia Henry             Richard Nock                   Frank Nielsen
             U. Antilles-Guyane / CEREGMIA                       SONY   CS Labs Inc.
           97275 Schoelcher, Martinique, France                Tokyo 141-0022, Japan
          {chenry,rnock}@martinique.univ-ag.fr                 Nielsen@csl.sony.co.jp


                    Abstract                          a simple assumption, a corresponding boosting algorithm.
                                                      Using a recent result due to [Nock and Nielsen, 2006],this
    In the past ten years, boosting has become a major algorithm uses real-valued weak hypotheses, but it does not
    Ô¨Åeld of machine learning and classiÔ¨Åcation. This  face the repetitive minimization of the exponential loss faced
    paper brings contributions to its theory and algo- by previous Real boosting algorithms [Friedman et al., 2000;
    rithms. We Ô¨Årst unify a well-known top-down de-   Schapire and Singer, 1999]. When the classiÔ¨Åer is an oblique
                                    [
    cision tree induction algorithm due to Kearns and decision tree, the algorithm obtained has three key features:
                 ]                      [
    Mansour, 1999 , and discrete AdaBoost Freund      it is fast, simple, and the Ô¨Årst provable boosting algorithm
                     ]
    and Schapire, 1997 , as two versions of a same    that fully exploits this class. This is important, as the prob-
    higher-level boosting algorithm. It may be used   lem of inducing oblique decision trees has a longstanding his-
    as the basic building block to devise simple prov- tory, and the algorithms available so far are either time con-
    able boosting algorithms for complex classiÔ¨Åers.  suming or complex to handle formally [Breiman et al., 1984;
    We provide one example: the Ô¨Årst boosting al-     Cant¬¥u-Paz and Kamath, 2003; Heath et al., 1993; Murthy et
    gorithm for Oblique Decision Trees, an algorithm  al., 1994; Shawe-Taylor and Cristianini, 1998]. The follow-
    which turns out to be simpler, faster and signiÔ¨Å- ing Section presents deÔ¨Ånitions; it is followed by a Section on
    cantly more accurate than previous approaches.    our theoretical results, and a Section that discusses them and
                                                      gives our boosting algorithm for oblique decision trees; two
1  Introduction                                       last Sections discuss experiments, and conclude. For the sake
Loosely speaking, a boosting algorithm repeatedly trains of clarity, proofs have been postponed to an appendix.
moderately accurate learners from which it gets its weak hy-
potheses, and combines them to output a strong classiÔ¨Åer 2 DeÔ¨Ånitions and problem statement
which boosts the accuracy to arbitrary high levels [Kearns Bold-faced variables such as w and x, represent vectors.
and Valiant, 1989]. A pioneering paper [Schapire, 1990] Unless otherwise stated, sets are represented by calligraphic
proved the existence of such boosting algorithms, and another upper-case alphabets, e.g. X , and (unless explicitely stated)
one drew the roots of their most popular representative: Ad- enumerated following their lower-case, such as {xi : i =
aBoost, that builds a linear combination of the predictions of 1, 2, ...} for vector sets, and {xi : i =1, 2, ...} for other sets.
the weak hypotheses [Freund and Schapire, 1997]. Another Consider the following supervised learning setting. Let X
paper due to [Kearns and Mansour, 1999] proved that some of denote a domain of observations of dimension n,suchasRn,
the most popular top-down decision tree induction algorithms {0, 1}n, etc. . We suppose a set S of |S| = m examples, with
                                [
are also boosting algorithms in disguise Breiman et al., 1984; |.| the cardinal notation, deÔ¨Åned as S = {si = xi,yi‚àà
Quinlan, 1993]. These two kinds of algorithms are outwardly X√ó{‚àí1, +1} : i =1, 2, ..., m}, onto which a discrete dis-
different from each other: while AdaBoost repeatedly modi- tribution w1 is known. ‚Äú+1‚Äù is called the positive class, and
Ô¨Åes weights on the training examples and directly minimizes ‚Äú-1‚Äù the negative class. Our primary objective is related to
aconvexexponential loss, top-down decision tree induction building an accurate classiÔ¨Åer (or hypothesis) H : X‚ÜíR.
algorithms do not modify weights on the examples, and they The goodness of Ô¨Åt of H on S may be evaluated by two quan-
minimize the expectation of a concave, so-called permissible tities:
function [Kearns and Mansour, 1999].
                                                                     w
  This explains why the starting point of this paper is a quite Œµ(H,  1)=Ew1      (1[sign(H(x))=y]) , (1)
surprising result, as we prove that these two kinds of algo-         w                ‚àí     x
                                                              Œµexp(H, 1)=Ew1      (exp( yH(  ))) .    (2)
rithms are in fact the same algorithm, whose induction is per-
                                                                           ‚â•      ‚àí
formed on two different classiÔ¨Åer ‚Äúgraphs‚Äù. The apparent per- Here, sign(a)=+1iff a 0 and 1 otherwise, 1[.] is the 0/1
ceptual differences in the algorithms stem only from different indicator variable, and E.() is the expectation. (1) is the con-
structural properties of the classiÔ¨Åers. This suggests a generic ventional empirical risk, and (2) is an upperbound, the expo-
induction scheme which gives, for many classiÔ¨Åers that meet nential loss [Schapire and Singer, 1999]. We are interested in

                                                IJCAI-07
                                                   842   Input: S, w1;                           Input: S, w1;                  Input: S, w1;
   for t =1, 2, ..., T                     for t =1, 2, ..., T            for t =1, 2, ..., T

     ht ‚Üê Tree(S, wt);                       let  ‚àà leaves(Ht‚àí1) containing let  ‚àà leaves(Ht‚àí1) containing
        ‚Üê                    ‚àí      x
     Œ±t    arg minŒ±‚ààR Ewt (exp( yŒ±ht( )));         examples of both classes;       examples of both classes;

     for i =1, 2, ..., m                     ht ‚Üê  Stump(S, w1);            ht ‚Üê StumpLS(S, w1);

        wt+1,i ‚Üê wt,i exp(‚àíŒ±tyiht(xi))/Zt;    ‚Üê  ht;                         ‚Üê ht;
   AdaBoost + Trees                        TopDown  DT (CART, C4.5)       TopDown  ODT (OC1, SADT)

Figure 1: An abstraction of 3 core greedy procedures of some popular induction algorithms (see text for references and details).

the stagewise, greedy Ô¨Åtting of H to S, from scratch. A large Figure 1 gives an abstract view of some of the most pop-
number of classes of classiÔ¨Åers have popular induction algo- ular induction algorithms, or at least of their core procedure
rithms whose core procedure follows this scheme, including which induces a large classiÔ¨Åer: AdaBoost with trees [Freund
Decision Trees (DT) [Breiman et al., 1984; Quinlan, 1993], and Schapire, 1997; Schapire and Singer, 1999],C4.5[Quin-
Branching Programs (BP) [Mansour and McAllester, 2002] lan, 1993],CART[Breiman et al., 1984],OC1[Murthy et
and Linear Separators (LS) [Freund and Schapire, 1997; al., 1994], SADT [Heath et al., 1993]; the Ô¨Årst algorithm for
Nock and Nielsen, 2006]. Virtually all these procedures share the induction of ODT dates back to the mid-eighties; it was a
another common-point: the components that are used to grow descendant of CART [Breiman et al., 1984]. Most of the in-
H are also classiÔ¨Åers. These are the DTs for AdaBoost with duction algorithms for DT or ODT integrate a pruning stage;
trees, the internal node splits for the DTs and BPs (akin to here, we are only interested in the greedy induction scheme.
decision stumps), etc.                                WL has various forms: it induces a decision tree on the whole
  Now, given some Ô¨Åxed class of classiÔ¨Åers in which we Ô¨Åt sample S and on a distribution which is repeatedly modiÔ¨Åed
H, here is the problem statement. A weak learner (WL) is for AdaBoost; it induces a decision tree with a single internal
assumed to be available, which can be queried with a sam- node (a stump) on the subset of S that reaches leaf  (noted
                                   
ple S and (discrete) distribution w on S ; the assump- S) and on a distribution which is not modiÔ¨Åed for CART and
tion of its existence is called a Weak Learning Assump- C4.5; it replaces this ordinary, axis-parallel stump, by a linear
tion (WLA). It returns in polynomial time1 a classiÔ¨Åer h separator stump (also called stump for the sake of simplicity)
on which only the following can be assumed: Œµ(h, w) ‚â§ for OC1 and SADT. The choice of a split for DT and ODT re-
1/2 ‚àí Œ≥ for some Œ≥>0     [Schapire and Singer, 1999]. lies on the repetitive minimization of an ‚Äúimpurity‚Äù criterion
Given 0 <<1, is it possible to build in polynomial   which is the expectation, over the leaves of the current tree
time some H with Œµ(H, w1) ‚â§  , after having queried T H, of a so-called permissible function [Kearns and Mansour,
times WL for classiÔ¨Åers h1,h2, ..., hT ,forsomeT>0 ?  1999]:
Provided additional assumptions are made for its generaliza-                                   
                                                                                            w+
tion abilities (see Section ‚ÄúDiscussion‚Äù below), this algorithm w                            1,S
                                                         Œµimp(H,  1,f)=E‚àºleaves(H)     f            ; (3)
is called a boosting algorithm [Freund and Schapire, 1997;                                  w1,S
Kearns and Valiant, 1989].
                                                                                     
                                                                                   S    w        +
                                                      here, w1,S is the total weight of in 1 and w.  is its
3  Unifying boosting properties                       weight further restricted to the positive class. In the expec-
For the sake of clarity, we now plug T in subscript on tation, the weight of a leaf  is w1,S . The permissible func-
                                             x        tion f :[0, 1] ‚Üí [0, 1] has to be concave, symmetric around
H; An element of LS is a classiÔ¨Åer HT with HT ( )=
  T       x          ‚àà R                              1/2, and with f(0) = f(1) =  0 and f(1/2) =  1.Ex-
  t=1 Œ±tht( ),whereŒ±t    is a leveraging coefÔ¨Åcient that amples of permissible functions are f(z)=4z(1 ‚àí z) for
may be interpreted as a conÔ¨Ådence in ht. An element of DT is Gini index [Breiman et al., 1984], f(z)=‚àíz log z ‚àí (1 ‚àí
a rooted directed tree in which each internal node supports a z) log(1 ‚àí z) for the entropy [Quinlan, 1993] (log base-2), or
single boolean test over some observation variable, and each       
                                                                        ‚àí                         [
leaf is labeled by a real. The classiÔ¨Åcation of some obser- even f(z)=2 z(1 z) for the optimal choice of Kearns
                                                      and Mansour, 1999]. Remark that we have Œµimp(H, w1,f) ‚â•
vation proceeds by following, from the root, the path whose  w        {    ‚àí  }          w
tests it satisÔ¨Åes, until it reaches a leaf which gives its class. Œµimp(H, 1, 2min z,1 z )=2Œµ(H, 1), for any per-
                                                      missible , and so minimizing (3) amount to minimizing
Figure 2 (left) presents an example of DT (n =2), where       f
                                                      the empirical risk of H as well. The reason why this is
v1,v2 are Boolean description variables. Finally, Oblique De-
cision Trees (ODT) generalizes DT, as linear combinations of a better choice than focusing directly on the empirical risk
                                                                                                  [
variables are authorized for the internal nodes, which allows comes from the concavity of the permissible function Kearns
                                                                      ]
splits that are oblique instead of just axis-parallel [Breiman et and Mansour, 1999 . Though seemingly very different from
al., 1984].                                           each other, AdaBoost and DT induction algorithms from the
                                                      CART-family were independently proven to be boosting al-
  1For the sake of simplicity, polynomial time means polynomial gorithms [Freund and Schapire, 1997; Kearns and Mansour,
in the relevant parameters throughout the paper.      1999; Schapire and Singer, 1999]. Sofar,nosuchformal

                                                IJCAI-07
                                                   843                                       h
                                         1                Input: S, w1;
        v2 =0     v2 =1          v2 =0     v2 =1
                                                          for t =1, 2, ..., T
                                h                                   S
                    +1            2          h3             compute   t;
 v1 =0    v1 =1           v1 =0    v1 =1
                                                            ht ‚Üê WL(St,  wt);
                                                            for i =1, 2, ..., m
    +1    ‚àí1                 h4    h5                                        ‚àí      x   
                                                                            1 (Œºtyiht( i)/ht ) ‚ààS
                                                                                  ‚àí 2      if si  t
                                                              w    ‚Üêw    √ó       1 Œºt                  ;
                        (Œ±1,h1)=(‚àí2, +1)                       t+1,i   t,i                     ‚ààS\S
                        (Œ±2,h2)=(3, +1)(Œ±3,h3)=(3, +1)                            1        if si     t
                        (Œ±4,h4)=(0, +1)(Œ±5,h5)=(2, ‚àí1)    for t =1, 2, ..., T
                                                               ‚Üê                      ‚àí
                                                            Œ±t    (1/(2ht )) ln((1 + Œºt)/(1 Œºt));
Figure 2: A DT with 3 leaves and 2 internal nodes (left) and GenericGreedy (G2)
an equivalent representation which Ô¨Åts to (A) (right).

                                                      Figure 3: The generic greedy induction of HT . The compu-
boosting algorithm or proof exist for ODT that would take tation of St depends on the decision graph of Ht.
full advantage of their structure combining oblique stumps

and decision trees. For this objective, let us shift to a more                                    
                                                      We also extend the weight notation, and let wt ,Sp =
general standpoint on our problem, and address the following                         
                                                             w    and w  St =        w    (with p ‚ààPand
question: what kind of classiÔ¨Åers may be used to solve it ? si‚ààSp t ,i t ,      si‚ààSt  t ,i
                                                        ‚â§   ‚â§                                 |  x  |‚àà
Consider the following assumption, that represents some 1 t   T +1). We also deÔ¨Åne ht =maxsi‚ààSt  ht( i)
                                  HT                  R                                 S
kind of local linear classiÔ¨Åer:                         , the maximal absolute value of ht over t.After[Nock and
                                                      Nielsen, 2006], we deÔ¨Åne two notions of margins:theÔ¨Årstis
    (assumption A) ‚àÄT>0, denote HT = {h1,h2, ..., hT }
                                                      the normalized margin ht over S:
    the set of outputs of WL; then, there exists a function               
                                                                     1
    which maps any observation to a non-empty subset of    Œº   =              w   y h (x ) ‚àà [‚àí1, +1] . (6)
    H         X‚Üí     HT \{‚àÖ}  ‚àÄx ‚ààX        x                t                  t,i i t i
      T , gHT :     2       .        , gHT ( ) is re-              h wt,St
                                                                    t     si‚ààSt
    quired to be computable polynomially in n and the size
    of HT ; it describes the classiÔ¨Åcation function of HT ,in With the help of this deÔ¨Ånition, Figure 3 presents the generic
    the following way:                                greedy induction of HT . Remark that when HT is a linear
                                                     separator, G2 is the AdaBoostR boosting algorithm of [Nock
        HT (x)=              Œ±tht(x) , ‚àÄx ‚ààX .        and Nielsen, 2006]. The second margin deÔ¨Ånition is the mar-
                      ‚àà    x                                             x  
                    ht gHT ( )                        gin of HT on example ,y  [Nock and Nielsen, 2006]:

                                                           ŒΩT (x,y) =   tanh(yHT (x)/2) ‚àà [‚àí1, +1] . (7)
By means of words, the classiÔ¨Åcation of HT is obtained by
                                   H
summing the outputs of some elements of T . Many classi- This margin comes to mind from the relationships between
Ô¨Åers satisfy (A), such as decisition trees, decision lists, linear boosting and the logistic prediction HT (x) = log(Pr[y =
separators, etc.                                      +1|x]/Pr[y = ‚àí1|x]) [Friedman et al., 2000]. In this case,
                                                                     x                    |x ‚àí
DeÔ¨Ånition 1 The decision graph of HT (on X )isanoriented (7) becomes ŒΩT ( ,y )=y(Pr[y =+1     ]   Pr[y =
                                                     ‚àí  |x
graph G =(HT  , E);anarc(ht,ht ) ‚ààEiff t<t and there   1  ]), whose expectation is the normalized margin (6) of
          x ‚ààX                 ‚àà     x                                     ‚àí
exists some      such that ht,ht  gHT ( ) and no ht   the Bayesian prediction in [ 1, +1] (also called gentle lo-
                   x                                                  [                   ]
with t<t  <t  is in gHT ( ).                          gistic approximation Friedman et al., 2000 ). Following
                                                      [Nock and Nielsen, 2006],wedeÔ¨Ånethemargin error of HT
Remark that G is acyclic, and g T maps each observation of
                          H                           (‚àÄŒ∏ ‚àà [‚àí1, +1]):
X to some path of G.WealsodeÔ¨ÅneP   as representing the
                               X
set of paths of G that is mapped from by gHT :                   ŒΩw1,HT ,Œ∏ =   Ew1 (1[ŒΩT (s)‚â§Œ∏]) ,    (8)
      P       { ‚äÜH     ‚àÉx ‚ààX           x }                              w    ‚â§
          =    p    T :       ,p=  gHT ( ) .          and we have Œµ(HT ,  1)    ŒΩw1,HT ,0. Thus, minimizing
                                                                                           w
                                                      ŒΩw1,HT ,0 would amount to minimize Œµ(HT , 1) as well. The
 The simplest case of G is obtained when g T (x)=
                                         H            following Theorem shows much more, as under some weak
HT , ‚àÄx ‚ààX: HT  is a linear separator, and G asinglepath
                                                      conditions, we can show that ŒΩw1 T is minimized for all
from h to h . Examples of classes of classiÔ¨Åers different                          ,H ,Œ∏
      1    T                                          values of Œ∏ ‚àà [‚àí1, +1) (and not only for Œ∏ =0).
from linear separators and that Ô¨Åt to (A) include DT and ODT.
In this case, G is a tree and weak hypotheses are in fact con- Theorem 1 After T ‚â• 1 queries of WL, the classiÔ¨Åer ob-
                                                      tained, H , satisÔ¨Åes:
stant predictions on the tree nodes. Figure 2 (right) displays T          
the way we can represent a DT so as to meet (A). Remark                                
   
                                                                  ‚â§  1+Œ∏    √ó                  ‚àí   2
that there exists many possible equivalent transformations of ŒΩw1 T             w    Sp       1  Œº   , (9)
                                                             ,H ,Œ∏   1 ‚àí Œ∏        T +1,            t
a DT; the way we induce HT shall favor a single one out of                   p‚ààP        ht‚ààp
all, as follows. We deÔ¨Åne two types of subsets of S (with
                                                      for any Œ∏ ‚àà [‚àí1, +1].
p ‚ààPand  1 ‚â§ t ‚â§ T +1):
                                                      (proof in appendix). To read Theorem 1, consider the follow-
        S       {x   ‚ààS            x  }
         p  =      i,yi    : p = gHT ( i) ,     (4)   ing WLA for real-valued weak hypotheses, borrowed from
        S       ‚à™       S
         t  =    p‚ààP:ht‚ààp p .                   (5)   [Nock and Nielsen, 2006]:

                                                IJCAI-07
                                                   844           | |‚â•                  ‚àÄ ‚â•                                   ‚àí    x                   2
    (WLA)  Œºt   Œ≥,forsomeŒ≥>0    ( t  1).              arg minR Ew1 (exp( yht( ))) (Figure 1), and G matches
                                                      exactly discrete AdaBoost [Freund and Schapire, 1997].
Under the WLA, Theorem    1 states that ŒΩw1 T    ‚â§
                                          ,H ,Œ∏         Thus, decision trees and linear separators are somehow ex-
K  exp(‚àí min ‚ààP |p|Œ≥2/2), with K constant whenever Œ∏
  Œ∏         p                  Œ∏                      tremal classiÔ¨Åers with respect to G2. Finally, when H is a
is a constant ‚àà [‚àí1, +1). In other words, provided the in-                                          T
                                                      linear separator without restriction on the weak hypotheses,
duction in G2 is performed so as to keep paths with roughly
                                                        2 specializes to AdaBoostR [Nock and Nielsen, 2006].
equal size, such as by a breadth-Ô¨Årst induction of the decision G
graph, the margin error is guaranteed to decrease exponen- 4.2 All boosting algorithms
tially fast. To see how G2 Ô¨Åts to tree-shaped decision graphs,
consider the following assumption:                    In the original boosting setting, the examples are drawn in-
                           ‚ààH                         dependently according to some unknown but Ô¨Åxed distribu-
    (assumption B) (i) each ht T is a constant, and (ii) tion D over X , and the goal is to minimize the true risk
    G is a rooted tree.
                                                      Œµ(HT ,D) with high probability, i.e. we basically wish that
Assumption (B) basically restricts HT to be a tree of any arity, Œµ(HT ,D) ‚â§  with probability ‚â• 1 ‚àí Œ¥ over the sampling of
still in which any kind of classiÔ¨Åer may be used to split the S [Freund and Schapire, 1997; Kearns and Valiant, 1989].
                                    +/‚àí
internal nodes. As in (3), we use notation w. as the index‚Äô Two sufÔ¨Åcient conditions for a polynomial time induction
weight for class ‚Äú+1‚Äù or ‚Äú-1‚Äù, respectively.          algorithm to satisfy this constraint are (i) return HT with
                                                      Œµ(H  , w )=0, and (ii) prove that structural parameters of
Theorem 2 Suppose that (A) and (B) hold. Then:            T   1
                                                      the class of classiÔ¨Åers to which HT belongs satisfy particular
                               +                      bounds [Freund and Schapire, 1997; Shawe-Taylor and Cris-
                          1   w1,St
              HT (x)=       ln ‚àí    ,          (10)   tianini, 1998]. Theorem 1 is enough to prove that (i) holds
                          2   w                                                               2
                               1,St                   under fairly general conditions for algorithm G in Figure 3
                                                      provided WLA holds. For example, T =(2/Œ≥2)log(1/) it-
‚àÄx ‚ààXand     h is the leaf of g T (x). Furthermore, (2)                           2
              t             H                                                  2/Œ≥
simpliÔ¨Åes as:                                         erations for LS and T =(1/) for DT are enough to have
                                                            w   ‚â§
                                                   Œµ(HT ,  1)   from Theorem 1. Fixing <mini w1,i easily
                                                     yields (i). The bound for LS is the same as AdaBoost (dis-
                           w+          w+
         w               √ó     1,St   ‚àí   1,St       crete or real) [Schapire and Singer, 1999], while that for DT
 Œµexp(HT , 1)=      w1,St  2         1         (11).
                              w1,St      w1,St                                           [
             ht leaf of G                             improves upon the exponent constant of Kearns and Man-
                                                     sour, 1999]. Finally, (ii) is either immediate, or follows from
                         w         ‚àí
             =   Œµimp(HT , 1, 2 z(1  z)) .     (12)   mild assumptions on G and WL. As a simple matter of fact,
                                                      (i) and (ii) also hold when inducing ODT with G2.
(proof in appendix).
                                                      4.3  Recursive Boosting and Oblique Decision
4  Discussion                                              Trees
4.1  Kearns and Mansour‚Äôs algorithm, AdaBoost         The preceeding Subsections suggest that G2 could be used
           2
     and G                                           not only to build HT , but also as the core procedure for WL.
The similarity between (12) and (3) with f(z)=2 z(1 ‚àí z) For example, it comes from Theorem 2 that AdaBoost + trees
                                                                                             2
is immediate, and quite surprising as it shows the identity be- without pruning (Figure 1) is equivalent to G growing lin-
                                                                                   2
tween a convex loss and the expectation of a concave loss. ear separators, in which WL is G growing a decision tree,
However, this is not a coincidence. Indeed, Theorem 2 shows in which WL returns any constant weak hypothesis. In the
a rather surprising result: the choice of the weak hypotheses general case, we would obtain a recursive/composite design
                                                      of the ‚Äúmaster‚Äù G2,viaG2 itself, and the recursion would
does not impact at all on HT (see (10)). When (A)and(B)
                                                      end until we reach a WL that can afford exhaustive search for
hold, the only way to modify HT is thus through its deci-
sion graph, i.e. on the choice of the splits of the tree. There simple classiÔ¨Åers (e.g. axis-parallel stumps, constant classi-
                                                                                       2            2
is a simple way to choose them, which is to do the same Ô¨Åers, etc.), instead of calling again G .However,G can
thing as the most popular LS boosting algorithms [Friedman also be used to build the decision graph of HT ,inthesame
et al., 2000; Schapire and Singer, 1999]: repeatedly mini- recursive fashion. Consider for example the class ODT. The
mize the exponential loss in (2). Because of Theorem 2, this internal nodes‚Äô splits are local classiÔ¨Åers from LS that decide
amounts to the minimization of the impurity criterion in (3) the path based on the sign of their output, or equivalently, on
                   ‚àí                                  the class they would give. This suggest to build the tree with
with f(z)=2    z(1   z).Thisisexactly the DT induc-     2
                                                      G  on both the linear separators in the internal nodes of HT
tion algorithm proposed by [Kearns and Mansour, 1999] that S
meets the representation optimal bound.               (use   to split leaf , where the linear separator uses ordi-
                                                      nary decision stumps), and on the tree shape as well. Call
  On the other hand, when  HT  is a linear separator,
there is no inÔ¨Çuence of the decision graph on the induc- BoostODT this ODT induction algorithm. It turns out that it
tion of H  as it is a single path from h to h .The    brings a boosting algorithm, that takes full advantage of the
         T                           1     T          ODT structure. However, this time, it is enough to assume the
only way to modify HT  is thus through the choice of
the weak hypotheses. Suppose that each weak hypothe-  WLA  one level deeper, i.e. only for the stumps of the linear
sis has output restricted to the set of classes, {‚àí1, +1}. separators, and not for the splits of the oblique decision tree.
In this case, Œ±t =(1/2) ln((1 ‚àí Œµ(ht, wt))/Œµ(ht, wt)) = Theorem 3 BoostODT is a boosting algorithm.

                                                IJCAI-07
                                                   845 100              100             100
          Xd6              Xd6             Xd6         Domain               BoostODT       OC1   AdaBoost
  80              80               80                                     T1 =50  T1 = 200          +C4.5
  60              60               60                  Adult-strech         0.00     0.00  0.15      0.00
  40              40               40                  Breast-cancer       28.67    27.27 37.76     33.92
  20              20               20                  Breast-cancer-w.     3.72     3.86  6.01      4.43
  0                0               0                   Bupa                28.12    28.12 37.97     31.59
  -1  -0.5  0  0.5  1 -1 -0.5  0  0.5  1 -1 -0.5  0  0.5  1 Colic          17.66    18.21 23.91     18.21
                                                       Colic.ORIG          13.86    15.76 16.03     32.07
                                                       Credit-a            14.64    14.93 20.43     15.51
Figure 4: Margin distributions for BoostODT (T1 =50)on Credit-g            26.50    25.40 31.10     28.40
domain XD6, with 10% (left), 20% (center) and 30% class Diabetes           25.91    23.44 34.64     29.82
noise (right). Stair-shaped (bold plain) curves are the theoret- Hepatitis 20.65    18.71 20.65     18.71
ical margins for the logistic model (see text).        Ionosphere           7.41     6.27  9.12      7.41
                                                       Kr-vs-kp             3.38     3.35  3.69      0.69
                                                       Labor               10.53    10.53 15.79     12.28
The proof, omitted due to the lack of space, builds upon The- LEDeven      15.25    14.75  9.75     10.50
orem (1) plus Lemma 2.1 in [Mansour and McAllester, 2002], LEDeven+17      22.75    21.50 38.25     30.75
and structural arguments in [Freund and Schapire, 1997; Monks1             25.36    25.36  0.00      2.16
Shawe-Taylor and Cristianini, 1998]. The proof emphasizes Monks2            1.00     0.67  0.33     26.96
the relative importance of sizes: suppose that each linear sep- Monks3      1.44     2.17  2.71      2.53
                                                       Mushroom             0.00     0.00  0.05      0.00
arator contains the same number of weak hypotheses (T1),
and the tree is complete with T internal nodes; then, having Parity        47.66    47.27 46.88     44.14
                         2                             Sick                 2.15     1.91  2.41      1.09
                              2
          T1 log T2 =   Œ©((1/Œ≥ ) log(1/))             Sonar               13.94    12.50 33.17     18.27
                                                       Vot e                3.91     3.45  4.37      5.29
is enough to have Œµ(HT , w1) ‚â§ . From an experimental XD6                 20.57    18.77  5.33      5.40
standpoint, this suggests to build trees with T1  T2. Yellow-small         0.00     0.00  0.00      0.00
                                                       #Wins (T1 =50)   17(10/4)           5(3)      8(3)
5  Experiments                                         #Wins (T1 = 200)          18(10/7)  5(3)      8(3)
We have performed comparisons on a testbed of 25 domains
with two classes, most of which can be found on the UCI Table 1: Results on 25 domains. For each domain, bold
repository of ML databases [Blake et al., 1998]. Comparisons faces indicate the lowest errors. In each row ‚Äú#Wins
are performed via ten-fold stratiÔ¨Åed cross-validation, against (T1 = z)‚Äù, bold faces denote the number of times the
OC1 and AdaBoost in which the weak learner is C4.5 un- corresponding algorithm in column is the best over three
                               ‚àà{       }
pruned. BoostODT was ran for T1   50, 200 (the weak   columns: BoostODT(T1  =  z), OC1 and AdaBoost+C4.5
hypotheses of the linear separators are decision stumps) and (z ‚àà{50, 200}). Furthermore, the four numbers in parenthe-
T2 =4. To make fair comparisons, we ran AdaBoost for  ses in each row are the number of signiÔ¨Åcant wins (student
a total number of T =5boosting iterations. This brings paired t-test, p = .05), for BoostODT vs OC1, BoostODT vs
fair comparisons, as an observation is classiÔ¨Åed by 5 nodes AdaBoost+C4.5, and OC1 vs BoostODT, AdaBoost+C4.5 vs
(including leaves) in BoostODT, and 5 unpruned trees in Ad- BoostODT (from left to right).
aBoost. Before looking at the results, BoostODT has proven
to be much faster than OC1 in practice (ten to hundred times
                                                      4 its margin error curves on domain XD6 with variable class
faster). OC1‚Äôs time complexity is O(nm2 log m) [Murthy
                                                                   [                    ]
et al., 1994], without guarantee on its result, while Boos- noise (see e.g. Nock and Nielsen, 2006 for a description of
                                                      the domain), averaged over the test folds [Nock and Nielsen,
tODT‚Äôs is O(nm) under the WLA, with the guarantee to
                                                          ]
reach empirical consistency in this case. Complexity reduc- 2006 .Themargin curve obtained is compared to that of the
                                                                        [                   ]
tions have almost the same order of magnitude with respect to logistic prediction of Friedman et al., 2000 , which can be
SVM based induction of ODT [Shawe-Taylor and Cristianini, computed exactly. The approximation of the logistic model
1998]. Table 1 summarizes the results obtained. With rejec- by BoostODT is quite remarkable. Indeed, its margin curves
tion probabilities p ranging from less than .05 to less than display the single stair-shape of a theoretical logistic model
                                                      for a domain XD6 with 8-13% additional class noise, uni-
.005 for the hypothesis H0 that BoostODT does not perform
better, the four sign tests comparing both runs of BoostODT formly distributed among the ODT leaves.
to its opponents are enough to display its better performances,
and this is conÔ¨Årmed by student paired t-tests. There is more: 6Conclusion
we can tell from simulated domains that BoostODT performs Perhaps one main contribution of this paper is to show that
as better as the domain gets harder. It is the case for the formal boosting is within reach using the same uniÔ¨Åed algo-
Monks domains, and the LEDeven domains. BoostODT is   rithm, for a wide variety of formalisms not restricted to the
indeed beaten by both opponents on LEDeven, while it beats most popular included in this paper (such as decision lists
both on LEDeven+17 (=LEDeven +17 irrelevant variables). [Rivest, 1987], simple rules [Nock, 2002], etc. ). Another
  Looking at these simulated domains, we have drilled down contribution, quite surprising, is to show that a boosting al-
the results of BoostODT. Using (8), we have plotted on Figure gorithm follows immediately even for complex combinations

                                                IJCAI-07
                                                   846