   Automated      Composition      of Web   Services    by  Planning    at the  Knowledge      Level

                         M. Pistore                 A. Marconi   and  P. Bertoli and  P. Traverso
                    University of Trento                              ITC-IRST
                    Via  Sommarive   14                          Via  Sommarive   18
                  38050  Povo  (TN), Italy                     38050  Povo  (TN), Italy
                    pistore@dit.unitn.it                  [marconi, bertoli, traverso]@itc.it

                    Abstract                            Recent works address the problem of the practicality of
                                                      the proposed solutions for web service composition. For
    In this paper, we address the problem of the auto- instance, [Traverso and Pistore, 2004; Pistore et al., 2005]
    mated composition of web services by planning on  propose a framework where web services are modeled with
    their â€œknowledge levelâ€ models. We start from de- stateful, nondeterministic, and partially observable behaviors,
    scriptions of web services in standard process mod- and planning techniques based on symbolic model checking
    eling and execution languages, like BPEL4WS, and  are used to address the scalability problem. However, these
    automatically translate them into a planning do-  techniques work under the rather unrealistic assumption that
    main that models the interactions among services  web services can exchange only a very small number of data
    at the knowledge level. This allows us to avoid   values. For instance, as the experimental results reported in
    the explosion of the search space due to the usu- [Traverso and Pistore, 2004; Pistore et al., 2005] show, rea-
    ally large and possibly inï¬nite ranges of data val- sonable performances are obtained for web services whose
    ues that are exchanged among services, and thus   variables can contain only two values. This amounts to say
    to scale up the applicability of state-of-the-art tech- that amazon.com could sell just two books!
    niques for the automated composition of web ser-    Luckily enough, as already stated in [Pistore et al., 2005],
    vices. We present the theoretical framework, im-  the composition solution should not depend on the actual data
    plement it, and provide an experimental evaluation exchanged among web services, in the same way as the op-
    that shows the practical advantage of our approach erations that one has to perform to buy a book do not de-
    w.r.t. techniques that are not based on a knowledge- pend on the precise book one wants to buy. The ï¬‚ow of
    level representation.                             operations and interactions depends instead on whether the
                                                      desired book is available or not, on whether its cost is af-
                                                      fordable, and so on. The relevant issues for interacting with
1  Introduction                                       amazon.com   are whether one knows whether the book is
Research in planning is more and more focusing on the prob- available or not, whether one knows the value of its price,
lem of the automated composition of web services: given a set and so on. The hope here is to apply planning techniques at
of services that are published on the Web, and given a goal, the knowledge level, in the style of those proposed in [Petrick
generate a composition of the available services that satis- and Bacchus, 2002], or used in [McIlraith and Son, 2002;
ï¬es the goal (see, e.g., [Narayanan and McIlraith, 2002]). In Martinez and Lesperance, 2004]. This would make it pos-
spite of the fact that several approaches have been proposed sible to model only those features of the services which are
so far (see, e.g., [McIlraith and Son, 2002; Wu et al., 2003; relevant to compose them, and thus allow for an efï¬cient au-
Sheshagiri et al., 2003; Traverso and Pistore, 2004]), solv- tomated composition.
ing this problem in practice, by scaling up to realistic de- Unfortunately, applying knowledge-level planning to solve
scriptions of web services, is far from trivial. Indeed it is the automated composition problem presents a major difï¬-
widely recognized that web services must be modeled with culty. While in [Petrick and Bacchus, 2002] the planning
nondeterministic and partially observable behaviors [Koehler domain at the knowledge level is deï¬ned by hand, this is
and Srivastava, 2003; Hull et al., 2003; Berardi et al., 2003; impractical for web service automated composition tasks.
McIlraith and Fadel, 2002; Traverso and Pistore, 2004; Mar- The knowledge level domain must be extracted automatically
tinez and Lesperance, 2004], and thus planning algorithms from the description of the services that are published, e.g.,
must work with incomplete information and with actions with in standard languages, like BPEL4WS [Andrews et al., 2003].
uncertain effects. Moreover, in several application domains, The problem is therefore to devise a proper knowledge level
web services cannot be simply modeled as atomic compo- model, which is suited for the automated composition task,
nents, but as stateful processes whose interactions are intrin- and which can be obtained automatically from the published
sically asynchronous [Fu et al., 2004; Foster et al., 2003; descriptions of the web services.
Pistore et al., 2005].                                  In this paper we propose a novel approach to the problem                              info_request(Item)      Shipper start with a request for transporting a product of
                                info(Size)
                               request(Item)          a given size to a given location. This might not be possi-
                              offer(Cost,Delay) Producer
                       Purchase                       ble, in which case the requester is notiï¬ed, and the protocol
           request(Item,Loc) &  not_avail
           offer(Cost,Delay) Ship ack/nack            terminates with failure. Otherwise, a cost and delivery time
     User    not_avail                                are computed and sent back to the requester. Then the Ship-
             ack/nack   (P&S) request(Size,Loc)
                              offer(Cost,Delay)       per waits for either an acceptance or a refusal of the offer
                                not_avail Shipper     from the invoker. In the former case, a delivery contract has
                                ack/nack              been deï¬ned and the protocol terminates with success, while
                                                      it terminates with failure in the latter case. Similar proto-
        Figure 1: The Purchase & Ship example.        cols are deï¬ned also for Producer and User. The messages
                                                      exchanged among the involved services are described in Fig-
                                                      ure 1.
of automated composition that is based on planning at the
                                                        The P&S has the goal to sell home-delivered furniture (i.e.,
knowledge level. We achieve this in the following steps:
                                                      to reach the situation where the user has conï¬rmed an or-
  Â  We formally deï¬ne a knowledge level model of web ser- der and the service has conï¬rmed the corresponding sub-
    vices that can be obtained automatically from speciï¬- orders to producer and shipper), interacting with Shipper,
    cations in standard languages for modeling and imple- Producer, and User according to their protocols. A typical
    menting services. We show indeed how BPEL4WS pro- interaction could be as follows:
    cesses can be automatically translated into their knowl-
                                                        1. the User asks P&S for an article Â¡ , that he wants to be
    edge level models.                                    transported at location Â¢ ;
  Â  We show how the automated composition problem can
    be described as a planning problem: from the knowledge 2. P&S asks the Producer for the size, the cost, and how
    level models of the available services and from the com- much time does it take to produce the article Â¡ ;
    position goal, we generate a planning problem such that 3. P&S asks the Shipper for the price and time needed to


    a solution plan encodes the desired composition.      transport an object of such a size to Â¢ ;
  Â 
    We apply the planning techniques described in [Pistore 4. P&S sends the User an offer which takes into account
    et al., 2005] to the knowledge level planning problem the overall cost (plus an added cost for P&S) and time
    that we obtain from the previous steps. The key advan- to achieve its goal;
    tage w.r.t. [Pistore et al., 2005] is that we do not have
    to deal with all the possible values of variables that are 5. the User sends a conï¬rmation of the order, which is dis-
    exchanged among services.                             patched by P&S to Shipper and Producer.
  Â  We implement the proposed framework, and provide a This is however only the normal case, and other interactions
    preliminary experimental evaluation that clearly shows should be considered, e.g., for the cases the producer and/or
    the beneï¬ts of our approach.                      delivery services are not able to satisfy the request, or the
                                                      user refuses the ï¬nal offer.
The paper is structured as follows. We ï¬rst describe a sim-
ple example of composition of BPEL4WS processes, which  With automated composition of web services we mean
we will use all along the paper (Section 2). We then brieï¬‚y the generation of a new composite service (the P&S in our
recall the framework for planning in asynchronous domains case) that interacts with a set of existing component services
that has been ï¬rst introduced in [Pistore et al., 2005] (Section (Shipper, Producer, and User in our case) in order to satisfy
3). In Section 4, we describe the knowledge level represen- a given composition goal (sell home-delivered furniture).
tation of web services, and the resulting planning framework We assume that the interaction protocols of the component
at the knowledge level. We ï¬nally describe the experimental services, as well as the composite service, are described as
evaluation (Section 5), some conclusions, and related work. BPEL4WS processes (see Figure 2 for a graphical representa-
                                                      tion of the Shipper BPEL4WS process). Notice that while ex-
2  Composition    of BPEL  processes                  isting services are described as abstract BPEL4WS processes
                                                      (providing essentially the communication protocol), the syn-
Our reference example is the Purchase and Ship (P&S here-
                                                      thesized service is an executable BPEL4WS process exporting
after) example introduced in [Pistore et al., 2005; Traverso
                                                      all the details to be directly deployed and run. A BPEL4WS
              ]
and Pistore, 2004 .                                   description speciï¬es the types and internal variables of a ser-
Example 1 The P&S  example consists in providing a furni- vice, and its input and output capabilities. The behavior
ture purchase & ship service by combining two independent of the process is described using input (receive) and out-
existing services, a furniture producer Producer and a de- put (invoke, reply) activities combined by standard con-
livery service Shipper. This way, the User, also described structs, such as sequences, loops, parallel executions, condi-
as a service, may directly ask the composite service P&S to tional choices, and nondeterministic choices.
purchase a given item and deliver it at a given place (for sim- From a BPEL4WS process, we can automatically extract
plicity, we assume that the shipment origin is ï¬xed and leave a formal model of the interactions with the service, cover-
it implicit).                                         ing both the static aspects (e.g., its communication chan-
  The interactions with the existing services have to follow nels) and the behavioral aspects (deï¬ned in term of transi-
speciï¬c protocols. For instance, the interactions with the tion steps). For the moment, the translation is restricted to a                                                      PROCESS Shipper;
                                                      TYPE
                                                        Size; Location; Cost; Delay;
                                                      INPUT
                                                        request(Size, Location); ack(); nack();
                                                      OUTPUT
                                                        offer(Delay, Cost); not avail();
                                                      FUNC
                                                        costOf(Size, Location) : Cost; delayOf(Size, Location) : Delay;
                                                      VARIABLE


                                                        pc: Â  START, getRequest, checkAvailable, end checkAvailable, sequence1, sequence2,
                                                         prepareOffer, sendOffer, waitAnswer, endWaitAnswer, empty1, prepareNotAvail,


                                                         sendNotAvail, SUCC, FAIL Â¡ ;
                                                        customer size: Size; customer loc: Location;
                                                        offer delay: Delay; offer cost: Cost;
                                                      INIT
                                                        pc := START;
                                                      TRANS


                                                        pc = START -[TAU]- Â¢ pc := getRequest;


                                                        pc = getRequest -[INPUT request(customer size, customer loc)]- Â¢ pc := checkAvailable,


                                                        pc = checkAvailable -[TAU]- Â¢ pc := sequence1;


                                                        pc = checkAvailable -[TAU]- Â¢ pc := sequence2;


                                                        pc = sequence1 -[TAU]- Â¢ pc := prepareOffer;


                                                        pc = prepareOffer -[TAU]- Â¢ pc := sendOffer,
                                                                       offer cost:=costOf(customer size,customer loc),
                                                                       offer delay:=delayOf(customer size,customer loc);


                                                        pc = sendOffer -[OUTPUT offer(offer cost, offer delay)]- Â¢ pc := waitAnswer;


                                                        pc = waitAnswer -[INPUT nack]- Â¢ pc := FAIL;


                                                        pc = waitAnswer -[INPUT ack]- Â¢ pc := empty1;


                                                        pc = empty1 -[TAU]- Â¢ pc := endWaitAnswer;


                                                        pc = endWaitAnswer -[TAU]- Â¢ pc := endCheckAvailable;


                                                        pc = endCheckAvailable -[TAU]- Â¢ pc := SUCC;


                                                        pc = sequence2 -[TAU]- Â¢ pc := prepareNotAvail;


                                                        pc = prepareNotAvail -[TAU]- Â¢ pc := sendNotAvail;


                                                        pc = sendNotAvail -[OUTPUT not avail]- Â¢ pc :=FAIL;
       Figure 2: The Shipper BPEL4WS process.
                                                              Figure 3: A formal model of the Shipper.
subset of BPEL4WS processes: we support all BPEL4WS ba-
sic and structured activities, like invoke, reply, receive,
sequence, switch,  while, flow  (without links) and   3   A Planning  Framework     for Service
pick; moreover we support assignments  and a limited      Composition
form of correlation.   Our next steps will be dealing The work in [Pistore et al., 2005] presents a formal frame-
with scopes and with fault, event and compensation    work for the automated composition of web services which
handlers.                                             is based on planning techniques: component services deï¬ne
  For  lack of  space  we  omit  the formal  deï¬ni-   the planning domain, composition requirements are formal-
tion of  this translation (details can be found  at   ized as a planning goal, and planning algorithms are used to
http://astroproject.org/)       but we  illustrate it generate the composite service. Due to the nature of web
in the case of the Shipper process.                   services, the resulting planning domain is nondeterministic
Example 2 Figure 3 shows a formal model of the Shipper, and partially observable. The framework of [Pistore et al.,
automatically extracted from the BPEL4WS process of Fig- 2005] differs from other planning frameworks since it as-
ure 2. The Shipper process is characterized by a set of ab- sumes an asynchronous, message-based interaction between
stract types used in the interactions (e.g., Size, Cost), by a the domain (encoding the component services) and the plan
set of inputs and outputs (e.g., request and offer, respec- (encoding the composite service). More precisely, the plan-
tively), and by a set of typed functions used to manipulate ning domain is modeled as a state transition system (STS
internal variables (e.g., function costOf, which is used to from now on) that can be in one of its possible states (a subset
obtain the cost of a particular shipping request). Variables of which are initial) and can evolve to new states as a result
are used to store information on the state of the process. In of performing some actions. In particular, input actions rep-
Figure 3, variables of abstract types (e.g., customer size) resent messages sent to the component services, while output
store values used in the communications, while an additional actions are messages received from the component services.
variable pc implements a â€œprogram counterâ€ that holds the Private actions are actions that the composite service can per-
current execution step of the service. The model describes form internally, without interacting with the component ser-
                                                          1
the evolution of the process through a set of possible transi- vices , while the special action Â£ is used to model internal
tions, each corresponding to a â€œstepâ€ in the BPEL4WS pro- evolutions of the component services which are not visible
cess; each transition deï¬nes an applicability condition, a ï¬r- to the service user. Finally, a labeling function associates to

ing action, and an effect (deï¬ned as a list of assignment to each state the set of properties Â¤Â¦Â¥Â¨Â§
Â© holding in that state.

variables). Possible actions are inputs, outputs, and a spe- 1
cial action TAU which is used to model internal evolutions of As we will see, private actions are used to model operations
the process, such as assignments and decision making (e.g., such as computing the total cost for the user from the costs received
                                                      from the producer and from the shipper. Private actions are speciï¬c
                      prepareOffer
the transition from state          , where the inter- of the knowledge-level approach presented here and for this reason
nal functions costOf and delayOf are used to compute the they do not appear in [Pistore et al., 2005]. The extension of the
shipping price and delivery time).                    theory of [Pistore et al., 2005] to private actions is straightforward.

                                                        Â 


                                                            Â¡E+:AÂ¤ Â¡RÂ¤LECN  %: Â¡      Â¡?EVÂ¤ Â¡RÂ¤LECNO 


                                                                     H           H                H



Deï¬nition 1 (state transition system (STS))               if       :       with      then             for


                     Â           Â¡Â£Â¢Â¥Â¤Â¦Â¢Â¨Â§Â©Â¤
Â¤Â¤Â¤Â¦Â¤Â¦ ECN Â¢
A state transition system is a tuple                      some   H   .
where:


                                                        In [Pistore et al., 2005], the composition problem for do-


  Â 


    Â¢
                                                                                X


      is the ï¬nite set of states;                     main Â  and composition goal is deï¬ned as the problem of


  Â 


                                                                              Â            Â    Â         X


                                                                                :          :YI

    Â¢Â§Â¢ is the set of initial states;             ï¬nding a deadlock-free STS such that      satisï¬es .


  Â                                                    Planning techniques, based on the planning as model check-


    
 is the ï¬nite set of input actions;              ing framework, are used to solve this problem, and the exper-
  Â 

     is the ï¬nite set of output actions;             imental results show the effectiveness of this approach.

  Â                                                      However, the approach of [Pistore et al., 2005] requires a
     is the ï¬nite set of private actions;


                                                      ï¬nite set of data values for all data types (e.g., only a ï¬nite


  Â 


                       Â£)(+*,$Â¢


    Â¢ !
#"Â¥"$%"'&   is the transition relation; number of articles, locations, costs. . . can be deï¬ned in the
  Â 

    .-/Â¢1032/465798 is the labeling function.       P&S  domain). This assumption guarantees that the formal
                                                      model of a BPEL4WS process such as the one in Figure 3 can
  In a composition problem, the composite service is deï¬ned
                                                      be mapped into a ï¬nite-state STS. Moreover, the number of

as a â€œcontrollerâ€ Â $: (also described as a STS), which interacts
                                                      data values impact dramatically on the size of the generated

with the domain Â  , orchestrating the component services by
                                                      STS, and very small sets of values need to be used to allow
invoking their operations and handling results. We now re-
                                                      for an effective plan generation: for instance, all experiments

call the formal deï¬nition of the behavior of a STS Â  when
                                                      in [Pistore et al., 2005] assume only two values for each data

controlled by Â $: .
                                                      type. In the following we show how to adapt the framework of


Deï¬nition 2 (controlled system)                       [Pistore et al., 2005] to a knowledge-level planning approach


            ;    Â¡<Â¢Â¥Â¤=Â¢Â¨Â§>Â¤?
$Â¤Â¤Â¤Â¦Â¤Â¦@ Â @: ;


Let    Â                               and             in order to remove this restriction and allow for automated


Â¡Â£Â¢6:AÂ¤Â¦Â¢Â§ Â¤BÂ¤?
$Â¤Â¤=%:CÂ¤Â¦DC


     :                 be  two state transition sys-  composition with a realistic (or even inï¬nite) number of data


           DÂ© E *F;G   E    Â¢           Â    Â 


                            :%H   :          :I


tems, where    :     for all      . The STS       ,   values.


                             Â                   Â 
describing the behaviors of system when controlled by : ,


is deï¬ned as:                                         4   Service Composition   via Knowledge-Level


  Â @: Â 1;JÂ¡<Â¢6:%Â¢Â¥Â¤=Â¢Â¨Â§ KÂ¢Â¨Â§>Â¤?
$Â¤Â¤Â¤Â¦%: Â¤


     I                               I
                    :
where:                                                    Planning



  Â                                                    The key aspect for extending the approach of [Pistore et al.,


    Â¡ E Â¤LE+*BÂ¤ Â£MÂ¤A ?EAN Â¤EC*  Â£ %* Â¡E Â¤ Â£MÂ¤EAN  


       :            H   :6I       :      H  :
                                      :
               :              if             ;


                                                          ]


  Â                                                    2005 to the knowledge level is the deï¬nition of an appropri-


    Â¡ E+:AÂ¤LE+*BÂ¤ Â£MÂ¤A ?EC:AÂ¤EANO*Â¦  <%: %* Â¡?E>Â¤ Â£MÂ¤EANO 


                          I             H


                    H          if           ;         ate model for providing a knowledge level description of the


  Â 


    Â¡ E+:AÂ¤LE+*BÂ¤ Â¡PÂ¤C ECN Â¤LECNO*Â¦  Â£%: %* Â¡Q ; Â£


                    H     I


               :              , with    , if          component services. In this section we formally deï¬ne such


    Â¡?E Â¤ Â¡PÂ¤ECN   Â¡E>Â¤ Â¡RÂ¤ECNO 


      :      H  :            H


           :      and            .                    a model in terms of a suitable knowledge base (from now on
                                                      ZU[
  Due to the asynchronous nature of web service interac-  ). Then we show how to construct the STS corresponding
tions, and in order to guarantee a correct execution of the to the planning domain by composing the knowledge bases of
composite service, we need to rule out explicitly the cases the component services.
where the sender is ready to send a message that the receiver Deï¬nition 4 (Knowledge Base)


is not able to accept. According to [Pistore et al., 2005], a A knowledge base Z\[ is a set of propositions of the following
                             Â¡


state E is able to accept a message if there exists some suc- form:


                                                          Z%]


       N


      E   E               E


cessor  of , reachable from through a (possibly empty)  Â 
                                                                      ^
                                                               <^)* where is a variable with an abstract type;



sequence of Â£ transitions, such that an input transition labeled


                                                          Z


                                                        Â 


                                                             <^;`_Â©*
                        E+N


with Â¡ can be performed in . This intuition is captured in          where x is an enumerative variable and v is
                                              E+*


the following deï¬nition, where we denote by Â£ -closure the one of its possible values;


                                                          Z


                                                        Â 
                                        Â£
set of states reachable from E through a chain of transitions.
                                                             <^%;bac* where x and y are two variables with the same
For what concerns private actions, since they correspond to type;




internal operations of the composite service, we simply as- Z


                                                        Â 
                                                                                     ^6Â¤Â¦aÂ©f+Â¤hgAghgjÂ¤aVi
                                                             <^;edYWaTf+Â¤AghgAghÂ¤Â¦a>iÂ©** where are vari-
sume that they are executable in the current state of Â  .

                                                          ables with an abstract type and d is a function compati-


Deï¬nition 3 (deadlock-free controller)


                                                                               f     i
                                                                                Â¤hghgAghÂ¤a


                                                          ble with the types of ^6Â¤Â¦a .


    Â   ;SÂ¡<Â¢Â¥Â¤=Â¢Â§TÂ¤
Â¤Â¤Â¤Â¦Â¤Â¦     Â    ;
                                              :


Let                           be a  STS and                Z


                                                             Â©R*                                  Â©


                                                      With      we mean that we know that proposition is true


     Â§


Â¡Â£Â¢6:AÂ¤Â¦Â¢ Â¤BÂ¤?
$Â¤Â¤=%:CÂ¤Â¦DC   Â    Â $:


                                                              Z
                                                                ]


     :                be a controller for .  is said
                                                                                                       ^


                                                      and with     W^R* that we know the value of the variable .


                    Â             E/:AÂ¤EC* Â¢6:'UÂ¢
to be deadlock free for if all states H        that


                                                      This deï¬nition of knowledge base is very simple; still, our


                                Â :  Â 
are reachable from the initial states of I satisfy the fol-
lowing conditions:                                    experiments show that it is powerful enough to model web


                                                      service composition problems.


  Â 


                                                                                  ZU[


      Â¡?EVÂ¤ Â¡RÂ¤LECNÂ£  Â¡                    ECN


              H          H                       H


    if             with       then there is some :      We  say that a knowledge base is consistent if it does


                          N    N N             N N




    Â£
             E+:*     Â¡?E Â¤ Â¡RÂ¤LE  %:     E


                                 H               H


                               :               :


     -closure   such that :           for some        not contain contradictory knowledge propositions such as


                                                      Z            Z                               ZU[



    Â¢6: ;


                                                                      <^\;k_Â©NO*  _lQ ;m_Â©N


                                                         W^\;k_c* and       , with      . We say that  is


  Â 


      Â¡E+:AÂ¤ Â¡RÂ¤LECN  %: Â¡ 
                E+N


               H           H                     H


    if      :       with       then there is some     closed under deduction if it contains all the propositions that


                                                                                         ZU[




    Â£
             E+*      Â¡E+NWÂ¤ Â¡PÂ¤ECN NO  E+N N Â¢
                                              H
     -closure  such that        H   for some      .   can be deduced from the propositions in ; for instance a

ZU[               Z]       Z


                                                        Â 


                               <^.; ac*


    containing both   W^R* and        should contain      we   restrict KB  with  the  knowledge  K(pc  =
    Z%]


also    <aM* .                                            getRequest)   associated to the transition condi-
  The knowledge base Z\[ of a component service is ob-    tion; in this speciï¬c case KB remains unchanged;

tained from the variables, functions and types of the service. Â  then we update KB with the knowledge carried by the
Example 3 An example of knowledge base for the Shipper    input action on the variables used as action parame-
process in Figure 3 is:                                   ters; this consists in removing from KB all the knowl-




    Â¡                                                     edge we had on customer size and customer  loc,


                      Â£             Â¢ Â£            Â¢
 KB= K(pc = waitAnswer) Â¢ K (customer size) K (customer loc) adding the new knowledge K(customer size = s),
   K(offer cost = costOf(customer size, customer loc)) Â¢  K(customer  loc  = l) and closing under deduction;



   K(offer delay = delayOf(customer size, customer loc)) Â¢ we obtain:


    Â£             Â£           Â¤Â¦Â¥



   K (offer cost), K (offer delay)                                  Â¡
                                                                                        Â£


                                                              KBâ€™ =  K(pc = getRequest), K (s) Â¢


                                                                     Â¢ Â£             Â¢  Â£            Â¢


In the following we describe when a transition can be exe-      K Â£ (l) K (customer size) K (customer loc)


                      ZU[
                                                                                                    Â¤
cuted in a knowledge base and how its execution affects         K(customer size = s) Â¢ K(customer loc = l) ;
ZU[ .
                                                        Â  ï¬nally we update the knowledge base with the effects,
  We model a transition Â§ , such as those presented in Fig-


                                                          removing from KBâ€™ all the knowledge we had on the


               Â©Â¨#Â¤ Â¡RÂ¤
F*  Â¨  ;3 Cf ghgAgjiP*
ure 3, as a triple     where                    are


                                                          variables modiï¬ed by the assignments, adding the new


                                
  ;  >fhgAghg+iM*
its conditions, Â¡ is its ï¬ring action and       are       knowledge (in this case K(pc := checkAvailable))
its effects. We start by deï¬ning the auxiliary restriction and and closing under deduction; we obtain:




update operations.                                                  Â¡


                                 ZU[
                                                                                                Â¢


  The restriction of a knowledge base with a condition        KBâ€™â€™ =  K(pc = checkAvailable), K Â£ (s)


                      Z\[


                                                                     Â¢ Â£             Â¢  Â£            Â¢


                                                                K Â£ (l) K (customer size) K (customer loc)


               Â¥+EÂ§ Â¥Â§j Â¤Â¨ *


Â¨ , denoted with             , is performed adding to


ZU[
                                                                                                    Â¤
                                                                K(customer size = s) Â¢ K(customer loc = l) .
    the knowledge obtained from Â¨ and closing under de-
duction; for instance:


                    Â¡                                 Deï¬nition 5 (KL Applicability and Execution)




            restrict( K(x = y) Â¤ , y = z) =


                                                                 Â§; Â©Â¨#Â¤ Â¡RÂ¤
F*                 Â¡,:



             Â¡                                        A transition         and a corresponding action are


                                                                 ZU[                    Z\[



              K(x = y), K(y = z), K(x = z) Â¤Â¦Â¥


                                                                             "!#$#&%(')"$*+%-,/. Â§109 Â¤ Â¡ *


                                                      applicable in  , written                : if:


                            Z\[
                                                        Â 


The update of a knowledge base  with an effect 
 , de-


                                                                 f     i              f     i


                                                          Â¡c:B;2 W^ Â¤hgAghgjÂ¤^ * Â¡c;3B Wa Â¤AghgAgjÂ¤Â¦a * 


                Z\[                                                        and                ,  where


                                                                       Z]         Z%]           ZU[


           Â© Â¡Â§ Â© Â¤!
*


noted with            , consists in performing the fol-




                                                                             f          i
                                            Z\[


                                                                            W^ *BÂ¤hgAghgAÂ¤  <^ *


                                                          is an  input,                      H        and
                                                                  ZU[



lowing steps: for each assignment in 
 , remove from the


                                                          /EÂ§ Â¥4Â§j Â¤!Â¨ *
                                                          Â¥               is consistent; or


knowledge we had on the modiï¬ed variable, add the knowl-


                                         Z\[


                                                        Â 


                                                                 f      i           f     i


                                                          c:B; Â§c <^ Â¤AghghghÂ¤Â¦^ * Â¡c; Â§c Wa Â¤hghgAgjÂ¤Â¦a * Â§


edge derived from the assignment and close the under      Â¡               and               , where  is an


                                                                            ZU[


                                                                    /EÂ§ Â¥4Â§j Â¤!Â¨ *


deduction. For instance:                                  output, and Â¥             is consistent; or


                                                                              Z\[


          Â¡
                                                        Â 




    update( K(x = y) Â¤ , z := x; x := w) =


                                                          c:B; Â¡c; Â£  Â¥/EÂ§ Â¥Â§j Â¤!Â¨ *


                                                          Â¡       and                is consistent.
           Â¡




     update( K(x = y), K(z = x), K(z = y) Â¤ , x := w) =


     Â¡
                                                                      ZU[



      K(z = y), K(x = w) Â¤Â¥


                                                                    Â§10   Â¤ Â¡c:L*


                                                      If  "#$#%5')!"6*Â¦%7,8. , then  we   denote  with


                                                      ZU[          ZU[                      ZU[


                                                          NO;9,!:,!)6. Â§10  Â¤ Â¡ *                  Â§


We now  give the deï¬nitions of applicability and execution              :  the execution on      of   and


                                                      Â¡
                                                       :


which depend on a service transition Â§ and on an action , deï¬ned as follows:


                                                                                    Z\[         ZU[


                                                        Â 
c:


Â¡  performed by a peer interacting with the service; the


                                                            Â©:B; Â£   Â§;  Â©Â¨#Â¤ Â£MÂ¤!
* NO;3 Â©/ Â¡Â§ T N NWÂ¤
*


                                                          if Â¡   and           then                     ,


                                                                ZU[           ZU[


                Â§                   Â¡M:


ï¬ring action Â¡ in and the peer action  correspond to


                                                                    NÂ£; Â¥/EÂ§ Â¥1Â¦Â§j Â¤!Â¨ *
                                                          where    N                 ;


the same action except that the former is instantiated on


                                                        Â 


                                                                     f     i


                                                              c:;3 W^ Â¤hgAghgjÂ¤^ *   


service variables, while the latter on variables of the peer. if Â¡           ,   where       is  an   in-


                                                                            ;  Â©Â¨#Â¤;B<aÂ©f/Â¤hghgAghÂ¤aViM*BÂ¤!
*


                                                          put,      and     Â§                        then
                                                                       ZU[


Consider for instance the following example where action  Z\[


                                                               Â©/ Â¡Â§ Â© N NWÂ¤aTf+- ;Â¥^)f<hghgAg+aViR- ; ^Ri=
*


                                                              NÂ£;                                ,  where
                                                                        ZU[


request(s,  l) performed by the peer corresponds to the   Z\[


                                                              NO; Â¥/EÂ§ Â¥1Â¦Â§j Â¤!Â¨ *


Shipper request(customer size,  customer  loc).               N                ;


                                                        Â 


                                                              Â¡ ; Â§c <^)f Â¤hgAghgjÂ¤^Pi,* Â§


Example 4 Letâ€™s consider the input transition t of the Ship- if :            ,   where       is  an  out-


                                                                                    f      i


                                                                            ;  Â¨#Â¤ Â§c <a Â¤AghgAghÂ¤Â¦a *jÂ¤
*


per                                                       put,      and     Â§                        then


                                                          Z\[          ZU[


                                                                              f   f      i   i


                                                               Â©/ Â¡Â§ Â© N NWÂ¤^ - ; a hghgAg+^ - ; a 
*


     pc = getRequest                                          NÂ£;                                ,  where


                                                          Z\[           ZU[        Z          Z


                                                                                     ]          ]


                                                              NO; Â¥/EÂ§ Â¥1Â¦Â§j Â¤!Â¨ * "U&  <aÂ©fh*jÂ¤hghgAghÂ¤  WaViM*(
      -[INPUT request(customer size, customer loc)]->         N                                       .


     pc := checkAvailable                             Notice that the execution of a transition increases the knowl-
                                                             Z\[
and suppose that our current knowledge base is:       edge in   , not only with the information in the effects, but




           Â¡                                          also with those in the condition. Indeed, if the transition is


                               Â£      Â£
                                          Â¤
       KB =  K(pc = getRequest), K (s) Â¢ K (l) .
                                                      executed, this means that the condition is known to hold.
where s:Size and l:Location  are additional variables.  The planning domain at the knowledge level is constructed
Action request(s, l), corresponding to invoking the Ship- from the knowledge-level models of each component service
per action using s and l as parameters, is applicable in KB and from a knowledge-level representation of the composi-
since we know the values of s and l and the condition of tion goal. The latter deï¬nes which are the variables and the
transition t is obviously consistent with KB.         functions of the composite service, like, for instance, the cost
  The knowledge base obtained by executing on KB transition of the offer to the user, or a special function that adds a mark
t and action request(s, l), is deï¬ned as follows:     up to the sum of the costs of the shipper and producer. We