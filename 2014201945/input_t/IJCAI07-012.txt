     Conditional Constraint Satisfaction: Logical Foundations and Complexity

             Georg Gottlob                 Gianluigi Greco                  Toni Mancini
         Computing Laboratory            Dip. di Matematica       Dip. di Informatica e Sistemistica
           Oxford University           Universit`a della Calabria Universit`a di Roma â€œLa Sapienzaâ€
         OX1 3QD Oxford, UK              I-87030 Rende, Italy            I-00198 Roma, Italy
    georg.gottlob@comlab.ox.ac.uk       ggreco@mat.unical.it          tmancini@dis.uniroma1.it

                    Abstract                            Indeed, CCSPs (proposed with the name of Dynamic CSPs
                                                      in [Mittal and Falkenhainer, 2000]) are CSPs tailored to sup-
    Conditional Constraint Satisfaction Problems (CC- port conditional activation of variables and constraints, which
    SPs) are generalizations of classical CSPs that sup- have been used in model diagnosis, structural design, and
    port conditional activation of variables and con- conï¬guration problems. As an example application, one may
    straints. Despite the interest emerged for CCSPs  think of an automated personal computer (PC) conï¬gurator
    in the context of modelling the intrinsic dynamism devoted to assemble several PC components. Conditional
    of diagnosis, structural design, and product conï¬g- constraints may require other components to be added to the
    uration applications, a complete characterization of current conï¬guration, depending on the choices made for the
    their computational properties and of their expres- others. E.g., if the motherboard does not embed a video-card,
    siveness is still missing. In fact, the aim of the pa- then a compatible one should be added.
    per is precisely to face these open research issues. Despite the interest emerged for the CCSPs framework
    First, CCSPs are formally characterized in terms of and the efforts spent in the design of specialized algo-
    a suitable fragment of ï¬rst-order logic. Second, the rithms for their efï¬cient solution (e.g., [Soininen et al., 1999;
    complexity of some basic reasoning tasks for CC-  Bowen and Bahler, 1991; Sabin et al., 2003; Gelle and Falt-
    SPs is studied, by establishing completeness results ings, 2003; Keppens and Shen, 2004]), many aspects have
    for the ï¬rst and the second level of the polynomial not yet been investigated and several research questions are,
    hierarchy. Finally, motivated by the hardness re- in fact, still open. For instance, both the expressiveness and
    sults, an island of tractability for CCSPs is identi- the complexity issues arising in this setting have only par-
    ï¬ed, by extending structural decomposition meth-  tially been studied in the literature [Soininen et al., 1999;
    ods originally proposed for CSPs.                 Bowen and Bahler, 1991; Mittal and Falkenhainer, 2000].
                                                      And, more importantly, differently from the case of classical
1  Introduction                                       CSPs where several classes of instances that are efï¬ciently
                                                      solvable have been singled out (e.g., [Pearson and Jeavons,
Constraint satisfaction is a static framework in its original 1997; Gottlob et al., 2000]), no island of tractability is known
formulation that cannot be used to model and solve deci- for CCSPs, whose identiï¬cation is instead crucial for appli-
sion problems in scenarios where uncertainty and dynamism cations in real world scenarios.
come into play. Indeed, a Constraint Satisfaction Problem The aim of this paper is precisely to shed lights on these
(CSP) instance (e.g., [Dechter, 2003]) is basically a triple
(Var   C)       Var                                   aspects and to face the above research questions. To make
    ,U,  ,where     is a ï¬nite set of variables, U is a ï¬- our analysis formal, we shall exploit the logic-based charac-
                       C = {             }
nite domain of values, and  C1,C2,...,Cq   is a ï¬nite                             [                    ]
                                    (    )            terization of a CSP instance (cf. Kolaitis and Vardi, 1998 )
set of constraints, where each Ci is a pair Si,ri ,inwhich as a pair (Ï†, D),whereD is the constraint database, i.e.,
   âŠ† Var                                 âŠ†    |Si|
Si       is called the constraint scope,andri U  is   the set of all the constraint relations ri, for each constraint
called the constraint relation. Then, by solving a CSP in- Ci =(Si,ri),andÏ† is a âˆƒFOâˆ§,+ sentence, i.e., an ex-
stance, we simply mean determining whether there is a sub- istentially quantiï¬ed ï¬rst-order formula with no negations
stitution Î¸ : Var â†’ U that satisï¬es all constraints. or disjunctions, over the relational vocabulary consisting of
  To remove the assumption that all the variables, the do- the atoms ri(Si). Within this framework, we investigate the
mains of values, and the constraints are known beforehand class of those constraint satisfaction problems build over the
and do not change over time, several generalized CSP frame- âˆƒFOâ†’,âˆ§,+ fragment of the ï¬rst-order logic, which consists
works have been already proposed in the literature (see, e.g., of all the formulas obtained extending âˆƒFOâˆ§,+ with the im-
[Verfaillie and Jussien, 2005] and the references therein). In plication connective â€œâ†’â€. The rationale of this approach is
this paper, we focus on the core of these extensions, by con- that enhancing âˆƒFOâˆ§,+ with the implication connective is a
sidering the framework for Conditional Constraint Satisfac- mathematically well-founded approach to model conditional
tion Problems (CCSPs).                                activation of variables, as for it is next exempliï¬ed.


                                                IJCAI-07
                                                   88Example 1. Consider again the PC conï¬guration scenario. -IfÏ†(X ) and Ïˆ(Z) are in FOâ†’,âˆ§,+,thenÏ†(X ) âˆ§ Ïˆ(Z) is
Then, the âˆƒFOâ†’,âˆ§,+ formula:                             in FOâ†’,âˆ§,+;
                                                            (  )               (   )
 âˆƒM  motherboard(M) âˆ§ (hasNoVideo(M)  â†’               -IfÏ†  X   is in FOâˆ§,+ and Ïˆ X,Y  is in FOâ†’,âˆ§,+,then
                       âˆƒV,C  ï¬t(M,V ) âˆ§ cost (V,C))     Ï†(X ) â†’âˆƒYÏˆ (X, Y ) is in FOâ†’,âˆ§,+.
states, intuitively, that a motherboard M is needed to assem- The set of all the variables in Ïˆ is denoted by V(Ïˆ).
ble a PC; moreover, if M has no embedded video, then a Example 2. The following formula Ïˆ0 âˆˆâˆƒFOâ†’,âˆ§,+ adds
video-card V ï¬tting the requirements of M has to be chosen some further requirements to the conï¬guration constraints in
(and, C is the additional cost).                     Example 1 (names have been shortened, for simplicity):
                    âˆƒ
  In fact, we show that FOâ†’,âˆ§,+ formulas characterize (in âˆƒMm(M)    âˆ§ (h(M) â†’âˆƒV,C f(M,V    ) âˆ§ c(V,C))
a precise, logical sense) the class of CCSPs. Based on this          âˆ§ (e(M) â†’  (b(M) â†’âˆƒHg(M,H)))
result, we then embark on a systematic study of âˆƒFOâ†’,âˆ§,+.
In summary:                                           Here, we have V(Ïˆ0)={M,V,C,H}.                    
                                                                                D       âˆƒ
Â£ We investigate the expressive power of CCSPs by depict- Given a constraint database and an FOâ†’,âˆ§,+ formula
                                                                     (  D)
 ing, in Section 3, a clear picture of its relationships with Ïˆ, we denote by Ïˆ, the constraint satisfaction problem
 other logic-based CSP formalisms. The results of this com- instance of deciding an assignment for variables in Ïˆ that sat-
                                                                              D
 parison are graphically summarized in Figure 1.      isï¬es all the constraints over .
Â£                                                       Note that because of the presence of the implication con-
  In Section 4, we study the computational complexity of nective, differently from the standard CSPs, a formula Ïˆ âˆˆ
 some basic reasoning tasks for CCSPs. We considered both
                                                      âˆƒFOâ†’,âˆ§,+  can be satisï¬ed by partial assignments over V(Ïˆ).
 the case where one is interested in ï¬nding a generic solu- Formally, a partial assignment Î¸ for (Ïˆ, D) is a mapping from
 tion and the case where solutions are reï¬ned by means of a subset of V(Ïˆ) to values in D. Then, the Î¸-reduct of Ïˆ is
 some pro-orders. From our analysis, summarized in Fig- the formula Î¸(Ïˆ) resulting from Ïˆ by (1) applying all the sub-
 ure 2, it emerges that reasoning with CCSPs is intractable, stitutions in Î¸ to the variables in Ïˆ, and (2) by replacing all
 with hardness and membership results being established for the atoms in which a variable in V(Ïˆ) \V(Î¸) occurs with
 various classes at the ï¬rst and the second level of the poly- â€œfalseâ€, where V(Î¸) denotes the variables in the domain of Î¸.
 nomial hierarchy.                                    A solution for (Ïˆ, D) is a partial assignment Î¸ such that Î¸(Ïˆ)
Â£ Motivated by the above complexity results, in Section 5, evaluates to true over D, denoted by D|= Î¸(Ïˆ).
 we turn to identify tractable classes of âˆƒFOâ†’,âˆ§,+ formulas,
                                                      Example 3. Consider the database D0 containing the rela-
 by issuing restrictions on the constraints interactions. As
                                                      tions: m = {(m1), (m2)}, h = {(m2)}, f = {(m2,v2)},
 a bad news, we show that decomposition methods for tra-
                                                      c =  {(v2,c4), (v1,c3)}, e = {(m1)}, b = {(m1)} and
 ditional CSPs do not guarantee the tractability of CCSPs.
                                                      g = {(m1,h4)}. Then, the followings assignments are par-
 Indeed, the NP-hardness of the SATISFIABILITY problem
                                                      tial:         Î¸1 = {M/m2,V/v2,C/c3}
 also holds for the class of CCSPs whose constraints inter-           = {            }
 actions can be modelled with an acyclic primal graph (see,         Î¸2   M/m1,H/h4
 e.g., [Dechter, 2003]).                                Note that Î¸1 is not a solution for (Ïˆ0, D0). On the other
                                                      hand, the Î¸2-reduct of Ïˆ0 evaluates true over D0. 
Â£ The major reason for the failure of traditional decompo-
 sition methods is that the primal graph obscures the real                   âˆƒFO
 nature of the interactions occurring in CCSPs due to the 3 Expressiveness of     â†’,âˆ§,+ Formulas
 variables activation. Hence, in Section 5.2, we introduce The ï¬rst crucial questions for CCSPs are how they relate with
 a special graphical representation for CCSPs, called impli- other approaches to deal with conditional activation of vari-
 cation graph,andshowthatSATISFIABILITY   is feasible ables and constraints, and whether they are more expressive
 in LOGCFL and hence in polynomial time, over instances (in a precise logical sense) than classical CSPs. Both the
 whose implications graphs are acyclic or have, more gener- questions are answered in this section.
 ally, bounded treewidth [Robertson and Seymour, 1986]. Let F be a CSP formalism, i.e., a formalism for modelling
                                                      constraint satisfaction problems (e.g., a subset of FO), and let
                                                      D                                    âˆˆ      S(  D)
2  âˆƒFOâ†’,âˆ§,+    Formulas: Syntax and Semantics           be a constraint database. For a formula Ï† F ,let Ï†,
                                                      denote the set of all the solutions, and for a set of variables
In this section, we propose a framework for modelling condi-
                                                      V,letS(Ï†, D)[V] denote the set obtained from S(Ï†, D) by re-
tional activation of variables and constraints in CSPs, which stricting each solution over the variables in V.
is based on an extension of the fragment âˆƒFOâˆ§,+ with the
                                                        Let F1 and F2 be two CSP formalisms.  We say that
logical implication, as formalized next.
                                                      F1 weakly simulates F2 if for each Ï†2 âˆˆ F2 there exists
  An âˆƒFOâ†’,âˆ§,+  sentence (over a vocabulary R of constraint
                                                      Ï†1 âˆˆ F1 such that for each constraint database D, S(Ï†2, D)=
relations) is a formula âˆƒ  (  ),where (  ) belongs to the S( D)
                    XÏ†X          Ï†  X                   Ï†1,   [V(Ï†2)]. We say that F1 is more expressive than F2 iff
fragment FOâ†’,âˆ§,+ of ï¬rst-order logic, deï¬ned as follows: F1 simulates F2 but F2 does not simulate F1.IfF1 simulates
- â€œtrueâ€ and â€œfalseâ€ are in FOâ†’,âˆ§,+;                  F2 and viceversa, F1 and F2 are equivalent.IfF1 does not
                                                               2      2                1            1
- Any atom of the form r(X ) (r âˆˆR)isinFOâ†’,âˆ§,+;      simulate F ,andF does not simulate F , we say that F and
                                                      F2 are incomparable.


                                                IJCAI-07
                                                   89                                                        It is possible to show (details omitted for lack of space)
                                                      that, for every constraint c of Ï€, a legal assignment Î¸ satisï¬es
                                                      c iff the corresponding partial assignment Î¸ of ÏˆÏ€ satisï¬es the
                                                      subformula Ï†c. Hence, âˆ€D,itis:S(Ï€, D)=S(ÏˆÏ€, D).

                                âˆƒ                       Not surprisingly, CCSPs have been previously simulated
        Figure 1: Expressiveness of FOâ†’,âˆ§,+.          by means of different logic-based frameworks. For instance,
                                                      [                      ]
  Armed with the notions above, we compared the expres- Bowen and Bahler, 1991 expressed CCSPs by means of
                                                      the FOF logic; and, [Bacchus and Walsh, 2005] discussed a
siveness of âˆƒFOâ†’,âˆ§,+ with conditional CSPs (CCSP)s, with
                                                      rich formalism where implications can be simulated by nega-
âˆƒFOâˆ§,+  and with the positive existential disjunctive frag-
                                                      tions and disjunctions, by introducing a speciï¬c propagation
ment âˆƒFOâˆ¨,âˆ§,+ of FO. Results are summarized in Figure 1.
                                                      method and characterizing when this method enforces gener-
3.1  Comparison with Conditional CSPs                 alized arc-consistency. Yet, the precise logical characteriza-
                                                      tion of CCSPs was unknown, which is made clear below.
A CCSP speciï¬cation Ï€  is a tuple Var , Var I , CC, CA ,
where Var is a set of variables, Var I âŠ† Var is a set of Theorem 2. CCSP simulates âˆƒFOâ†’,âˆ§,+.
initial variables (intuitively, of the variables that are initially            âˆƒ
â€œactiveâ€), and where the set of constraints is partitioned into Proof (Sketch). Let Ïˆ be an FOâ†’,âˆ§,+ formula. We build
                                                      a CCSP  Ï€Ïˆ as follows. First, all the atoms are converted
compatibility (CC)andactivity (CA) constraints.
                                                      into compatibility constraints. Then, for each subformula
  Compatibility constraints are constraint atoms (as in tra-                  
ditional CSPs), while activity constraints are of the follow- Ï† (X ) â†’âˆƒYÏ† (X, Y ) where Ï† = c1(X )âˆ§Â·Â·Â·âˆ§ck(X ),and
                                          RV                                                            j
ing kinds: require variable (RV): c(V1,...,Vk)â†’ V ; al- where Y = {Y1,...Ym}, we create m Ã— k fresh variables Yi
ways require variable (ARV): {V1,...,Vk}ARVâ†’ V ; require (1 â‰¤ i â‰¤ m, 1 â‰¤ j â‰¤ k), m Ã— k activation constraints of the
                                                                   j
          (         )â†’RN                                        RV           RV  j
not (RN): c V1,...,Vk  V ; always require not (ARN):  form cj(X )â†’Y1 ,...cj(X )â†’Ym (1 â‰¤ j â‰¤ k), and m ARV
           ARN
{         } â†’       {            }âŠ†Var                                       1      k ARV
 V1,...,Vk    V , with V1,...,Vk,V      .             constraints of the form {Y ,...,Y } â†’ Yi. It can be shown
                          (  D)                                             i      i
  A CCSP instance is a pair Ï€, ,whereÏ€  is a speciï¬-  that for each database D, S(Ïˆ, D)=S(Ï€Ïˆ, D)[V(Ïˆ)].
         D
cation and is a constraint database. A legal assignment for Interestingly, if Ïˆ is such that the left-hand side of any im-
(  D)                                 Var
 Ï€,   is a partial mapping Î¸ from variables in to domain plicative formula is a constraint atom only, the encoding can
        D
values in .Asolution is a legal assignment such that: (1) be adjusted not to use fresh variables. Hence, we can show a
Var  âŠ†V(   )
   I      Î¸ ; (2) Î¸ satisï¬es every active compatibility con- stronger kind of simulation: âˆ€D, S(Ïˆ, D)=S(Ï€Ïˆ, D).
straints, i.e., those compatibility constraints whose variables
are in V(Î¸);and(3) Î¸ satisï¬es every activity constraint: Corollary 1. CCSP and âˆƒFOâ†’,âˆ§,+ are equivalent.
  â€¢WARVâ†’ V is satisï¬ed if WâŠ†V(Î¸) implies V âˆˆV(Î¸);       Before leaving the section, note that in [Mittal and Falken-
                RV                                    hainer, 2000] solutions to CCSPs are also required to be
  â€¢ c(V1,...,Vk)â†’V  is satisï¬ed if {V1,...,Vk}âŠ†V(Î¸)
                                                      subset-minimal. In fact, the simulation techniques of The-
    and (Î¸(V1),...Î¸(Vk)) âˆˆ c (in D) implies V âˆˆV(Î¸);
                                                      orem 1 and 2 (in the case left sides of implications are con-
  â€¢WARN               WâŠ†V(    )         
âˆˆV( )
      â†’ V  is satisï¬ed if    Î¸ implies V    Î¸ ;       straint atoms) established a one-to-one correspondence be-
                RN
  â€¢ c(V1,...,Vk)â†’V  is satisï¬ed if {V1,...,Vk}âŠ†V(Î¸)   tween solutions of CCSPs and assignments for âˆƒFOâ†’,âˆ§,+
    and (Î¸(V1),...Î¸(Vk)) âˆˆ c (in D) implies V 
âˆˆV(Î¸); formulas. Hence, further properties on the solutions are pre-
As usual, the set of all the solutions is denoted by S(Ï€, D). served as well, but formal results are omitted.
                  âˆƒ
  We next show that FOâ†’,âˆ§,+ formulas are, in fact, an el- 3.2 Comparison with Other Logics for CSPs
egant, mathematically-founded characterization of CCSPs.
                                                      A comparison between CSPs and CCSPs has been proposed
Theorem 1. âˆƒFOâ†’,âˆ§,+  simulates CCSP.                  in [Soininen et al., 1999], by focusing on a knowledge repre-
                     Var Var   C  C                  sentation perspective. Indeed, it is shown that CCSPs are not
Proof (Sketch). Let Ï€ be  ,   I , CV, A . We build an modular representable by standard CSPs, i.e., intuitively, that
âˆƒFOâ†’,âˆ§,+  formula ÏˆÏ€ = âˆƒVar , Var I       Ï†c,where
                                   câˆˆCC âˆªCA           small changes in a CCSP may result in signiï¬cant changes in
Ï†c is obtained as follows:                            any corresponding CSP, which is an encoding for it.
 â€¢ if c is the compatibility constraint c(V1,...,Vk),then Based on the logical equivalence between CCSPs and
   c =                      ( ) â†’  ( 1      k)        âˆƒ
  Ï†     V âˆˆ{V1,...,Vk}\Var I dom V c V ,...,V ;        FOâ†’,âˆ§,+, we can now    formally compare CCSPs with
 â€¢ if c is the activity constraint c(V1,...,Vk)â†’RV V , Ï†c is given CSPs, and in fact prove that there are CCSPs (formulas in
                                                      âˆƒ                                   âˆƒ
  by c(V1,...,Vk) â†’ dom(V ).                           FOâ†’,âˆ§,+) that cannot be â€œsimulatedâ€ in FOâˆ§,+.Thear-
                                                      gument is that there is no way to encode the â€œâ†’â€ connective
Note that other activity constraints can be, in fact, simulated
                                                      by means of conjunctions. In turn, â€œâ†’â€ cannot encode dis-
by RV and compatibility constraints (cf. [Mittal and Falken-
                                                      junction of atoms. Thus, the following relationships hold1.
hainer, 2000]). Moreover, w.l.o.g., we have assumed the ex-
istence of a monadic relation dom listing all possible values Theorem 3. âˆƒFOâ†’,âˆ§,+ is such that: (1) it is more expressive
for the variables â€” without this relation, the simulation is than âˆƒFOâˆ§,+; and, (2) it is incomparable with âˆƒFOâˆ¨,âˆ§,+.
also possible, but would have required a much intricate con-
                                                         1Proofs are reported in an extended version of the paper available
struction for Ï€.
          Ïˆ                                           at www.unical.it/âˆ¼ggreco.

                                                IJCAI-07
                                                   904  The Complexity of Reasoning with CCSPs                            â€”       â€œâŠ†â€        â€œâ‰¤â€        â€œâ€
   (  D)                                                CHECKING    in P   co-NP-c    co-NP-c    co-NP-c
Let Ïˆ,   be a CCSP instance. The intrinsic complexity of                    Î£P      NP[O(log n)]  NP
                           (  D)                       RELEVANCE   NP-c      2 -c  P         -c  P   -c
some basic reasoning tasks for Ïˆ, has been studied in                               NP[O(log n)]  NP
[Soininen et al., 1999; Mittal and Falkenhainer, 2000].Inpar- NECESSITY co-NP-c co-NP-c P    -c  P   -c
ticular, it is known that the SATISFIABILITY problem (does Figure 2: Complexity of CCSPs (â€˜câ€™ stands for complete).
there exists a partial assignment Î¸ such that Î¸ is a solution for
(Ïˆ, D)?) is NP-complete.                              X1,...,Xn  is not satisï¬able, i.e., deciding whether there ex-
  However, there are other important reasoning tasks that of- ist no truth assignments to the variables making each clause
ten come into play with CSPs, and whose complexity has not cj true, is a well-known co-NP-complete problem.
been investigated for CCSPs. In this section, we explore these We build a CCSP instance (Ïˆ(Î¦), D(Î¦)) as follows.

issues, by focusing on the following problems:        For each clause cj, which is w.l.o.g. of the form tj1 âˆ¨
                                                         âˆ¨                                          Â¬
  â€¢                                                   tj2  tj3 ,wheretj1 is a variable Xi or its negation Xi,
    CHECKING: Given a partial assignment Î¸,isÎ¸ a solution D(Î¦)                     =  {(        ) |    âˆˆ
    for (Ïˆ, D)?                                             contains the relation rcj   T1,T2,T3    Ti
                                                      {â€œtrueâ€, â€œfalseâ€} s.t. cj is not satisï¬ed when tji = Ti, âˆ€i}.
  â€¢ RELEVANCE: Given a variable X,isX   contained in
                                                      Then, for each variable Xi in Î¦, D(Î¦) contains the rela-
    V(Î¸) for some solution Î¸ for (Ïˆ, D)?
                                                      tion rvi = {(â€œtrueâ€), (â€œfalseâ€)}. Finally, unsat = {(1)}
  â€¢ NECESSITY: Given a variable X,isX   contained in
                                                      is in D(Î¦), and no other relation is inD(Î¦).Thefor-
    V(Î¸) for every solution Î¸ for (Ïˆ, D)?                   (Î¦)            âˆƒ                     (  ) âˆ§
                                                      mula Ïˆ   is of the form X1, ..., Xn,Z 1â‰¤iâ‰¤n rvi Xi
                                                              (  (         ) â†’       ( ))          âˆˆ
  When moving to CCSPs, these problems can be specialized 1â‰¤jâ‰¤m rcj Xj1 ,Xj2 ,Xj3  unsat Z  ,whereXji
to take care of those solutions that are partial assignments.  
                                                      {X1, ..., Xn} is a variable such that Xji occurs in cj.
Indeed, knowing whether there are solutions in which some Let x be a truth value assignment for the variables in Î¦.Let
                                                       x                                              
variable is not â€œactiveâ€ may be quite relevant. For instance, Î¸ denote the assignment for (Ïˆ(Î¦), D(Î¦)) such that: Xi is
in product conï¬guration, one may be interested in ï¬nding the mapped to â€œtrueâ€ (resp., â€œfalseâ€) in Î¸(x) iff Xi is true (resp.,
conï¬guration with the minimum number of (additional) com- false) x, and such that Z/1 is in Î¸x iff x is not satisfying.
ponents that, yet, meets the usersâ€™ requirements.     Then, any solution Î¸ for (Ïˆ(Î¦), D(Î¦)) is such that V(Î¸) âŠ‡
                                                                                               
  In order to model scenarios as above, it is convenient to re- {X1, ..., Xn}; moreover, Z may not occur in V(Î¸ ) if and
                                                                                                     
ï¬ne the notion of solutions by means of some pre-order on only if there is a satisfying assignment x for Î¦ such that Î¸ =
the set of all the possible partial assignments. Accordingly, a Î¸x. To conclude the proof, we can hence take an assignment
           (  D)                                                                         x
solution Î¸ for Ïˆ, is said -minimal if for each solution Î¸ , xu that does not satisfy Î¦ and notice that Î¸ u is âŠ†-minimal
                                       
it holds: Î¸ Î¸ . In particular, we next consider -minimal â‡” there is no satisfying assignment for Î¦.
                                           2
solutions, where is one of the following pre-orders : CHECKINGâ‰¤   and CHECKING   are co-NP-complete: Mem-
subset minimality â€œâŠ†â€: Î¸1 âŠ†v Î¸2 iff V(Î¸1) âŠ†V(Î¸2).     berships can be shown with similar arguments as above. The
                    â‰¤      â‰¤      |V(  )|â‰¤|V(   )|    hardness of CHECKINGâ‰¤  can be shown by observing that,
minimum cardinality â€œ â€: Î¸1  Î¸2 iff  Î¸1       Î¸2 .                         x                        x
                                                     in the above reduction, Î¸ u is in fact â‰¤-minimal â‡” Î¸ u âŠ†-
weighted cardinality â€œ â€: A weight w is attached to each      â‡”                                 Î¦
    variable, and                                     minimal   there is no satisfying assignment for . Finally,
                                                    the hardness of CHECKINGâŠ† follows by assigning unitary
      Î¸1  Î¸2 iff        w(X)  â‰¤          w(X).
                  XâˆˆV(Î¸1)          XâˆˆV(Î¸2)            weights to all the variables of Ïˆ(Î¦).
  Next, we depict a complete picture of the complexity ï¬g-
ures arising in the CCSP setting.
                                                      5   Restricted Classes of CCSPs
Theorem  4. The complexity of CHECKING, RELEVANCE,    In the light of the intractability results of the previous section,
and NECESSITY  and of their variants for -minimal solu-
     âˆˆ {  âŠ†    â‰¤     }                              it is relevant to single out classes of CCSPs that can be efï¬-
tions (   â€œ â€, â€œ â€, â€œ â€ ) is as shown in Figure 2.    ciently solved. To this aim, we next investigate how to adapt
Proof (Sketch). When no pre-order is considered, results eas- the approaches used in traditional CSPs, where tractable
ily derive from standard results on CSPs. Due to space limi- classes are identiï¬ed by structural decomposition methods
tations, we next only report the proof sketches for the variants (e.g., [Pearson and Jeavons, 1997; Gottlob et al., 2000]).
of CHECKING.
                                                      5.1  The Hardness of Acyclic Structures
CHECKINGâŠ†   is co-NP-complete: (Membership) Let (Ïˆ, D)
be a CCSP instance, and let Î¸ be a partial assignment such that Let Ïˆ be a FO formula. The structure of constraints interac-
Î¸ |= Ïˆ. Consider the complementary problem of deciding tions in Ïˆ can be represented by the primal graph G(Ïˆ)=
whether there is an assignment Î¸ such that (i) Î¸ is a solution (V(Ïˆ),E), where two variables occur in some edge of E if
for (Ïˆ, D) and (ii) V(Î¸) âŠ†V(Î¸) does not hold. Clearly, Î¸ they appear together in a constraint atom in Ïˆ. We next focus
can be guessed in NP, while (i) and (ii) can be checked in P. on classes of primal graphs having bounded treewidth.
  (Hardness) Deciding whether a Boolean formula in con- A  tree decomposition of a graph G =(V,E) is a pair
                                                                    =(     )
junctive normal form Î¦=c1 âˆ§ ...âˆ§ cm over the variables T,Ï‡ ,whereT      N,F   is a tree, and Ï‡ is a function as-
                                                      signing to each vertex p âˆˆ N a set of vertices Ï‡(p) âŠ† V ,
  2In fact, these pre-orders have been widely used for reï¬ning so- such that the following conditions are satisï¬ed: (1) âˆ€b âˆˆ V ,
lution concepts in other AI frameworks.               âˆƒp âˆˆ N  such that b âˆˆ Ï‡(p);(2)âˆ€{b, d}âˆˆE, âˆƒp âˆˆ N such


                                                IJCAI-07
                                                   91                                                      to sj,thenrSji(Xi) evaluates false over the database, and
                                                      the implication is trivially satisï¬ed. Otherwise, i.e., if Xi is
                                                      mapped to sj, we must have that Xi with Ii âˆˆ Sj is mapped
                                                                                                  C
                                                      to sj as well, which in fact holds by construction of Î¸ .
                                                        (â‡)  Assume there is a solution Î¸ for (Ï†(I, S), D(I, S)).
                                                      We ï¬rst notice that the following properties hold on Î¸:(P1)
                                                      V(Î¸)={X1, ..., Xn};and(P2)ifXi   is mapped to sj in Î¸,
                                                      then Xi is mapped to sj, for each Ii âˆˆ Sj. Then, we can
                                                                  Î¸
                                                      build the set C = {Sj |âˆƒXi that is mapped to sj in Î¸},and
                                                      notice that it is an exact cover.
                                                      5.2  Tractable Classes
                                                      Since classical approaches fail in isolating classes of tractable
    Figure 3: An EXACT-COVER-BY-3-SETS instance.      CCSPs, we next propose and study a decomposition strategy
                                                      speciï¬c for âˆƒFOâ†’,âˆ§,+ formulas. We shall focus on plain
   {   }âŠ†    ( )   âˆ€  âˆˆ          {  âˆˆ    | âˆˆ   ( )}
that b, d  Ï‡ p ;(3)  b  N,theset  p   N   b  Ï‡ p      formulas, where nesting of the implication connective is not
                                               
induces a connected subtree of T .Thewidth of T,Ï‡ is  allowed. Formally, a plain âˆƒFOâ†’,âˆ§,+ formula is of the form:
maxpâˆˆN  |Ï‡(p) âˆ’ 1|,andthetreewidth of G (short: tw(G))is                 
the minimum width over all its tree decompositions.          âˆƒXÏ† (X ) âˆ§    (bi(X ) â†’âˆƒYihi(X, Yi))
  Let L be a subset of FO. We denote by CSPbtw(L) the                   1â‰¤iâ‰¤n
class of all the CSP instances (Ï†, D),whereÏ† is in L and      â‰¥ 0
        (G( ))                                        where n    ,andÏ†, bi, hi are in FOâˆ§,+.
where tw   Ï†   is bounded by a ï¬xed constant. It is well- In fact, arbitrary formulas can be made plain by iteratively
              [                ]                                                              
known (see, e.g., Gottlob et al., 2000 )thatSATISFIABILITY substituting each subformula (Ï† â†’ ((Ï† â†’ Ï† ) âˆ§ Ï† )) with
can be solved in polynomial time on CSPbtw(âˆƒFOâˆ§,+).We (  âˆ§   â†’  ) âˆ§ ( â†’   )
                                CSP    (âˆƒ        )     Ï†   Ï†    Ï†      Ï†    Ï†  ; this transformation preserves
next show that this is not the case for btw FOâ†’,âˆ§,+ , the set of all the solutions, and is feasible in quadratic time.
even when further restricted on the class CSPac(âˆƒFOâ†’,âˆ§,+)
                                                        Let Ïˆ be a plain âˆƒFOâ†’,âˆ§,+. Constraint interactions in
of acyclic instances (i.e., those having treewidth 1). Ïˆ can be represented with the implication graph IG(Ïˆ)=
Theorem  5. SATISFIABILITY is NP-hard, even when re-  (V,E),whereV   =  V(Ïˆ) âˆª{b1, ..., bn}âˆª{h1, ..., hn} and
stricted on the class CSPac(âˆƒFOâ†’,âˆ§,+).                edges have the form: (X, Y ) between pairs of variables oc-
                                                      curring in the same atom; (X, bi) if X occurs in some atom of
Proof. Let I = {I1, ..., In} be a set of elements, and let S = ( )                             (    )
{        }                                            bi; X, hi if X occurs in some atom of hi;and bi,hi ,for
 S1, ..., Sm be a number of sets each one containing exactly         ( (  ) â†’âˆƒ    (   ))
three elements in I. Recall that the EXACT-COVER-BY-3- each subformula bi X     Yihi X,Yi  . E.g., a portion
                                                      of the implication graph for the EXACT-COVER-BY-3-SETS
SETS problem of deciding whether there exists a set CâŠ†
                                                      instance in the proof of Theorem 5, which reveals the â€œhid-
{S1, ..., Sm} such that S âˆˆC Si = {I1, ..., In} and Siâˆ©Sj =
                     i                                denâ€ intricacy of the problem, is reported in Figure 3 (bj,i,i
âˆ…, for each Si,Sj âˆˆCwith i 
= j, is NP-complete.
                                                      and hj,i,i refer to the implication rSji(Xi) â†’ rSji (Xi )).
  As an example instance, Figure 3 shows (on the left)
                                                        Then, the class CSP[i]btw(âˆƒFOâ†’,âˆ§,+) is deï¬ned as the set
the sets S1 = {I1,I2,I3}, S2 = {I4,I5,I6},andS3  =
                                                      of all the CCSPs instances (Ïˆ, D),whereÏˆ is a plain for-
{I3,I4,I5}. A solution consists of the set {S1,S3}.
                                                      mula in âˆƒ   â†’,âˆ§,+ such that  (IG( )) is bounded by a
  We build a CCSP instance (Ïˆ(I, S), D(I, S)) as fol-          FO                tw    Ïˆ
                                                      ï¬xed constant. An algorithm, called DecideSolutionk, decid-
lows.  For each item Ii, D(I, S) contains the relation
                                                      ing whether an instance in CSP[i]btw(âˆƒFOâˆ§,+) has a solution
rIi =   {(sj) |  Sj  âˆˆSand   Ii  âˆˆ  Sj}.   For each
                                                      is reported in Figure 4.
set Sj and item Ii  âˆˆ  Sj,  D(I, S) contains the re-
                                                        The algorithm works on an tree decomposition of IG(Ï†) of
lation rSji =  {(sj)}.  And, no other relation is in
                                                      width k, whose shape is T =(N,F). Roughly, it is based
D(I, S). Moreover, the formula Ïˆ(I, S) is of the form:
                                                    on a recursive procedure ï¬ndSolution that receives in input
âˆƒX1, ..., Xn, i rIi(Xi) âˆ§ i,i,j|{I ,I }âŠ†S (rSji(Xi) â†’
                               i i  j                avertexv  âˆˆ N. Each vertex is equipped with some nodes
    (  ))
rSji Xi  . Importantly, given that constraint relations in associated with variables of , denoted by V( ),aswellas
 (I S)          G((  (I S) D(I  S)))                                          Ï†              v
Ïˆ  ,   are unary,   Ïˆ  ,  ,    ,    does not contain  with nodes from {b1, ..., bn} and {h1, ..., hn}. The sets of
any edge and, hence, it is trivially acyclic.         these nodes are denoted by B( ) and H( ), respectively.
                                             I                                 v        v
  We now claim that: there exists an exact cover of with Basically, ï¬ndSolution guesses for each child of (in
        Sâ‡”(    (I S) D(I  S))                                                                    c   v
sets from    Ïˆ   ,  ,    ,   admits a solution.         ), a partial assignment c for V( ) (conforming with the
  (â‡’)    C                                       C    F                     Î¸       c
      Let  be an exact cover. Consider the assignment Î¸ assignment for v), and two â€œstatesâ€ bc and hc.Thestatebc
                   V( (I S)) =  V( C )                             Î¸
build as follows: (1) Ïˆ ,         Î¸  ;and(2)Xi   is   (resp., hc) is a mapping from B(c) (resp., Hc)tothevalues
          j             i âˆˆ  j      j âˆˆC
mapped to s if and only if I S and S    . Note that  {T, F, willF, wasF}. The mapping bc(bi)=T states that the
                  (   )             C
the conjunction i rIi Xi is satisï¬ed by Î¸ , by construction conjunct bi of Ï† must be true. In fact, when bc(bi)=T,
                 D(I  S)
of the relation rIi in , . Hence, it remains to show that it must be the case that the atoms in bi restricted over the
                        (  ji( i) â†’   ji ( i ))
each implication of the form rS X  rS   X     is sat- assignment for v are satisï¬ed in D (short: D|= Ï€bi (v) in B1).
isï¬ed as well. We distinguish two cases. If Xi is not mapped Note that the information that bc(bi)=T is propagated to all


                                                IJCAI-07
                                                   92