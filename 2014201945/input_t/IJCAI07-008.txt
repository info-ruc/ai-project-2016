          New Constraint Programming Approaches for the Computation of
                   Leximin-Optimal Solutions in Constraint Networks

                               Sylvain Bouveret    and Michel LemaË†Ä±tre
                        Ofï¬ce National dâ€™EtudesÂ´ et de Recherches AÂ´erospatiales
                       sylvain.bouveret@onera.fr and michel.lemaitre@onera.fr

                    Abstract                          variables, and can possibly be used to ensure a kind of equity
                                                      among a set of agents. Equity is also studied in Operational
    We study the problem of computing a leximin-
                                                      Research, with for example [Ogryczak and SliwiÂ´Â´ nski, 2003],
    optimal solution of a constraint network. This prob-
                                                      who investigate a way of solving linear programs by aggre-
    lem is highly motivated by fairness and efï¬ciency
                                                      gating multiple criteria using an Ordered Weighted Average
    requirements in many real-world applications im-
                                                      Operator (OWA) [Yager, 1988]. Depending on the weights
    plying human agents. We compare several generic
                                                      used in the OWA, this kind of aggregators can provide equi-
    algorithms which solve this problem in a constraint
                                                      table compromises.
    programming framework. The ï¬rst one is entirely
                                                        Microeconomy and Social Choice theory provide an im-
    original, and the other ones are partially based on
                                                      portant literature on fairness in collective decision making.
    existing works adapted to ï¬t with this problem.
                                                      From this theoretical background we borrow the idea of rep-
                                                      resenting the agents preferences by utility levels, and we
1  Introduction                                       adopt the leximin preorder on utility proï¬les for conveying
                                                      the fairness and efï¬ciency requirements. Being a reï¬nement
Many advances have been done in recent years in modeling                    1
and solving combinatorial problems with constraint program- of the maximin approach , it has an inclination to fairness,
ming (CP). These advances concern, among others, the abil- while avoiding the so-called drowning effect of this approach.
ity of this framework to deal with human reasoning schemes, Apart from the fact that it conveys and formalizes the con-
such as, for example, the expression of preferences with soft cept of equity in multiagent contexts, the leximin preorder is
constraints. However, one aspect of importance has only re- also a subject of interest in other contexts, such as fuzzy CSP
ceived a few attention in the constraints community to date: [Fargier et al., 1993], and symmetry-breaking in constraint
the way to handle fairness requirements in multiagent combi- satisfaction problems [Frisch et al., 2003].
natorial problems.                                      This contribution is organized as follows. Section 2 gives a
  The seek for fairness stands as a subjective but strong re- minimal background in social choice theory and justiï¬es the
quirement in a wide set of real-world problems implying hu- interest of the leximin preorder as a fairness criterion. Sec-
man agents. It is particularly relevant in crew or worker tion 3 deï¬nes the search for leximin-optimality in a constraint
timetabling and rostering problems, or the optimization of programming framework. The main contribution of this pa-
long and short-term planning for ï¬remen and emergency ser- per is Section 4, which presents three algorithms for com-
vices. Fairness is also ubiquitous in multiagent resource al- puting leximin-optimal solutions, the ï¬rst one being entirely
location problems, like, among others, bandwidth allocation original, and the other ones adapted from existing works.
among network users, fair share of airspace and airport re- The proposed algorithms have been implemented and tested
sources among several airlines or Earth observing satellite within a constraint programming system. Section 5 presents
scheduling and sharing problems [LemaË†Ä±tre et al., 1999]. an experimental comparison of these algorithms.
  In spite of the wide range of problems concerned by fair-
ness issues, it often lacks a theoretical and generic approach. 2 Background on social choice theory
In many Constraint Programming and Operational Research We ï¬rst introduce some notations. Calligraphic letters (e.g.
works, fairness is only enforced by speciï¬c heuristic local X
                                                        ) willâˆ’â†’ stand for sets. Vectors will be written with anâˆ’â†’ arrow
choices guiding the search towards supposed equitable solu- (e.g. x ), or between brackets (e.g. x1,...,xn). f( x ) will
                                                                                                  âˆ’â†’â†‘
tions. However, a few works may be cited for their approach                   1        n 
                                                      be used as a shortcut for f(x ),...,f(x ) . Vector âˆ’â†’x will
of this fairness requirement. [LemaË†Ä±tre et al., 1999] make stand for the vector composed by each element of x rear-
                                                                                           â†‘
use of an Earth observation satellite scheduling and sharing ranged in increasing order. We will write x the ith compo-
                                                                  âˆ’â†’                       i
problem to investigate three ways of handling fairness among nent of vector x â†‘. Finally, the interval of integers between k
agents in the context of constraint satisfaction. More recently and l will be written k, l.
[Pesant and RÂ´egin, 2005] proposed a new constraint based on
statistics, which enforces the relative balance of a given set of 1Trying to maximize the utility of the unhappiest agent.

                                                IJCAI-07
                                                   622.1  Collective decision making and welfarism         much better than the ï¬rst one. In other words, the min ag-
                                                      gregation function can lead to non Pareto-optimal decisions,
Let N beasetof    agents, and S be a set of admissible
                n                                     which is not desirable.
alternatives concerning all of them, among which a benevo-
                                                        The leximin preorder is a well-known reï¬nement of the or-
lent arbitrator has to choose one. The most classical model
                                                      der induced by the min function that overcomes this draw-
describing this situation is welfarism (see e.g. [Keeney and
                                                      back. It is classically introduced in the social choice literature
Raiffa, 1976; Moulin, 1988]): the choice of the arbitrator is
                                                      (see [Moulin, 1988]) as the social welfare ordering that rec-
made on the basis of the utility levels enjoyed by the indi-
                                                      oncile egalitarianism and Pareto-efï¬ciency, and also in fuzzy
vidual agents and on those levels only. Each agent i âˆˆN
                                                      CSP  [Fargier et al., 1993].Itisdeï¬nedasfollows:
has an individual utility function ui that maps each admissi-                                      âˆ’â†’
              âˆˆS                                                                 [            ]
ble alternative s to a numerical index ui(s).Wemake   Deï¬nitionâˆ’â†’ 1 (leximin preorderâˆ’â†’ Moulin,âˆ’â†’ 1988 ) Let x and
here the classical assumption that the individual utilities are y be two vectors of Nn. x and y are said leximin-
                                                                      âˆ’â†’         âˆ’â†’            âˆ’â†’â†‘   âˆ’â†’â†‘
comparable between the agents2. Therefore each alternative s indifferent (written x âˆ¼leximin y ) if and only if x = y .
                                                             âˆ’â†’                    âˆ’â†’       âˆ’â†’ â‰º
can be attached to a single utility proï¬le u1(s),...,un(s) . âˆ’â†’The vector y is leximin-preferred to x (written x leximin
According to welfarism, comparing two alternatives is per- y ) if and only if âˆƒi âˆˆ 0,n âˆ’ 1 such that âˆ€j âˆˆ 1,i,
                                                       â†‘     â†‘     â†‘       â†‘            âˆ’â†’          âˆ’â†’
formed by comparing their respective utility proï¬les. x  =  y  and x   <y     . We write x 
leximin y for
                                                      âˆ’â†’j    j    âˆ’â†’i+1 âˆ’â†’ i+1      âˆ’â†’
  A standard way to compare individual utility proï¬les is to x â‰ºleximin y or x âˆ¼leximin y . The binary relation
aggregate each of them into a collective utility index, stand- 
leximin is a total preorder.
ing for the collective welfare of the agents community. If g is
a well-chosen aggregation function, we thus have a collective In other words, the leximin preorder is the lexicographic pre-
utility function uc that maps each alternative s to a collec- order over ordered utility vectors. For example, we have
                                                             â‰º              
tive utility level uc(s)=g(u1(s),...,un(s)). An optimal 4, 1, 5, 1 leximin 2, 2, 1, 2 .
alternative is one of those maximizing the collective utility. A known result is that no collective utility function can rep-
                                                      resent the leximin preorder5, unless the set of possible utility
                                                      proï¬les is ï¬nite. In this latter case, it can be represented by
2.2  The leximin preorder as a fairness and                                             âˆ’â†’     n
                                                                                           â†’âˆ’        âˆ’xi
     efï¬ciency criterion                              the following non-linear functions: g1 : x  i=i n
                                                      (adapted for leximin from a remark in [Frisch et al., 2003])
                                                              âˆ’â†’      n    âˆ’q
The main difï¬culty of equitable decision problems is that and g2 : x â†’âˆ’ i=1 xi ,whereq>0   is large enough
we have to reconcile the contradictory wishes of the agents. [Moulin, 1988]. Using this kind of functions has however
Since generally no solution fully satisï¬es everyone, the ag-
                                                      a main drawback: it rapidly becomesâˆ’â†’ unreasonable when the
gregation function g must lead to fair and Pareto-efï¬cient3 upper bound of the possible values of x increases. Moreover,
compromises.                                          it hides the semantics of the leximin preorder and hinders the
  The problem of choosing the right aggregation function g computational beneï¬ts we can possibly take advantage of.
is far beyond the scope of this paper. We only describe the In the following, we will use the leximin preorder as a
two classical ones corresponding to two opposite points of criterion for ensuring fairness and Pareto-efï¬ciency, and we
view on social welfare4: classical utilitarianism and egalitar- will be seeking the non-dominated solutions in the sense of
ianism. The rule advocated by the defenders of classical util- the leximin preorder. Those solutions will be called leximin-
itarianism is that the best decision is the one that maximizes optimal. This problem will be expressed in the next section
the sum of individual utilities (thus corresponding to g =+). in a CP framework.
However this kind of aggregation function can lead to huge
differences of utility levels among the agents, thus ruling out 3 Constraint programming and
this aggregator in the context of equitable decisions. From
the egalitarian point of view, the best decision is the one that leximin-optimality
maximizes the happiness of the least satisï¬ed agent (thus cor- The constraint programming framework is an effective and
responding to g =min). Whereas this kind of aggregation ï¬‚exible tool for modeling and solving many different com-
function is particularly well-suited for problems in which fair- binatorial problems such as planning and scheduling prob-
ness is essential, it has a major drawback, due to the idempo- lems, resource allocation problems, or conï¬guration prob-
tency of the min operator, and known as â€œdrowning effectâ€ in lems. This paradigm is based on the notion of constraint
the community of fuzzy CSP (see e.g.[Dubois and Fortemps, network [Montanari, 1974]. A constraint network consists
1999]). Indeed, it leaves many alternatives indistinguishable, of a set of variables X = {X1,...,Xp} (in the following,
such as for example the ones with utility proï¬les 0,...,0 variables will be written with uppercase letters), a set of asso-
                  
and 1000,...,1000, 0 , even if the second one appears to be ciated domains D = {DX1 ,...,DXp },whereDXi is the set
                                                      of possible values for Xi, and a set of constraints C,where
  2In other words, they are expressed using a common utility scale. each c âˆˆCspeciï¬es a set of allowed tuples R(c) over a set of
  3A decision is Pareto-efï¬cient if and only if we cannot strictly variables X (c). We make the additional assumption that all
increase the satisfaction of an agent unless we strictly decrease the the domains are in N, and we will use the following notations:
satisfaction of another agent. Pareto-efï¬ciency is generally taken as X =min(DX ) and X =max(DX ).
a basic postulate in collective decision making.
  4                                                      5                              âˆ’â†’         âˆ’â†’ â‡”
   Compromises between these two extremes are possible. See e.g. âˆ’â†’In otherâˆ’â†’ words there is no g such that x leximin y
[Moulin, 2003, page 68] or [Yager, 1988] (OWA aggregators). g( x ) â‰¤ g( y ).See[Moulin, 1988].

                                                IJCAI-07
                                                   63  An instantiation v of a set S of variables is a function that Deï¬nition 3 (Meta-constraint AtLeast) Let Î“ be a set of p
maps each variable X âˆˆSto a value v(X) of its domain DX . constraints, and k âˆˆ 1,p be an integer. The meta-constraint
If S = X , this instantiation is said to be complete, otherwise AtLeast(Î“,k) holds on the union of the scopes of the con-
it is partial. If S  S, the projection of an instantiation of straints in Î“, and allows a tuple if and only if at least k con-
S over S is the restriction of this instantiation to S and is straints from Î“ are satisï¬ed.
written vâ†“S . An instantiation is said to be consistent if and
only if it satisï¬es all the constraints. A complete consistent Due to its genericity, this meta-constraint cannot provide
instantiation of a constraint network is called a solution. The very efï¬cient ï¬ltering procedures. In our case where the
set of solutions of (X , D, C) is written sol(X , D, C). We will constraints of Î“ are linear, this meta-constraint is simply a
also write v[X â† a] the instantiation v where the value of X counting constraint, and bound-consistency can be achieved
is replaced by a.                                     in O(n).  The speciï¬c meta-constraint AtLeast can also
                                                                                                [
  Given a constraint network, the problem of determining be implemented with a set of linear constraints Garï¬nkel
                                                      and Nemhauser, 1972, p.11], by introducing n 0â€“1 variables
whether it has a solution is called a Constraint Satisfaction {  }                          {          â‰¥
Problem (CSP)andisNP-complete. The  CSP can be clas-   Î”1,...,Î”n  , and a set of linear constraints X1 +Î”1Y
                                                                       â‰¥     n     â‰¤   âˆ’  }
sically adapted to become an optimization problem in the fol- Y,...,Xn +Î”nY Y, i=1 Î”i n  k .
lowing way. Given a constraint network (X , D, C) and an Our ï¬rst approach for computing a leximin-optimal solu-
objective variable O âˆˆX, ï¬nd the value m of DO such   tion is presented in algorithm 1.
that m =max{v(O)   | v âˆˆ sol(X , D, C)}. We will write
     X D  C
max(  ,  , ,O) for the subset of those solutions that maxi- Algorithm 1: Computation of a leximin-optimal solution
mize the objective variable O.                         using a cardinality combinator.
  Expressing a collective decision making problem with a                    (X D C)          âˆˆXn
numerical collective utility criterion as a CSP with objective input : A const. network , , ; U1,...,Un
                                                        output: A solution to the MaxLeximinCSP problem
variable is straightforward: consider the collective utility as
the objective variable, and link it to the variables represent- 1 if solve(X , D, C)=â€œInconsistentâ€ return â€œInconsistentâ€;
                                                        (X  D C ) â† (X D C)
ing individual utilities with a constraint. However this cannot 2 0, 0, 0 , , ;
                                                      3 for i â† 1 to n do
directly encode our problem of computing a leximin-optimal X  â†X     âˆª{  }
solution, which is a kind of multicriteria optimization prob- 4 i iâˆ’1  Yi ;
                                                           D  â†D    âˆª{D  }    D   = min (  ) max (  )
lem. We introduce formally the MaxLeximinCSP problem  5      i    iâˆ’1   Yi  with Yi      j Uj ,   j Uj ;
as follows :                                          6    Ci â†Ciâˆ’1  âˆª
                                                                 {AtLeast({  â‰¤          â‰¤   }   âˆ’  +1)}
           MaxLeximinCSP                                                   Yi  U1,...,Yi  Un ,n   i    ;
Deï¬nition 2 (               problem)                  7    vb(i) â† maximize(Xi, Di, Ci,Yi);
Input: a constraint network (X , D, C); a vector of variables 
                                                      8    Di â†Di  with DYi â†{vb(i)(Yi)};
âˆ’â†’                  n
      1      nâˆˆX
U =  U  ,...,U       , called an objective vector.    9 return vb(n)â†“X ;
Output:                  X  D C    âˆ…
       â€œInconsistentâ€ if sol( , , )=âˆ’â†’ .Otherwiseaso-âˆ’â†’
lution v such that âˆ€v âˆˆ sol(X , D, C), v(U ) 
leximin v(U ).
                                                        The functions solve and maximize (the detail of which is
  We describe in the next section several generic constraint
                                                      the concern of solving techniques for constraints satisfaction
programming algorithms that solve this problem. The ï¬rst
                                                      problems) of lines 1 and 7 respectively return one solution
one is entirely original, and the other ones are based on exist-
                                                      v âˆˆ sol(X , D, C) (or â€œInconsistentâ€ if such a solution does
ing works that are adapted to ï¬t with our problem.
                                                      not exist), and an optimal solution v âˆˆ max(Xi, Di, Ci,Yi)
                                                      (or â€œInconsistentâ€ if sol(Xi, Di, Ci)=âˆ…). We assume â€“ con-
4  Proposed algorithms                                trary to usual constraint solvers â€“ that these two functions do
4.1  Using a cardinality combinator                   not modify the input constraint network.
Our ï¬rst algorithm is based on an iterative computation of the The following example illustrates a1 a2 a3
                                                      the behavior of the algorithm. It is a
components of the leximin-optimal vector. It ï¬rst computes                              o1   3   3    3
                 1                              âˆ€     simple resource allocation problem,
the maximal value y such that there is a solution v with i,                            o2   5   9    7
 1 â‰¤    i ,orinotherwords     1 â‰¤     i     ,where    where 3 objects must be allocated
y    v(U )                  i(y   v(U )) = n                                            o3   7   8    1
by convention the value of (y1 â‰¤ v(Ui)) is 1 if the inequality to 3 agents, with the following con-
is satisï¬ed and 0 otherwise6. Then, after having ï¬xed this straints: each agent must get one and only one object, and
value for y1, it computes the maximal value y2 such that there one object cannot be allocated to more than one agent (i.e. a
is a solution v with i(y2 â‰¤ v(Ui)) â‰¥ n âˆ’ 1, and so on perfect matching agent/objects). A utility is associated with
until the maximal value yn such that there is a solution v with each pair (agent,object) with respect to the array above.
  i(yn â‰¤ v(Ui)) â‰¥ 1.                                    This problem has 6 feasible solutions (one for each permu-
  To enforce the constraint on the yi,wemakeuseofthe  tation of 1, 3), producing the 6 utility proï¬les shown in the
meta-constraint AtLeast, derived from a cardinality com- columns of the following array:
binator introduced by [Van Hentenryck et al., 1992],and
                                                                      p1  p2   p3  p4  p5   p6
present in most of CP systems:
                                                                 u1   3    3   5   5    7   7
  6This convention is inspired by the constraint modeling language u2 9    8   3   8    3   9
OPL [Van Hentenryck, 1999].                                      u3   1    7   1   3    7   3

                                                IJCAI-07
                                                   64  The algorithm runs in 3 steps: Step 1: After having intro- Proof of proposition 1: If sol(X , D, C)=âˆ…,andifsolve
duced one variable Y1, we look for the maximal value y1 of is correct, then algorithm 1 obviously returns â€œInconsistentâ€. Other-
                                                                                             (b  )
Y1 such that each (at least 3) agent gets at least Y1.Weï¬nd wise, following lemma 2, it outputs an instantiation v(n) â†“X which
                                                                                   (X  D  C )=(X   D C)
y1 =3.ThevariableY1 is ï¬xed to this value, implicitly re- is, according to lemma 3, a solution of 0, 0, 0 , , .
                                                        Suppose that there is a   âˆˆ     (X D  C) such that
moving proï¬les p1 and p3. Step 2: After having introduced âˆ’â†’           âˆ’â†’     v       sol ,  ,
                                                     v(U ) leximin vb(n)(U ). Then following deï¬nition 1, âˆƒi âˆˆ 1,n
one variable Y2, we look for the maximal value y2 of Y2 such          âˆ’â†’         âˆ’â†’       âˆ’â†’         âˆ’â†’
                                                                        â†‘         â†‘         â†‘         â†‘
that at least 2 agents get at least Y2.Weï¬ndy2 =7.Thevari- such that âˆ€j<i, v(U )j = vb(n)(U )j and v(U )i > vb(n)(U )i .
able 2 is ï¬xed to this value, implicitly removing proï¬le 4. +
    Y                                           p     Let v(i) be the extension of v respectively instantiating Y1,...Yiâˆ’1
Step 3: After having introduced one variable Y3, we look for                         âˆ’â†’ â†‘
                                                      to vb(n)(Y1),...vb(n)(Yiâˆ’1) and Yi to v(U ) . Following lemma 4,
the maximal value y3 of Y3 such that at least 1 agent gets at        âˆ’â†’               i
                                                      âˆ€  b  (  )=b   (  )â†‘
least Y3.Weï¬ndy3 =9. Only one instantiation maximizes j, v(n) Yj v(n) U j . By gathering all the previous equalities,
                                                                   +                  âˆ’â†’ â†‘    +  âˆ’â†’ â†‘
Y3: p6. Finally, the returned leximin-optimal allocation is: we have âˆ€j<iv(i)(Yj )=vb(n)(Yj )=v(U )j =(v(i)(U ))j .We
a1 â† o3, a2 â† o2 and a3 â† o1.                                  +        âˆ’â†’ â†‘    + âˆ’â†’  â†‘
                                                      also have v (Yi)=v(U )i =(v (U ))i . By lemma 1, âˆ€j â‰¤ i at
                                                              (i)               (i)âˆ’â†’
                               maximize      solve                            +
Proposition 1 If the two functions       and          least n âˆ’ j +1numbers from (v(i)(U )) are greater than or equal to
are both correct and both halt, then algorithm 1 halts and + ( )        +
        MaxLeximinCSP                                 v(i) Yj , proving that v(i) satisï¬es all the cardinality constraints at
solves the              problem.                      iteration i. Since it also satisï¬es each constraint in C and maps each
                                                     variable of Xi to one of its possible values, it is a solution of soli,
  In the next proofs, we will write soli and soli for respec-       âˆ’â†’        âˆ’â†’
                                                         + (  )=  (  )â†‘  b   ( )â†‘ = b  ( )
tively sol(Xi, Di, Ci) and sol(Xi, Di, Ci). We will also write and v(i) Yi v U i > v(n) U i v(i) Yi . It contradicts the
                                                               maximize                      
(soli)â†“Xj and (soli)â†“Xj for the same sets of solutions pro- deï¬nition of , proving the proposition 1.
jected on Xj (with j<i). We can notice that sol0 =
                                                     4.2  Using a sorting constraint
sol(X , D, C),andthatâˆ€i, soli âŠ† soli.
             âˆ’â†’                                       Our second algorithm is directly based on the deï¬nition 1 of
Lemma 1  Let x be a vector of size n.Atleastn âˆ’ i +1
            âˆ’â†’                          â†‘             the leximin preorder, which involves the sorted version of the
components of x are greater than or equal to x .
                                        i             objective vector. This can be naturally expressedâˆ’â†’ in the CP
  The proof of this useful lemma is obvious, so we omit it. paradigm by introducingâˆ’â†’ a vectorâˆ’â†’ of variables Y and enforc-
                                                      ing the constraint Sort(U,Y ) which is deï¬ned as follows:
Lemma 2  If sol0 = âˆ… then v(n) is well-deï¬ned and not equal                        âˆ’â†’    âˆ’â†’
to â€œInconsistentâ€.                                    Deï¬nition 4 (Constraint Sort) Let X and X  be two vec-
                                                     tors of variables of the same length, and v be an instantiation.
  Proof: Let i âˆˆ 1,n, suppose that soliâˆ’1 = âˆ…,andletv(i) âˆˆ           âˆ’â†’ âˆ’â†’
                                                     The constraint Sort(X,X ) holds on the set of variables be-
soliâˆ’1. Then extending v(i) by instantiating Yi to minj (Uj ) leads
                                                                 âˆ’â†’      âˆ’â†’
to a solution of (Xi, Di, Ci) (only one constraint has been added and ing either in X or in X , and is satisï¬ed by v if and only if
                                                        âˆ’â†’                      âˆ’â†’
it is satisï¬ed by the latter instantiation). Therefore soli = âˆ… and, if is the sorted version of in increasing order.
                                                     v(X  )                   v(X )
maximize is correct, vb(i) = â€œInconsistentâ€ and vb(i) âˆˆ soli.So,
                                                       This constraint has been particularly studied in two works,
soli = âˆ…. It proves lemma 2 by induction. 
                                                      which both introduce a ï¬ltering algorithm for enforcing

Lemma 3  If sol0 = âˆ…,then(v(n))â†“Xi âˆˆ soli, âˆ€i âˆˆ 0,n. bound consistency on this constraint. The ï¬rst algorithm
                                                                 [                                   ]
                                                    comes from Bleuzen-Guernalec and Colmerauer,âˆ’â†’ 1997 and
  Proof: We have soli âŠ† soli,and(soli+1)â†“Xi âŠ† soli (since
                                                     runs in O(n log n) (n being the size of X). [Mehlhorn and
from (Xi, Di, Ci) to (Xi+1, Di+1, Ci+1) we just add a constraint).
                                                     Thiel, 2000] designed a simpler algorithm that runs in O(n)
More generally, (soli)â†“Xj âŠ† (soli)â†“Xj ,and(soli+1)â†“Xj âŠ†                                               âˆ’â†’
                                          
(soli)â†“Xj , as soon as j â‰¤ i. Hence, (vb(n))â†“Xi âˆˆ (soln)â†“Xi âŠ† plus the time required to sort the interval endpoints of X,
                                                     which can asymptotically be faster than    .
(soln)â†“Xi âŠ†Â·Â·Â·âŠ†(soli+1)â†“Xi âŠ† soli âŠ† soli.                                              O(n log n)
                                        âˆ’â†’
                âˆ…     âˆ’â†’                â†‘
Lemma 4  If sol0 = , v(n)( y ) is equal to v(n)(U ) .  Algorithm 2: Computation of a leximin-optimal solution
                                                       using a sorting constraint.
  Proof: For all i âˆˆ 1,n, (vb(n))â†“Xi is a solution of soli
                                         âˆ’â†’                                                        n
                                            â†‘                               (X D C)  1      nâˆˆX
by lemma 3. By lemma 1, (vb(n))â†“X [Yi â† vb(n)(U ) ] satis- input : A const. network , , ; U ,...,U
                              i             i                              MaxLeximinCSP
ï¬es the cardinality constraint of iteration i, and is then a solu- output: A solution to the problem
                              maximize                    solve(X D C)=
tion of soli. By deï¬nitionâˆ’â†’ of function , we thus have 1 if     , ,     â€œInconsistentâ€ return â€œInconsistentâ€;
                 â†‘                                      X  â†Xâˆª{           }
vb(i)(Yi) â‰¥ vb(n)(U )i .Sincevb(i)(Yi)=vb(n)(Yi),wehave 2         Y1,...,Yn ;
             âˆ’â†’ â†‘                                         
                                                        D  â†Dâˆª{DY        DY  } DY  = minj ( j ) maxj ( j )
vb(n)(Yi) â‰¥ vb(n)(U )i .                              3             1 ,..., n ,  i        U  ,     U   ;
                                                                     âˆ’â†’ âˆ’â†’
  Since vb(n) is a solution of soln, at least n âˆ’ i +1numbers from 4 C â†Câˆª{Sort(U,Y )};
         âˆ’â†’                                                 â†  1
     b  (  )                      b  ( i)             5 for i   to n do
vector v(n) U are greater than or equal to v(n) Y . At least the                
                            âˆ’â†’                        6    vb(i) â† maximize(X , D , C ,Yi);
n âˆ’ i +1greatest numbers from vb(n)(U ) must then be greater than
                                                      7    DY  â†{b(i)( i)}
                                         âˆ’â†’ â†‘                 i   v   Y  ;
or equal to vb(n)(Yi). These components include vb(n)(U )i ,which
                                                              b(n)â†“X
                   âˆ’â†’ â†‘                               8 return v   ;
leads to vb(n)(Yi) â‰¤ vb(n)(U )i , proving the lemma. 
  We can now put things together and prove proposition 1.

                                                IJCAI-07
                                                   65Proposition 2 If the two functions maximize and solve  Algorithm 3: Computation of a leximin-optimal solution
are both correct and both halt, then algorithm 2 halts and in a branch and bound manner.
        MaxLeximinCSP                                                                              n
solves the              problem.                        input : A const. network (X , D, C); U1,...,UnâˆˆX
  Proof: If sol(X , D, C)=âˆ… and if solve is correct, then al- output: A solution to the MaxLeximinCSP problem
gorithm 2 obviously returns â€œInconsistentâ€. We will suppose in the 1 vb â† null; v â† solve(X , D, C);
             (X D  C) = âˆ…
following that sol , ,  and we will use the following nota- 2 while v = â€œInconsistentâ€ do
                                  (X  D C)
tions: soli and soli are the sets of solutions of , , respec- 3 vb â† v;
tively at the beginning and at the end of iteration i.                        âˆ’â†’  âˆ’â†’
                                                     4    Câ†Câˆª{Leximin(vb(U    ), U )};
  We have obviously âˆ€i âˆˆ 1,nâˆ’ 1 soli+1 = soli, which proves
                                                      5    v â† solve(X , D, C);
that if soli = âˆ…, then the call to maximize at line 6 does not
return â€œInconsistentâ€, and soli+1 = âˆ…. Thus vb(n) is well-deï¬ned, 6 if vb = null then return vb else return â€œInconsistentâ€;
and obviously (vb(n))â†“X is a solution of (X , D, C).
  We note vb = vb(n) the instantiation computed by the last
maximize  in algorithm 2. Suppose that there is an instantiation work by enumerating, at each step, all the subsets of fuzzy
                       âˆ’â†’           âˆ’â†’           +
v âˆˆ sol(X , D, C) such that vb(U ) â‰ºleximin v(U ).Wedeï¬nev constraints (corresponding to our agents) having a property
                                     âˆ’â†’ â†‘
the extension of v that instantiates each yi to v(U )i . Then, due connected to the notion of consistency degree.
                âˆ’â†’      +
to constraint Sort, vb(Y ) and v (Y ) are the respective sorted ver- [Ehrgott, 2000, p. 162] describes two very simple algo-
       âˆ’â†’      +
sion of vb(U ) and v (U). Following deï¬nition 1, there is an i âˆˆ rithms for solving the closely related â€œLexicographic Max-
                                  +                   Orderingâ€ problem (that could be called â€œleximax-optimalâ€
0,nâˆ’ 1 such that âˆ€j âˆˆ 1,i, vb(Yj )=v (Yj ) and vb(Yi+1) <
 +                                                    in our terms). However, they do not seem realistic in the con-
v (Yi+1). Due to line 7, we have vb(Yi+1)=vb(n)(Yi+1)=
                  +                                text of combinatorial problems, since they are based on an
vb(i+1)(Yi+1). Thus v is a solution in max(X , D , C ,Yi+1)
                +                                     enumeration of all utility proï¬les.
with objective value v(i+1)(Yi+1) strictly greater than vb(i+1)(Yi+1),
which contradicts the hypothesis about maximize. 
                                                      5   Experimental results
4.3  Using a multiset ordering constraint             The algorithms 1, 2, 3 and the ï¬rst algorithm proposed
Our third algorithm computing a leximin-optimal solution is in [Dubois and Fortemps, 1999] have been implemented and
perhaps the most intuitive one. It proceeds in a pseudo branch tested using the constraint programming tool CHOCO [Labur-
and bound manner: it computes a ï¬rst solution, then tries to the, 2000]. So as to test them on realistic instances, we have
improve it by specifying that the next solution has to be better extracted, from a real-world problem, a simpliï¬ed multiagent
(in the sense of the leximin preorder) than the current one, and resource allocation problem. In this problem, the resource is a
so on until the constraint network becomes inconsistent. This set of objects O, that must be allocated to some agents under
approach is based on the following constraint:        volume and consumption constraints. The individual utility
                                  âˆ’â†’                  functions are speciï¬ed by a set of weights wa,o (one per pair
Deï¬nitionâˆ’â†’ 5 (Constraint Leximin) Let X be a vector of (agent, object)): given an allocation of the objects, the indi-
variables, Î» be a vector of integers,âˆ’â†’ â†’âˆ’ and v be an instanti- vidual utility of an agent i is the sum of the weights wi,o of
                   Leximin                            the objects o that she receives. The weights can be generated
ation. The constraint âˆ’â†’   ( Î»,X) holds on the set of
variables belonging to X, and is satisï¬ed by v if and only if uniformly or can be concentrated around some powers of 10,
âˆ’â†’         âˆ’âˆ’âˆ’â†’                                       so as to simulate some kind of priorities8.
  â‰º
Î»   leximin v(X).                                       We have developed a customizable generator of random
  Although this constraint does not exist in the literature, the instances, available online9. We tested our algorithms on sev-
work of [Frisch et al., 2003] introduces an algorithm for en- eral instances, with very different characteristics, leading to
forcing generalized arc-consistency on a quite similar con- very different kind of problems. Here is a brief description
straint: the multiset ordering constraint, which is, in the con- of each kind of instances appearing in table 1 (by default, the
text of multisets, the equivalent of a leximax7 constraint on weights are non-uniformly distributed, and the constraints are
vectors of variables. At the price of some slight modiï¬ca- of medium tightness):
tions, the algorithm they introduce can easily be used to en- (1) 10 agents, 100 objects. (2) 4 agents, 100 objects. (3) 20
force the latter constraint Leximin.                  agents, 40 objects. (4) 10 agents, 100 objects, low-tightness
                                                      constraints. (5) 10 agents, 100 objects, hard-tightness con-
Proposition 3 If the function solve is correct and halts, then
                           MaxLeximinCSP              straints. (6) 10 agents, 30 objects, uniform weights (with low
algorithm 3 halts and solves the           problem.   values), hard-tightness constraints. (7) 4 agents, 150 objects.
  The proof is rather straightforward, so we omit it.   The results from table 1 show that algorithm 1 has the best
                                                      running times with most of the instances, followed by algo-
4.4  Other approaches                                 rithm 2 which is almost as fast, but is less efï¬cient when the
In the context of fuzzy constraints, two algorithms dedicated number of agents increases (instances of kind 3), whereas al-
to the computation of leximin-optimal solutions have been gorithm 3 is better on this kind of instances. As expected, the
published by [Dubois and Fortemps, 1999]. These algorithms algorithm from [Dubois and Fortemps, 1999] explodes when

  7The leximax is based on an increasing reordering of the values, 8Approximating the conditions of our real-world application.
instead of a decreasing one for leximin.                 9http://www.cert.fr/dcsd/THESES/sbouveret/benchmark/

                                                IJCAI-07
                                                   66