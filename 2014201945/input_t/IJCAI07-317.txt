                          Planning for Temporally Extended Goals
                                  as Propositional Satisï¬ability
                    Robert MattmullerÂ¨                             Jussi Rintanen
                Albert-Ludwigs-UniversitÂ¨at                  National ICT Australia and
                   Institut fÂ¨ur Informatik                Australian National University
                    Freiburg, Germany                            Canberra, Australia
           mattmuel@informatik.uni-freiburg.de              Jussi.Rintanen@nicta.com.au

                    Abstract                          2001], and Metric Interval Temporal Logic (MITL) and Lin-
                                                      ear Temporal Logic (LTL) in TLPlan [Bacchus and Kabanza,
    Planning for temporally extended goals (TEGs)     1996; 2000]. Recently, the Planning Domain Deï¬nition Lan-
    expressed as formulae of Linear-time Temporal     guage (PDDL) has been extended to express state trajectory
    Logic (LTL) is a proper generalization of classi- constraints [Gerevini and Long, 2005]. Both TALplanner and
    cal planning, not only allowing to specify prop-  TLPlan are forward-chaining planners, pruning the search
    erties of a goal state but of the whole plan exe- space by progressing the temporal formula. Other approaches
    cution. Additionally, LTL formulae can be used    include compiling tasks including LTL goals into classical
    to represent domain-speciï¬c control knowledge to  tasks [Cresswell and Coddington, 2004; Baier and McIlraith,
    speed up planning. In this paper we extend SAT-   2006] before solving them by using a classical planner.
                    LTL                    LTL
    based planning for  goals (akin to bounded          Bounded model-checking [Biere et al., 1999; Latvala et al.,
    model-checking in veriï¬cation) to partially ordered 2004], which is an extension of the planning as satisï¬abil-
    plans, thus signiï¬cantly increasing planning efï¬- ity approach [Kautz and Selman, 1992], can be viewed as a
    ciency compared to purely sequential SAT plan-    SAT-based technique for planning with TEGs. Since the ef-
    ning. We consider a very relaxed notion of par-   ï¬ciency of SAT-based planning techniques is often strongly
                                      LTL
    tial ordering and show how planning for goals     dependent on the notion of partially ordered or parallel plans
    (without the next-time operator) can be translated [Kautz and Selman, 1996; Rintanen et al., 2006], extend-
    into a SAT problem and solved very efï¬ciently. The ing the SAT-based LTL model-checking/planning approach to
    results extend the practical applicability of SAT- parallel plans may in some cases be very critical to obtain efï¬-
    based planning to a wider class of planning prob- cient planning. The contribution of this paper is an encoding
    lems. In addition, they could be applied to solving of constraints that preserve the semantics of LTL formulae
    problems in bounded LTL model-checking more ef-   under parallel plans.
    ï¬ciently.                                           In Section 2 we give a formal description of the problem to
                                                      be solved. In Section 3 we present the propositional encod-
                                                      ing, in which we use the base encoding of planning as sat-
1  Introduction                                       isï¬ability [Kautz and Selman, 1992] reproduced in Section
In classical planning, a goal that an agent has to achieve is 3.1 and the translation of LTL formulae to propositional logic
simply a property of a goal state to reach. TEGs are speciï¬- [Latvala et al., 2004] reproduced in Section 3.2. Section 3.3
cations not only stating desired properties of a ï¬nal state but shows our adaption of the encoding of parallelism constraints
of a sequence of states, namely the execution of a plan sat- given in [Rintanen et al., 2006] to tasks with TEGs. Our ex-
isfying the speciï¬cation. Expressing these goals as formulae periments are described in Section 4.
of an adequate temporal logic, one can impose more precise
constraints on plans than one could with classical reachabil- 2 Planning for Temporally Extended Goals as
ity goals. So for instance it is possible to specify mainte-
nance goals (some property must be maintained indeï¬nitely), Propositional Satisï¬ability
goals stating how the agent should react to some environmen- 2.1 Problem Description
tal condition, and safety goals that impose a restriction on the
agentâ€™s behavior not to change certain properties of the world Notation
state while trying to achieve a reachability goal.    Let A be a set of propositional variables and Î¦ a proposi-
  In planning, temporal speciï¬cations are usually either re- tional or temporal formula. We write Lit(A) as a shorthand
garded as extended goals or as a means of encoding domain- for A âˆª{Â¬a | a âˆˆ A} and Lit(Î¦) instead of Lit(var(Î¦)),
speciï¬c search control knowledge used to guide the planner. where var(Î¦) is the set of variables in Î¦.IfLit is a set of lit-
                                                                      Î¦
Different formalisms have been used, e. g. Temporal Ac- erals, we write Lit := Lit âˆ© Lit(Î¦).IfÎ¦ is a propositional
tion Logics (TAL) in TALplanner [Doherty and KvarnstrÂ¨om, formula, then a occurs positively (negatively) in Î¦ iff there

                                                IJCAI-07
                                                  1966                                                                                            âˆ
is an occurrence of a in Î¦ nested within an even (odd) num- q[(iâˆ’b)mod(bâˆ’k)]+k, otherwise. Note that qÂ¯k is actually a
ber of negation signs. A negative literal Â¬a occurs positively path, i. e. consecutive states are related by â†’.AnLTLâˆ’X
(negatively) in Î¦ iff a occurs negatively (positively) in Î¦.A formula Ï• is valid along such a ï¬nite sequence qÂ¯, written as
literal  occurs in Î¦ if it occurs positively or negatively in Î¦. qÂ¯ |= Ï•,iffthereisak âˆˆ{0,...,bâˆ’ 1} such that qb = qk and
                                                       âˆ
We write pos(, Î¦), neg(, Î¦),andocc(, Î¦), respectively. qÂ¯k |= Ï•.
                                                        We make sure that there is a k âˆˆ{0,...,bâˆ’ 1} such that
Linear Temporal Logic
                                                      qb = qk by allowing idling in a ï¬nal state (enforcing it if there
In order to specify TEGs, we have to choose a speciï¬cation is no other loop).
language. Here we use propositional LTL [Emerson, 1990]
without next-time operator because it has a simple and well- Planning
deï¬ned semantics and it is sufï¬ciently expressive for many A planning task is a tuple P = A, I, O, Ï• ,whereA is a
qualitative TEGs.                                     ï¬nite set of Boolean state variables, I âˆˆ 2A is the initial state,
  The set of well-formed LTLâˆ’X formulae in negation nor- O is a ï¬nite set of operators, and Ï• is an LTLâˆ’X formula with
mal form over a set A of propositional variables (LTLâˆ’X variables in A. Operators have the form o = p, e, c ,wherep
formulae for short) is inductively deï¬ned as follows: for all is a propositional formula over A, the precondition of o, e is a
a âˆˆ A, a and Â¬a are LTLâˆ’X formulae. If Ï•, Ï•1,andÏ•2 are ï¬nite set of literals over A, the unconditional effects of o,and
LTLâˆ’X  formulae, so are Ï•1 âˆ§ Ï•2, Ï•1 âˆ¨ Ï•2, FÏ• (â€œeventually c is a ï¬nite set of pairs f  d, consisting of a propositional
Ï•â€), GÏ• (â€œalways Ï•â€), Ï•1UÏ•2 (â€œÏ•1 until Ï•2â€) and Ï•1RÏ•2 formula f and a ï¬nite set of literals d. These pairs are the
(â€œÏ•1 releases Ï•2â€).                                   conditional effects of o.
     LTL           Ï•      A                                                    o                  o
  An     âˆ’X formula   over  is evaluated along an inï¬-  The set of all effects of will be written as [ ]â™¦ :=
nite path in a state space over A. Formally, a Kripke model e âˆª {d | f  d âˆˆ c}, the set of unconditional effects as
M  =   Q, â†’,L  is a triple where Q is a set of states, o      e                                     q
                                                      [ ] :=   , and the set of active effects in a state as
â†’âŠ†   Q Ã— Q                              Q              o     e âˆª  {d | f  d âˆˆ c   q | f}
           is a reï¬‚exive binary relation over ,thetran- [ ]q :=                and  =    for a single oper-
sition relation, and L : Q â†’ 2A is a function assigning to
                                                      ator o and [S]q := oâˆˆS [o]q for a set S of operators.
each state a propositional valuation of the variables in A.A S                               q  q |  p
      M             Ï€  N â†’  Q               n âˆˆ N       Aset   of operators is applicable in a state if = for
path in  is a function :      such that for all   ,   all o âˆˆ S and [S] is consistent. We identify an operator
Ï€(n) â†’ Ï€(n +1).IfÏ€ is a path in M and i âˆˆ N, then the ith             q
           i                     i                    o with the singleton set {o}, thus o is applicable in q if its
sufï¬x of Ï€, Ï€ : N â†’ Q,isdeï¬nedasÏ€ (j):=Ï€(i  + j) for
all j âˆˆ N.                                            precondition is satisï¬ed and its active effects are consistent.
     k, b âˆˆ N k<b       Ï€   u Â· vÏ‰                    For a set S of operators, possibly singleton for sequential
  For       ,     ,apath  =       consisting of a ï¬nite                                    q         S
preï¬x u = Ï€(0),...,Ï€(kâˆ’1) and a loop v = Ï€(k),...,Ï€(bâˆ’ plans or empty to model idling, and a state such that is
                                 b, k                 applicable in q, the simultaneous application of S in q results
1), repeated inï¬nitely often, is called a ( )-loop. It is called q           q                       S
a b-loop if it is a (b, k)-loop for some k<b.         in the state obtained from by making the literals in [ ]q
                                                      true and leaving the other state variables unchanged. We then
               LTLâˆ’X         Ï•           Ï€
  The truth of an     formula  along a path , symbol-        S      o  
ically Ï€ |= Ï•, is now inductively deï¬ned as follows:  write qâˆ’â†’q (or qâˆ’â†’q if S = {o}). Let SÂ¯ = S0,...,Sbâˆ’1 
                                                      be a sequence of sets of operators and q0 a state such that
          Ï€ | a  â‡” a âˆˆ L Ï€
            =   :       ( (0))                           S0   S1    Sbâˆ’1
                                                      q0âˆ’â†’q1âˆ’â†’   ...âˆ’âˆ’âˆ’â†’qb is deï¬ned. Then the sequence of
         Ï€ | Â¬a  â‡” a/âˆˆ L Ï€
           =    :       ( (0))                        states exec(q0, SÂ¯):=q0,...,qb  is called the execution
    Ï€ |= Ï•1 âˆ§ Ï•2 :â‡” Ï€ |= Ï•1 and Ï€ |= Ï•2               of SÂ¯ in q0. Finally, let SÂ¯ = S0,...,Sbâˆ’1  be a sequence
                                                                         â‰º    â‰º  ,...,â‰º    
    Ï€ |= Ï•1 âˆ¨ Ï•2 :â‡” Ï€ |= Ï•1 or Ï€ |= Ï•2                of sets of operators, Â¯ =  0      bâˆ’1  a sequence of
                            i                         binary relations such that â‰ºt is a total ordering of St,say
        Ï€ |= FÏ• :â‡”âˆƒi  âˆˆ N : Ï€ |= Ï•                    o   â‰º  Â·Â·Â· â‰º  o             t âˆˆ{,...,bâˆ’    }     q
                                                       t,0  t     t  t,|St|âˆ’1,forall   0        1 ,and  0
                            i                                              o     o     o      o
        Ï€ | GÏ•   â‡”âˆ€i  âˆˆ N  Ï€  | Ï•                                           t,0 1 t,1 2 t,2    t,|St|âˆ’1
          =     :         :   =                       a state. Assume that qtâˆ’âˆ’â†’qt âˆ’âˆ’â†’qt âˆ’âˆ’â†’ ...âˆ’âˆ’âˆ’âˆ’âˆ’â†’qt+1
                            i                                             t   âˆˆ{,...,bâˆ’       }
     Ï€ |= Ï•1UÏ•2 :â‡”âˆƒi  âˆˆ N : Ï€ |= Ï•2 and               is  deï¬ned  for all           0        1 .Then
                                                                                            Â¯
                                       j              the   sequence   of   states  exec(q0, S,â‰ºÂ¯ ):=
                   âˆ€j âˆˆ{  ,...,iâˆ’  }  Ï€ |  Ï•1              1  2        1  2
                         0        1  :   =            q0,q0,q0,...,q1,q1,q1,...,q2,...,qbâˆ’1  is called a
                            i                                             SÂ¯  q
     Ï€ |= Ï•1RÏ•2 :â‡”âˆ€i  âˆˆ N : Ï€ |= Ï•2 or                linearized execution of in 0.
                                       j                A plan of length b for P = A, I, O, Ï•  is a tuple SÂ¯ =
                   âˆƒj âˆˆ{0,...,iâˆ’  1} : Ï€ |= Ï•1.
                                                      S0,...,Sbâˆ’1  with St âŠ†  O for all t âˆˆ{0,...,bâˆ’  1}
  If a given path Ï€ is a b-loop, the ï¬rst b states of Ï€ together together with a sequence â‰ºÂ¯ = â‰º0,...,â‰ºbâˆ’1  such that
with the value of k contain all the information needed to eval- (a) â‰ºt is a total ordering of St for all t âˆˆ{0,...,bâˆ’ 1}
uate Ï• along Ï€. In the following, all paths we will deal with and (b) qÂ¯ = exec(I,S,Â¯ â‰ºÂ¯ ) is deï¬ned and qÂ¯ |= Ï• in the Kripke
are of that type.                                     model induced by P.
  Let qÂ¯ = q0,...,qb  be a ï¬nite sequence of states such
that qi â†’ qi+1 for all i âˆˆ{0,...,bâˆ’ 1} and that there is 2.2 Reduction to Satisï¬ability
a k âˆˆ{0,...,bâˆ’  1} with qb = qk. In order to be able to Planning as satisï¬ability [Kautz and Selman, 1992] roughly
evaluate an LTLâˆ’X formula along qÂ¯, we consider an inï¬nite works as follows: given a planning task P = A, I, O, Ï• ,
unraveling of qÂ¯:Ifqb âˆˆ{q0,...,qbâˆ’1},sayqb = qk,let   propositional formulae Î¦0, Î¦1, Î¦2,... are generated such
 âˆ                  âˆ                       âˆ
qÂ¯k : N â†’ Q,whereqÂ¯k  (i)=qi,ifi<b,andqÂ¯k     (i)=    that there exists a plan of length b for P if Î¦b is satisï¬able.

                                                IJCAI-07
                                                  1967The Î¦b are evaluated by using a SAT solver. If Î¦b is unsatis- P = A, I, O, Ï•  be a planning task and b âˆˆ N.Then
ï¬able, the evaluation will proceed to Î¦b+1, otherwise a plan Pb  looptoAx  âˆ§ beforeAx âˆ§ uniqueAx  âˆ§
for P can be extracted from a satisfying valuation v for Î¦b. bmc :=        b           b          b
                                                                                 0
                                                                    inftyAx b âˆ§ Ï•b , where
                                                                                            
2.3  Solution Quality                                              bâˆ’1        
                                                       looptoAx b :=      lt â†’      (at â†” ab) ,
                          SÂ¯   S ,...,S                              t=0        aâˆˆA
The quality of a parallel plan = 0      bâˆ’1  can be                        bâˆ’1                      
                                         b
measured with respect to its parallel plan length or its se- beforeAx b := Â¬bef 0 âˆ§ bef t â†” (bef tâˆ’1 âˆ¨ ltâˆ’1) ,
                    bâˆ’1 |S |                                                 t=1
quential plan length t=0 t . We will focus on ï¬nding               bâˆ’1                         bâˆ’1
plans with a low parallel plan length because the size of the uniqueAx b := bef t â†’Â¬lt , inftyAx b :=  lt,
                                                                      t=0                          t=0
largest propositional formula to be considered for a given task
is roughly proportional to the parallel length of a plan corre- with fresh auxiliary variables lt, bef t, t âˆˆ{0,...,bâˆ’ 1}
sponding to a satisfying valuation. As SAT solver running (with the intended semantics that there is a loop from qbâˆ’1
                                                                                  
times grow exponentially in the formula size in the worst back to qt or back to some qt ,t <t, respectively). The
                                                                          0
case, obtaining small formulae is particularly important. recursive translation Ï•b of Ï• is deï¬ned as
                                                                         t<b                t  b
                                                                                            =
                                                             t                            bâˆ’1
3  Propositional Encoding                                 a             at                 (lj âˆ§ aj)
                                                             b                           j=0
                                                              t                          bâˆ’1
                                                          Â¬a           Â¬at                (lj âˆ§Â¬aj)
3.1  Base Encoding                                            b                         j=0
                                                                t        t      t     bâˆ’1             j
                             b                         Ï•1 âˆ§ Ï•2     Ï•1 âˆ§ Ï•2         (lj âˆ§ Ï•1 âˆ§ Ï•2 )
We ï¬rst give the base encoding P of the transition sys-       b        b      b   j=0              b
                             base                               t        t      t     bâˆ’1             j
                          P   A, I, O, Ï•              Ï•1 âˆ¨ Ï•2     Ï•1 âˆ¨ Ï•2         (lj âˆ§ Ï•1 âˆ¨ Ï•2 )
tem induced by a planning task =         for a bound            b        b      b     j=0            b
b                                                             t        t       t+1      bâˆ’1          j
 on the plan length ï¬rst proposed by [Kautz and Selman,  FÏ•       Ï• âˆ¨ FÏ•             (lj âˆ§FÏ•   )
                                                              b        b       b       j=0          b
1992], omitting the reachability goal formula:                t        t       t+1     bâˆ’1           j
                                                         GÏ•       Ï• âˆ§ GÏ•            (lj âˆ§GÏ•   )
                                                              b        b  
    b      j=0           b
                           bâˆ’1                                 t      t       t      bâˆ’1             j
                 b                                      Ï•1UÏ•2b   Ï•2b âˆ¨ Ï•1b âˆ§    j=0(lj âˆ§Ï•1UÏ•2   b)
              Pbase = I0 âˆ§     Rt,                                            
                              t=0                                    Ï• UÏ•  t+1
                                                                       1   
2 b     
                                                                t       t       t     bâˆ’1             j
where Rt is the conjunction of precondition axioms ot â†’ Ï•1RÏ•2     Ï•2 âˆ§  Ï•1 âˆ¨        lj âˆ§Ï•1RÏ•2  
                                                               b       b       b    j=0(            b)
pt, effect axioms ot â†’ et+1, conditional effect axioms                      t+1
                                                                    âˆ¨Ï•1RÏ•2b
       ((ot âˆ§ ft) â†’   dt+1) for all o = p, e, c âˆˆO,
 fdâˆˆc                                                    FÏ•   t  Ï•t âˆ¨FÏ•   t+1         âŠ¥
and positive and negative frame axioms (Â¬at âˆ§at+1) â†’        b        b       b
                                                          GÏ•   t Ï•t âˆ§GÏ•   t+1          
 oâˆˆO(ot âˆ§ (EPC a(o))t) and (at âˆ§Â¬at+1) â†’   oâˆˆO(ot âˆ§            b      b   
    b
 EPC    o                      a âˆˆ  A                   Ï• UÏ•    t Ï• t âˆ¨ Ï• t âˆ§          âŠ¥
(    Â¬a( ))t), respectively, for all . In the frame       1   2 b    2 b     1 b 
axioms, EPC (p, e, c ) is deï¬ned as ,if âˆˆ e,andas               Ï• UÏ•    t+1
                                                                       1  
2 b
 {f | f  d âˆˆ c and  âˆˆ d},otherwise.                           t      t       t
                                                        Ï•1RÏ•2   b Ï•2b âˆ§ Ï•1b âˆ¨          
  This encoding contains propositional variables at for all                     
                                                                     Ï• RÏ•    t+1
state variables a âˆˆ A and time points t âˆˆ{0,...,b} as                  1   2 b
well as ot for all operators o âˆˆ O and time points t âˆˆ                      Â·t
{ ,...,bâˆ’  }                              a           Notice that the translation b is closely related to the formula
 0        1  with the intended semantics that holds at                          [
         t   a                        o               progression procedures used in Bacchus and Kabanza, 2000;
time point iff t is true, and that operator is applied at Doherty and KvarnstrÂ¨om, 2001].
time point t iff ot is true. Where sets of variables or proposi-
                                t                       The following theorem states the correctness and com-
tional formulae are indexed with some , this actually denotes pleteness of the propositional translation. A slightly different
the sets or formulae with variables indexed correspondingly. formulation as well as a proof can be found in [Latvala et al.,
  The following theorem states the correctness of the propo- 2004].
sitional translation. A proof can be found in [Rintanen et al.,      P    A, I, O, Ï• 
2006].                                                Theorem 2.  Let   =            be a planning task and
                                                      b âˆˆ  N. Then there exists a sequence of sets of operators
Theorem  1. Let P  =  A, I, O, Ï•  be a planning task. SÂ¯ = S0,...,Sbâˆ’1  such that qÂ¯ = exec(I,SÂ¯) is deï¬ned and
                                                                            b        b
Then there exists a sequence of sets of operators SÂ¯ = qÂ¯ |= Ï• iff the formula Pbase âˆ§ Pbmc is satisï¬able.
S0,...,Sbâˆ’1  such that exec(I,SÂ¯) is deï¬ned iff the formula
   b                                                  3.3  Parallel Plans
Pbase is satisï¬able.
                                                      In this section we present our main contribution, being con-
3.2  Temporally Extended Goals                        straints which guarantee that the meaning of LTLâˆ’X formulae
                                                      is preserved under parallel plans, and a propositional encod-
In this subsection we reproduce the reduction of the bounded ing of these constraints.
LTL/LTLâˆ’X  model-checking problem to propositional satis- Theorem 2 tells us how to encode the requirement that
ï¬ability given in [Latvala et al., 2004], adding the constraint there is a sequence SÂ¯ such that exec(I,SÂ¯) |= Ï•.Butwe
that a satisfying sequence of states must contain a loop: let have not yet made sure that SÂ¯ is in fact a plan, i. e. there

                                                IJCAI-07
                                                  1968is a sequence â‰ºÂ¯ of corresponding total orderings such that its set of active effects for any t âˆˆ{0,...,bâˆ’ 1}.These
exec(I,S,Â¯ â‰ºÂ¯ ) |= Ï•. For such a sequence â‰ºÂ¯ toyieldanadmis- two possibilities are ruled out by condition (1.a.) together
sible linearization, it must ensure that (a) qÂ¯ = exec(I,S,Â¯ â‰ºÂ¯ ) with (1.b.i.) and (1.b.ii.) of Deï¬nition 2 respectively (see
is deï¬ned and if so, that (b) qÂ¯ |= Ï•. In order to state how this [Rintanen et al., 2006] for a detailed proof of that claim).
can be achieved, we need some deï¬nitions. The ï¬rst one and If exec(I,S,Â¯ â‰ºÂ¯ ) is deï¬ned, by using Lemma 3 it is sufï¬-
the subsequent lemma are due to [Lamport, 1983].      cient to show that exec(I,SÂ¯) âˆ¼ exec(I,S,Â¯ â‰ºÂ¯ ) in the Kripke
               Ï€    q ,q ,q ,...   Ï€   q , q , q ,... model M   =  Q, â†’,L ,whereQ    and â†’  form the state
Deï¬nition 1. Let =  0  1  2    and Ëœ =Ëœ0  Ëœ1 Ëœ2                                         var(Ï•)
be two inï¬nite (ï¬nite) paths in a Kripke model Q, â†’,L . space induced by P and L : Q â†’ 2     is deï¬ned by
                                                      L q    q âˆ© var Ï•
Then Ï€ and Ï€Ëœ are called stuttering equivalent, Ï€ âˆ¼ Ï€Ëœ for ( )=     ( ). To see that this is true, consider a sin-
short, if there are two inï¬nite (ï¬nite) sequences of natural gle time point t âˆˆ{0,...,bâˆ’ 1} ï¬rst. Let â‰ºt be the total
                                                                S          o   â‰º  Â·Â·Â· â‰º  o
numbers 0=i0   <i1  <i2  <  ...(<in)  and 0=j0   <    ordering of t and, say, t,0 t    t  t,|St|âˆ’1. Then the
j1 <j2  <  ...(<jn)  such that for all 0 â‰¤ k (<n):    subsequence of the linearized execution exec(I,S,Â¯ â‰ºÂ¯ )
L q       L q        ...    L q           L q
 ( ik )=   ( ik+1)=      =    ( ik+1âˆ’1)=   (Ëœjk )=                o     o    o       o
L q        ...   L q                                       Â·Â·Â·âˆ’â†’q âˆ’âˆ’t,â†’0 q1âˆ’âˆ’t,â†’1 q2âˆ’âˆ’t,â†’2 ...âˆ’âˆ’âˆ’âˆ’âˆ’t,|St|âˆ’â†’1 q âˆ’â†’ Â·Â·Â·
 (Ëœjk +1)=     =   (Ëœjk+1âˆ’1). A ï¬nite subsequence like          t     t     t                t+1
q ,q    ,...,q        Ï€   Ï€
 ik ik +1    ik+1âˆ’1 of  or Ëœ consisting of identically la-                                     exec I,SÂ¯
beled states is called a block.                       corresponds to the subsequence of the execution ( )

             Ï•      LTL            M    Q, â†’,L                              St
Lemma 3.  Let  be an    âˆ’X formula,   =          a                    Â·Â·Â·âˆ’â†’qtâˆ’â†’qt+1âˆ’â†’ Â·Â·Â·
Kripke model, where L : Q â†’ 2A for some A âŠ‡ var(Ï•), and
Ï€, Ï€Ëœ two inï¬nite (ï¬nite) paths in M with Ï€ âˆ¼ Ï€Ëœ.ThenÏ€ |= Ï• Note that condition (2.) of Deï¬nition 2 together with the fact
iff Ï€Ëœ |= Ï•.                                          that no operator affects an operator applied later in â‰ºt makes
                                                                  o â‰º  o  o Ï• âŠ†  o Ï•
  The following deï¬nition, adapted from a similar one by sure that for t , [ ]â™¦   [ ] holds and thus all ef-
                                                              St             Ï•
[Rintanen et al., 2006], is crucial for the rest of this section fects in [ ]qt relevant to , i. e. those effects concerning
                                                                          Ï•             o
in that it describes under which circumstances an operator o a variable occurring in , are effects of t,0. Therefore, the
                                                             o   ,...,o
may or may not be applied before an operator o in a lin- operators t,1 t,|St|âˆ’1 do not have an additional effect
                                                                               1       2
earization â‰º of a set of operators S if one wants to ensure on the labeling L. Thus, L(qt )=L(qt )=... = L(qt+1),
                                                           1  2
that for all time points t the application of St in qt in the or- and qt ,qt ,...,qt+1 form one block of the stuttering equiv-
dering given by â‰ºt is deï¬ned in the ï¬rst place, and if so, that alence of exec(I,S,Â¯ â‰ºÂ¯ ) and exec(I,SÂ¯). The corresponding
exec(I,S,Â¯ â‰ºÂ¯ ) |= Ï•.                                 block in exec(I,SÂ¯) is the singleton {qt+1}. The other blocks
                                                      are constructed analogously.
Deï¬nition 2. Let P = A, I, O, Ï•  be a planning task and
o   p, e, c ,o p,e,c âˆˆO.Theno affects o iff o  o
 =           =                                 =        The next step is to ï¬nd a propositional formula encoding
and either (1.) there is a literal  over A such that (a.)  âˆˆ [o]â™¦                                     
                                                 the condition that at no time point t any two operators o, o
and (b.) (i.) neg(, p ) or (ii.) occ(, f ) for some f  d âˆˆ c , o   o    o â‰º  o
      o Ï• \ o Ï•  âˆ…                                  such that affects and    t   can be applied simultane-
or (2.) [ ]â™¦ [ ] = .                                 ously. For that purpose we deï¬ne the notion of a disabling
          Ï•                                                                                  P
  Here, [o ]â™¦ is the restriction of [o ]â™¦,i.e. ofthesetof graph [Rintanen et al., 2006] for a planning task .
                                          
all conditional and unconditional effect literals of o , to those Deï¬nition 3. Let P = A, I, O, Ï•  be a planning task. A
literals occurring (positively or negatively) in Ï•. Similarly, directed graph G = O, E ,whereE âŠ† O Ã—O,isadisabling
   o  p, e, c  o Ï• e âˆ© Lit Ï•                                                          
for =        , [ ] =     ( ).                        graph for P if E contains all edges (o, o ) such that (1.) there
  The cases correspond to different problems that can poten-  q              I                O         o
                                                     is a state reachable from with operators in in which
tially arise if o is applied before o in a linearization, namely and o are simultaneously applicable and (2.) o affects o.
to o falsifying the precondition of o [(1.a.) + (1.b.i.)], o af-
                            o                   o      Let St be a set of operators. If the subgraph Gt = St,Et ,
fecting the set of active effects of [(1.a.) + (1.b.ii.)], and E E âˆ© S Ã— S                 G    O, E 
and o putting at risk the stuttering equivalence of exec(I,SÂ¯) t = ( t t), of a disabling graph =    for
                                                      P induced by St is acyclic, then there is an ordering â‰ºt of
and exec(I,S,Â¯ â‰ºÂ¯ ) [(2.)]. The deï¬nition gives rise to a condi-                               
                                                      St in which there are no two operators o â‰ºt o with o af-
tion on the admissibility of a sequence â‰ºÂ¯ of total orderings. 
                                                      fecting o . In fact, â‰ºt can be an arbitrary topological or-
             P     A, I, O, Ï•                SÂ¯                    âˆ’1
Lemma 4.  Let   =            be a planning task, =    dering of St,Et  . As the strongly connected components
S0,...,Sbâˆ’1  a sequence of sets of operators such that (SCCs) of a directed graph form a directed acyclic graph, in-
exec I,SÂ¯ | Ï•     â‰º    â‰º ,...,â‰º    
    (   ) =  , and Â¯ =   0      bâˆ’1  a sequence such  stead of ensuring the acyclicity of Gt, it is sufï¬cient to ensure
that â‰ºt is a total ordering of St for all t âˆˆ{0,...,bâˆ’ 1}.                          G
                                                    the acyclicity of the subgraphs of t induced by the SCCs
If there are no operators o, o âˆˆ St such that o affects o and C G    Gi    Si,Ei        Si   S  âˆ© C
                                                       i of ,i.e. of t =    t  t ,where  t =   t   i and
o â‰ºt o       t âˆˆ{ ,...,bâˆ’  }     SÂ¯            â‰ºÂ¯       i         i    i
      for any    0        1 ,then  together with is   Et = Et âˆ© (St Ã— St ). This can be achieved as follows:
        P
aplanfor  .                                             Let G = O, E  be a disabling graph, C = {C1,...,Cm}
                                                                        G      â‰ºi
Proof sketch. We have to show that exec(I,S,Â¯ â‰ºÂ¯ ) is deï¬ned the set of SCCs of ,and an arbitrary total ordering
                                                         Ci     {oi ,...,oi  }       i  âˆˆ{,...,m}
   exec I,S,Â¯ â‰º | Ï•                                   of     =     1      |Ci| for all      1       ,say
and    (     Â¯ ) = . As argued in [Rintanen et al., 2006], i      i           1      n
                                                      oi  â‰º  Â·Â·Â· â‰º oi        o ,...,o  âˆˆ O  E,R  âŠ† O
in order to show that exec(I,S,Â¯ â‰ºÂ¯ ) is deï¬ned, it sufï¬ces to 1     |Ci | .For            ,          and
show that no operator o âˆˆ St can disable another operator  âˆˆ Lit(A), we deï¬ne formulae stating that there are no
                                                               1     n
o âˆˆ St by potentially falsifying its precondition or altering oi,oj âˆˆ{o ,...,o },i < j, such that oi âˆˆ E,oj âˆˆ R,and

                                                IJCAI-07
                                                  1969oi,oj are applied simultaneously (intuitively, operators in E in Remark 1 form such a sequence. Thus, the precondition
can disable operators in R wrt ):                    of Lemma 4 is satisï¬ed and it follows that SÂ¯ together with â‰ºÂ¯
      1     n                                         is a plan for P, and in particular that exec(I,S,Â¯ â‰ºÂ¯ ) is deï¬ned
chain(o ,...,o ; E; R; ):=                                      Â¯
^Ë˜                                               Â¯    and exec(I,S,â‰ºÂ¯ ) |= Ï•.
   oi â†’ aj, | i<j,oi âˆˆ E,oj âˆˆ R, {oi+1,...,ojâˆ’1}âˆ©R = âˆ…
  Ë˜                                              Â¯
 âˆª ai, â†’ aj, | i<j,{oi,oj }âŠ†R, {oi+1,...,ojâˆ’1}âˆ©R = âˆ… 4  Experiments
  Ë˜               Â¯
 âˆª ai, â†’Â¬oi | oi âˆˆ R ,                               4.1  Setting

          i,                                         We compared the cumulative SAT solver running times un-
where the a  are fresh auxiliary variables. Now, the nega- til the ï¬rst satisï¬able formula for (a.) the parallel encoding
tion of (1) in Deï¬nition 2 translates to the conjunction of
chain                                           Ï•     described in Section 3 and (b.) a sequential encoding derived
     formulae for all time points, SCCs, and literals in , from the parallel one by replacing the parallelism constraints
if we use the following sets E,R:
                                                      by axioms demanding at most one operator per time point.
 E := {o âˆˆ O |  âˆˆ [o]â™¦ } and                        The evaluation of the formulae corresponding to increasing
                                                      plan lengths was performed sequentially. Additionally, we
 R := {p, e, c âˆˆO | pos(, p) or ex. f  d âˆˆ c s. t. occ(, f)}.
                                                      compared the (parallel) plan lengths of the resulting plans.
Similarly, the negation of (2) in Deï¬nition 2 translates to the We used two types of planning tasks. First, we considered
            chain                    Eâˆ¼,Râˆ¼
conjunction of    formulae with the sets   :        a simple hand-crafted logistics-like transportation task with
   âˆ¼                         âˆ¼                        three portables and trucks each. The goal was to ï¬nd an in-
 E  := {o âˆˆ O | /âˆˆ [o] } and R := {o âˆˆ O |  âˆˆ [o]â™¦ }.
                                                     ï¬nite plan assuring that the portables are shipped back and
So, the parallelism constraints can be encoded in the formula forth between two locations indeï¬nitely.
  The goal formula
               "                                                        2         3
          b^âˆ’1 ^m  ^                                  we used was Ï• =   j=1 GF    i=1 at(pi, dij) ,wherethe
     b
  Plin :=            chain(oi ,...,oi ; E; R; )t pi                  dij
                              1     |Ci|                are portables and the are locations.
          t=0 i=1 âˆˆLit(A)                              The other tasks were adapted from the 2006 International
                                              #
               ^                                      Planning Competition. We modiï¬ed the qualitative prefer-
                                      âˆ¼  âˆ¼  Ëœ
           âˆ§       chain(oi ,...,oi ; E ; R ; )t .
                          1      |Ci|                 ences tasks from the rovers domain by turning the soft tem-
             âˆˆLit(Ï•)                                 poral constraints (preferences) into hard constraints and by
                                                      ignoring the metric function. When changing soft into hard
Remark 1. If the valuation corresponding to a sequence of
              SÂ¯   S ,...,S            Pb          constraints, it turned out that it was necessary to drop some
sets of operators =  0      bâˆ’1  satisï¬es  lin ,then  of them in order to keep the tasks solvable. This was done by
for all time points t and SCCs Ci of the disabling graph                       Îº
G   O, E                        Pb                 drawing uniformly at random constraints for each task and
  =       used in the construction of lin , all subgraphs only retaining the ones drawn.2 The constraints were trans-
Gi    Si,Ei           1
 t =    t  t are acyclic. As the SCCs form an acyclic lated to LTLâˆ’X as explained in [Gerevini and Long, 2005].
                            â‰º     C
graph, there is a total ordering C on such that for all Unlike the ï¬rst task above, the rovers tasks lacked explicit
i, j âˆˆ{1,...,m} with Ci â‰ºC Cj,therearenoo âˆˆ  Ci and                           3
                               i                    nesting of temporal operators and could, if solvable at all, be
o âˆˆ Cj such that (o, o ) âˆˆ E.SinceGt is acyclic, there is a solved by plans always yielding ï¬nite executions, apart from
             i     i
total ordering â‰ºt of St for each t âˆˆ{0,...,bâˆ’ 1} and i âˆˆ inï¬nite idling in a ï¬nal state. The reachability goals speci-
                                    i
{1,...,m} (consistent with the ordering â‰º used in the con- ï¬ed in the problem deï¬nitions were required to hold in such
             b                           
struction of Plin ) such that there is no pair o, o âˆˆ Ci with a ï¬nal state.
                i                i
(o, o ) âˆˆ E and o â‰ºt o . The relations â‰ºt, i âˆˆ{1,...,m}, The SAT solver we used was SIEGE V. 4 [Ryan, 2004].The
and â‰ºC can be combined lexicographically, resulting in an or- experiments were run on a PC with 1.8 GHz AMD ATHLON
dering â‰ºt of St. It follows that there is no t âˆˆ{0,...,bâˆ’ 1} 64 CPU, 768 MB RAM, and a LINUX operating system.
                                       
and no o, o âˆˆ St such that o affects o and o â‰ºt o .
  The following theorem combines the conclusions from 4.2  Results
Theorem 2 and Lemma 4 with the above Remark.          Table 1 contains results from the logistics task and the modi-
                                                                       Îº
Main Theorem.  Let P =  A, I, O, Ï•  be a planning task ï¬ed rovers tasks for =3.
               b        b        b                      The second and third columns show the size M of the
and b âˆˆ N.IfPbase âˆ§ Pbmc âˆ§ Plin is satisï¬able, then
there is a plan of length b for P.                    largest SCC of the computed disabling graph compared to its
                                                      overall number of nodes |O|. The fourth column shows the
Proof sketch. From Theorem 2 we know that there exists a parallel plan lengths bp obtained with our parallel encoding,
sequence of sets of operators SÂ¯ = S0,...,Sbâˆ’1  such that compared to sequential plan lengths bs in column ï¬ve. Where
qÂ¯ = exec(I,SÂ¯) is deï¬ned and qÂ¯ |= Ï•. In order to be able to an interval (m, n] is given, the shortest sequential plan has
use Lemma 4, we still need a sequence â‰ºÂ¯ = â‰º0,...,â‰ºbâˆ’1  length m<bs â‰¤ n, but we could not precisely determine bs
of corresponding total orderings such that there is no time because of SAT solver running times exceeding our time-out
                                  
point t âˆˆ{0,...,bâˆ’ 1} and no pair o, o âˆˆ St of operators
                                                       2   Îº =3
with o affecting o and o â‰ºt o . The orderings â‰ºt constructed For , the tasks r-03, r-05 and r-15 remained unsolvable.
                                                         3There is an implicit nesting of depth two to three in the tem-
  1We will not formally prove this here. A similar proof can be poral operators sometime-after, sometime-before and
found in [Rintanen et al., 2006].                     at-most-once.

                                                IJCAI-07
                                                  1970