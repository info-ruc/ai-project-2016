                           Observation Reduction for Strong Plans

                     Wei Huang1, Zhonghua Wen1,       2, Yunfei Jiang1, Lihua Wu1
             1. Software Research Institute, School of Information Science and Technology,
                               Sun Yat-sen University, Guangzhou, China
              2. College of Information Engineering, Xiangtan University, Xiangtan, China
                                  Email: huangbodao@yahoo.com.cn

                    Abstract                          are optional and many of them are useless in the executions
                                                      of the plans; on the other side, information acquisition may
    Strong planning under full or partial observability require some kind of cost (e.g. time, money, and power etc.).
    has been addressed in the literature. But this re- So it is signiï¬cant to ï¬nd a minimal set of observation vari-
    search line is carried out under the hypothesis that ables that are necessary for the execution of a plan, and to
    the set of observation variables is ï¬xed and compul- best of our knowledge, it is still an open problem.
    sory. In most real world domains, however, obser-   In this paper we present a ï¬rst attempt to solve the problem.
    vation variables are optional and many of them are Under the hypothesis that any two distinct states of the do-
    useless in the execution of a plan; on the other side, main can be distinguished by an observation variable at least,
    information acquisition may require some kind of  we deï¬ne an algorithm that ï¬nds an approximate minimal set
    cost. So it is signiï¬cant to ï¬nd a minimal set of
                                                      (written as Vobs) of observation variables that are necessary
    observation variables which are necessary for the for the execution of a strong plan under full observability (i.e.
    execution of a plan, and to best of our knowledge, a state-action table), and transforms the plan into a strong plan
    it is still an open problem. In this paper we present under partial observability (i.e. a conditional plan branching
    a ï¬rst attempt to solve the problem, namely, we de-
                                                      on the observations built on Vobs). This algorithm ï¬rst ex-
    ï¬ne an algorithm that ï¬nds an approximate minimal ploits the belief state [Bonet and Geffner, 2000] (i.e. the set
    set of observation variables which are necessary for
                                                      of possible current states) at every step to compute Vobs; then,
    the execution of a strong plan under full observabil- it transforms the given stateâ€“action table into a conditional
    ity (i.e. a stateâ€“action table); and transforms the
                                                      plan branching on the observations built on Vobs. The algo-
    plan into a strong plan under partial observability rithm is based on the frameworks for strong planning under
    (i.e. a conditional plan branching on the observa- full observability proposed in [Cimatti et al., 2003] and par-
    tions built on these observation variables).      tial observability proposed in [Bertoli et al., 2006].
                                                        The paper is organized as follows. We ï¬rst recap the frame-
1  Introduction                                       works proposed in [Cimatti et al., 2003] and [Bertoli et al.,
                                                          ]
In recent years, increasing interest has been devoted to plan- 2006 (Section 2); then, we introduce the key notions of the
ning in nonâ€“deterministic domains. Strong planning (i.e. algorithm and describe the algorithm in detail (Section 3); ï¬-
ï¬nding automatically a plan which is guaranteed to achieve nally, Section 4 draws some conclusions and discusses future
the goal regardless of nondeterminism) is an important prob- research directions.
lem in this research ï¬eld. Under full observability or partial
observability, this problem has been addressed in the litera- 2 Domains, Observations, Plans, and
ture: in the frame for full observability proposed in [Cimatti Problems
et al., 1998b; 2003], a plan is a state-action table; in the frame
for partial observability proposed in [Bertoli et al., 2001; In this section, we brieï¬‚y review some deï¬nitions of strong
2006], a plan is a conditional plan branching on the values planning in non-deterministic domains under full observabil-
of observation variables.                             ity and partial observability that are relevant to our work. Fur-
  The cases of full observability, see e.g., [Cimatti et al., ther details and examples of these deï¬nitions can be found in
                                                      [                                 ]
1998b; 2003], where the whole status of the domain is ob- Cimatti et al., 2003; Bertoli et al., 2006 .
served at every step, and the cases of partial observability, see A planning domain is a model of a generic system with its
e.g., [Boutilier, 2002; Eiter et al., 2003; Herzig et al., 2003; own dynamics.
Bertoli et al., 2001; 2006], where the plan executor cannot Deï¬nition 1 A planning domain is a tuple Î£=S, A, R,
access the whole status of the domain, are both under the where S is a ï¬nite set of states, A is a ï¬nite set of actions, and
assumption that the set of observation variables is ï¬xed and R : SÃ—Aâ†’2S is the transition function. The transition
compulsory. In real world domains (e.g., many robotics, con- function associates to each state s âˆˆSand to each action
trol, and scheduling domains), however, observation variables a âˆˆAthe set R(s, a) âŠ†Sof next states.

                                                IJCAI-07
                                                  1930  The set of actions that are applicable in state s is ACT(s)= +,-
                                                           4
{a|âˆƒs âˆˆR(s, a)}.
  In practice, a domain may have many observation vari-   5
ables, whose value can be observed at runâ€“time.          +    6+     6,     6-       6+             6,
Deï¬nition 2 Let Î£=S, A, R be a planning domain. Let V
be a ï¬nite set of observation variables.Anobservation func-
tion over S and V is a function X : SÃ—Vâ†’{, âŠ¥}.          ,    6.     6/     60       6.            6/
  From Deï¬nition 2, for each state, there is a corresponding
complete set of assignments to observation variables.
  Plans can control the evolutions of the domain by trigger- - 61    62     63       61            62
ing actions. A plan under full observability is a set of stateâ€“
action pairs.
Deï¬nition 3 A plan Ï€F for Î£ is a set of pairs s, a (i.e. a Figure 1: A simple domain and the execution structure in-
                       s âˆˆS  a âˆˆ     (s)
stateâ€“action table), where: ,    ACT   , and there is duced by Ï€F from I
at most one action a such that s, aâˆˆÏ€F for any state s.
  The execution of a stateâ€“action table Ï€F in Î£ can be rep-
resented as execution structure, i.e. a directed graph in which In the following example, we illustrate the deï¬nitions given
the nodes are all of the states of the domain that can be in this section.
reached by executing actions in the stateâ€“action table, and Example 1 A simple robot navigation domain Î£ is
the arcs represent possible state transitions caused by actions
  Ï€                                                   shown on the left of Figure 1.  The robot can be in
in F .                                                nine positions of a room, corresponding to the states
Deï¬nition 4 Let Ï€F be a stateâ€“action table for Î£.Theex- of the domain: S  =   {s0,...,s8}.Itcanmove
ecution structure induced by Ï€F from the set of initial states in the four directions, corresponding to actions A =
IâŠ†Sis a tuple K = Q, T,whereQâŠ†Sand     TâŠ†SÃ—S        {GoNorth, GoSouth, GoEast,GoWest}. Anactionisap-
are the minimal sets satisfying the following rules:  plicable only if there is no wall in the direction of mo-
                                                               R(s0, GoSouth)=âˆ…
 1. if s âˆˆI,thens âˆˆQ, and                             tion, e.g.                   . All the actions are de-
                                                      terministic (e.g., R(s7, GoWest)={s6}), except for ac-
 2. if s âˆˆQand there exists a stateâ€“action pair s, aâˆˆÏ€F GoEast           s0     s3
                                                   tion        when on     (or   ), where the robot may
    such that s âˆˆR(s, a),thens âˆˆQand T (s, s ).       slip and end up either in s1 or s4 (or in s1, s4,ors7),
A state s âˆˆQis a terminal state of K if there is no s âˆˆQ i.e. R(s0, GoEast)={s1,s4} and R(s3, GoEast)=
                                                     {s1,s4,s7}        I   =   {s0,s3}      G  =   {s6}
such that T (s, s ).Apath of K from s0 âˆˆIis a possi-            .Let                    and             .
                                                           Ï€   =  {s0, GoEast, s1, GoSouth, s3, GoEast,
bly inï¬nite sequence s0,s1,... of states in Q such that, for Then F
                                                      s4, GoSouth, s7, GoWest}                  P  =
every state si in the sequence, either si is the last state of                    is a strong plan to
                                                      Î£, I, G                      K
the sequence (in which case si is a terminal state of K)or    , and its execution structure is shown on the right
T (si,si+1) holds.                                    of Figure 1.
                                                        Suppose that the sensors of the robot can detect walls in
  A planning problem for a given domain is described by a
                                                      the current position. This can be formalized with four obser-
set of possible initial states, and a set of goal states.
                                                      vation variables, i.e. WallN, WallS, WallW and WallE.
Deï¬nition 5 Let Î£=S,  A, R be a planning domain. A  In addition, there are six responders (i.e. X0, X1, X2, Y0,
planning problem for Î£ is a triple P = Î£, I, G,whereIâŠ† Y1, and Y2) located at the north or west border of the room.
S and GâŠ†S.                                            They work as the Xâ€“axis and Yâ€“axis of the nine positions (let
                                                      1 â‰¤ n â‰¤ 3
  In the following discussion, Î£=S, A, R, V, X , P =         ):
Î£, I, G, Ï€F ,andK represent a planning domain, a ï¬nite set 1. The robot sends n pulses north (or west) via the ground.
of observation variables, an observation function over S and
                                                                        X        Y            n
V, a planning problem for Î£, a stateâ€“action table for Î£,and 2. If the responder nâˆ’1 (or nâˆ’1) receives pulses then
the execution structure induced by Ï€F from I, respectively. it sends a responsive pulse south (or east), else it does
  In many cases, we are interested in strong solutions to P, nothing.
i.e. plans that are guaranteed to achieve the goal in spite of 3. The robot can detect whether its X-coordinate (or Y-
nondeterminism.                                           coordinate) is n by receiving a responsive pulse or not
Deï¬nition 6 Ï€F is a strong solution to P if K is acyclic and in a appointed time.
                 K       G
all terminal states of are in .                       This   can   be  formalized  with   six  observation
  In fact, any stateâ€“action table Ï€F for Î£ is a strong solution variables, i.e. X0, X1, X2, Y 0, Y 1  and
to some planning problems for Î£, if its execution structure Y 2. So the set of observation variables V is
K is acyclic and all terminal states of K are in G.Soin {WallN, WallS, WallW, WallE, X0,X1,X2,Y0,Y1,
the following discussion, we use interchangeably the terms Y 2}; and the observation function X is such that
strong solution and strong plan.                      X (s0, WallE)=âŠ¥,  X (s2,X2) = , and so on.

                                                IJCAI-07
                                                  19313  Observation Reduction for Strong Plans               â€¢ Îµ âˆˆ Î , Îµ is the empty plan;
In most real world domains, observation variables are op- â€¢ if a âˆˆAand Ï€ âˆˆ Î ,thena â—¦ Ï€ âˆˆ Î ;
tional and many of them are useless in the execution of a plan
                                                        â€¢ if o   âˆˆO(V,    X ),  and  Ï€1,Ï€2   âˆˆ   Î ,then
(e.g. consider the situation represented in Example 1, the re-
                                                          if o then Ï€1 else Ï€2 âˆˆ Î .
sponder X2 can be turned off before the execution of Ï€F );
on the other side, information acquisition may require some In general, we are interested in applicable plans, i.e. plans
kind of cost (e.g. time, money, and power etc.). So it is sig- whose execution guarantees that an action is never attempted
niï¬cant to ï¬nd a minimal set of observation variables which unless it is applicable, regardless of nondeterminism.
are necessary for the execution of a plan.            Deï¬nition 8 AplanÏ€ for Î£, V, Xis applicable in state s iff
  In this paper, it is assumed that any two distinct states of either
the domain can be distinguished by an observation variable
                                                        â€¢ Ï€ is the empty plan Îµ;or
at least. So stateâ€“action tables are acceptable at execution
                                                                                          
level. In the execution of a stateâ€“action table Ï€F , the execu- â€¢ Ï€ is a â—¦ Ï€ , a is applicable in s, and Ï€ is applicable in
                                                                
tor is required to observe the values of all the observation every s âˆˆR(s, a);or
variables; consequently, it can know what the current state â€¢ Ï€ is if o then Ï€1 else Ï€2, and:
is and execute the appropriate action at every step. But in
                                                            â€“ if the formula CODE(s, V, X ) â†’ o is a tautology,
many cases, there is much observation information that is     Ï€               s
useless in the execution of a plan. For example, it makes no    1 is applicable in ; and
sense to observe the value of an observation variable v,where â€“ if the formula CODE(s, V, X ) â†’Â¬o is a tautology,
X (s, v)= (or X (s, v)=âŠ¥) for any possible current state     Ï€2 is applicable in s.
s (hereafter, B denotes the set of possible current states, i.e. The execution of a conditional plan is deï¬ned in terms
the current belief state); and there is no need to do any de- of the runs associated to it. Intuitively, a run contains the
tection if there exists a âˆˆAsuch that s, aâˆˆÏ€F for any states, observations and actions encountered while executing
s âˆˆB.                                                 the plan.
  In this section, we deï¬ne an algorithm that ï¬nds an approx-
                                        V             Deï¬nition 9 A run is a sequence Ïƒ =(s0,o0) â—¦ a1 â—¦ (s1,o1) â—¦
imate minimal set of observation variables (i.e. obs)which ... â—¦ a â—¦ (s ,o )  s  âˆˆS    o  âˆˆO(V,  X )
are necessary for the execution of a strong plan, and trans- n    n  n ,where  i     ,  i           , and
                                                      ai âˆˆA. A sequence Ïƒ is a run of Ï€ (Ï€ is a conditional plan
forms the strong plan into a conditional plan branching on Î£, V, X       s
the observations built on these observation variables. Before for ) from state iff either
explaining the algorithm in detail, we introduce some notions â€¢ Ï€ = Îµ, and Ïƒ =(s, o) with o = CODE(s, V, X );or
used in it.                                             â€¢ Ï€  =  a â—¦ Ï€1 and  Ïƒ =(s, o)  â—¦ a â—¦ Ïƒ1 with o =
                    Ï€
  In the execution of F , the action that should be exe-  CODE(s, V, X ), and Ïƒ1 is a run for Ï€1 from some s1 âˆˆ
        s                    (s, Ï€ )
cuted on  is written as ACTION   F .Thatistosay,          R(s, a) = âˆ…;or
if âˆƒa âˆˆA.  s, aâˆˆÏ€F   then ACTION(s, Ï€F )=a,else
                                                        â€¢ Ï€  =  if o then Ï€1 else  Ï€2   ODE(s, V, X ) â†’ o
ACTION(s, Ï€F )=nop  (nop means doing nothing).                                       , C
                                                                             Ïƒ            Ï€1
  Let âˆ…âŠ‚Vobs   âŠ†V. For each  s âˆˆS,werepresentthe          is a tautology, and  is a run of   starting from
                                                          (s,     (s, V, X ))
corresponding set of assignments to the observation variables CODE         ;or
of Vobs with CODE(s, Vobs, X ),where:                   â€¢ Ï€  = if o then Ï€1  else Ï€2, CODE(s, V, X ) â†’Â¬o
                                                                             Ïƒ            Ï€
  â€¢ if Vobs   =   {v}   and X (s, v)=,then               is a tautology, and  is a run of 2 starting from
                                                          (s,     (s, V, X ))
    CODE(s, Vobs, X )=v.                                     CODE          .
                                                                                    (s, Ï€)
  â€¢ if Vobs   =   {v}   and X (s, v)=âŠ¥,then             In the following, we write RUNS  to denote the set of
                                                             Ï€            s                       (s, Ï€)
    CODE(s, Vobs, X )=Â¬v.                             runs of  starting from . We write FINALSTATES    to
                                                      indicate the set of the ï¬nal states of the runs of RUNS(s, Ï€).
  â€¢ if |Vobs| > 1 and v âˆˆVobs,then
                                                        The deï¬nition of strong plans to P, V, Xis given as fol-
    CODE(s, Vobs, X )=CODE(s,           {v}, X ) âˆ§
                                                      lows. In fact, it is similar to the one proposed in [Bertoli et
    CODE(s, Vobs âˆ’{v}, X ).
                                                      al., 2006].
The above representation naturally extends to any âˆ…âŠ‚QâŠ†S
                                                      Deï¬nition 10 A conditional plan Ï€ for Î£, V, X is a strong
as follows:                                                 P, V, X
                                                     plan to        iff
      CODE(Q,  Vobs, X )=    CODE(s, Vobs, X )          â€¢ Ï€ is applicable in every state of I, and
                         sâˆˆQ                            â€¢ every run of Ï€ from a state in I ends in G,i.e.
The set of observations built on V and X is O(V, X )=       sâˆˆI FINALSTATES(s, Ï€) âŠ†G.
{CODE(Q, Vobs, X ) |âˆ…âŠ‚QâŠ†S,   âˆ…âŠ‚Vobs  âŠ†V}.
                                           O(V, X )     Now we can introduce the algorithm for observation reduc-
  The deï¬nition of conditional plans branching on     tion of strong plans in detail.
is given as follows. In fact, it is an extension of the one pro- The basic algorithm (i.e. STRONGâ€“FOâ€“PO) is presented
posed in [Bertoli et al., 2006].
                                                      in Figure 2. Given a planning problem P, a strong plan Ï€F to
Deï¬nition 7 The set of conditional plans Î  for Î£, V, X is P, a ï¬nite set of observation variables V, and an observation
the minimal set such that:                            function X , the algorithm transforms Ï€F into a strong plan

                                                IJCAI-07
                                                  1932     1.   function STRONGâ€“FOâ€“PO(P,Ï€F   , V, X)               1.  function REDUCTION(dis, V, X )
     2.     dis â† FINDSTATEPAIRS(P,Ï€F  );                          // Suppose V = {v1,...,vn}
     3.     Vobs â† REDUCTION(dis, V, X );                    2.    for n â‰¥ i â‰¥ 1 do di[i] â† 0;
     4.     return TRANSFORM(P,Ï€F  , Vobs, X );              3.    for all (s1,s2) âˆˆ dis
     5.   end                                                4.      for n â‰¥ i â‰¥ 1
                                                             5.        if (X (s1,vi) = X (s2,vi)) then
                                                                         di[i] â† di[i]+1
         Figure 2: STRONGâ€“FOâ€“PO algorithm                    6.                        ;
                                                             7.        ï¬;
                                                             8.      endfor;
     1.  function FINDSTATEPAIRS(P,Ï€F )                      9.    endfor;
           // Suppose P = Î£, I, G                         10.    Vobs â†âˆ…;
     2.    parts â† DIVIDE(I,Ï€F );                           11.    while (dis = âˆ…)
     3.    if (parts = âˆ…) then                              12.      let di[i]=max{di[k] | n â‰¥ k â‰¥ 1};
     4.      return âˆ…;                                      13.      Vobs â†Vobs âˆª{vi};
     5.    ï¬;                                               14.      for all (s1,s2) âˆˆ dis
     6.    dis â†âˆ…;                                          15.        if (X (s1,vi) = X (s2,vi)) then
     7.    for each (a, Q) âˆˆ parts                          16.           delete (s1,s2) from dis;
     8.      Inext â† EXECUTE(Î£,  Q,a);                      17.        ï¬;
               
     9.      P  â†Î£,  Inext, G;                            18.      endfor;
                                          
    10.      dis â† dis âˆª FINDSTATEPAIRS(P  ,Ï€);             19.      di[i] â† 0;
    11.    endfor;                                          20.    endwhile;
    12.    if (Iâˆ©G= âˆ…) then                                21.    return Vobs;
    13.      parts â† parts âˆª{(nop, Iâˆ©G)};                   22.  end
    14.    ï¬;
                  (a , Q ) (a , Q ) âˆˆ parts
    15.    for any  1  1 ,  2  2        ,                        Figure 4: REDUCTION procedure.
              where a1 = a2
    16.      for any s1 âˆˆQ1, s2 âˆˆQ2
               dis â† dis âˆª{(s ,s )}
    17.                      1  2  ;                      empty set is returned by FINDSTATEPAIRS.
    18.      endfor;                                    â€¢                                dis
    19.    endfor;                                        Third (lines 6â€“11), the elements of corresponding
    20.    return dis;                                    to the next belief state are computed by simulating the
    21.  end                                              strong planâ€™s execution for one step and an application
                                                          of FINDSTATEPAIRS  itself. The simulation of a plan
                                                          is realized through the function EXECUTE. Formally,
         Figure 3: FINDSTATEPAIRS procedure
                                                          EXECUTE(Î£,  Q,a)=    sâˆˆQ R(s, a).
                                                        â€¢ Finally (lines 12â€“19), if the actions speciï¬ed by Ï€F for I
                                                                             |parts| > 1
to P, Vobs, X,whereVobs is an approximate minimal set of are not consistent (i.e.    ), then any two states
observation variables which are necessary for the execution of (e.g. s1 and s2) from different divisions of I should be
                                                                                         (s ,s )  (s ,s )
Ï€F .TheSTRONGâ€“FOâ€“PO algorithm has two main phases:        distinguished from each other, i.e. 1 2 or 2 1
                                                                             dis  a = a  (a , Q ) âˆˆ parts
(1) an observation reduction phase (lines 2â€“3), in which Vobs should be included in if 1 2, 1  1        ,
                                                          (a , Q ) âˆˆ parts s âˆˆQ       s âˆˆQ
is computed by applications of FINDSTATEPAIRS and RE-       2   2        , 1    1,and  2    2.
DUCTION,and(2)a transform phase (line 4), in which Ï€F   Figure 4 shows the REDUCTION procedure. Given dis âŠ†
is transformed into a conditional plan for Î£, Vobs, X by an SÃ—S, V,andX as input, the REDUCTION procedure returns
application of TRANSFORM.                             an approximate minimal set of observation variables Vobs
  In order to compute Vobs, we calculate dis âŠ†SÃ—S:if  such that âˆ€(s1,s2) âˆˆ dis. âˆƒv âˆˆVobs. X (s1,v) = X (s2,v).It
(s1,s2) âˆˆ dis,then{s1,s2}âŠ†B(i.e. the set of possi-    starts with Vobs = âˆ… and iteratively adds some v âˆˆVinto
ble current states) at some step of the execution of Ï€F and Vobs until d = dis,whered = {(s1,s2) âˆˆ dis |âˆƒv âˆˆ
ACTION(s1,Ï€F ) = ACTION(s2,Ï€F ). This task is accom- Vobs. X (s1,v) = X (s2,v)}.
plished by the FINDSTATEPAIRS procedure, which is pre-  The TRANSFORM   procedure is presented in Figure 5. Its
sented in Figure 3.                                   role is to transform Ï€F (i.e. a strong plan to P) into a strong
  Now let us introduce the FINDSTATEPAIRS procedure in plan Ï€ to P, Vobs, X.
detail:                                                 Now let us introduce the TRANSFORM procedure in detail.
                                                                                     I
  â€¢ First (line 2), the set of possible current states (i.e. I) At ï¬rst (line 2), the belief state (i.e. ) is divided into some
                                                                                             Ï€
    are divided into some divisions according to the ac- divisions according to the actions speciï¬ed by F . The parti-
                                                                                      IVIDE
    tions speciï¬ed by Ï€F . The partition is realized through tion is realized through the function D .Andthen:
    the function DIVIDE. Formally, DIVIDE(I,Ï€F )=       1. If IâŠ†G(lines 3â€“4), then an empty plan Îµ is returned.
    {(a, Q) | a âˆˆA, âˆ…âŠ‚QâŠ†I,sâˆˆQ         s, aâˆˆÏ€ }
                                   iff        F .       2. Else if Iâˆ©G = âˆ… (lines 5â€“8), then if o then Îµ else
                                                                        
  â€¢ Second (lines 3â€“5), if parts = âˆ… (i.e. IâŠ†G), then an  TRANSFORM(P    ,Ï€F , Vobs, X ) is returned, where:

                                                IJCAI-07
                                                  1933  1.  function TRANSFORM(P,Ï€F  , Vobs, X )                  1.  function MAKECODE(Q1,   Q2, Vobs, X )
        // Suppose P = Î£, I, G                            2.     dis â†âˆ…;
  2.    parts â† DIVIDE(I,Ï€F );                              3.     for any s1 âˆˆQ1, s2 âˆˆQ2
  3.    if IâŠ†Gthen                                          4.       dis â† dis âˆª{(s1,s2)};
  4.      return Îµ;                                         5.     endfor;
  5.    else if Iâˆ©G= âˆ… then                                6.     Vnow â† REDUCTION(dis,  Vobs, X );
  6.      o â†MAKECODE(Iâˆ©G,     Iâˆ’G,   Vobs, X );            7.     return CODE(Q1, Vnow, X );
  7.      P â†Î£,  Iâˆ’G,  G;                                8.  end
  8.      return if o then Îµ
                                   
                else TRANSFORM(P   ,Ï€F , Vobs, X );              Figure 6: MAKECODE  subroutine.
  9.    else if parts = {(a, Q)} then // i.e. |parts| =1
 10.      Inext â†EXECUTE(Î£,  Q,a);
            
 11.      P  â†Î£,  Inext, G;
                                                       In fact, Theorem 1 can be proved by showing that all the
 12.      return a â—¦ TRANSFORM(P  ,Ï€F , Vobs, X );    paths of the execution structure K induced by Ï€F from I are
 13.    else                                          ï¬nite. According to Deï¬nition 6, all the paths of K are ï¬nite
                         (a, Q)    parts
 14.      select an element    from     ;             (i.e. K is acyclic) because Ï€F is a strong plan to P.
 15.      o â†MAKECODE(Q,    Iâˆ’Q,   Vobs, X );
                                                   Theorem 2 Let Ï€F be a strong plan to P.LetQt be the set
 16.      P  â†Î£,  Q, G, P â†Î£,  Iâˆ’Q,  G;
                                                     of terminal states of K (i.e. the execution structure induced
 17.      return if o then TRANSFORM(P ,Ï€F , Vobs, X )
                                                    by Ï€F from I). Suppose Ï€ is the conditional plan returned by
                else TRANSFORM(P    ,Ï€F , Vobs, X );
                                                      STRONGâ€“FOâ€“PO(P,Ï€F    , V, X ). Then:
 18.    ï¬;
                                                        â€¢ Ï€ is a strong plan to P, V, X, and
 19.  end                                                 
                                                        â€¢   sâˆˆI FINALSTATES(s, Ï€)=Qt  âŠ†G.
           Figure 5: TRANSFORM procedure.
                                                        In the following example, we illustrate the algorithms de-
                                                      scribed in this section.
      â€¢ o is an observation that can distinguish the states in Example 2 Consider the situation depicted in Exam-
        Iâˆ©Gfrom the states in Iâˆ’G.                    ple 1.   We apply  STRONGâ€“FOâ€“PO    to (P,Ï€F , V, X ).
      â€¢P  = Î£, Iâˆ’G, G.                             Firstly, dis is computed by FINDSTATEPAIRS(P,Ï€F ), and
                                                      it is {(s1,s7), (s4,s7)}; and then, Vobs is computed by
    o is computed by MAKECODE(Iâˆ©G,   Iâˆ’G,  Vobs, X ).
                                                      REDUCTION(dis, V, X ), and it is {WallS}; lastly, Ï€ is re-
    Figure 6. shows the MAKECODE  subroutine. Given
                                                      turned by TRANSFORM(P,Ï€F  , Vobs, X ),where:
    Q1 âŠ†S,   Q2 âŠ†S,  Vobs,andX   as input, the MAKE-
                                                        â€¢ Ï€ = Ï€  = GoEast  â—¦ Ï€
    CODE  subroutine ï¬nds an approximate minimal set of        0              1, and
    observation variables Vnow âŠ†Vobs such that âˆ€(s1,s2) âˆˆ â€¢ Ï€1 = if WallS then (GoWest â—¦ Îµ) else Ï€2, and
    Q1 Ã—Q2.  âˆƒv âˆˆVnow.  X (s1,v) = X (s2,v),andre-
                                                        â€¢ Ï€2 = GoSouth  â—¦ Ï€3, and
    turns the observation of Q1 built on Vnow and X (i.e.
                                                        â€¢ Ï€  = if WallS then (GoWest â—¦ Îµ) else Ï€
    CODE(Q1, Vnow, X )).                                   3                                   4, and
                                                        â€¢ Ï€  = GoSouth  â—¦ GoWest  â—¦ Îµ
 3. Else if the actions speciï¬ed by Ï€F for I are con-      4                         .
                  |parts|  =1
    sistent, i.e.                (lines 9â€“12), then   It is easy to ï¬nd that Ï€ is a strong plan to P, V, X, and G =
    a â—¦           (P,Ï€  , V  , X )
       TRANSFORM        F  obs    is returned, where:   sâˆˆI FINALSTATES(s, Ï€)={s6}   (i.e. the set of terminal
                                                                                           Ï€      I
      â€¢ a is the action speciï¬ed by Ï€F for all the possible states of the execution structure induced by F from ).
                                                                                      Vâˆ’V
        current states.                                 In fact, the observation variables of obs are useless in
                                                     the whole executions of Ï€ and Ï€F . So the sensors and the re-
      â€¢P   = Î£, Inext, G. Inext is the belief state at next
                                                      sponders that correspond to these observation variables (i.e.
        step, and it is computed by EXECUTE(Î£, Q,a).
                                                      WallN,  WallW,  WallE, X0,  X1, X2, Y 0, Y 1, and Y 2)
 4. Else (lines 13â€“17) (a, Q) is selected from parts,andif can be turned off before executing Ï€. Furthermore, it is not
    o then Ï€1 else Ï€2 is returned, where:             necessary to observe all the values of observation variables
                                                        V                          Ï€
      â€¢ o is an observation that can distinguish the states in of obs at every step: for instance, requires the plan execu-
                                                                  GoEast
        Q from the states in Iâˆ’Q, and it is computed by tor to execute    at ï¬rst, regardless of the observation
        MAKECODE(Q,   Iâˆ’Q,   Vobs, X ).               information about the current state.
      â€¢ Ï€1 =TRANSFORM(Î£,   Q, G,Ï€F , Vobs, X ).
                                                      4   Conclusions
      â€¢ Ï€2 =TRANSFORM(Î£,   Iâˆ’Q,  G,Ï€F , Vobs, X ).
                                                      This paper presents an algorithm (i.e. STRONGâ€“FOâ€“PO) for
  From Deï¬nition 6, Deï¬nition 10 and the algorithms pre- observation reduction of strong plans under full observability,
sented above, we can get Theorem 1 and Theorem 2.     which take the form of stateâ€“action tables. To the best of
Theorem   1  If Ï€F  is a  strong plan  to P,then      our knowledge, no other work has discussed and tackled this
STRONGâ€“FOâ€“PO(P,Ï€F    , V, X ) terminates.             problem.

                                                IJCAI-07
                                                  1934