                                symmetric component caching                                 matthew kitching     fahiem bacchus                                     department science                                       university toronto canada                                    kitchingfbacchuscstorontoedu                        abstract                          problem tree width cspgraph                                                        graph determined constraint scopes darwiche       caching symmetries search decomposi                                                          component produced decomposition point      tion powerful techniques pruning search                                                        search tree appear nodes search      space constraint problems paper                                                        tree caching allows solve each component      present innovative way efï¬ciently combining                                                        reuse solution rest search      techniques branch bound solv                                                        caching added decomposition worst case complexity      ing certain types constraint optimization prob                                                                                           ow       lems cops new method signiï¬cantly      search reduced      dar                                                                                                      duces overhead performing decomposition    wiche  bacchus dalmao  pitassi                                                                                                              during search dynamic variable orderings signiï¬cant speedup practice results sang                                                                        employed addition supports exploita  et al   course caching requires space      tion dynamic symmetries appear during case space requirements completely ï¬‚exible partic      search symmetries previously com  ular caching used speedup algorithmâ€”it      bined decomposition finally achieve   required correctness cache solved      superior integration decomposition caching components space forâ€”within certain practical      branch bound previous approaches   limits space caching faster search      test methods maximum density  proceed furthermore prune cache      life problem show each ideas yields useful items available space exhausted      signiï¬cant gain search performance            decomposition caching impose signiï¬cant overhead                                                        during search techniques effective                                                        complex constraint problems ï¬nding best solu    introduction                                       tion optimization marinescu  dechter  counting  variables constraint satisfaction problem csp number solutions sang et al  static  assigned during backtracking search problem variable ordering used overhead elim  break disjoint parts consider csp consisting inated using data structures computed prior search dar  variables abmxy  constraints ca wiche  dynamic variable orderings yield  cmxy   make assignment  mthen signiï¬cant reductions size search tree  resulting reduced csp consist disjoint sub pay added overhead marinescu  dechter  problems share variables subproblem  methods reducing overhead                                        mm  variables constraint  making techniques effective  cmm  subproblem needed increase practical beneï¬ts dynamic decom                       mm  constraint cmm       position  disjoint subproblems created variable assign paper present method making search  ments components components created decomposition caching effective context  signment  solved independently solution dynamic variable orderings key contribution involves  a   b ï¬rst solution x   y method representing common structure entire set  second combined  obtain components single data structure component  lution original csp a      template individual components instances   y worst case complexity solving csp template share single representation com  exponential number variables decomposition mon information making caching considerable space  components yield signiï¬cant computational gains  efï¬cient templates increase efï¬ciency    insight exploited perform search cache lookupâ€”we access templateâ€™s  decomposition applied recursively bayardo  pe stances simple array indexing templates allow  houshek  darwiche  park  gelder  sang perform component detection during search efï¬ciently  et al  dechter  amir  mcilraith ï¬nal key contribution paper method  yield reduction worst case complexity search automatically detecting symmetries templates          ow        wheren  number variables detected templates symmet                                                    ijcai                                                     ric use discovered symmetry mapping map note equally use objective function  instances symmetric instance tem decomposed product sum objectives  plate symmetry encodes entire set individual compo similarly cast problem minimization task  nent symmetries makes computing template symme maximization task  tries cost effective computing symmetries components backtracking search each node search  individual components template symmetries allow tree corresponds set variable assignments  make effective use cached informationâ€”cached assignments cause problem broken  component bounds used provide bounds disjoint components component subset origi  symmetric components yield signiï¬cant nal problem isolated set assignments  ductions size explored search space    present formalization idea tailored    finally show achieve better integration subsequent developments  tween branch bound component caching caching component Ïofacopp      v dom o tuple  bounds components requiring compo ÏvÏoÏa ÏvâŠ†v ÏoâŠ†oand   Ïa   nents completely solved prior stored cache set assignments vi  ai subject following  marinescu  dechter       conditions let varsÏa set variables assigned    sequel ï¬rst expand background values Ïa  approach present new technique compo                                                                  Ïo        ov âˆˆ scopeo  nent templates show exploited        âˆˆÏv     achieved beneï¬ts just described present  varsÏa âˆª Ïv  oâˆˆÏo scopeo  initial empirical results test problem maximum den varsÏa âˆ© Ïv  âˆ…  sity life                                                                                                   minimal tuple p     background                                             ÏvÏoÏa satisï¬es conditions   paper concentrate solving constraint opti ÏvâŠ†Ïv   ÏoâŠ†Ïo  ÏaâŠ†Ïa    mization problems cops decomposable objective sets strict subset  functions template technique used                                                          component contains set variables  applications component caching search decom                                                        objectives variables furthermore ob  position caching counting solutions                                                        jectives isolated rest problem set  constraint optimization problem cop speciï¬ed assignments Ïa variables mention ei  tuple v dom cowherev set variables ther variables component instantiated Ïa  each âˆˆv   domv  domain values set furthermore variables component  constraints objective function assigns variables Ïv assigned Ïa  value complete assignments values variables components node each node set  typical goal solving cop ï¬nd assignment assignments set variables  values variables maximizes time                                                        remain unassigned components Ï Ïkare  satisï¬es constraints                                                        components ÏivâŠ†uthe variables    techniques effective cops decompos components unassigned ÏiaâŠ†athe current  able objective functions constraints particular assignments isolate variables component  quire decomposed sum objective sub                                                                                                  functions oi    oi each oi dependent example  consider cop variables                                                                                subset variables scopeoi âŠ‚vandthat       constraints                     each constraint âˆˆcalso dependent subset cmn node just assignment ma  variables scopec âŠ‚v constraints objective components Ïab  subfunctions uniï¬ed treating each constraint Ïabv  ab Ïabo  candÏaba    additional objective subfunction mapping satisfying assign Ïxyn Ïxynv  xy Ïxyno  cc                                                            Ï       ments  violating assignments âˆ’âˆ the overall xyn                                                  uniï¬ed objective function          computing components  node easily accom  problem simply maximize augmented ob plished standard algorithms detecting connected  jective function formulation like softconstraint components graph unionï¬nd depthï¬rst  problem paper regard cop search particular consider undirected graph gn      v dom o       tuple             includes original objec contains node objective  tive subfunctions hard constraints encoded addi uninstantiated variable  edge  tional objective subfunctions use term objectives nodes gn nodes variable node                          denote subfunctions                           objective node âˆˆ scopeo                                                                                                       objective function constraints decomposed observation  connected components cor  method correct decompositions gen respond minimal components particular Ï  erated during search objective global component exists connected compo  straints reformulated decomposed form    nent gn Ïv set variable nodes Ïo                                                    ijcai                                                     set objective nodes candÏa assignments plying decomposition recursively solve individual  instantiated variables objectives components  observation veriï¬ed realizing conditions  templates    deï¬nition component introduce new idea component templates used  achieved incrementally adding connected objectives represent shared information group components  Ïo                        Ïv      connected variables stopping each instance template  connections follow precisely basic idea quite simple innovation arising  nected components   algorithms algorithms templates exploited algorithmically                             Ïa  compute minimal components  computed    deï¬nitions observed  Ïv    Ïo         ï¬nalized note objective components Ï Ï Ïv  Ïv   âˆ…                                       fully instantiated node Ïo  Ïo sets objectives men                 isolated node single node component tioning variables minimal fur  fully instantiated objectives form components vari thermore variables assigned Ïa identical  ables objective assignments required fully variables assigned Ïa sets assign  instantiate objective                           variables Ïio Ïiv fact dif  example  suppose example assign  ference nonequal components containing  assignments   nonempty set variables particular val                                                                      Ïa    Ïa  generate  components Ïab ues assigned       differ consequence                                                        valueÏ    valueÏ  affected new assignment Ïxyn split              differ objec                                                        tives maximized subject differing values  components Ïxy  x cn   b Ïmn                                                         Ïa    Ïa  c   a note Ïmn contains vari          ables just single fully instantiated objective use component templates represent compo  component Ïxy does contains  assignment nents identical set variables formally com                                                                        t d  set parent component Ïxyn did        ponent template                    set variables                                                        objectives set variables dis  computation beneï¬ts components Ï component joint called dependency variables  value assignment variables Ïvis set assignments variables gener  equal sum objectives Ïo evaluated set ates instance template taand instance  assignments aâˆªÏa note objectives Ï tais component ta t athatisthe  functions Ïv assignments Ïa instance component variables objec  complete assignment Ïv Ïa sufï¬cient tives templates set assignments  fully instantiate objectives yielding single nu disconnects rest problem  meric value each objective sum example  instance consider component Ïab                        Ï valueÏ  value maximal value       maximum value a bcm     a seen previous example                                                Ïv  achieved assignment variables  component template tab  a m includes                                                       Ï                                 m   a  Ï   valueÏ          max                oaâˆªÏa       ab instances particular ab   ab             aa assignment Ïv oâˆˆÏo          using templates during search described                                                        components each node backtracking search  solution component assignment variables determined connected components algorithm run  achieves maximal value note components cor graph gn note gn contains vari  responding fully instantiated objective value equal ables objectives does mention actual values  value instantiated objective note assigned instantiated variables algorithm  value component computed examining assign actually identiï¬es set templates components  ments componentâ€™s variables rest prob node particular instances templates  lem ignored                                   termined assignments  proposition  let na set assignments template detected ï¬rst time create  node nandletÏÏk  set components data structure represent template instance store  maximal value obtain complete set template cache data structure used  assignments variables cop efï¬ciently detect instances components  aâŠ‡na     leaf node subtree future nodes search follows    k   valueÏi furthermore complete assignment observation  let set assignments node  achieves maximal value equal na nandlett component template instantiates  unioned solution each component Ïi        variables variables vthen                                                        ta                                   a       proposition follows fact values components                                                        av âˆˆaâˆ§v    âˆˆtd                components independent each computationally                      subset assigns                                                                      means solve each component independently variables   obtain computational advantage ap efï¬ciently detect variables                                                    ijcai                                                     instantiated node using standard lazy watch techniques metry computation different components  moskewicz et al  assigned key making automatic symmetry detection cost effective  test variables unassigned reduce cost symmetry detection conï¬ne  triggered know forms compo variable symmetries ï¬nergrain sym  nent current node templateâ€™s variables metries deï¬ned variablevalues  objectives removed gn reducing formally require symmetry templates  size connected components run onetoone mapping Ïƒ  smaller remaining graph identify components variables tdâˆªtv tdâˆªtv  current node triggering components reducing                                                           td  Ïƒtd tv  ÏƒtvwhereÏƒ applied  size gn way yield nontrivial improvement                                                            set ÏƒsÏƒv âˆˆ  total time needed perform component detection    template triggered need access  assignment variables tdâˆª  formation particular instance exists cur tv value objectives evaluated  rent search node tat d associated each template identical value objectives evaluated  value cache used store upper lower bounds ÏƒawhereÏƒ applied set assignments  values instances solutions stored ÏƒaÏƒv av   âˆˆa                       ta  solved instances  template instance otherwords Ïƒ keeps dependency variables tem  talb taub denote stored lower              valueta                               plate variables separated preserves value  bounds            instance template objectives value template instance  seen bounds given default initial val                                                        ta maximum sum objectives  ues search subtree current node                                                        der ï¬xed assignment dependency variables td  compute value instance making talb                                                         assignment tvwehavethat  taub compute better bounds value backtrack                                                                             updating bounds template observation    symmetric map                                                             Ïƒ                            a  accessing instanceâ€™s bounds efï¬cient par ping instance                                                           valuet avaluet  Ïƒa  ticular each variable ï¬nite domain values                      each instance tais deï¬ned values assign means bounds computed com  variables use instanceâ€™s deï¬ning se ponent tÏƒa reused component ta  quence values index multidimensional array automatically detect symmetries templates  instances template en during search map problem graph isomorphism  countered during search branch bound problem constructing graph representation each tem  pruning array large use plate graph representation property tem  instanceâ€™s sequence values hash code index platesâ€™ graph representations graph isomorphic  small hash table suitable storing sparse data templates symmetric sense deï¬ned                                                        graph isomorphism maps vertices graph  example  previous example set                                                         provides variable variable symmetry mapping  ï¬rst time create new template tab tabv                                                         templates  ab tabo  candtabd    represent                                                          solve graph isomorphism problem using available  component Ïab instance template tabm  a                                                                                                     immediately created search proceeds variables graph automorphism software case nauty mckay                                                                                    returning upper lower bounds component   shown puget  software sur                                                        prising efï¬cient graph isomorphism known  Ïab instantiation  bounds  maximal value achieved objectives polynomial complexity utilize symmetries during                                                        search proceed follows template ï¬rst  tabo possible values subject                                                         created construct graph representation gt nauty  bounds stored template cache tabm   alb    m    aub                               used compute isogt  canonical isomorph        ab            bounds indexed                                              assignment                                          symmetric previously cached template                                                        graph isomorphs equal isogt     assign  later search                                                        isogt   using hashing techniques isogt   unassigned tab triggered bounds new                                                        ï¬nd isomorphic template near constant time iso  instance tm m  k retrieved templateâ€™s value                                                        morphic template  utilize invertible map  cache  cached upper lower bounds                                                        pings gt  â†’ isogt   gt â†’ isogt  produced  reused new search node                                                                                                                      nauty compute symmetry map   template symmetries key computational use    utilize symmetry avoid allocating value cache  templates perform automatic symmetry detection â€™s instances instead mark symmetric  tween components abstract level templates par  store symmetry map Ïƒ continue use  ticular compute symmetries templates during detect instances created transparently  search templates created during search sym rest code read store information  metry templates applied â€™s instances instead remap access  instances allowing amortize single sym symmetric instance  instances                                                    ijcai                                                                                                          ccsbbtalb  able utilize bounds computed instances fur                                                            âˆ…âˆ¨taub â‰¤ lb âˆ¨ talb  taub  thermore bound computed instances stored                                                            return  information instances                                                           lb  talb lb   talb  different templates symmetric symmetries                                                                             map earliest created template means    select variable branch                                                           ts   information computed instance uti       templates contained graph                                                                             tob    tv âˆ’v   lized symmetric components                        consisting                                                                     foreach âˆˆ domv   example  consider cop described earlier                                                             foreach ti âˆˆ ts  set  ï¬rst time create new template        aâˆªv   d                                                                                 tid  txy txyv  xy txyo   candtxyd            foreach âˆˆ ts   a ub  lb                                                                                   represent component Ïxyifc type                                                               lbi   lb  ji tj aj ub  constraint graph representation tab                                                               ccsbbtiapilbi   txy isomorphism                                                                     lb ub     tiailb tiaiub  templates case mapping variable  lb  maxlblbd  cache template txy point cache                                                                                              talb taub  maxdlb  maxdub   template tab mapping â†’ create  instance txyn  a use cached results figure  template component caching search branch  tabm  alb tabm  aub                      bound templates try compute valueta    note original cop example  soon discover valueta â‰¤ lb                   nm  exchangable       symmetry does cache used store values fully solved  exist assigned mechanism components default initial bounds used  detect dynamic symmetries                        trying solve unsolved component    unfortunately space restrictions prohibit present search computed better bounds previous attempt  ing details template graphical representation ï¬rst thing algorithm does line  check  mention choices representation template contains variables case  exist representation utilizes nautyâ€™s ability input tains single objective function fully instantiated  coloured graphs ensure computed graph symme assignments talb taub  tries dependency variables template variables equal value objective taub â‰¤ lb  separated condition  allows exploitation case required bound achieved                                                  fact objectives exchangeable variables talb  taub case component al  uses colours ensure equivalent objectives ready fully solved actually captures case  map each                                    cases procedure immediately    symmetric component caching search                 return                                                          check known com  search algorithm given figure  shows uti ponent achieve higher value required lb line  lize ideas perform recursive decompositions                               ccsbb                    case algorithm going compute com  tegrated branch bound      attempts ï¬nd  ponentâ€™s maximum value computation aborted  value single component given template instance bounding make efï¬cient reset  ta provided lower bound lb                                                                                       ta         ting lower bound higher value variable  abort computation soon discovers split selected determine compo  achieve value greater bound com nent decompose variable assigned line   putation aborted routine stores best combination template triggering  bounds able compute termination line  nected component analysis triggered templates  storing bounds produced partial computation removed constraint graph each remaining connected  componentâ€™s value allows better integration branch component forms new template objective input  bound described bounds stored template âˆˆto uninstantiated variable  templateâ€™s value cache symmetric templateâ€™s forms template  v  âˆ… o   value cache                                         instance template a upper    branch bound inevitably implies search lower bounds equal evaluated compo  attempt compute value particular template instance nents containing variables generate new templates  times aborting each attempt current automatic symmetry detection performed  bound updating componentâ€™s bounds each assigned different values different instances templates  attempts work saved particular each new ts created solved  tempt proceed efï¬ciently utilizing stronger                                                          lines   identify new template instances compo  bounds computed previous attempt approach                           contrast presented marinescu  dechter  nents created current value  components                                                        solved lines â€“ abandon assignment         variables xi xj exchangeable objective line  time sum upper bounds  exchanging assigned values effect objective components fails reach required lower bound                                                    ijcai                                                     
