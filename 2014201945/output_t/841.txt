                               planning petri net unfolding                     sarah hickmott jussi rintanen sylvie thiebauxÂ´    langwhite                                           national ict australia               school electrical  electronic engineering university adelaide                     sciences laboratory australian national university                        abstract                          net acyclic avoids certain conï¬‚icts petri net                                                        analysis problem prove absence      factored state representation concurrency deadlocks unfolding amounts breadthï¬rst search      semantics petri nets closely related stops generated occurrence net represents mark      concurrent planning domains planning  ings reachable original net size unfolded      petri net analysis developed independently  net bounded typically exponentially larger      minimal usually unconvincing attempts size original petri net bounded      crossfertilisation paper investigate typically exponentially smaller size      exploit relationship areas fo state space represents searching unfolding space      cusing petri net unfolding attractive offers potential gains state space search      reachability analysis method naturally enables                                                          section  provide necessary background petri      recognition separate resolution indepen nets unfolding pointing differences ap      dent subproblems hand based                                                        proximate reachability analysis performed planning      folding develop new forward search method                                                        graph blum furst  section  trans      costoptimal partialorder planning lation planning problems safe place transition nets      exponentially efï¬cient state space                                                        low level nets offtheshelf unfolding tools apply      search hand inspired wellknown                                                          section  new planning method      planning heuristics investigate automatic                                                        costly option ï¬rst build complete      generation heuristics guide unfolding result                                                        folded net extract partially ordered plans      ing efï¬cient directed reachability analy                                                        time linear size capitalise      sis tool petri nets                                                        approach planning instead embed heuristic search                                                        unfolding resulting directed modelchecker    introduction                                       edelkamp et al  petri nets show mono                                                                                       petri nets traditionally used modelling analysing tonic planning heuristics haslum geffner  distributed systems murata  provide compact  directly computed original petri net  description state space way plan guide unfolding minimal cost plans  ning operators additionally represent independence loss completeness  concurrency causal relations actions way finally section  present analyse experimen  enables recognition separate resolution inde tal results obtained benchmark problems inter  pendent subproblems confers ability rea national planning competition standard petri net  son partially ordered sets actions having benchmark proofs omitted grounds space  consider interleavings exploited early available technical report hickmott et al   godefroid kabanza  synthesize reactive plans    fair say work failed  petri nets unfolding  sufï¬ciently develop utilize connections  areas recent exception edelkamp jabbarâ€™s  placetransition net   work applying planning heuristic search consider low level petri nets called placetransition pt  tecting deadlocks petri nets primary goal work nets ptnet lefthand side figure  consists  contrast determine techniques developed net initial marking net directed bipar  petri net analysis successfully applied planning tite graph types nodes places transitions    focus petri net unfolding mcmillan  esparza represent state variables events  et al anexact reachability analysis technique derlying arcs capture dynamics  particularly attractive preserves exploits directed places transitions vice versa  structure inherent petri net unfolding process marking ptnet represents state  generates forward simpler type net called occurrence models assigns each place  tokens                                                     ijcai                                                    deï¬nition  ptnet tuple path through net events causal history  disjoint ï¬nite sets places transitions conï¬‚ict  spectively Ã—  âˆª Ã—  â†’  ï¬‚ow  lation indicating presence  absence  arcs  conï¬gurations   â†’ initial marking                   understand unfolding built important               â€¢                                        notions conï¬guration local conï¬guration    preset   node  net set   event conï¬guration represents possible partial run   âˆˆ   âˆª       thepostset    â€¢ node       yx                                    ofthenetitisanysetofeventsc  set âˆˆ âˆª simplicity assume  transition nonempty preset postset partic  causally closed event                                    âˆ€  âˆˆ         â‰¤        ï¬guration ancestors occurrence  ular marking enables transition pfp                               mp occurrence ï¬ring transition absorbs net âˆ€e â‰¤ âˆˆ â‡’ âˆˆ  ken each preset places produces token  contains forward conï¬‚ict â€” motivated  each postset places moving net fact events forward conï¬‚ict                      âˆ’            âˆ€ âˆˆ           occur order simultaneously run  new marking                                                   â€¢    â€¢  corresponds state transition modelled net âˆ€ ee âˆˆ   â‡’ âˆ©  âˆ…  set transitions  concurrently enabled marking                                                                                               instance ï¬nite preï¬x figure    is possible âˆˆ occur simultaneously viz conï¬guration conï¬guration associated  âˆ€  âˆˆ               â‰¤            tâˆˆt    instance net marking markc original net identifying  figure  transitions   concurrently enabled conditions contain token events ï¬red                                                                                                    â€¢  â€¢  given marking transitions   conversely transi initial marking markcÏ•b âˆª   tions   forward conï¬‚ict means whilst câ€¢  eâ€¢e âˆˆ â€¢c  â€¢ee âˆˆ cthatis  each individually enabled ï¬re firing marking conï¬guration identiï¬es resultant state  transitions   order concurrently followed original petri net events oc  transition  results token each places gwesay cur instance figure  marking conï¬guration  ptnet nsafe number tokens each place Ï•c cg  exceed paper consider safe nets local conï¬guration event denoted consists                                                        event ancestors minimal conï¬g    unfolding placetransition net               uration containing example ee ea  unfolding method reachability analysis ex set conditions simultaneously marked union  ploits preserves concurrency information planning local conï¬gurations presets forms conï¬guration  terms unfolding approach allows searching partially unfolding process involves identifying transitions  ordered plans considering unnecessary interactions enabled conditions currently occurrence  actions unfolding ptnet produces oc net simultaneously marked identiï¬ed tran  currence net nodes called conditions events sitions referred possible events new instance  represent particular occurrences places tran each added occurrence net instances  sitions respectively possible runs original net places each postsets  initial marking unfolding achieves eliminat  finite complete preï¬x unfolded net  ing cycles backward conï¬‚icts transitions output                                                        cases unfolding Î² petrinet inï¬nite  place backward conï¬‚ict eliminating                                   know exactly transitions ï¬red obtain par reason seek complete ï¬nite preï¬x Î² Î²                                                        contains information Î² formally pre  ticular marking planning terms elimination   ward conï¬‚icts achieves property postuniqueness ï¬x Î² Î² complete reachable marking                                                                                 âˆˆ    action set backstrom nebel  implies exists conï¬guration Î²  know exact set actions causes state variable  markcmand  certain value point plan       transition enabled exists    unfolding ptnet Î²        ï¬guration âˆªe eâˆˆ Ï•et                             Ï• whereon      bef    occurrence net  key obtaining complete ï¬nite preï¬x identify  Ï• homomorphism mapping events cease unfolding loss  ditions events places transitions respec information events referred cutoff events  tively occurrence net starts conditions representing deï¬ned terms adequate order conï¬gurations  places initially marked ptnet Ï• maps mcmillan  esparza et al  following  set conditions preset oneone âŠ•e                              â‰¥                          denotes conï¬guration extends ï¬nite  set places                   set events disjoint    righthand side figure  shows preï¬x                    â‰º  folding ptnet example lefthand side notice deï¬nition  partial order ï¬nite conï¬gurations ad  multiple instances place example different equate  paths through reached note tran  â‰º founded  sition  does appear unfolding exists  âŠ‚ â‡’ â‰º                                                     ijcai                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                figure  example ptnet left finite preï¬x unfolding right placescircles transitionssquares tokensdots        â‰º preserved ï¬nite extensions â‰º algorithm  mole unfolding algorithm                            mark     mark   ï¬nite extensions add conditions preï¬x        âŠ•e         âŠ•e                           isomorphic initialise priority queue events possible                âŠ•e   â‰º    âŠ•e                                        queue  loss information terms threat remove ï¬rst event queue  completeness cease unfolding event eife cutoff  takes net marking caused   add event postset preï¬x  event e e â‰º events identify new possible events  markings proceed proceed     insert queue  e relevant proofs esparza et al  endif                                                        endwhile  deï¬nition  let â‰º adequate partial order event                                                        add postsets cutoff events preï¬x  cutoff event respect â‰º preï¬x contains  event e marke  marke e â‰º    mole  freeware program unfolds safe pt  nets uses adequate order â‰º conï¬gurations bound concurrency esparza et al   based comparing cardinality reï¬ned com presence concurrency typically leads preï¬xes expo  parisons based parikhvectors foata normal form nentially smaller unfolding builds space  make order strict minimise size gen partially ordered sets events avoids combinato  erated preï¬x esparza et al  preï¬x right rial interleavings events handled concurrently  hand side figure  complete ï¬nite preï¬x mole  generates example events eande  unfolding vs planning graph  cutoff events each local conï¬g  urations ï¬rstly marking local conï¬gura reader ï¬nd useful view unfolding  tion event eief secondly greater powerful planning graph blum furst   local conï¬guration event respect adequate ditions events play role graphâ€™s proposition  partial order implemented mole notice ï¬nite action nodes respectively number impor  preï¬x unfolding ceases cutoff events tant differences firstly whilst planning graph  resulting conditions enable actions performs approximate reachability analysis unfolding                                                        computes reachability exactly byproduct petri net    unfolding algorithm                              semantics mutexes just binary ones prop  mole  builds complete ï¬nite preï¬x following algo agated accounted determining sets possible  rithm  algorithm maintains priority queue possible events secondly unfolding duplicates nodes needed  events increasing order â‰º wrt local conï¬guration guarantee postuniqueness conditions proposi  expensive algorithm computation tion nodes unique event action node predecessor  possible events exponential maximal size consequence differences plans ex  presets transitions esparza et al  tracted unfolding time linear length  details size preï¬x obtained decreases plan extraction planning graph requires search fi  strength ordering concurrency nally global notion level unfolding  original net ordering strict size stead asynchronous vision time confers  unfolding bounded reachable state independent subproblems local levels conse  space net small factor equals quently unfolding lends easily gener                                                        ation partiallyordered plans optimal cost         httpwwwfmiunistuttgartdeszstoolsmole    graph better suited producing stepoptimal parallel plans                                                     ijcai                                                      translating planning   problems ptnets                                  use unfolding tool mole planning need                                                                                      turn planning problems safe placetransition nets                    tools accept input fact safety  helps representing propositional planning operators  reading truth value boolean variable presence                                                                                       absence token allowing multiple tokens place               a        meaningless best require nontrivial  bookkeeping multiple tokens place resulting figure  ptnet translation operator   repeatedly making variable true need a Â¬b Â¬a d transformation safe op                                                                                                moved make variable false                    erators positive preconditions   a Â¬a a    translation operates three steps ï¬rst step                                                                         a Â¬a a Â¬d d  safety established replacing planning operator  safe ones concept safe operator deï¬ned  second step eliminate negative precon  ditions lacking ptnets step second step translation negative preconditions                                                        Â¬  resulting problem ï¬nally mapped ptnet prove eliminated usual way gazen knoblock  translation correct characterise extent  replacing corresponding positive precon                                                                                            notion concurrency ptnet obtain ditions forcing state variable value                                                                                               matches independencebased notion concurrency com opposite value operator                                                                                     monly used planning                               placed p e aâˆªa pâˆ©aâˆªaÂ¬a âˆˆ                                                        e  âˆªÂ¬aa âˆˆ âˆ© aâˆªaÂ¬a âˆˆ    establishing safety                              instance operator  a Â¬b Â¬e Â¬a b                                                                                                      let set state variables set literals replaced  a de Â¬a a Â¬b    âˆªÂ¬aa  âˆˆ  athecomplement   lit       âˆˆ                   Â¬      Â¬           âˆˆ  eral  deï¬ned             correctness  sets literals deï¬ne  ll âˆˆ eastate                                                                        â†’   assigns values   state vari deï¬ne set operators obtained  ables planning operator pair p e performing steps effect literal                                                           Â¬                    Â¬                     âˆª âŠ† planning operator p e positive precon iff effect literal effect literal iff                                                                                                ditions âŠ† aitissafe âŠ† effect effect literal executing operator preserves                                                                                      âˆˆ          literals appear negatively preconditions planning property state   problem quadruple a g set state instead executing operator execute  variables  â†’  initial state set exactly operators effects  planning operators set goal literals  operator depends current state prop    map planning problem equivalent erty state variable mentioned effects actually  property operator positive preconditions changes operator executed def  safe start establishing safety opera inition safety requires  tor  p e ï¬rst replaced ep safe operators following theorem establishes correctness               âŠ†                                      translation proof based fact operator  follows let    set effect literals            ï¬ne new operator works like changes exactly sequence âˆˆ replaced oando  literals e addition literals âˆ© replaced exactly operator  clearly requires change safe operator changes                                                        theorem   let  a g planning problem  exactly literals retains values effects                                                                âˆª    âˆª                              p âˆª âˆª epe âˆª âˆ© p                    let       oâˆˆos  states                                                                                                      pa Â¬b eÂ¬a Â¬e operator â†’   aâˆªa â†’  a                                                                       op e replaced safe operators oi piei  sas âˆˆ reachable state                                                                                           given respective values e  reachable state     Â¬b       Â¬a Â¬e                                              Â¬b Â¬e  Â¬a                                                             mapping ptnets    Â¬b Â¬d Â¬e  Â¬a                                               Â¬b  Â¬a Â¬e  Â¬e     finally map resulting planning problem ptnet                                              Â¬b Â¬d  Â¬a Â¬e  Â¬e follows let  a g planning problem                                                        deï¬ne ptnet pnetrp m    eliminating negative preconditions                 â€¢ places  âˆª a                                                   given set state variables introduce set  â€¢ transitions  âˆªoâˆˆoso  aa âˆˆ new state variables idea a true â€¢ set arcs obtained  p eâˆˆt  exactly false                                   âˆˆ pâˆªt  âˆˆ âˆˆ Â¬a  âˆˆ                                                     ijcai                                                      â€¢ âˆˆ maiff iaand  ma     mole  actually supports option suf                                           iff iaandforalla   âˆˆ  âˆª maor       ï¬ces augment planning operator set dummy op      ma                                          erator precondition goal require mole                                                        stop event labelled corresponding tran  figure  illustrates mapping single operator                                                        sition dequeued local conï¬guration event    reachable marking place âˆˆ                                                        partially ordered plan problem owing  resulting ptnet ma â‰¤  proof following                                                        fact moleâ€™s queue orders events increasing local  theorem induction length transition sequences                                                        ï¬guration cardinality plan contains fewest actions  leading                                                          cardinalitybased ordering relation used mole  theorem  let planning problem ptnet drawback planning leads mole  pnetr safe                                    perform breadthï¬rst search natural idea change                                                        ordering provide better guidance goal    concurrency                                      generalising restricted notion optimality currently  interested notion concurrent partially place considering arbitrary additive action costs  ordered plans allow simultaneous execution sev turns given arbitrary monotonic heuristic  eral operators question arises notion concur possible build adequate order implements let  rency used connection ptnets obtained ting heuristic guide unfolding optimal plans  translation coincides standard notion concurrency adequacy ensures retaining completeness  ai planning turns case preï¬x generated rejoins work directed model    standard notion concurrency planning indepen checking pioneered edelkamp et al edelkamp et al  dence operators pe pe independent iff  heuristic estimates optimal cost reaching  pi âˆ© ej  âˆ… ei âˆ© ej  âˆ… âˆˆ    jthis goal given state hsat goal  captures intuition executed order states let costo positive cost operator oand  yielding result cases               reso result applying state mono    independence does general imply concurrency tonic iff hs â‰¤ hreso  costo nongoal states  ptnet sense instance consider indepen operators applicable deï¬nitions easily  dent planning operators a b a cthecor transfer ptnet case identifying each operator  responding petri net transitions token corresponding transition considering set places  ï¬re concurrently remedied state variables represented  considering petri nets readarcs complicates places true monotonic heuristics like hm  unfolding process supported mole      haslum geffner  automatically generated    ptnets general converse implication does planning problem description equally easily gen  hold cases transitions erated ptnets deï¬ne following ordering  place simultaneously planning context simul conï¬gurations  taneous instance consider petri net transitions       â‰º  t â€¢t  tâ€¢  â€¢t  cand    deï¬nition   let heuristic conï¬guration   â€¢                                                                                           t   markings places contain deï¬ne      eâˆˆc cost Ï•                                                                            â‰º                          token transitions ï¬re order mark  deï¬ne                                                                            currently transitions interpreted planning op            Â¬         Â¬     erators         concurrency theorem  monotonic ordering â‰ºh adequate  possible operators dependent  like general case concurrency relation arising proof matter checking  conditions required  translation strictly stronger independence adequacy nd condition nontrivial prove                                                        makes use monotonicity heuristic  theorem  let  a g planning problem let                              â‰º                                                     ordering moleâ€™s queue  mono  pnet      let operators tonic heuristic obtain planner generates partially  transitions tt âˆˆ âˆˆ    âˆˆ                                                 ordered plans smallest total action cost contrast   ï¬re simultaneously state art deterministic planners optimise parallel  independent executed simultaneously plan length aware partialorder  proven contrapositively assuming planner able optimise sum arbitrary action costs  independent showing safety finally heuristic search unfolding space substantially  complementary role places a implies differs existing partialorder planning algorithms  to ï¬re simultaneously                                                           experimental results    directing mole planning                        implemented petrify extended version trans  problem translated ptnet easy let lation planning operators ptnets petrify handles  mole produce partially ordered plan problem al adl fragment pddl modiï¬ed mole  gorithm  slightly altered stop event implement variety search strategies heuristics  taken queue labelled designated transition ï¬ned respective ordering relations order                                                     ijcai                                                    
