                          planning temporally extended goals                                    propositional satisï¬ability                      robert mattmullerÂ¨                             jussi rintanen                  albertludwigsuniversitÂ¨at                  national ict australia                     institut fÂ¨ur informatik                australian national university                      freiburg germany                            canberra australia             mattmuelinformatikunifreiburgde              jussirintanennictacomau                        abstract                           metric interval temporal logic mitl lin                                                        ear temporal logic ltl tlplan bacchus kabanza      planning temporally extended goals tegs       recently planning domain deï¬nition lan      expressed formulae lineartime temporal     guage pddl extended express state trajectory      logic ltl proper generalization classi constraints gerevini long  talplanner      cal planning allowing specify prop  tlplan forwardchaining planners pruning search      erties goal state plan exe space progressing temporal formula approaches      cution additionally ltl formulae used    include compiling tasks including ltl goals classical      represent domainspeciï¬c control knowledge  tasks cresswell coddington  baier mcilraith      speed planning paper extend sat    solving using classical planner                      ltl                    ltl      based planning  goals akin bounded          bounded modelchecking biere et al  latvala et al      modelchecking veriï¬cation partially ordered  extension planning satisï¬abil      plans signiï¬cantly increasing planning efï¬ ity approach kautz selman  viewed      ciency compared purely sequential sat plan    satbased technique planning tegs ef      ning consider relaxed notion par   ï¬ciency satbased planning techniques strongly                                        ltl      tial ordering show planning goals     dependent notion partially ordered parallel plans      nexttime operator translated kautz selman  rintanen et al  extend      sat problem solved efï¬ciently ing satbased ltl modelcheckingplanning approach      results extend practical applicability sat parallel plans cases critical obtain efï¬      based planning wider class planning prob cient planning contribution paper encoding      lems addition applied solving constraints preserve semantics ltl formulae      problems bounded ltl modelchecking ef   parallel plans      ï¬ciently                                           section  formal description problem                                                        solved section  present propositional encod                                                        ing use base encoding planning sat    introduction                                       isï¬ability kautz selman  reproduced section  classical planning goal agent achieve  translation ltl formulae propositional logic  simply property goal state reach tegs speciï¬ latvala et al  reproduced section  section   cations stating desired properties ï¬nal state shows adaption encoding parallelism constraints  sequence states execution plan sat given rintanen et al  tasks tegs ex  isfying speciï¬cation expressing goals formulae periments described section   adequate temporal logic impose precise  constraints plans classical reachabil  planning temporally extended goals  ity goals instance possible specify mainte  nance goals property maintained indeï¬nitely propositional satisï¬ability  goals stating agent react environmen  problem description  tal condition safety goals impose restriction  agentâ€™s behavior change certain properties world notation  state trying achieve reachability goal    let set propositional variables Î¦ proposi    planning temporal speciï¬cations usually tional temporal formula write lita shorthand  garded extended goals means encoding domain âˆªÂ¬a  âˆˆ litÎ¦ instead litvarÎ¦  speciï¬c search control knowledge used guide planner varÎ¦ set variables Î¦iflit set lit                                                                        Î¦  different formalisms used temporal ac erals write lit  lit âˆ© litÎ¦ifÎ¦ propositional  tion logics tal talplanner doherty kvarnstrÂ¨om formula occurs positively negatively Î¦ iff                                                    ijcai                                                                                                                                                âˆ  occurrence Î¦ nested odd num qiâˆ’bmodbâˆ’kk note qÂ¯k actually  ber negation signs negative literal Â¬a occurs positively path consecutive states related â†’anltlâˆ’x  negatively Î¦ iff occurs negatively positively Î¦a formula Ï• valid ï¬nite sequence qÂ¯ written  literal  occurs Î¦ occurs positively negatively Î¦ qÂ¯  Ï•iffthereisak âˆˆbâˆ’  qb  qk                                                         âˆ  write pos Î¦ neg Î¦andocc Î¦ respectively qÂ¯k  Ï•                                                          make sure âˆˆbâˆ’   linear temporal logic                                                        qb  qk allowing idling ï¬nal state enforcing  order specify tegs choose speciï¬cation loop  language use propositional ltl emerson   nexttime operator simple planning  deï¬ned semantics sufï¬ciently expressive planning task tuple  a Ï• wherea  qualitative tegs                                     ï¬nite set boolean state variables âˆˆ initial state    set wellformed ltlâˆ’x formulae negation ï¬nite set operators Ï• ltlâˆ’x formula  mal form set propositional variables ltlâˆ’x variables operators form  p wherep  formulae short inductively deï¬ned follows propositional formula precondition  âˆˆ Â¬a ltlâˆ’x formulae Ï• Ï•andÏ• ï¬nite set literals unconditional effects oand  ltlâˆ’x  formulae Ï• âˆ§ Ï• Ï• âˆ¨ Ï• fÏ• â€œeventually ï¬nite set pairs  consisting propositional  Ï•â€ gÏ• â€œalways Ï•â€ Ï•uÏ• â€œÏ• Ï•â€ Ï•rÏ• formula ï¬nite set literals pairs  â€œÏ• releases Ï•â€                                   conditional effects       ltl           Ï•                                                                                 âˆ’x formula    evaluated inï¬  the set effects written  â™¦   nite path state space formally kripke model âˆª   âˆˆ set unconditional effects      q â†’l  triple set states                                                                                                       set active effects state  â†’âŠ†   Ã—                                               âˆª    âˆˆ                reï¬‚exive binary relation thetran                       single oper  sition relation  â†’ function assigning                                                        ator sq  oâˆˆs oq set operators  each state propositional valuation variables aa                                                     Ï€  â†’                âˆˆ       aset   operators applicable state   path  function            âˆˆ consistent identify operator  Ï€n â†’ Ï€n ifÏ€ path âˆˆ ith                                                                singleton set applicable  sufï¬x Ï€ Ï€  â†’ qisdeï¬nedasÏ€ jÏ€i    âˆˆ                                            precondition satisï¬ed active effects consistent       âˆˆ kb       Ï€   Â· vÏ‰                    set operators possibly singleton sequential               apath         consisting ï¬nite                                             preï¬x  Ï€Ï€kâˆ’ loop  Ï€kÏ€bâˆ’ plans model idling state                                                   applicable simultaneous application results   repeated inï¬nitely called  loop called q                                  bloop kloop kb         state obtained making literals                                                         true leaving state variables unchanged                 ltlâˆ’x         Ï•           Ï€    truth     formula  path  symbol                ically Ï€  Ï• inductively deï¬ned follows  write qâˆ’â†’q qâˆ’â†’q  let sÂ¯  ssbâˆ’                                                         sequence sets operators state            Ï€   â‡” âˆˆ Ï€                                                         sbâˆ’                                                        qâˆ’â†’qâˆ’â†’   âˆ’âˆ’âˆ’â†’qb deï¬ned sequence           Ï€  Â¬a  â‡” aâˆˆ Ï€                                                 states execq sÂ¯qqb  called execution      Ï€  Ï• âˆ§ Ï• â‡” Ï€  Ï• Ï€  Ï•               sÂ¯ finally let sÂ¯  ssbâˆ’  sequence                                                                           â‰º    â‰º  â‰º          Ï€  Ï• âˆ¨ Ï• â‡” Ï€  Ï• Ï€  Ï•                sets operators Â¯         bâˆ’  sequence                                                      binary relations â‰ºt total ordering stsay          Ï€  fÏ• â‡”âˆƒi  âˆˆ  Ï€  Ï•                      â‰º  Â·Â·Â· â‰º              âˆˆbâˆ’                                                                       tstâˆ’forall                                                                                                              Ï€  gÏ•   â‡”âˆ€i  âˆˆ  Ï€   Ï•                                                tstâˆ’                                                    state assume qtâˆ’âˆ’â†’qt âˆ’âˆ’â†’qt âˆ’âˆ’â†’ âˆ’âˆ’âˆ’âˆ’âˆ’â†’qt                                                                            âˆˆbâˆ’              Ï€  Ï•uÏ• â‡”âˆƒi  âˆˆ  Ï€  Ï•                deï¬ned                                                                                                                  Â¯                                                        sequence     states  execq sâ‰ºÂ¯                      âˆ€j âˆˆ  iâˆ’    Ï€   Ï•                                                                              qqqqqqqqbâˆ’  called                                                                          sÂ¯        Ï€  Ï•rÏ• â‡”âˆ€i  âˆˆ  Ï€  Ï•                linearized execution                                                         plan length  a Ï•  tuple sÂ¯                      âˆƒj âˆˆiâˆ’    Ï€  Ï•                                                        ssbâˆ’  st âŠ†  âˆˆbâˆ’      given path Ï€ bloop ï¬rst states Ï€ sequence â‰ºÂ¯  â‰ºâ‰ºbâˆ’   value contain information needed eval â‰ºt total ordering st âˆˆbâˆ’   uate Ï• Ï€ following paths deal qÂ¯  execisÂ¯ â‰ºÂ¯  deï¬ned qÂ¯  Ï• kripke  type                                     model induced    let qÂ¯  qqb  ï¬nite sequence states  qi â†’ qi âˆˆbâˆ’   reduction satisï¬ability  âˆˆbâˆ’   qb  qk order able planning satisï¬ability kautz selman  roughly  evaluate ltlâˆ’x formula qÂ¯ consider inï¬nite works follows given planning task  a Ï•   unraveling qÂ¯ifqb âˆˆqqbâˆ’sayqb  qklet   propositional formulae Î¦ Î¦ Î¦ generated   âˆ                  âˆ                       âˆ  qÂ¯k  â†’ qwhereqÂ¯k  iqiifibandqÂ¯k        exists plan length Î¦b satisï¬able                                                    ijcai                                                    Î¦b evaluated using sat solver Î¦b unsatis  a Ï•  planning task âˆˆ nthen  ï¬able evaluation proceed Î¦b plan pb  looptoax  âˆ§ beforeax âˆ§ uniqueax  âˆ§  extracted satisfying valuation Î¦b bmc                                                                                                                                                                                    inftyax âˆ§ Ï•b                                                                                                   solution quality                                              bâˆ’                                                                 looptoax       lt â†’      â†” ab                             sÂ¯   s                                     aâˆˆa  quality parallel plan        bâˆ’                         bâˆ’                                                                  measured respect parallel plan length se beforeax  Â¬bef  âˆ§ bef â†” bef tâˆ’ âˆ¨ ltâˆ’                       bâˆ’                                                   quential plan length  focus ï¬nding               bâˆ’                         bâˆ’  plans low parallel plan length size uniqueax  bef â†’Â¬lt  inftyax   lt                                                                                                  largest propositional formula considered given task  roughly proportional parallel length plan corre fresh auxiliary variables lt bef âˆˆbâˆ’   sponding satisfying valuation sat solver running intended semantics loop qbâˆ’                                                                                      times grow exponentially formula size worst qt qt respectively                                                                              case obtaining small formulae particularly important recursive translation Ï•b Ï• deï¬ned                                                                           tb                                                                                                                                                                                                        bâˆ’    propositional encoding                                 a                             lj âˆ§ aj                                                                                                                                                                                 bâˆ’                                                            Â¬a           Â¬at                lj âˆ§Â¬aj    base encoding                                                                                                                                                     bâˆ’                                                                   Ï• âˆ§ Ï•     Ï• âˆ§ Ï•         lj âˆ§ Ï• âˆ§ Ï•   ï¬rst base encoding p transition sys                     j                                            base                                               bâˆ’                                          a Ï•              Ï• âˆ¨ Ï•     Ï• âˆ¨ Ï•         lj âˆ§ Ï• âˆ¨ Ï•   tem induced planning task          bound                            j                                                                                           bâˆ’            plan length ï¬rst proposed kautz selman  fÏ•       Ï• âˆ¨ fÏ•             lj âˆ§fÏ•                                                                                                 omitting reachability goal formula                                 bâˆ’                                                                     gÏ•       Ï• âˆ§ gÏ•            lj âˆ§gÏ•                                                                                                                           bâˆ’                                                 bâˆ’                                                                    Ï•uÏ•b   Ï•b âˆ¨ Ï•b âˆ§    jlj âˆ§Ï•uÏ•                  pbase  âˆ§     rt                                                                                                                Ï• uÏ•  t                                                                                                                                                                    bâˆ’              rt conjunction precondition axioms ot â†’ Ï•rÏ•     Ï• âˆ§  Ï• âˆ¨        lj âˆ§Ï•rÏ•                                                                                               pt effect axioms ot â†’ et conditional effect axioms                                                                                           âˆ¨Ï•rÏ•b         ot âˆ§ ft â†’   dt  p âˆˆo   fdâˆˆc                                                    fÏ•    Ï•t âˆ¨fÏ•           âŠ¥  and positive negative frame axioms Â¬at âˆ§at â†’                                                                                gÏ•   Ï•t âˆ§gÏ•               oâˆˆoot âˆ§ epc aot âˆ§Â¬at â†’   oâˆˆoot âˆ§                          epc                         âˆˆ                    Ï• uÏ•    Ï• t âˆ¨ Ï• t âˆ§          âŠ¥      Â¬a respectively  frame                       axioms epc p  deï¬ned if âˆˆ eandas               Ï• uÏ•                                                                                    âˆˆ  âˆˆ dotherwise                                                                                               Ï•rÏ•   Ï•b âˆ§ Ï•b âˆ¨              encoding contains propositional variables                                                                                             Ï• rÏ•     state variables âˆˆ time points âˆˆb                       ot operators âˆˆ time points âˆˆ                      Â·t   bâˆ’                                          notice translation closely related formula             intended semantics holds                                                                            progression procedures used bacchus kabanza   time point iff true operator applied doherty kvarnstrÂ¨om   time point iff ot true sets variables proposi                                                        following theorem states correctness com  tional formulae indexed  actually denotes pleteness propositional translation slightly different  sets formulae variables indexed correspondingly formulation proof latvala et al    following theorem states correctness propo   sitional translation proof rintanen et al         a Ï•                                                   theorem   let               planning task                                                        âˆˆ  exists sequence sets operators  theorem   let    a Ï•  planning task sÂ¯  ssbâˆ’  qÂ¯  execisÂ¯ deï¬ned                                                                                      exists sequence sets operators sÂ¯  qÂ¯  Ï• iff formula pbase âˆ§ pbmc satisï¬able  ssbâˆ’  execisÂ¯ deï¬ned iff formula                                                        parallel plans  pbase satisï¬able                                                        section present main contribution    temporally extended goals                        straints guarantee meaning ltlâˆ’x formulae                                                        preserved parallel plans propositional encod  subsection reproduce reduction bounded ing constraints  ltlltlâˆ’x  modelchecking problem propositional satis theorem  tells encode requirement  ï¬ability given latvala et al  adding constraint sequence sÂ¯ execisÂ¯  Ï•butwe  satisfying sequence states contain loop let sure sÂ¯ fact plan                                                    ijcai                                                    sequence â‰ºÂ¯ corresponding total orderings set active effects âˆˆbâˆ’  execisÂ¯ â‰ºÂ¯   Ï• sequence â‰ºÂ¯ toyieldanadmis possibilities ruled condition  sible linearization ensure qÂ¯  execisÂ¯ â‰ºÂ¯  bi bii deï¬nition  respectively  deï¬ned qÂ¯  Ï• order state rintanen et al  detailed proof claim  achieved need deï¬nitions ï¬rst execisÂ¯ â‰ºÂ¯  deï¬ned using lemma  sufï¬  subsequent lemma lamport       cient show execisÂ¯ âˆ¼ execisÂ¯ â‰ºÂ¯  kripke                 Ï€       Ï€      model     q â†’l whereq    â†’  form state  deï¬nition  let           Ëœ Ëœ  Ëœ Ëœ                                         varÏ•  inï¬nite ï¬nite paths kripke model q â†’l  space induced  â†’      deï¬ned                                                           âˆ© var Ï•  Ï€ Ï€Ëœ called stuttering equivalent Ï€ âˆ¼ Ï€Ëœ         true consider sin  short inï¬nite ï¬nite sequences natural gle time point âˆˆbâˆ’  ï¬rst let â‰ºt total                                                                             â‰º  Â·Â·Â· â‰º   numbers              ordering say     tstâˆ’     jn   â‰¤    subsequence linearized execution execisÂ¯ â‰ºÂ¯                                 ik     ik           ikâˆ’   Ëœjk                                                                               Â·Â·Â·âˆ’â†’q âˆ’âˆ’tâ†’ qâˆ’âˆ’tâ†’ qâˆ’âˆ’tâ†’ âˆ’âˆ’âˆ’âˆ’âˆ’tstâˆ’â†’ âˆ’â†’ Â·Â·Â·   Ëœjk         Ëœjkâˆ’ ï¬nite subsequence like                                            Ï€   Ï€   ik ik     ikâˆ’  Ëœ consisting identically la                                     exec isÂ¯  beled states called block                       corresponds subsequence execution                   Ï•      ltl               q â†’l                              st  lemma   let     âˆ’x formula                                Â·Â·Â·âˆ’â†’qtâˆ’â†’qtâˆ’â†’ Â·Â·Â·  kripke model  â†’ âŠ‡ varÏ•  Ï€ Ï€Ëœ inï¬nite ï¬nite paths Ï€ âˆ¼ Ï€ËœthenÏ€  Ï• note condition  deï¬nition  fact  iff Ï€Ëœ  Ï•                                          operator affects operator applied later â‰ºt makes                                                                    â‰º  o  o Ï• âŠ†  Ï•    following deï¬nition adapted similar sure   â™¦     holds ef                                                                st             Ï•  rintanen et al  crucial rest section fects  qt relevant  effects concerning                                                                            Ï•              describes circumstances operator variable occurring  effects                                                                  applied operator lin operators tstâˆ’ additional effect                                                                                          earization â‰º set operators wants ensure labeling lqt lqt   lqt                                                                 time points application st qt qt qt qt form block stuttering equiv  dering given â‰ºt deï¬ned ï¬rst place alence execisÂ¯ â‰ºÂ¯  execisÂ¯ corresponding  execisÂ¯ â‰ºÂ¯   Ï•                                 block execisÂ¯ singleton qt blocks                                                        constructed analogously  deï¬nition  let  a Ï•  planning task    p o pec âˆˆotheno affects o iff  o                                                       step ï¬nd propositional formula encoding   literal   âˆˆ oâ™¦                                                                                        condition time point operators  neg  ii occ   âˆˆ    o    â‰º  o        o Ï•  Ï•  âˆ…                                  affects      applied simultane    â™¦                                     ously purpose deï¬ne notion disabling            Ï•                                                                                     â™¦ restriction â™¦ie ofthesetof graph rintanen et al  planning task                                               conditional unconditional effect literals  deï¬nition  let  a Ï•  planning task  literals occurring positively negatively Ï• similarly directed graph  o wheree âŠ† Ã—oisadisabling      p  Ï• âˆ© lit Ï•                                                                                                     graph contains edges      cases correspond different problems poten                                                                                            state reachable operators  tially arise applied linearization o simultaneously applicable  affects o  falsifying precondition o  bi af                              o                        let st set operators subgraph gt  stet   fecting set active effects  bii âˆ© Ã—                    o   o putting risk stuttering equivalence execisÂ¯   disabling graph                                                            induced st acyclic ordering â‰ºt  execisÂ¯ â‰ºÂ¯   deï¬nition gives rise condi                                                                                       st operators â‰ºt af  tion admissibility sequence â‰ºÂ¯ total orderings                                                         fecting  fact â‰ºt arbitrary topological                   a Ï•                sÂ¯                    âˆ’  lemma   let               planning task     dering stet   strongly connected components  ssbâˆ’  sequence sets operators sccs directed graph form directed acyclic graph  exec isÂ¯  Ï•     â‰º    â‰º â‰º                 Â¯          bâˆ’  sequence  stead ensuring acyclicity gt sufï¬cient ensure  â‰ºt total ordering st âˆˆbâˆ’                                                                                acyclicity subgraphs induced sccs  operators âˆˆ st affects    gi    siei        si    âˆ©                                                                     â‰ºt       âˆˆ bâˆ’       sÂ¯            â‰ºÂ¯                                        et  et âˆ© st Ã— st  achieved follows           aplanfor                                               let  o  disabling graph  ccm                                                                               â‰ºi  proof sketch show execisÂ¯ â‰ºÂ¯  deï¬ned set sccs arbitrary total ordering                                                           ci     oi oi          âˆˆm     exec isÂ¯ â‰º  Ï•                                                  ci             say          Â¯    argued rintanen et al                                                                              oi  â‰º  Â·Â·Â· â‰º oi         âˆˆ  er  âŠ†  order show execisÂ¯ â‰ºÂ¯  deï¬ned sufï¬ces      ci                        show operator âˆˆ st disable operator  âˆˆ lita deï¬ne formulae stating                                                                       âˆˆ st potentially falsifying precondition altering oioj âˆˆo  oi âˆˆ eoj âˆˆ rand                                                    ijcai                                                    oioj applied simultaneously intuitively operators remark  form sequence precondition  disable operators wrt                     lemma  satisï¬ed follows sÂ¯ â‰ºÂ¯                                                     plan particular execisÂ¯ â‰ºÂ¯  deï¬ned  chaino                                        Â¯  Ë˜                                               Â¯    execisâ‰ºÂ¯   Ï•     oi â†’ aj  ijoi âˆˆ eoj âˆˆ oiojâˆ’âˆ©r  âˆ…    Ë˜                                              Â¯   âˆª ai â†’ aj  ijoioj âŠ†r oiojâˆ’âˆ©r  âˆ…   experiments    Ë˜               Â¯   âˆª ai â†’Â¬oi  oi âˆˆ                                  setting              i                                         compared cumulative sat solver running times   fresh auxiliary variables nega til ï¬rst satisï¬able formula parallel encoding  tion  deï¬nition  translates conjunction  chain                                           Ï•     described section  sequential encoding derived       formulae time points sccs literals  parallel replacing parallelism constraints  use following sets er                                                        axioms demanding operator time point   e  âˆˆ   âˆˆ oâ™¦                         evaluation formulae corresponding increasing                                                        plan lengths performed sequentially additionally   r  p âˆˆo  pos ex  âˆˆ occ                                                        compared parallel plan lengths resulting plans  similarly negation  deï¬nition  translates used types planning tasks considered              chain                    eâˆ¼râˆ¼  conjunction    formulae sets           simple handcrafted logisticslike transportation task     âˆ¼                         âˆ¼                        three portables trucks each goal ï¬nd   e   âˆˆ  âˆˆ  r  âˆˆ   âˆˆ oâ™¦                                                        ï¬nite plan assuring portables shipped  parallelism constraints encoded formula forth locations indeï¬nitely   goal  formula                                                                                              bâˆ’                                    used Ï•    gf    atpi dij wherethe          plin             chainoi oi  e r t pi                  dij                                     ci                portables locations            âˆˆlita                              tasks adapted  international                                                                                                       planning competition modiï¬ed qualitative prefer                                        âˆ¼  âˆ¼  Ëœ             âˆ§       chainoi oi  e  r  t                                   ci                 ences tasks rovers domain turning soft tem               âˆˆlitÏ•                                 poral constraints preferences hard constraints                                                        ignoring metric function changing soft hard  remark  valuation corresponding sequence                sÂ¯   s            pb          constraints turned necessary drop  sets operators         bâˆ’  satisï¬es  lin  order tasks solvable  time points sccs ci disabling graph                       Îº    o                        pb                 drawing uniformly random constraints each task           used construction lin  subgraphs retaining ones drawn constraints trans  gi    siei                   acyclic sccs form acyclic lated ltlâˆ’x explained gerevini long                               â‰º      graph total ordering unlike ï¬rst task rovers tasks lacked explicit  âˆˆm ci â‰ºc cjtherearenoo âˆˆ  ci                                                                               nesting temporal operators solvable  âˆˆ cj  âˆˆ esincegt acyclic solved plans yielding ï¬nite executions apart                    total ordering â‰ºt st each âˆˆbâˆ’  âˆˆ inï¬nite idling ï¬nal state reachability goals speci                                       consistent ordering â‰º used ï¬ed problem deï¬nitions required hold                                           struction plin  pair âˆˆ ci ï¬nal state                                   âˆˆ â‰ºt  relations â‰ºt âˆˆm sat solver used siege  ryan  â‰ºc combined lexicographically resulting experiments run pc  ghz amd athlon  dering â‰ºt st follows âˆˆbâˆ’   cpu  mb ram linux operating                                           âˆˆ st affects â‰ºt     following theorem combines conclusions   results  theorem  lemma  remark          table  contains results logistics task modi                                                                         Îº  main theorem  let   a Ï•  planning task ï¬ed rovers tasks                                                     second columns show size  âˆˆ nifpbase âˆ§ pbmc âˆ§ plin satisï¬able  plan length                    largest scc computed disabling graph compared                                                        overall number nodes fourth column shows  proof sketch theorem  know exists parallel plan lengths bp obtained parallel encoding  sequence sets operators sÂ¯  ssbâˆ’  compared sequential plan lengths bs column ï¬ve  qÂ¯  execisÂ¯ deï¬ned qÂ¯  Ï• order able interval given shortest sequential plan  use lemma  need sequence â‰ºÂ¯  â‰ºâ‰ºbâˆ’  length mbs â‰¤ precisely determine bs  corresponding total orderings time sat solver running times exceeding timeout                                      point âˆˆbâˆ’  pair âˆˆ st operators                                                            Îº   affecting â‰ºt  orderings â‰ºt constructed  tasks remained unsolvable                                                           implicit nesting depth three tem    formally prove similar proof poral operators sometimeafter sometimebefore  rintanen et al                      atmostonce                                                    ijcai                                                    
