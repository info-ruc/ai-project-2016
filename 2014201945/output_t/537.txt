                                  parameterized      compilability                                                  hubie  chen                                        departament   tecnologia                                         universitat pompeu   fabra                                              barcelona spain                                         hubiechenupfedu                        abstract                          cadoli et al    gogic et al                                                         based ad hoc proofs did explicitly use uniï¬ed      compilability measure effectively com proof technique      pilation preprocessing applied knowl cadoli et al  robust theory compilability      edge bases speciï¬ed particular knowledge rep developed possible systematically orga      resentation formalism aim compilation  nize knowledge representation formalisms according      allow efï¬cient online query processing compilability way classical complexity      theory compilability established ory possible systematically organize languages      ganizing knowledge representation formalisms ac  according intractability particular theory      cording scheme â€œcompilability classesâ€   compilability provides way deï¬ne clas      bears strong analogies classical theory sical complexity class analogous compilability class      complexity permits organization  compc  theory provides notion reduction      computational problems according complexity    use compilability classes compc compilabil      classes develop novel theory compilabil ity class compp analog languages      ity called parameterized compilability decidable polynomial time contains formalisms      corporates notion parameterization used compilable second formalism query pro      parameterized complexity permits reï¬ned   cessing performed polynomial time saying      analysis compilability                        formalism compilable second formalism mean                                                        roughly knowledge base ï¬rst formal    introduction                                       ism knowledge base fx second formal                                                        ism having answers queries  compilability computational reasoning problems  size fx polynomial size  involve deciding query entailed â€œpolynomial sizeâ€ requirement models intuition com  knowledge base database reasoning problems pilation useful does greatly increase size  computationally intractable methodology cop knowledge base  ing intractability compilation called prepro demonstration formalism compp pos  cessing involves translating knowledge base itive compilation result analogous demonstration  form allows efï¬cient query processing compi language positive tractability result likewise  lation appropriate knowledge bases remain stable demonstration formalism compnphard neg  time queried numerous times ative compilation result implies formalism  compilation performed efï¬ciently compp complexitytheoretic assumption  cost compilation amortized speedup just demonstration language nphard implies  query processing recent years seen language standard assumption  teresting results compilation basic idea simplifying  np  sequence computations preprocessing set useful                                                          cadoli et al   later papers  values old mathematics discussed cadoli et al                                                        including liberatore  liberatore schaerf                                                           liberatore   theory compilability pre                                                        sented cadoli et al  applied successfully  systematic theory number results nineties classify knowledge representation formalisms ap  demonstrated noncompilability results show peared artiï¬cial intelligence literature particular  stance knowledge bases particular knowledge multitude formalisms including propositional logic cir  representation formalism compilable cumscription default logic demonstrated  formalism query processing performed contained compp complete analog compc  polynomial time initial results type including standard complexity class downside theseclassiï¬cation results negative show viewed classically example languages  ing formalism complete compilability ver npcomplete demonstrate parameterized  sion intractable complexity class compnp complexity somewhat orthogonal classical complexity  compconp                                           example vertex cover indicates pa                                                        rameterized complexity provide tractability results                                                        classical complexity does allowance  parameterized complexity abundance  negative  nonpolynomial dependence parameter input  compilability results mirrors state affairs complexity stance ï¬xedparameter tractability permits use al  theory problems classiï¬ed gorithmic ideas utilized proving standard polynomial  according developed scheme complexity classes time tractability results ï¬eld parameterized com  np conp abundance negative results plexity developed rich mathematically deep suite  show completeness hardness classes believed algorithmic techniques  strictly larger generally intractable  problems need dealt practice number parameterized compilability contribution pa  theoretical frameworks developed provide ï¬ner parameterized compilability new theory compil  analysis hard problems offered standard com ability incorporating notion parameterization used  plexity theory examples frameworks include parameterized complexity theory provides novel  ory approximation algorithms averagecase analysis set concepts proving compilability results allowing  relatively recent alternative framework parameterized use sophisticated toolkit developed                                     complexity downey fellows                 proving ï¬xedparameter tractability intractability    parameterized complexity theory classical sults provides avenue reï¬ning negative  complexity theory compilability theory provides classes noncompilability results proved using es  notion reduction categorizing objects case tablished theory compilability articulated downey  parameterized complexity objects categorized pa et al  beneï¬t using parameterized notion  rameterized languages languages instances consisting computational tractability possible en  parts main parameter languages gage extended dialogue single problem  classically studied viewed naturally investigation variety parameters provide  parameterized languages example each instance theoretical framework anticipate formu  vertex  cover  problem viewed consisting lation exploration interesting parameters context  graph main natural number pa parameterized compilability lead reï¬ned analysis  rameter question decide graph compilability results  vertex cover size similarly inde results paper follows parame  pendent  set problem viewed parameterized terized complexity class deï¬ne compilability variant  language instance graph paired natu parcompc deï¬ne notion reduction use  ral number question decide parcompc classes demonstrate robustness  graph independent set size    â€“ particular transitive compatible formal    parameterized ï¬‚avor tractability called ï¬xed sense classes parcompc develop gen  parameter tractability formally parameterized language eral method demonstrating hardness formalism  ï¬xedparameter tractable class fpt exists class parcompc study structure classes  constant instances main parcompc relating structure directly structure                                           size parameter solved time  ex nonuniform versions parameterized complexity classes                                              ample vertex cover solved time kn  constant parameter size  main consequently ï¬xed instances  preliminaries  vertex  cover  main size parame  ter solved time vertex cover attempted make paper selfcontained  considered ï¬xedparameter tractable possible familiarity basic notions com  running time ï¬xedparameter tractable languages exhibits plexity theory including nonuniform complexity classes  restricted form dependence parameter lan parameterized complexity compilability theory  guages solvable practice parameter falls helpful balcazarÂ´ et al  downey fel  limited range fact given time lows cadoli et al  references  bound vertex cover problem solved topics respectively recommend surveys  polynomial time parameter olog downey fellows downey et al  pa  hand independent set believed require time rameterized complexity  main exhibits exponential dependence  parameter â€“ time form similar â„¦nk  deï¬nitions notation  deed independent  set complete parameterized strings assume Î£ ï¬xed ï¬nite alphabet  complexity class believed properly contain fpt ac used form strings length string denoted  cordingly believed outside fpt           times assume pairs strings thatis elements Î£âˆ— Ã— Î£âˆ— represented strings denoted cppoly contains parameterized lan  elements Î£âˆ— pairing function hÂ· Â·i make stan guages exists parameterized polynomial  dard assumptions pairing function size function  âˆ— Ã— Î£âˆ— â†’ Î£âˆ— language  length hx yi linear  hx yi computed âˆˆ Î£âˆ— Ã— Î£âˆ— âˆˆ  time polynomial  polynomialtime hfx xi âˆˆ                                        âˆ—      âˆ—  computable projection functions Ï€ Ï€  Î£ â†’ Î£      parameterized language deï¬ne l  Ï€hx yi  Ï€hx yi  hÂ· Â·i length set   âˆˆ  monotone â‰¤ hx yi â‰¤ hx zi  hy xi â‰¤ hz xi assume tripling knowledge representation formalisms knowledge  function    representing triples strings single         hÂ· Â· Â·i                                        representation formalism krf subset Î£âˆ— Ã— Î£âˆ—  strings similar assumptions hold          parameterized knowledge representation formalism pkrf                                                        subset Î£âˆ— Ã— Î£âˆ— Ã— Î£âˆ—  functions usual consider function  â†’  polynomial exists constant âˆˆ conventions view ternary function  Î£âˆ— Ã— Î£âˆ— Ã—                                 âˆ—  pn  function  Ã— Î£ â†’ param   Î£âˆ— â†’  Î£âˆ— binary function  Î£âˆ— Ã— Î£âˆ— â†’ Î£âˆ— pair  eterized polynomial exists constant âˆˆ ing ï¬rst arguments ghx yi                âˆ—                                   âˆ—  function  Î£ â†’  âˆˆ Ã— Î£  fx example ternary function  Î£âˆ— Ã— Î£âˆ— Ã—                                           âˆ—  pn â‰¤ hkn    words  Ã— Î£ â†’ Î£âˆ— â†’ Î£âˆ— considered parameterized polynomialsize  parameterized polynomial exists constant âˆˆ exists parameterized polynomial  Ã— Î£âˆ— â†’                       âˆ—  each âˆˆ Î£  function pk  â†’ deï¬ned âˆˆ Î£âˆ— Ã— Î£âˆ— Ã— Î£âˆ— fx â‰¤                         pkn  pn                           phx yi similarly pkrf viewed parameter    function  Î£âˆ— â†’ Î£âˆ— polynomialsize ex ized language pairing ï¬rst strings each  ists polynomial  â†’ âˆˆ Î£âˆ— triple considered belong parameterized com                                        âˆ—    âˆ—     âˆ—  fx â‰¤ px similarly function  Î£ Ã— Î£ â†’ Î£  plexity class language  hx yi  âˆˆ  parameterized polynomialsize exists parame  belongs                              âˆ—  terized polynomial  Ã— Î£  â†’     readability times use natural number âˆˆ           âˆ—    âˆ—  âˆˆ Î£ Ã— Î£  fx â‰¤ px               place unary representation    function  Î£âˆ— â†’ Î£âˆ— polynomialtime computable  exist polynomial  â†’ turing machine  compilability   âˆˆ Î£âˆ— turing machine input subsection review theory compilability  produces output gx time px similarly deï¬nitions theorems subsection  function  Î£âˆ—Ã—Î£âˆ— â†’ Î£âˆ— parameterized polynomialtime cadoli et al  presentation based  computable exist parameterized polynomial  Ã— subsection following assumptions  Î£âˆ— â†’  turing machine âˆˆ concerning complexity classes languages effect  Î£âˆ— Ã— Î£âˆ— turing machine input hx ki produces just cadoli et al   output gx time px                                                        assumption  complexity class compatible    function  Î£âˆ— â†’ Î£âˆ— recursively computable                                                        complete problems polynomialtime  exists turing machine âˆˆ Î£âˆ—                                                        reduction â‰¤p   turing machine input produces output hx                                                                        assumption  languages sufï¬xed blanks considered                                                        irrelevant string x considered  languages complexity classes language sub language  set Î£âˆ— set strings parameterized language  subset Î£âˆ— Ã— Î£âˆ— set pairs strings krf  refer each âˆˆ Ï€f  knowl  parameterized complexity class set parameterized edge base knowledge base considered represent                                                                         âˆ—  languages parameterized complexity class knowledge âˆˆ Î£  âˆˆ  roughly speaking  â‰¤ reduction say compatible â‰¤ krf considered compilable complexity class  parameterized languages â‰¤ âˆˆ following preprocessing each knowledge base pos  imply âˆˆ parameterized com ing query knowledge base â€“ deciding  plexity class â‰¤ reduction say hard âˆˆ â€“ performed formal deï¬nition  alternatively chard â‰¤ reductions âˆˆ krfs compilable complexity class includes  â‰¤ say complete alternatively ingredients ï¬rst preprocessing function  ccomplete â‰¤ reductions âˆˆ chard preprocessing knowledge base useful greatly    complexity class nonuniform version increases size knowledge base required                                                                                                   â€œadviceâ€ version denoted cpoly contains polynomial size second â€œtargetâ€ krf  mandated  languages exists polynomialsize func inside class krf translated  tion  âˆ— â†’ Î£âˆ— language function  âˆˆ Î£âˆ— âˆˆ  hfx xi âˆˆ deï¬nition  compc let complexity class krf  parameterized complexity class nonuniform version belongs compc exist  â€¢ binary polynomialsize function  Î£âˆ— Ã— âˆ— â†’ Î£âˆ— properly contained cpoly                                                    properly contained cpoly    â€¢ krf                                                           parameterized  complexity  pairs âˆˆ Î£âˆ— Ã— Î£âˆ—                                                        parameterized complexity theory classiï¬cation         âˆˆ fx âˆˆ  parameterized languages â€“ languages constituents    obtain compilability class compc components classical complexity theory  complexity class compc classes offer rich base complexity class modeling feasible computation  scheme classify krfs just conventional deï¬ned using notion polynomialtime pa  complexity classes offer rich scheme clas rameterized complexity theory base complexity class  sify computational problems ï¬rst reading deï¬ fpt â€œï¬xedparameter tractableâ€ deï¬nable using  nition  conceptually easiest notion parameterized polynomialtime  complexity class equal polynomialtime         fpt                                                                               deï¬nition      parameterized language belongs  case requirement means queries                        fpt                                                       parameterized complexity class exists pa  posed processed efï¬ciently trans rameterized polynomialtime computable function  Î£âˆ— Ã—  lates each knowledge base â€“ necessarily Î£âˆ— â†’   pairs âˆˆ Î£âˆ— Ã— Î£âˆ—  form allows efï¬cient resolution queries  â€“ knowledge base fx â€“ form      âˆˆ gx                                             allows efï¬cient resolution queries       roughly speaking parameterized language    following notion reduction associated class fpt exists constant âˆˆ each  compc  classes allows compare compilability      def                                                        â€œksliceâ€        computable poly  different krfs                                                        âˆˆ                                                          nomial time polynomial degree degree  deï¬nition  comp reducibility krf comp reducible polynomials bounding time lk â€œuniversalâ€                                  krf denoted â‰¤comp  exist     constant depend hand                                          âˆ—   âˆ—    âˆ—    coefï¬cients polynomials arbitrary depen    â€¢ binary polynomialsize functions  Î£ Ã—  â†’ Î£                                                    dence                                                 âˆ—        following notion reducibility used com    â€¢ binary polynomialtime computable function  Î£ Ã— pare complexity parameterized languages      Î£âˆ— â†’  Î£âˆ—                                                        deï¬nition  parameterized reducibility parameterized  pairs âˆˆ Î£âˆ— Ã— Î£âˆ—                                                        language parameterized reducible parameterized                                                     âˆˆ fx gfx âˆˆ  language denoted â‰¤par exist  theorem  complexity class comp reduc â€¢ parameterized polynomialtime computable function  tion transitive compatible class compc  Î£âˆ— Ã— Î£âˆ— â†’ Î£âˆ—    structure compilability classes compc â€¢ recursively computable function  Î£âˆ— â†’ Î£âˆ—  directly related structure complexity classes                    âˆ—   âˆ—  cpoly                                               pairs âˆˆ Î£ Ã— Î£                                                                                                      theorem  let complexity classes      âˆˆ fx hk âˆˆ   tainment compc âŠ† compc  holds deï¬ne parameterized complexity classes  tainment cpoly âŠ† cpoly holds                      contrast class fpt each classes deï¬ned      complexity classes obey directly languages reducible particular language                            proper containment   theorem  gives strong evi deï¬nition  deï¬ne following parameterized lan  dence corresponding compilability classes compc guages weight truth assignment deï¬ned               compc  obey similar proper containment compc  number variables maps true  compc note making observation appeal  widely held belief relationships â€œstandardâ€ â€¢ weighted formula satisfiability  complexity classes affected nonuniformity input boolean formula                                                             question does   satisfying assignment    deï¬nition compc â€œnonuniformâ€ prepro weight  cessing translation function takes knowledge base  input addition given length query â€œuni â€¢ weighted circuit satisfiability  formâ€ version classes compc translation function input boolean circuit  given knowledge base studied compared question does satisfying assignment  compc classes cadoli et al  paper present weight  nonuniform theory parameterized compilability fur  ther discuss uniform compc classes use ideas note term â€œnonuniformityâ€ intended  concepts present paper develop corresponding usual complexitytheoretic sense opposed slightly  uniform theory                                       different sense compc called nonuniformdeï¬nition  deï¬ne following parameterized com classes natural way substantiate claim  plexity classes                                      sidering special cases deï¬nition  lend                                                        intuition reader    â€¢ wsat class parameterized languages                                                          consider case preprocessing function      parameterized reducible weighted formula                                                        simply returns output ï¬rst argument equal      satisfiability                                                                                                                                       projection Ï€ follows equal  conse    â€¢ wp class parameterized languages quently pkrf contained parcompc      parameterized reducible weighted circuit sat  contained intuitively func      isfiability                                      tion does perform preprocessing compilabil    straightforward verify parameterized com ity class parcompc simpliï¬es original class  plexity classes deï¬ned fpt wsat wp consider case pkrf property                                                                                  âˆ—  compatible parameterized reduction strings âˆˆ Î£  holds âˆˆ                                                                            paper assume discussed parameterized  âˆˆ  â€œignoresâ€  complexity classes property component â€œparameterâ€ strings case  complete problems                                    pkrf  naturally induces krf fËœ deï¬ned  assumption  parameterized complexity class  âˆƒkx âˆˆ    âˆ€kx âˆˆ   compatible complete problems pa pkrf contained parcompfpt  rameterized reduction â‰¤par                                                        induced krf fËœ contained compp â€œignor                                                        ingâ€ parameter pkrf  compilability class    parameterized    compilability                     parcompfpt  simpliï¬es nonparameterized vari    classes reductions                           ant compp mention imposing  theory compilability starting point strictions discussed cases simultaneously ef  theory parameterized compilability deï¬nition fectively obtain class think fpt  compilability classes compilability version compp different generalizations  each nonparameterized complexity class deï¬ned deï¬ uniï¬ed obtained specializations  nition  deï¬ne compilability version parcompc parcompfpt  each parameterized complexity class               following notion reducibility comparing    deï¬nition compc  deï¬nition  compilability pkrfs  parcompc  includes translation function space deï¬nition  parcomp reducibility pkrf par                                                                                               par      bound â€œtargetâ€ pkrf  required compreducible pkrf denoted â‰¤comp   inside                                             exist                                                                                                        âˆ—  deï¬nition  let parameterized complexity class â€¢ parameterized polynomialsize functions  Î£ Ã—  pkrf  belongs parcompc exist              âˆ— Ã— Î£âˆ— â†’ Î£âˆ—    â€¢ parameterized polynomialsize function  Î£âˆ— Ã— âˆ— Ã— â€¢ parameterized polynomialtime function  Î£âˆ— Ã—Î£âˆ— Ã—      Î£âˆ— â†’  Î£âˆ—                                         Î£âˆ— â†’  Î£âˆ—                                                                                             âˆ—     âˆ—    â€¢ pkrf                                      â€¢ recursively computable function  Î£ â†’ Î£                                                                                      âˆ—    âˆ—    âˆ—  triples âˆˆ Î£âˆ— Ã— Î£âˆ— Ã— Î£âˆ— natural triples âˆˆ Î£ Ã— Î£ Ã— Î£ natural  numbers â‰¥                                      numbers â‰¥                                        âˆˆ            âˆˆ          âˆˆ                                                                                                                     fx gfx hk âˆˆ     implication containment pkrf inside  parcompc function pkrf  fol note deï¬nition parcomp reducibility  lowing deï¬ne each âˆˆ Î£âˆ— â€œksliceâ€ pkrf direct analog deï¬nition compreducibility deï¬ni            def                                         tion  â€œpreprocessing phaseâ€ given upper bound  gk    âˆˆ deï¬ne size query opposed length       âˆ—   âˆ—     âˆ—  fk  Î£ Ã— â†’  Î£  function fkx  fx query deï¬nition  believe notion                        âˆ—                notice each âˆˆ Î£  krfs fk fk binary duction preferable assumption like assumption  function fk satisfy condition deï¬nition  each  necessary establish transitivity                                                      kslice fk compilable corresponding kslice fk allows simpler proof transitivity proof transi        function fk size bounded tivity specialized proof transitivity â€œupper  parameterized polynomial falling limited boundâ€ variant deï¬nition  removing parameter  range functions fk behave polynomially likewise   âˆˆ fpt falling limited range krf sketch direction claim suppose pkrf  slices  time complexity behaving polynomially described form parcompfpt fix arbitrary                                                           âˆ—                     âˆ—    âˆ—     âˆ—    initial acquaintance deï¬nition  appear âˆˆ Î£  deï¬ne function fËœ  Î£ Ã—  â†’ Î£ fËœx   complex believe classes parcompc fx deï¬ne krffËœ  âˆˆ   unify classes compc parameterized complexity veriï¬ed thatfËœ contained compp fËœ fËœ
