        computational      complexity     dominance       consistency     cpnets        judy  goldsmith             jerÂ´ omeË† lang        miroslaw  truszczynskiÂ´          nic wilson    dept comp   sci              irit               dept comp  sci         cork constraint   university kentucky    universiteÂ´ paul sabatier  university kentucky       computation  centre       lexington ky            toulouse cedex         lexington  ky         university college cork       usa                 france                 usa                ireland    goldsmitcsukyedu            langiritfr            mirekcsukyedu          nwilsoncuccie                        abstract                            study computational complexity prob                                                        lems results obtained far concerned restricted       investigate computational complexity   classes cpnets requiring graph variable      testing dominance consistency cpnets  pendencies implied preference statements cpnet      complexity dominance   acyclic certain assumptions dominancetesting      determined restricted classes problem np additional assumptions      dependency graph cpnet acyclic   domshlak brafman  boutilier et al      preferences deï¬ne complexity general case remained      cyclic dependency graphs modeled  open problem show fact pspace      general cpnets show domi     complete propositional case exhibiting      nance consistency testing general cpnets section  pspacehardness proof dominance testing      pspacecomplete reductions used      turn consistency testing acyclic cp      proofs strips planning estab  nets guaranteed consistent case      lish strong connections areas       general cpnets domshlak brafman                                                         brafman dimopoulos  detailed examples    introduction                                       discussions section  show consistency testing  problems eliciting representing reasoning hard dominance testing  preferences multivariable multiattribute domain prove hardness results ï¬rst establish                                                           pspace  arise ï¬elds planning design group  hardness problems related proposi  cision making explicit representation preference tional strips planning show problems  dering elements refer outcomes reduced cpnet dominance consistency testing  multivariable domains exponentially large number exploiting connections actions strips plan  attributes ai researchers developed lan ning preference statements cpnets  guages representing preference orderings succinctly assume familiarity complexity class                                                        pspace                                formalism cpnets boutilier et al      refer papadimitriou  details                                                                                               npspace     popular ones cpnet provides succinct represen particular rely later equivalences                                                        pspace    copspace  tation preference ordering outcomes terms local                                                                          complexity results paper address cyclic cp  preference statements form  xi  xj  xi xj  values variable logical condition infor nets earlier work concentrated acyclic  mally preference statement   means given model argue acyclic cpnets suf                                                    ï¬ciently expressive capture human preferences  xi strictly preferred xj ceteris paribus  things equal meaning cpnet given simple domains consider instance diner  certain ordering relation dominance set choose red white wine ï¬sh meat  comes derived reading preference statements given red wine prefer meat conversely given meat  outcome dominates say dominant prefer red wine hand given white wine  preferred                                     prefer ï¬sh conversely given ï¬sh prefer white    reasoning preference ordering dominance rela wine gives consistent cyclic cpnet  tion expressed cpnet far easy key prob acyclic cpnet giving rise preferences  lems include dominance testing consistency testing comes cyclicity preference variables does  ï¬rst problem given cpnet outcomes Î± Î² necessarily lead cyclic order outcomes  want decide Î² dominates Î± second prob  lem asks dominance cycle dominance  generalized propositional cpnets  ordering deï¬ned input cpnet let      xn ï¬nite set variables each  outcome dominates preferred   variable âˆˆ  assume ï¬nite domain dx values anoutcome ntuple     dn dx Ã— Â· Â· Â· Ã— dxn  deï¬nition     paper focus propositional variables vari gcpnet locally consistent âˆˆ                                                                      âˆ’         ables binary domains let ï¬nite set propo  formula pc âˆ§ pc unsatisï¬able locally                                                                                 âˆ’        sitional variables âˆˆ  set   Â¬     complete âˆˆ  formula pc âˆ¨ pcx  overload notation write vari tautology  able values refer Â¬x liter                                                        deï¬nition  propositional cpnet cpnet set                        Â¬l                        als given literal write denote dual literal  propositional variables locally consistent lo  focus binary variables makes presentation clearer cally complete gcpnet   impact complexity results    conditional preference rule short preference problems cpdominance cpconsistency  rule expression   Â¬l literal ï¬ned analogously deï¬nition   atom âˆˆ propositional formula deï¬nition cpnet differs given  does involve variable                     boutilier et al uses explicit conditional pref                                                        erence tables representation compact  deï¬nition  generalized cpnet generalized cpnet easy verify equivalent gives rise  short gcpnet set conditional prefer                                        âˆ’              deï¬nition dominance  ence rules âˆˆ deï¬ne pc pc usually deï¬ning decision problem critical specify                      âˆ’                 written just follows pc equal way represent input instances representation  disjunction exists rule   Â¬x affect complexity problem unless stated oth        âˆ’  pcx disjunction exists erwise assume gcpnets cpnets  rule  Â¬x  deï¬ne associated directed represented set preference rules described deï¬  graph gc dependency graph consist nition  size gcpnet given total                                                  pairs variables appears size formulas pâˆ’x px âˆˆ   pâˆ’x    complexity results need following  propositional strips planning  representation gcpnets gcpnet said section derive technical results proposi  junctive form contains rules   Â¬l tional strips planning form basis complex  possibly conjunction literals case ity results sections   establish complexity  formulas pâˆ’x px disjunctive normal form plan existence problems propositional strips planning  disjunction conjunctions literals including  â€“ restrictions input instances make problem  conjunction literals                       useful studies dominance consistency gcp    gcpnets determine transitive relation outcomes nets  terpreted terms preference preference rule   Â¬l let ï¬nite set variables state com  represents statement â€œgiven holds preferred plete consistent set literals  Â¬l ceteris paribusâ€ intended meaning follows view conjunction members state  outcome Î² satisï¬es Î² preferred equivalent outcome deï¬ned cpnets context  come Î± differs Î² assigns Â¬l                                                        deï¬nition  propositional strips planning proposi  variable situation say improv                                                        tional strips instance tuple hv Î±  Î³ act  ing ï¬‚ip Î± Î² sanctioned rule   Â¬l                                                                                         ï¬nite set propositional variables  Î±     Î±m sequence outcomes â‰¥  each  outcome sequence obtained previous  Î± state  called initial state                                      Î±      Î±  improving ï¬‚ip say       Î³ state called goal  improving sequence Î± Î±m gcpnet                                                           act  ï¬nite set    each action  Î±m dominates Î± written Î± â‰º Î±m                                        actions                  âˆˆ    finally gcpnet consistent outcome Î± act described consistent conjunction literals  strictly preferred Î± â‰º Î± prea precondition consistent conjunction    main objective paper establish com literals posta postcondition effect  plexity following problems concerning notion action executable state Î± Î±  prea ef  dominance associated gcpnets fect state Î± state Î± containing literals  strictions class input gcpnets           Î± variables mentioned posta liter                                                        als posta assume action ap  deï¬nition                                                              state effect preconditions                  given gcpnet outcomes Î± plied  gcpdominance                                         hold assumption effect complexity  Î² decide Î± â‰º Î²                                                                                             problem                    given gcpnet decide    propositional  strips plan existence  gcpconsistency                                                    short decide given  consistent                                        strips plan                                                        propositional strips instance hv Î± Î³ act    properties gcpnets essential successful plan sequence actions leading  linking original notion cpnets boutilier et initial state Î± state satisfying goal Î³  al                                     plan irreducible action changes statewe assume loss generality action denote states  pairs Î± Î±  literal posta appears prea state integer  â‰¤ â‰¤ âˆ’   omit literal posta changing effect view compact representation state variables  action posta conjunction     zn assuming binary representation  action omitted act effect    dn dn signiï¬cant digit repre    following result proved bylander   sents state contains zi di   Â¬zi                                                                                               act    proposition  bylander                         pe  acyclic executing action incre                                                        ments counter action executed  strips plan pspacecomplete                                                        counter reached value âˆ’     typically propositional strips instances require claim plan pe  goals complete restrict consideration com plan pe assume plan pe let  plete goals restriction effect complex Ï€ shortest plan pe let length  ity plan existence problem remains pspacecomplete â‰¤ âˆ’ state Ï€ repeats shorter  goalcompleteness restriction lang  plans Ï€ pe exist let Î± Î±     Î±m                                                         Î³ sequence states obtained executing Ï€ let    acyclic strips                                                        action used transition Î±k Î±k  deï¬nition  acyclic sets actions set actions act  âˆ’  exactly  â‰¤ â‰¤  acyclic state Î± hv Î± Î± act action ai applies state Î±  replacing                                                               nonempty irreducible plan informally non Ï€ yields plan started Î±  leads  trivial directed cycles space states induced act  Î±m  Î³ appending plan appropriate                                                                                     âˆ’   consider following problems      actions increment counter yields plan                                                        pe conversely Ï„ plan pe plan obtained    acyclic strips plan given propositional strips Ï„ removing actions form bj replacing each      instance hv Î± Î³ acti act acyclic action ai plan pe      Î±    Î³ decide plan   claim assertion follow            hv Î± Î³ acti    actionset acyclicity given set act actions proposition                    act      decide    acyclic                     actionset  acyclicity pspacecomplete  show problems pspacecomplete  proof argument membership pspace  proposition                                          standard  prove pspacehardness  proceed  acyclic strips plan pspacecomplete               follows let pe  hv Î± Î³ act strips instance                                                        act acyclic Î±  Î³ let new action  proof membership pspace evident problem                                                                               deï¬ned prea  Î³ posta  Î±  easy                                 pspace                                                      restriction strips plan prove   hardness  act âˆª acyclic exists  exhibit polynomialtime reduction strips plan let                                                        plan pe pspacehardness complement  pe  hv Î±  Î³ acti instance strips plan                                                       actionset  acyclicity  problem follows                                       counter  idea reduction introduce  proposition  pspace  copspace  sufï¬ces  each time action executed counter incremented                                                        prove hardness assertion       counter count   making  use additional variables counter initialized   reaches âˆ’  longer incremented  mapping strips plans singleeffect  action executed set actions strips  plans  resulting instance strips plan acyclic                                                        versions strips plan acyclic strips plan    reduction write     xn  deï¬ne pe  hv  Î±  Î³ act follows         problems important allow singleeffect ac                                                       tions actions exactly literal postconditions            â€¢       xn     zn zi new vari input propositional strips instances refer      ables use implement counter       strictions se strips plan acyclic se strips plan                                                                  pspace    â€¢ Î±  Î± âˆ§ Â¬z âˆ§ Â· Â· Â· âˆ§ Â¬zn                        prove         hardness problems                                                       scribe mapping strips instances singleeffect    â€¢ Î³  Î³ âˆ§ âˆ§ Â· Â· Â· âˆ§ zn                                                       strips instances                                                â€¢ each action âˆˆ act  include act actions consider instance pe  hv Î± Î³ act strips              â‰¤ â‰¤                          plan problem act  necessarily acyclic                prea   prea âˆ§ Â¬zi âˆ§ zi âˆ§ Â· Â· Â· âˆ§ zn        each action âˆˆ act introduce new variable xa      post ai   post                                  âˆ§ âˆ§ Â¬ âˆ§ Â· Â· Â· âˆ§ Â¬       set   vaâˆˆact  Â¬xa  conjunction                                      â€¢ furthermore include act actions bi  â‰¤ â‰¤ negative literals additional variables addition                                           each âˆˆ act set xa  xa âˆ§ vbâˆˆactâˆ’a Â¬xb                                                                                              prebi  Â¬zi âˆ§ zi âˆ§ Â· Â· Â· âˆ§ zn                 deï¬ne instance pe  hv  Î± Î³  sact      postbi  zi âˆ§ Â¬zi âˆ§ Â· Â· Â· âˆ§ Â¬zn               se strips plan problem follows                        â€¢ set variables  âˆª xa  âˆˆ act         gcpdominance  gcpconsistency  problems                                                       constructing reduction direction    â€¢ initial state Î±  Î± âˆ§                                                         reduction complex used    â€¢ goal state Î³  Î³ âˆ§                            boutilier et al  fact cpnets impose    â€¢ set actions sact   ai  âˆˆ act       restrictions strips planning firstly strips           posta                         planning allows multiple effects gcpnets allow      let âˆˆ  act   posta   âˆ§ Â· Â· Â· âˆ§ lq ï¬‚ips  Â¬x Â¬x  change value vari            deï¬ne                       able constructed reduction strips                                        prea   prea âˆ§ âˆ§ Â¬li posta   xa        planning singleeffect strips planning section          qi              qi      prea    xa posta     li                   secondly cpnets impose restrictions local      deï¬ne                                    sistency local completeness natural                                        prea     xa âˆ§ âˆ§ Â· Â· Â· âˆ§ lq posta   Â¬xa counterparts context strips planning    let Ï€ sequence actions act  deï¬ne sÏ€ dominance consistency problems considered  sequence actions sact  obtained replacing paper membership pspace demonstrated  each action Ï€     aq  posta considering nondeterministic algorithms consisting  consider sequence Ï„ actions sact  peatedly guessing appropriate improving ï¬‚ips algo  Ï„ action ai  posta   rithms work polynomial space show membership  replace actions form aposta denote problems solve npspace consequently  resulting sequence actions act sÏ„ fol pspace npspace  pspace  lowing properties easy check details omitted space restrictions provide arguments                                                        pspacehardness problems consider  lemma   deï¬nitions   Ï€ plan pe sÏ€ plan pe  dominance  generalized cpnets  ii Ï„ irreducible plan pe sÏ„ plan prove gcpdominance problem      pe                                           pspacecomplete   reduction problem se  iii act acyclic sact  acyclic strips plan know pspacecomplete  proposition                                          mapping  singleeffect strips problems gcpnets  se strips  plan  acyclic   se strips  plan    dominance problems  pspacecomplete                                      let hv Î± Î³ act instance se strips plan  proof se strips plan acyclic  se  strips plan    problem action âˆˆ act denote la                                                        unique literal postcondition posta  la  problems restrictions strips plan                   membership pspace   follows pspacehardness    denote pre conjunction literals prea                                                        different Â¬la recall convention adopted  acyclic se strips plan  prob                                                               earlier pre does contain la deï¬ne ca  lem shown reduction acyclic strips plan                                                                                            conditional preference rule pre  la  Â¬la  consider instance pe  hv Î± Î³ act acyclic                                                    deï¬ne mact   gcpnet  ca âˆˆ act   strips plan deï¬ne pe    hv  Î± Î³  sact  lemma  iii instance acyclic se strips sequence states plan corresponds improving  plan problem lemma  ii exists plan sequence Î± Î³ leads following result                                          pe exists plan pe    lemma    notation                                                            nonempty  irreducible plan     dominance                                              hv Î± Î³ acti Î³ dominates Î±                                                             goal section prove gcpdominance  problem pspacecomplete complexity does ii act acyclic mact  consistent  restrict class inputs cp                                                        theorem   gcpdominance   problem pspace  nets use results propositional strips planning complete remains restrictions  section  prove general gcpdominance gcpnet consistent conjunctive form  problem pspacecomplete show com  plexity does change impose requirements lo proof pspacehardness shown  reduction  cal consistency local completeness input gcpnets acyclic se strips plan proposition  let    similarities dominance testing cpnets hv Î± Î³ acti instance acyclic se strips  propositional strips planning ï¬rst noted boutilier plan problem lemma ii mact  consistent  et al  reduction presented gcpnet conjunctive form Î±  Î³  boutilier et al given dominance plan hv Î± Î³ act nonempty  problem plan existence problem class propo irreducible plan hv Î± Î³ act lemma  sitional strips planning speciï¬cations consisting unary Î³ dominates Î±        actions actions single effects prove results  dominance  cpnets                             improving sequence Î± Î²                                                                                                      Â¯  section show gcpdominance  remains       ls improving sequence Î±Î±Â¯ Î²Î²  pspacecomplete  restriction locallyconsistent ii improving sequence Î±Î±Â¯ Î²Î²Â¯ lt  locallycomplete gcpnets cpnets refer improving sequence Î± Î²  restriction gcpdominance cpdominance         iii consistent consistent    show pspacehardness cpdominance                             reduction gcpdominance consistent gcpnets sketch proof let  vixi â†” yi deï¬nitions                                                        arranged ensure following cpnet    mapping locallyconsistent gcpnets cpnets                                                         suppose holds outcome outcome  let   locallyconsistent gcpnet let                                                              written Î±Î±Â¯ Î± improving ï¬‚ip      xn set variables deï¬ne                                                             changes variable xi furthermore im  âˆª     yn     yn âˆ©  âˆ… deï¬ne                                                          proving ï¬‚ip changing variable yi  gcpnet  show cpnet improving ï¬‚ip gcpnet outcome Î±  end âˆˆ  deï¬ne conditional preference                                                            changing variable xi applying ï¬‚ip changing  rules qz   Â¬z qâˆ’z  Â¬z  included                                                            variable yi exactly improving ï¬‚ip possible  specifying formulas qz qâˆ’z                                                            changing xi holds follows    each variable xi âˆˆ  set                                                            ing yi immediately ï¬‚ipped                             âˆ’                             locally consistent             xi  yi  xi  Â¬yi                                                         does hold outcome improving  xi depends yi note                 âˆ’                                         ï¬‚ips possible change value variable xi  mulas xi xi satisfy localconsistency local                                                            yi make xi â†” yi hold  completeness requirements                                                          implies ii implies half iii    each variable yi  â‰¤ â‰¤ deï¬ne                                                        inconsistent inconsistent conversely                                                                             ei    â†” âˆ§ Â· Â· Â· âˆ§ xiâˆ’ â†” yiâˆ’        suppose inconsistent exists improving                                                                                 âˆ§xi â†”  yi âˆ§ Â· Â· Â· âˆ§ xn â†” yn     sequence    outcome                                                        improving ï¬‚ip applied outcome does                             âˆ’        âˆ’         fi  ei âˆ§ xi fi  ei âˆ§ xi         hold increases number xi â†” yi                                                        holds implies hold outcome  finally deï¬ne                                                        cyclic write outcome Î±Î±Â¯                              âˆ’                                                                     Î±Î±Â¯                yi  fi âˆ¨ Â¬fi âˆ§ xi                cyclically permute form improving sequence                                                        ii implies exists improving                                                    ï¬‚ipping sequence Î± showing                âˆ’       âˆ’                      yi  fi âˆ¨ Â¬fi âˆ§ Â¬xi                inconsistent                                                                         yi depends variable                                                     note local consistency formulas fi âˆ§ theorem  cpdominance pspacecomplete   âˆ’  fi   â‰¤ â‰¤ unsatisï¬able consequently formulas holds restrict cpnets consistent          âˆ’                                        yi âˆ§ yi  â‰¤ â‰¤ unsatisï¬able proof use reduction pspacehardness                         qy  âˆ¨ qâˆ’y   locally consistent finally      equivalent gcpdominance  problem gcpnets restricted             âˆ’                              fi âˆ¨ Â¬xi âˆ¨ fi âˆ¨ xi tautology locally consistent theorem  let consistent                                  complete cpnet                   locally consistent gcpnet  let Î±    let Î±   Î²  outcomes      xn Î² outcomes  consider cpnet       yn respectively Î±Î² denote outcome variables  constructed lemma ii imply          obtained concatenating ntuples Î± Î² Î² dominates Î± Î²Î²Â¯ dominates Î±Î±Â¯                            versely outcome written way consistent lemma iii    let Î± outcome  deï¬ne Î±Â¯ hardness assertion follows        come     yn obtained replacing Î±  component form xi yi component Â¬xi  Â¬yi  â‰¤ â‰¤ Î±Î±Â¯  ei        consistency  gcpnets    let  sequence Î±     Î±m outcomes    deï¬ne  ls sequence outcomes  section show gcpconsistency problem                                                        pspacecomplete using results sections    Î±Î± Î±Î± Î±Î± Î±Î±     Î±mÎ±m let se                           quence       m outcomes   Î±Î±Â¯ theorem          Â¯            m  Î²Î²  deï¬ne sequence obtained gcpconsistency pspacecomplete holds  projecting each element iteratively removing restriction gcpnets conjunctive form  elements sequence prede                                                        proof  pspacehardness   shown reduction  cessor consecutive outcomes different                                                        actionset  acyclicity    apply function  lemma   deï¬nitions                   section  followed section  maps
