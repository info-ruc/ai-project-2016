           abstract interpretation programs modelbased debugging                                   wolfgang mayer        markus stumptner                                   advanced computing research centre                                        university south australia                                        mayermstcsunisaeduau                                                                                 language                      abstract                                               semantics      testcases      developing modelbased  automatic debugging      strategies active research area sev                                                          program      eral years present modelbased debug                                  conformance test                                                                       components      ging approach based abstract interpre                                            fault                                                                                        conï¬‚ict sets      tation technique borrowed program analy                                             assumptions      sis abstract interpretation mechanism inte      grated classical modelbased reasoning en                             mbsd engine      gine test approach sample programs      provide ï¬rst experimental comparison      earlier models used debugging results                                     diagnoses      show abstract interpretation based model      provides precise explanations previous                                                                        figure  mbsd cycle      models standard nonmodel based approaches                                                           modelbased debugging    introduction                                       modelbased software debugging mbsd application                                                        modelbased diagnosis mbd  techniques locat  developing tools support software engineer locating ing errors programs mbsd ï¬rst intro  bugs programs active research area during duced console et al  goal identifying  decades increasingly complex programs require incorrect clauses logic programs approach  effort understand maintain dif extended different programming languages includ  ferent approaches developed using syntactic ing vhdl  java   semantic properties programs languages          basic principle mbd compare modelade    paper extends past research modelbased diagnosis scription correct behaviour observed  mainstream object oriented languages java behaviour traditional mbd systems receive  crete example  show abstract program anal description observed behaviour through direct mea  ysis techniques used improve accuracy results surements model supplied systemâ€™s  level capabilities past modelling ap signer difference behaviour anticipated  proaches particular discuss adaptive model reï¬ne model actual observed behaviour used iden  ment model reï¬nement process targets loops partic tify components assumed deviate  ular identiï¬ed main culprits mal behaviour explain observed behaviour  imprecise diagnostic results exploit information ob key idea adapting mbd debugging ex  tained abstract program analysis generate reï¬ned change roles model actual  model allows detailed reasoning conï¬‚ict model reï¬‚ects behaviour incorrect program  detection                                            test cases specify correct result differences    section  provides introduction modelbased diag values computed program anticipated  nosis application automatic debugging section  sults used compute model elements assumed  outlines adaption program analysis module behave differently explain observed misbehaviour  debugger discusses differences clas programâ€™s instructions partitioned set model com  sical analysis frameworks section  contains results obtained ponents form building blocks explanations each  series experiments compares outcome component corresponds fragment programâ€™s source  techniques discussion related future text diagnoses expressed terms original  work concludes paper                             program indicate potential fault programmer                                                    ijcai                                                     figure                                                            â†’     each component operate normal mode denoted             int   Â¬ab  Â· component functions speciï¬ed       int   program abnormal modes denoted ab Â·       â‰¤   different behaviour intuitively each component mode           â€œ correct  âˆ— â€  corresponds particular modiï¬cation program                                                                                  example  program  figure  partitioned  ï¬ve components cc each representing sin             assert    gle statement components representing assignments  possible ab mode leave variableâ€™s value undeter figure  example program test speciï¬cation  mined possibility expand assignment  set variables rendering values undetermined                                                                                    loops number iterations altered     example   assume component   representing line                                                         program figure  abnormal case ex    model components formal description seman ecution terminates state satisfying   tics programming language set test cases fore fault line  explain programâ€™s misbe  submitted conformance testing module determine haviour contrast value left undetermined  program reï¬‚ecting fault assumptions consistent line  execution exists program satisï¬es  test cases program consistent test assertion potential explanation  case speciï¬cation program possibly satisï¬es behaviour  speciï¬ed test case                              deï¬nition explanation intuitive pre    case program does compute anticipated cise test undecidable approximated differ  sult mbsd engine computes possible explanations ent abstractions proposed literature ranging  terms mode assignments components invokes purely dependencybased representations  pred  conformance testing module determine explanation icate abstraction  following section introduces  valid process iterates possible approximation based abstract interpretation  tech  explanations                         nique borrowed program analysis    formally mbsd framework based reiterâ€™s  ory diagnosis  extended handle multiple fault modes  model construction  component mbsd relies test case speciï¬cations models developed vhdl early models java  determine set fault represents valid explanation based static analysis represented program  each test case describes anticipated result ï¬xed model representing programâ€™s structure test  execution using speciï¬c input values                 cases taken account necessary repre  deï¬nition  debugging problem debugging problem   sent possible executions fault assumptions  triple p c source text pro approach used successfully debug vhdl pro  gram consideration set test cases grams dynamic method lookup exception handling  denotes set components derived         lead large models java programs                                                          mayer stumptner  propose approach                                      set  partition statements contains model constructed dynamically taking account  building blocks explanations returned debugger executions feasible given test case ap  simplicity presentation assumed proach based abstract interpretation  programs  separate component each program statement        generalised fault assumptions test case informa       set      fault  assumptions   Î”        Ë†   tion account following basic principles  ab ab ck valid explanation  introduced detailed presentations given   model modiï¬ed components  ci  exhibit     deviating behaviour remaining components exhibit  normal behaviour longer implies incorrect behaviour  abstract interpretation  deï¬nition  explanation fault assumption Î” model derived graph representing effects  sistent explanation debugging problem p c iff individual statements program  alltestcasest âˆˆ derived executions                   Î”                                deï¬nition  program graph program graph pro   altered reï¬‚ect  violate                     gram tuple vssÏ‰ e ï¬nite set         âˆ€t Ë† ioâˆˆt    âŠ• Î” âŠ•   âŠ¥      vertices âŠ† Ã— set directed edges s âˆˆ                                                        sÏ‰ âˆˆ denote distinct entry exit vertices  represent input values assertions describing vertices program graph represent sets program  correct output values speciï¬ed test speciï¬cation states edges represent effects program instructions  spectively  Â· denotes semantic function program transforming sets program states new sets states  ming language fault assumptions âŠ• denotes ap initial vertex  associated initial program state  plication fault assumptions Î” test assertions described test speciï¬cation execution pro     âŠ¥     denotes infeasible program state           gram starts initial state s proceeds following                                                    ijcai                                                                                                                                                   Ë†    Ë†                      proximation  computed program guar     s  â†’             s                                                    Ë†                                                        anteed terminate state Î³sÏ‰ work apply                Ë†          Ë†                              s          variant bourdoncleâ€™s bidirectional method                                   Ë†           Ë†    Ë†         ward backward analyses applied repeatedly reï¬ne                       approximations                     Ë†             Ë†   Ë†                             âˆ‡ â‰¤  example  using backward analysis derived      âˆ‡  â‰¤                                                       program figure  terminate sÏ‰  â†’                           Ë†              Ë†                                       â‰¤                                                                                     hold  assuming left             Ë†             Ë†            undetermined                                                              Ë†          Ë†                 dynamic model creation                                                                       utilise abstract interpretation debugging deï¬nition                         sË†     sË†                              Ï‰                         lifted abstract domain replacing  Â·                                                                                                                                           abstract counterparts  Â· iË† respectively                                                        translation necessary assumed rep     figure  program graph abstract equation resented assertions programming language                                                                                                                                evaluated using  Â·   edges ï¬nal vertex Ï‰ reached program framework apply wellknown nonrelational  states sÏ‰ represent result computed program interval abstraction  approximate concrete program  example  figure  depicts program graph derived states use simple abstraction described   program figure  Î”  âˆ… each program state ensure dynamically allocated data structures repre  ment represented edge connecting program state sented ï¬nitely  statement executed successor state contrast purely static program analysis  loop statement line  induces possible successors assume ï¬xed program graph modelling possible execu                                                        tions instead graph constructed dynamically using  transition representing case loop entered       transition representing loop termination starting puts assertions test case speciï¬cations                   â†’                                 paths executed starting state  initial state     ï¬‚ow graph induces trace                        âŠ¥  traverses loop times stops sÏ‰ created paths contain ignored program   â†’                                               state reached multiple paths followed                                                        apply conventional equationbased analysis remain  case initial state fully speciï¬ed parts ing execution framework placed mid  intermediate state undetermined fault assump dle grounds purely static analysis  dynamic  tions potentially inï¬nite number paths followed analysis                         determine states Ï‰                           algorithm determining consistency program    ensure analysis graph ï¬nite concrete fault assumptions Î” test case outlined  program states concrete semantics program follows  replaced abstract versions formally abstract                                                                                         Î”     interpretation framework  uses complete lattices repre  add assertions apply   sent concrete abstract states sË† sË† âŠ¥    construct initial program graph using forward                                                                                 safe abstraction p  âˆ… âŠ† âˆª âˆ© âŠ¥ abstract semantics  Â· initial state iË†  notes infeasibility  represents possible states  rep  resents abstract state ordering   denote  apply backward analysis approximate initial pro  upper bound greatest lower bound operator respec gram states implying assertion violations later  tively                                                   execution    key component framework pair functions  analyse program graph forward direction using  Î± Î³ â€œgalois connectionâ€ Î± maps sets concrete new initial program states eliminate values  program states abstract representation Î³ imple realised  ments reverse mapping semantic functions operating  repeat step  ï¬xpoint reached                                       Â· Ë† Î±â—¦ Â· â—¦Î³  abstract domain deï¬ned            case initial program state âŠ¥ execution  approximation program execution obtained satisfying test case speciï¬cations  translating program graph set equations Î” valid explanation Î” consistent  computing ï¬xpoint solution case abstract lattice test case considered  inï¬nite height program graph cyclic widening  operators âˆ‡ applied ensure termination widen beneï¬ts dynamic approach follows  ing operators selectively discard information ab equation concise signiï¬cant  stract states guarantee computation mutually advantage dealing paths representing excep  dependent equations eventually converges                  tions java runtime exceptions thrown    similar equations systems ï¬xpoint solutions large number statements typically                                            Ë†  rived backward analyses given sÏ‰ ap paths actually followed execution                                                    ijcai                                                      ii ambiguity control ï¬‚ow reduced compared sÏ‰   â†’  â†’ âˆ backward analysis reveals      purely static approach important advan  â†’  hold loop state      tage precision abstraction dynamic data ï¬‚icts program state loop contains      structures deteriorates dramatically pres  â†’  subsequently loop expanded attempt      ence loops program graph               prove Î” does represent true fault pro                                                        cess repeats stops expansions leading state  iii simple nonrelational abstractions sufï¬cient ob   â†’ âˆx â†’ âˆ      tain good results values related variables                 point proved                                                        assertion violated sÏ‰  âŠ¥ subsequent      known expressions partially evaluated leading              âŠ¥              Î”      tighter bounds remaining variables    ward pass derives     eliminates set                                                        potential explanations  iv case values potentially accessed called      method known program state method  fault assumptionsstructural ï¬‚aws                     ab      does include   components ï¬xpoint compu similar modelbased hardware diagnosis  previous      tation replaced native execution     mbsd approaches great difï¬culty faults mani    ï¬xpoint analysis limited regions execu fest structural differences model dynamic mod  tion values abstract states critical regionâ€™s elling approach described ï¬‚exible fault  execution undetermined fault assumptions af assumptions modifying variables originally af  fect minor program state execution pro fected componentâ€™s behaviour addressed  ceed normally unaffected regions consequently al appropriately modelling dynamically allocated data  ternative branches considered purely static structures beneï¬ts particular scope fault assump  abstract interpretation eliminated            tions determined precisely compared  example  assume  mbsd    examines Î”        crude modelling previous mbsd approaches led                                                        large fraction undesirable explanations  ab running example case execu  tion proceeds normally line  reached execution expressive speciï¬cations correct behaviour                                                         believe extended fault modes deal effectively  ab leads state  â†’  unde  termined known execution statement  complex faults  proceed normally ambiguity control ï¬‚ow arises  line  fact entire trace reduces linear chain  evaluation  backward analysis derives value hold af section presents experimental results obtained  ter statement  executed remaining occurrences model described previous sections compares  undetermined values initial state results mbsd approaches results ob  graph âŠ¥ Î” consistent considered valid ex tained slicing  readers interested theoretical  planation                                            comparison different models referred     iterative reï¬nement                                slicing  partially determined abstract states facilitate iter classic principle program slicing  eliminate  ative model reï¬nement abstraction effects loops statements program inï¬‚uence value  recursive method calls improved known distinguished variable given location program  states loop method contain conï¬‚ict pair v ariable location denotes slicing criterion  ing values case execution inconsistent working hypothesis typically small fraction  loop method expanded case program contributes variableâ€™s value rest  loop shown terminate example pruned away reduce debugging effort  through syntaxbased methods presented  limit static backward slicing starts variable location  number iterations recursive calls set mentioned slicing criterion recursively collects  user loop expanded result values statements inï¬‚uence variableâ€™s value pro  lost through widening heap abstraction regained gram execution statements cause  potentially leading contradiction similar im location skipped included process repeats  provements achieved through informed restructuring ï¬xpoint reached static slices com  model based automatically derived userspeciï¬ed puted quickly large programs remaining pro  properties program regions space reasons illus gram remains large  trate reï¬nement approach context running dynamic slicing aims reducing number statements  example rely  detailed discussion considering dependencies arise state  example  assume mbsd engine examines candi  ments executed particular test case execution similar  date explanation Î”  ab loop condition static slicing dependencies variable followed  assumed incorrect loop condition evaluated statements contributing variableâ€™s value collected  uniquely implies number loop iterations dynamic slices typically smaller  known program state loop approx static counterparts programs control depen  imated using intervals   â†’ âˆi  â†’ âˆthe dencies long dataï¬‚ow chains results remain similar  upper bound intervals widening opera example  static slice program figure  wrt  tor assertion satisï¬ed leading slicing criterion i  includes statements                                                       ijcai                                                     remaining statements ignored relevant niï¬cant differences detected test pro  computation test case dynamic slicing com grams exception adder using  putes result difference ap test cases attributed structure  proaches seen case loop executed selected programs large fraction statements  static slice x  contains statements test cases executed test cases  dynamic slice does include statement              seen static slicing dynamic slicing                                                        cases improve compared entire pro    dependencybased mbsd                            gram statements executed test cases similarly dy  number dependencybased mbsd approaches namic slices improve little compared executed  introduced wotawa shown ap statements statements contribute ï¬nal result  proaches provide results equivalent static dynamic slic comparing vbm aim seen aim im  ing case single abnormal variable observed proves vbm cases fact case  following limit attention results obtained through vbm provides fewer explanations explanations  slicing explicitly stating results hold missed vbm comparing aim slicing aim  dependencybased mbsd                                provides signiï¬cantly fewer explanations computation                                                        ally demanding slicing approaches typically compute    valuebased mbsd                                 solutions milliseconds note vbm aim                                                        currently optimised speed rely java inter                              valuebased models vbm  extend simple  preter written visualworks smalltalk  pendency tracking model effects program state  ments explicitly contrast abstract interpretation  related work  based approach discussed vbm does abstract  concrete semantics relies statically delta debugging  aims isolating root cause pro  structed models model effective programs gram failure minimising differences run  dependencybased representations provide ac exhibits fault similar does differences  curate results poor abstraction causes model col program states point executions  lapse loop iterations recursive method calls systematically explored minimised resulting sin  determined precisely                              gle â€œroot causeâ€ explaining program fails                                                          model checking recently applied locate    experimental results                             faults   comparing abstract execution traces leading                                                        correct erroneous program states likely causes  set test programs used evaluate perfor                                                        misbehaviour identiï¬ed focussing traces  mance different debugging approaches programs                                                        deviate slightly passing failing test cases  taken siemens test suite  transcribed java                                                          error traces applied synthesise poten  debugging test bench commonly used debugging                                                        tial corrections faulty programs given speciï¬cation  community retained earlier tests                                                        programâ€™s correct behaviour  symbolic evaluation  vbm dependencybased models                                                        used compare symbolic representations program states    summary results obtained given figure                                                         computed program versus states necessary satisfy  loc denotes number noncomment lines pro                                                        post condition program differences pred  gramâ€™s source code comp represents number diagno                                                        icates allow heuristically synthesise replacement expres  sis components used construct explanations sslice dslice                                                        sions correcting single faults program approach  exec denote number statements static slice                                                        able provide corrections automatically formal  dynamic slice number executed statements respec                                                        speciï¬cation given required mbsd  tively vbm aim denote number statements  turned potential explanations vbm model  described paper time average diagnosis time conclusion  seconds wallclock time required aim results introduced basic principle modelbased software  aim vbm limited single fault explana debugging illustrated model centred abstract  tions limitations implementation vbm simulation programs differences previous approaches  diagnoses listed aim included outlined results obtained using different debugging  vbmâ€™s results initial experiments multiple faults indi strategies compared notable improvements  cated number explanations does differ signiï¬ approaches achieved particular â€œdifï¬cultâ€  cantly static slicing does warrant additional programs traditional debugging techniques  overhead necessary aim vbm               form    each program variants different faults cre abstract interpretation based model shown  ated tested test cases variant achieve considerable improvement compared slicing  test results reported averages each program previous modelbased debugging approaches reduc  variants test cases slight improvements ob tion average number explanations   served using single test case sig static slicing roughly  conversely model com                                                        putationally demanding require optimisation    httpwwwstaticccgatecheduaristotle         applicable midsized large programs interactive  toolssubjects                                       setting                                                    ijcai                                                     
