
the factored state representation and concurrency semantics of petri nets are closely related to those of concurrent planning domains  yet planning and petri net analysis have developed independently  with minimal and usually unconvincing attempts at cross-fertilisation. in this paper  we investigate and exploit the relationship between the two areas  focusing on petri net unfolding  which is an attractive reachability analysis method as it naturally enables the recognition and separate resolution of independent subproblems. on the one hand  based on unfolding  we develop a new forward search method for cost-optimal partial-order planning which can be exponentially more efficient than state space search. on the other hand  inspired by well-known planning heuristics  we investigate the automatic generation of heuristics to guide unfolding  resulting in a more efficient  directed reachability analysis tool for petri nets.
1 introduction
petri nets are traditionally used for modelling and analysing distributed systems  murata  1 . they provide a compact description of the state space in much the same way as planning operators do  but additionally represent independence  concurrency  and causal relations between actions in a way that enables the recognition and separate resolution of independent subproblems. this confers  e.g.  the ability to reason about partially ordered sets of actions without having to consider their interleavings. this was exploited early on by godefroid and kabanza  to synthesize reactive plans.
모nevertheless  it is fair to say that work since then has failed to sufficiently develop and utilize the connections between the two areas. a recent exception is edelkamp and jabbar's  work on applying planning via heuristic search to detecting deadlocks in petri nets. the primary goal of our work  by contrast  is to determine whether techniques developed for petri net analysis could be successfully applied to planning.
모we focus on petri net unfolding  mcmillan  1; esparza et al.  1   an exact reachability analysis technique which is particularly attractive in that it preserves and exploits much of the structure inherent in the petri net. the unfolding process generates  forward  a simpler type of net called an occurrence net  which is acyclic and avoids certain conflicts. in petri net analysis  where the problem is often to prove the absence of deadlocks  unfolding amounts to a breadth-first search which stops when the generated occurrence net represents all markings reachable in the original net. the size of the unfolded net is bounded below by and is typically exponentially larger than the size of the original petri net  but is bounded above by and is typically exponentially smaller than the size of the state space it represents. hence searching in unfolding space offers potential gains over state space search.
모in section 1  we provide the necessary backgroundon petri nets and unfolding  pointing out the differences with the approximate reachability analysis performed by the planning graph  blum and furst  1 . in section 1  we give a translation from planning problems to 1-safe place transition nets  low level nets to which off-the-shelf unfolding tools apply.
모in section 1  we describe our new planning method. a rather costly option would be to first build the complete unfolded net  and then extract from it the partially ordered plans of interest in time linear in their size. to capitalise on the approach for planning  we instead embed heuristic search into the unfolding  resulting in a directed model-checker  edelkamp et al.  1  for petri nets. we show that monotonic planning heuristics such as hm  haslum and geffner  1  can be directly computed from the original petri net  and guide the unfolding towards minimal cost plans without loss of completeness.
모finally  in section 1  we present and analyse experimental results obtained with benchmark problems from the international planning competition and with a standard petri net benchmark. proofs are omitted on grounds of space and are available in the technical report  hickmott et al.  1 .
1 petri nets and unfolding
1 place-transition net
we consider low level petri nets called place-transition  pt  nets. a pt-net  see left-hand side of figure 1  consists of a net n and its initial marking m1. the net is a directed  bipartite graph. the two types of nodes are places and transitions  which represent the state variables and the events of the underlying system. arcs  which capture the dynamics of the system  are directed from places to transitions and vice versa. the marking m of a pt-net represents the state of the system it models. it assigns to each place 1 or more tokens.
definition 1 a pt-net is a 1-tuple  p  t  f  m1  where p and t are disjoint finite sets of places and transitions  respectively  f :  p 뫄 t  뫋  t 뫄 p  뫸 {1} is a flow relation indicating the presence  1  or absence  1  of arcs  and m1 : p 뫸 in is the initial marking.
모the preset  x of a node x in the net is the set {y 뫍 p 뫋 t|f y x  = 1}. the postset x  of a node is the set {y 뫍 p 뫋 t|f x y  = 1}. for simplicity  we assume that every transition has non-empty preset and postset. a particular marking m enables a transition t if  p 뫍 p f p t  뫞 m p . the occurrence  or firing  of transition t absorbs a token from each of its preset places and produces a token in each of its postset places  thus moving the net from m to the new marking.
this corresponds to a state transition of the modelled system. a set of transitions t is concurrently enabled at the marking m if it is possible for allto occur simultaneously  viz.
. for instance  in the net of figure 1  transitions 1 and 1 are concurrently enabled for the given marking  as are transitions 1 and 1. conversely  transitions 1 and 1 are in forward conflict  which means that  whilst each is individually enabled  only one of them can fire. firing transitions 1 and 1  in any order or concurrently  followed by transition 1 results in one token each in places f and g. we say that a pt-net is n-safe if the number of tokens in each place can never exceed n. in this paper  we consider 1-safe nets.
1 unfolding the place-transition net
unfolding is a method for reachability analysis which exploits and preserves concurrency information. in planning terms  the unfolding approach allows searching for partially ordered plans without considering unnecessary interactions between actions. the unfolding of a pt-net produces an occurrence net whose nodes are called conditions and events. these represent particular occurrences of the places and transitions  respectively  in possible runs of the original net from the initial marking. the unfolding achieves this by eliminating cycles and backward conflicts. two transitions that output to the same place are in backward conflict; by eliminating this we know exactly which transitions were fired to obtain a particular marking. in planning terms  the elimination of backward conflicts achieves the property of post-uniquenessof the action set  backstrom and nebel  1   which implies that we know the exact set of actions that causes a state variable to have a certain value at some point in the plan.
모the unfolding of a pt-net n =  p t f m1  is 붹 =  on     where is an occurrence net and   is a homomorphism from on to n  a mapping from conditions b and events e to places p and transitions t respectively. the occurrence net starts with conditions representing the places initially marked in the pt-net  that is    maps the set b1 of conditionswhich have an emptypreset one-oneonto the set of places p such that m1 p  뫟 1.
모the right-hand side of figure 1 shows a prefix of the unfolding of the pt-net example in the left-hand side. notice the multiple instances of place g for example  due to the different paths through which it can be reached. note also that transition 1 does not appear in the unfolding  as there exists no path through the net in which the events in its causal history are not in conflict.
1 configurations
to understand how the unfolding is built  the most important notions are that of a configuration and the local configuration of an event. a configuration represents a possible partial run of the net. it is any set of events c such that:
1. c is causally closed  that is if any event is in the configuration  then so are all its ancestors in the occurrence
.
1. c contains no forward conflict - this is motivated by the fact that two events in forward conflict cannot both occur  in any order or simultaneously  in the same run of the net:.
for instance  in the finite prefix in figure 1  {e1 e1 e1 e1} is a configuration. a configuration c can be associated with a marking mark c  of the original net by identifying which conditions will contain a token after the events in c are fired from the initial marking: mark c  =    b1 뫋 c    c   where c  = {e |e 뫍 c} and  c = { e|e 뫍 c}. that is  the marking of configuration c identifies the resultant state of the original petri net when  only  the events in c occur. for instance  in figure 1  the marking of configuration {e1 e1 e1 e1} is   {c1 c1}  = {g b}.
모the local configuration of an event e  denoted  e   consists of that event and all of its ancestors. it is the minimal configuration containing e. for example   e1  = {e1 e1 e1 e1}. a set of conditionscan be simultaneously marked if the union of the local configurations of their presets forms a configuration. the unfolding process involves identifying which transitions are enabled by those conditions  currently in the occurrence net  that can be simultaneously marked. the identified transitions are referred to as the possible events. a new instance of each is added to the occurrence net  as are instances of the places in each of their postsets.
1 finite complete prefix of unfolded net
in most cases  the unfolding 붹 of a petri-net is infinite. for this reason  we seek a complete finite prefix  one which contains as much information as 붹. formally  the prefix  is complete if for every reachable marking m  there exists a configuration such that
1. mark c  = m  and
1. for every transition t enabled by m there exists a configuration c 뫋 {e} such that e /뫍 c and   e  = t.
모the key to obtaining a complete finite prefix is to identify those events at which we can cease unfolding without loss of information. such events are referred to as cut-off events and are defined in terms of an adequate order on configurations  mcmillan  1; esparza et al.  1 . in the following  c  e denotes a configuration that extends c with the finite set of events e disjoint from c.
definition 1 a partial order   on finite configurations is adequate if
1.   is well founded  1. c1   c1   c1   c1  and

figure 1: example pt-net  left . finite prefix of its unfolding  right . places=circles  transitions=squares and tokens=dots.
1.   is preserved by finite extensions: if c1   c1 and mark c1  = mark c1   then for all finite extensions c1뇬1 and c1뇬1 such that e1 and e1 are isomorphic  we have c1  e1   c1  e1
without loss of information  or in other terms  without threat to completeness  we can cease unfolding from an event e  if e takes the net to a marking which can be caused by some other event e such that . this is because the events  and thus markings  which proceed from e will also proceed from e. relevant proofs can be found in  esparza et al.  1 :
definition 1 let   be an adequate partial order. an event e is a cut-off event with respect to   if the prefix contains some event e such that mark  e   = mark and .
모mole1 is a freeware program which unfolds 1-safe ptnets. it uses an adequate order   on configurations which is based on comparing their cardinality. this is refined by comparisons based on parikh-vectors and the foata normal form to make the order strict and thus minimise the size of the generated prefix  esparza et al.  1 . the prefix on the righthand side of figure 1 is the complete finite prefix that mole generates for our example. the events e1  e1  and e1 are all cut-off events. this is because each of their local configurations  firstly  has the same marking as the local configuration of event e1  ie. {f g}  and  secondly  is greater than the local configuration of event e1 with respect to the adequate partial order implemented by mole. notice that the finite prefix of the unfolding ceases at cut-off events  even though resulting conditions could indeed enable other actions.
1 unfolding algorithm
mole builds the complete finite prefix following algorithm 1. the algorithm maintains a priority queue of possible events in increasing order of   wrt. their local configuration. the expensive part of the algorithm is the computation of the possible events which is exponential in the maximal size of the presets of the transitions; see  esparza et al.  1  for details. the size of the prefix obtained decreases with the strength of the ordering and with the amount of concurrency in the original net. when the ordering is strict  the size of the unfolding is bounded above by that of the reachable state space of the net  up to a small factor  and only equals that

1 http://www.fmi.uni-stuttgart.de/szs/tools/mole/
algorithm 1 the mole unfolding algorithm

add the conditions in b1 to the prefix initialise the priority queue with the events possible in b1 while the queue is not empty: remove the first event in the queue if it is not a cut-off
add the event and its postset to the prefix identify the new possible events and insert them in the queue
endif
endwhile
add the postsets of all cut-off events to the prefix

bound if there is no concurrency at all  esparza et al.  1 . the presence of concurrency typically leads to prefixes exponentially smaller. this is because the unfoldingbuilds a space of partially ordered sets of events and avoids the combinatorial interleavings of events that can be handled concurrently.
1 unfolding vs planning graph
the reader might find it useful to view the unfolding as a powerful planning graph  blum and furst  1   where conditions and events play the role of the graph's proposition and action nodes  respectively. there are a number of important differences  however. firstly  whilst the planning graph performs an approximate reachability analysis  the unfolding computes reachability exactly: a by-product of the petri net semantics is that all mutexes  not just binary ones  are propagated and accounted for when determining sets of possible events. secondly  the unfolding duplicates nodes as needed to guarantee post-uniqueness  i.e.  that conditions  proposition nodes  have a unique event  action node  as predecessor. a consequence of these differences is that plans can be extracted from the unfolding in time linear in their length  while plan extraction from the planning graph requires search. finally  there is no global notion of level in the unfolding. instead  there is an asynchronous vision of time which confers on independent subproblems their own local levels. consequently  the unfolding lends itself more easily to the generation of partially-ordered plans with optimal cost  while the graph is better suited to producingstep-optimal parallel plans.
1 translating planning problems into pt-nets
to use an unfolding tool such as mole for planning  we need to turn planning problems into 1-safe place-transition nets  which these tools accept as an input. in fact  1-safety rather helps in representing propositional planning operators. when reading the truth value of a boolean variable as the presence or absence of a token  allowing multiple tokens in a place would be meaningless. at best  it would require non-trivial book-keeping  since multiple tokens in a place resulting from repeatedly making a variable true would all need to be removed to make this variable false.
모our translation operates in three steps. in the first step 1safety is established by replacing every planning operator by several 1-safe ones  the concept of 1-safe operator is defined below . in the second step  we eliminate negative preconditions which are lacking in pt-nets. in the third step  the resulting problem is finally mapped onto a pt-net. we prove that our translation is correct. we also characterise the extent to which the notion of concurrency in the pt-net we obtain matches the independence-based notion of concurrency commonly used in planning.
1 establishing 1-safety
let a be a set of state variables. the set of literals over a is l = a 뫋 { a|a 뫍 a}. the complement l of a literal l 뫍 l is defined by.
for sets e of literals  we define e = {l|l 뫍 e}. a state s : a 뫸 {1} assigns values 1 or 1 to the state variables. a planning operator over a is a pair such that p 뫋 e   l. a planning operator  has positive preconditions if p   a. it is 1-safe if e   p  that is  if all effect literals appear  negatively  in the preconditions. a planning problem is a quadruple where a is a set of state variables  i : a 뫸 {1} is an initial state  o is a set of planning operators  and g is a set of goal literals.
모we map every planning problem to an equivalent one with the property that every operator has positive preconditions and is 1-safe. we start by establishing 1-safety. an opera-
tor is first replaced by 1|e p| 1-safe operators as follows. let  be a set of effect literals. we define a new operator that works like o when o changes exactly the literals e  in addition to those literals in e 뫌 p which o clearly requires to change . a 1-safe operator that changes exactly these literals and retains the values of other effects of
.
모take e.g. p={a  b c} and e={ a b d  e}. the operator is replaced with the four 1-safe operators
given below along with the respective values for e.


1 eliminating negative preconditions
for a given set a of state variables  we introduce the set a =
exactly when a is false.	  of new state variables. the idea is that a

figure 1:	the pt-net translation of operator x	=
  after transformation into two 1-safe opand  b 		 erators with positive preconditions x
in the second step of our translation  negativepreconditions
 a are eliminated in the usual way  gazen and knoblock 
  by replacing them by corresponding positive precon-
opposite to the value of a. an operator  is reditions a and forcing every state variable a to have the value
placed by 
and		.
모for instance  the operator b} above is replaced with.
1 correctness
we define s o  as the set of operators obtained from o by performing the above two steps. since a is an effect literal iffis an effect literal  and  a is an effect literal iff a is an effect literal  executing every operator in s o  preserves the property that for every state.
모instead of executing the operator o  we can always execute exactly one of the operators in s o  with the same effects. this operator depends on the current state and has the property that every state variable mentioned in its effects actually changes when the operator is executed  which is what the definition of 1-safety requires.
모the following theorem establishes the correctness of our translation. the proof is based on the fact that in any operator sequence any can be replaced by o  and o can be replaced by exactly one operator in s o .
theorem 1 let be any planning problem.
. then for all states s : such that is a reachable state of r
if and only if s is a reachable state of r.
1 mapping to pt-nets
finally we map the resulting planning problem to a pt-net as follows. let be a planning problem. we define a pt-net such that
  the places are p = a 뫋 a 
as e}
  for all
iff i a  = 1  and for all a 뫍 a 뫋 a  m1 a  = 1 or m1 a  = 1.
figure 1 illustrates this mapping for a single operator.
모for every reachable marking m and every place a 뫍 p in the resulting pt-net  m a  뫞 1. the proof of the following theorem is by induction on the length of transition sequences leading to m.
theorem 1 let r be a planning problem. then the pt-net pnet r  is 1-safe.
1 concurrency
we are interested in the notion of concurrent or partiallyordered plans which allow the simultaneous execution of several operators. the question arises if the notion of concurrency used in connection with the pt-nets obtained by our translation coincides with the standard notion of concurrency in ai planning. it turns out that this is not the case.
모the standard notion of concurrencyin planning is independence: two operators are independent iff
. this
captures the intuition that they can be executed in any order  yielding the same result in both cases.
모independence does not in general imply concurrency in the pt-net sense. for instance  consider the two independent planning operators. the corresponding petri net transitions both take a token from a and therefore cannot fire concurrently. this could be remedied by considering petri nets with read-arcs  but this complicates the unfolding process  and is not supported by mole.
모for pt-nets in general  the converse implication does not hold either  ie. in some cases  transitions that could not take place simultaneously in the planning context can be simultaneous. for instance  consider two petri net transitions t and t such that   and
. in markings in which places a and c contain a token these two transitions can fire in any order and concurrently. if these transitions are interpreted as planning operators  no concurrency is possible because the operators are dependent. however  unlike in the general case  the concurrency relation arising out of our translation is strictly stronger than independence:
theorem 1 let be a planning problem  let  and o1 be operators in o. if there are transitions t1 t1 뫍 t such that t1 뫍 s o1   t1 뫍 s o1  and t1 and t1 can fire simultaneously  then o1 and o1 are independent  and can be executed simultaneously .
this can be proven contrapositively  assuming that o1 and o1 are not independent  and showing that together with 1-safety
and the complementary role of places in a and a  this implies
that cannot fire simultaneously.	
1 directing mole for planning
once the problem is translated to a pt-net  it is easy to let
mole produce a partially ordered plan for that problem. algorithm 1 can be slightly altered to stop whenever the event taken out of the queue is labelled by a designated transition.
mole actually already supports this option. therefore  it suffices to augment the planning operator set with a dummy operator whose precondition is the goal  and to require mole to stop whenever an event labelled with the corresponding transition is dequeued. the local configuration of this event is a partially ordered plan for the problem. further  owing to the fact that mole's queue orders events by increasing local configuration cardinality  this plan contains the fewest actions.
모the cardinality-based ordering relation used by mole has a serious drawback for planning however  as it leads mole to perform a breadth-first search. a natural idea is to change the ordering to provide better guidance towards the goal  while generalising from the restricted notion of optimality currently in place by considering arbitrary additive action costs.
모it turns out that given an arbitrary monotonic heuristic  it is possible to build an adequate orderwhich implements a*  letting the heuristic guide the unfolding towards optimal plans  adequacy ensures that we are retaining completeness of the prefix generated . this rejoins the work on directed modelchecking pioneered by edelkamp et al.  edelkamp et al.  1 . a heuristic h estimates the optimal cost of reaching the goal from a given state and is such that h s  = 1 at goal states. let cost o  be the  positive  cost of operator o  and res o s  be the result of applying o in state s; h is monotonic iff h s  뫞 h res o s   + cost o  for all non-goal states s and operators o applicable in s. these definitions easily transfer to the pt-net case  by identifying each operator with the corresponding transition and considering a set of places as the state in which all and only the variables represented by those places are true. monotonic heuristics which  like hm  haslum and geffner  1   can be automatically generated from a planning problem description  are equally easily generated from pt-nets. we then define the following ordering on configurations:
definition 1   h  let h be a heuristic. for a configuration
c  define  and f c  = g c  + h mark c  . define if and only if or and .
theorem 1 if h is monotonic  the ordering  h is adequate.
the proof is a matter of checking the 1 conditions required for adequacy. only the 1nd condition is non-trivial to prove  and makes use of the monotonicity of the heuristic.
모when ordering mole's queue with  h for some monotonic heuristic h  we obtain a planner that generates partially ordered plans with the smallest total action cost. in contrast  most state of the art deterministic planners optimise parallel plan length. moreover  we are not aware of any partial-order planner able to optimise the sum of arbitrary action costs. finally  our heuristic search in unfolding space substantially differs from existing partial-order planning algorithms.
1 experimental results
we implemented petrify  an extended version of our translation from planning operators to pt-nets. petrify handles most of the adl fragment of pddl. we modified mole to implement a variety of search strategies and heuristics defined by their respective ordering relations. all these orderings are complemented with comparisons based on parikhvectors and the foata normal form in case of equality  esparza et al.  1   so as to make the order strict. in our experiments below we use the a* strategy  i.e.  the  h ordering  with the following heuristics1  bonet and geffner  1; haslum and geffner  1 :
 1 : uniform cost  i.e.   h with h s  = 1
  h1 : the h1 heuristic  i.e.   h with h s  = h1 s g   heuristic  i.e.  h with
모unlike  the 1 and h1 heuristics are monotonic  which guarantees not only optimality but also  by theorem 1  completeness. nonetheless  works well in practice.
모we call pup  planning via unfolding of petri nets   the planner resulting from running our guided version of mole on the petri net encoding produced by petrify.
모all experiments were conducted on a pentium m 1 ghz with 1gb of memory.
1 artificial benchmarks
our first experiment illustrates the claim that planning via unfolding can be exponentially more efficient than planning via state-space search. consider an artificially constructed problem in which the goal is a conjunction of n subgoals. the ith subgoal is achievable by a sequence ai of length i. the ais are disjoint. each action ai j in ai has a unique precondition ei j 1 which it deletes  and one positive effect ei j  which acts as precondition of the next action ai j+1 and so on. proposition ei 1 is true in the initial state  ei i is the ith subgoal  and the ei j are all different propositions. the degree c of concurrency in the problem varies from 1  sequential  to n  fully concurrent  by making the ith subgoal  i = c...n 1  a precondition to the execution of the i + 1th sequence  i.e.  ei i is a precondition of ai+1 .
모the left-hand graph of figure 1 shows the number of nodes expanded by forward state space search  sps  and unfolding  unf   each using the 1 and h1 heuristics  for n = 1...1 and c varying from 1 to n in each case. to ensure fairness  we report the number of nodes expanded to prove optimality  to prove that there is no solution of cost less than the optimal  rather than to find the optimal solution. the figure clearly shows that  as c increases  the performance of state-space search degrades exponentially  while the number of nodes expanded by the unfolding is constant  it equals n n + 1 /1  the number of actions in the plan . the h1 heuristic makes no significant difference except in the purely sequential case where it enables both techniques to prove optimality without search. state space search fails to solve some of the problems as early as n = 1  while unfolding solves all problems of size n = 1  not shown in the figure  in a couple of minutes each  producing plans over 1 actions long.
1 ipc benchmarks
next  we look at the gains we typically obtain with more realistic problems taken from the international planning competition. we start by comparing the performance of unfolding vs state-space search and by demonstrating the effect of the heuristics h1 and  on the unfolding. in figure 1  we present results for the first 1 ipc-1 airport instances  and for openstacks instances warwick 1 which feature 1 products  1 orders and an increasing ratio r =1 to 1 of products per order. we use the natural encoding of openstacks which allows several products to be produced in parallel. in contrast  the ipc-1  propositional  version disables concurrency.
모in airport  the unfolding expands up to 1 orders of magnitude fewer nodes than state-space search for the hardest instances. h1 and further reduce this by up to 1 orders of magnitude  except for the easiest problems where underperforms. in openstacks  the gap between the unfolding and state space search is less spectacular  and decreases with r as the problems get easier. however  the benefits from using are striking: it systematically expands 11 nodes across all problems. this shows that our guided unfolding is able to exploit the fact that non-optimal openstacks is an easy problem  and solve much larger instances than were previously within the reach of the unfolding technique.
모we made similar observations in a range of domains that allow some degree of concurrency  from rovers to pipesworld. in domains that fully disallow concurrency  such as psr  the number of nodes expanded by unfolding and state space search is always identical for a given heuristic  and so unfolding gives no advantage.
모next  we turn to run times. generally  the run times we obtain with the 1 heuristic are comparable  and in a number of cases better  than those obtained by the ipc-1 and ipc-1 optimal planners. a fair comparison is delicate because most of these planners  including the ipc-1 optimal track winner satplan1  optimise the number of parallel plan steps. cost-optimal planning is usually considered more challenging. even in the simple case where actions have unit cost  we might produce plans that contains fewer actions than step-optimal parallel planners. to the exception of the hsp* family of planners1  we are not aware of any ipc planner currently capable of optimising the sum of arbitrary action costs. the middle and right-hand graphs in figure 1 give a feel for the run time of pup  run with the 1 heuristic   using the same airport and openstacks instances as previously. for reference  we also present the run times of the state of the art cost-optimal planner hsp1  run with the -seq and -bfs options   and those of the state of the art step-optimal parallel planner satplan1  run with the default options . note that satplan1 is not able to solve any of the openstack instances within our 1mn time limit.
1 petri net benchmarks

figure 1: number of expansions for artificial  left   airport  middle   and openstacks  right .

figure 1: reachability coverage for dartes  left . run times for airport  middle  and openstacks  right .our final experiment demonstrates the benefits of guiding the unfolding with planning heuristics  when analysing reachability in petri nets which have no connection to planning. as before  we are interested in determining whether a given transition of the petri net is reachable.
모we obtained a set of standard petri net benchmarks from the developers of mole. only one of them  dartes  corbett  1   which models the communication skeleton of a fairly complex ada program  turned out to be challenging.
mole is unable to decide the reachability of certain dartes transitions in reasonable time  whereas for the other benchmarks in the set  mole generates even the complete finite prefix in a matter of seconds.
모figure 1  left  compares the performance of the original version of mole to the version guided by the heuristic. for each of the 1 dartes transitions  we recorded the time taken by each version to decide reachability; the graph shows the percentage of problems solved within given computation time limits ranging from 1 sec to 1 sec. the original breadth-first version of mole is quickly able to solve the simplest problems - 1% to 1% of the problems are solved within 1 to 1 sec. for those problems  the overhead in computing the heuristic outweighs the benefits. however  if a problem cannot be solved by the original version within 1 secs  the heuristic does help. in total  within our overall 1 sec time limit  the original version solves 1 of the 1 problems  1%   whereas the guided version solves 1 of them  1% . only 1 of the problems that the original version could solve were unsolved by the guided version. unsurprisingly  all the solved problems were positive decisions  the transitions were reachable . for sanity  we checked that depth-first search didn't improve on the results obtained with. as it turns out  depth-first achieves over 1% coverage extremely quickly  solving the corresponding problems within 1 sec   but only reaches 1% coverage overall.
1 conclusion
this paper exploits the relationship between planning and petri net analysis to the advantage of both fields. on the one hand  we have demonstrated that petri net unfolding  a form of partial order reduction  godefroid  1   is a promising technique to recognise independent planning subproblems and treat them separately. on the other hand  we have shown that planning heuristics are able to effectively direct unfolding-based reachability analysis. the first product of our work is an original forward heuristic search algorithm for minimal-cost partially-ordered planning. the second is an enhanced reachability analysis tool which might be applicable where existing methods  esparza and schro몮ter  1  suffer from having to generate a complete finite prefix.
모we are not aware of any work that explores the potential of current petri net analysis techniques for planning  in the depth given here. meiller and fabiani  use colored petri nets to implement a multi-valued version of the planning graph  merely obviating the need to explicitly consider certain types of permanent mutexes. silva et al.  recast plan extraction from the graph as a petri net submarking reachability problem  yet without demonstrating many benefits.
모our work lays the foundation for planning in unfolding space. there are many possibilities for future work and improvement on our current approach. for instance  the reduction in number of nodes expanded by the h1 heuristic does not always carry over to runtime  due to the cost of its recomputation at every node - this is a problem inherent to forward search  see  bonet and geffner  1 . remedying this is critical to improving pup's run time. possible ways forward include switching to heuristics which only need to be computed once  such as pattern databases heuristics  edelkamp  1  or h1 for an inverted dynamics of the domain  refanidis and vlahavas  1 . alternatively  we could investigate whether an analogue of regression search would make sense in the unfolding space.
모the translation of planning operators into petri nets is another area where improvements are likely. we first experimented with a translation linear in the number of propositions  but quadratic in the number of actions in the domain as it requires  mutex  places to ensure 1-safety. unfortunately  we found that in many benchmarks  the number of mutex places greatly dominates the size of the petri net. this motivated the need for the translation we give in the paper  which is linear when the actions are 1-safe  but is exponential in the number of operators effects in the worst case. even though petrify experienced only a few problems with the ipc benchmarks  it would be beneficial to extend it to combine both translations as appropriate. more ambitious developments concern more compact translations into high-level nets making use e.g. of first-order and multi-valued variables.
모finally  we believe that a more exhaustive analysis of the connections between planning  or search  and petri net unfolding will be fruitful. this includes determining the precise relationship between the size of the unfolding and properties of the causal graph of the planning problem  such as treewidth   and identifying weaker properties of heuristics and orderings that guarantee completeness of the finite prefix.
acknowledgements
many thanks to stefan schwoon and patrik haslum for their help with mole and the experiments  respectively. we also thank jonathan billington  blai bonet  javier esparza  malte helmert  rao kambhampati  maurice pagnucco  john slaney  david smith  and the anonymous reviewers for interesting discussions and comments. thanks to national ict australia  nicta  and the australian defence science & technology organisation  dsto  for their support  in particular via the dpolp  dynamic planning  optimisation & learning  project. nicta is funded through the australian government's backing australia's ability initiative  in part through the australian national research council.
