
in this paper  we develop fringe-saving a*  fsa*   an incremental version of a* that repeatedly finds shortest paths in a known gridworld from a given start cell to a given goal cell while the traversability costs of cells increase or decrease. the first search of fsa* is the same as that of a*. however  fsa* is able to find shortest paths during the subsequent searches faster than a* because it reuses the beginning of the immediately preceeding a* search tree that is identical to the current a* search tree. fsa* does this by restoring the content of the open list of a* at the point in time when an a* search for the current search problem could deviate from the a* search for the immediately preceeding search problem. we present first experimental results that demonstrate that fsa* can have a runtime advantageover a* and lifelong planning a*  lpa*   an alternative incremental version of a*.
1 introduction
most research on heuristic search has studied how to solve one-shot search problems. however  search is often a repetitive process where one needs to find shortest paths to series of similar search problems because the world changes over time. for example  the traffic conditions can change when one drives to the airport and one might have to change the current route if the radio reports additional congestion. in this case  one has to replan for the new situation. incremental search algorithms are often able to find shortest paths to series of similar search problems faster than is possible by solving each search problemindependently by re-usinginformation from the preceeding searches  koenig et al.  1b . in this paper  we develop fringe-saving a*  fsa*   an incremental version of a*  hart et al.  1  that repeatedly finds shortest paths in a known gridworld from a given start cell to a given goal cell while the traversability costs of cells increase or decrease. however  fsa* is often able to find shortest paths during the subsequent searches faster than a* because it reuses the beginning of the immediately preceeding a* search tree that is identical to the current a* search tree. fsa* does this by restoring the content of the open list of a* at the point in time when an a* search for the current search problem could possibly deviate from the a* search for the immediately preceeding search problem because the a* search for the current search problem has encountered a changed edge cost. fsa* then restarts the a* search at that point. in the following sections  we first describe which search problems fsa* solves. second  we explain in detail how fsa* reuses information from the immediately preceeding search to speed up the current search. finally  we present first experimental results that demonstrate that fsa* can have a runtime advantage over a* and lpa*  koenig et al.  1a   an alternative incremental version of a*.
1 search problems and notation
fringe-saving a*  fsa*  solves path-planning problems in known finite gridworlds whose vertices correspond to the cells and whose edge costs increase or decrease over time. in this paper  we describe a version of fsa* that works on gridworlds of square cells that are either blocked or unblocked  where one can always move from an unblocked cell to one of the four adjacent cells with cost one  provided that the adjacent cell is unblocked. we use the following notation to be able to state the search problems formally: s denotes the finite set of unblockedcells. succ s    s denotes the set of unblocked cells that border unblocked cell s ¡Ê s. fsa* repeatedly determines a shortest  unblocked  path from a given unblocked cell sstart ¡Ê s to a given unblockedgoal cell sgoal ¡Ê s with sstart goal as the traversability of cells changes  always knowing which cells are currently unblocked.
1 a*
a*  hart et al.  1  is the most popular heuristic search algorithm. it maintains three values for every cell: first  the h-value h s  of a cell s is the user-given approximation of the distance from the cell to the goal cell  = heuristic   which we assume to be consistent  that is  it satisfies the triangle inequality  pearl  1 . it is not changed during an a* search. second  the g-value g s  of a cell s is an approximation of the distance from the start cell to the cell. it is changed during the a* search. finally  the parent pointer parent s  of a cell s points to its parent cell in the a* search tree. it is also changed during the a* search. a* maintains two data structures: first  the closed list contains all cells that have been expanded during the a* search. initially  it is empty. second  the open list contains all cells that have been generated but not yet expanded during the a* search. initially  it contains only the start cell with g-value zero. a* repeats the following procedure: a* removes a cell with the smallest sum of g-value and h-value from the open list  inserts it into the closed list and expands it by performing the following procedure for each unblocked adjacent cell. if the adjacent cell is neither in the open nor closed list  then a* generates the adjacent cell by setting the g-value of the adjacent cell to the g-value of the expanded cell plus one  setting the parent pointer of the adjacent cell to the expanded cell  and then inserting the adjacent cell into the open list. if the adjacent cell is in the open list and the g-value of the expanded cell plus one is smaller than the g-value of the adjacent cell  then a* sets the g-value of the adjacent cell to the g-value of the expanded cell plus one and sets the parent pointer of the adjacent cell to the expanded cell. a* terminates immediately when its open list is empty or when it is about to expand the goal cell.  for simplicity  we count the goal cell as expanded.  figure 1 shows the state of an a* search with start cell d1  marked s  and goal cell f1  marked g  after termination. we use the consistent manhattan distance  the sum of the absolute x and y distances between a cell and the goal cell  as an approximation of the distance from a cell to the goal cell. every cell has its h-value in the lower left corner. every generated cell also has its g-value in the upper left corner  the sum of g-value and h-value in the upper right corner  and its parent pointer pointing to its parent cell in the a* search tree. every expandedcell also has its sequencenumber in the lower right corner that indicates when it was expanded. fsa* makes use of the following four properties of a*: first  a* terminates. second  the sum of g-value and h-value of the sequence of expanded cells is monotonically nondecreasing over time. third  the g-value and parent pointer of any cell are correct when it is expanded and then do not change any longer  that is  the g-value of an expanded cell is equal to the distance from the start cell to the cell  = the start distance of the cell  and a shortest path from the start cell to the cell can be identified in reverse by following the parent pointers from the cell to the start cell. this property implies that a* finds a shortest path from the start cell to the goal cell if it terminates because it is about to expand the goal cell. fourth  no path exists from the start cell to the goal cell if a* terminates because its open list is empty.
1 fsa*
fringe-saving a*  fsa*  is an incremental version of a*.
figure 1 gives its pseudo code.1 the idea behind fsa* is

figure 1: search problem 1
simple. the first search of fsa* to determine a shortest path from the start cell to the goal cell is the same as an a* search. now assume that the traversability of some cells changes and consider another a* search to determine a shortest path from the start cell to the goal cell. the second a* search initially expands the same cells in the same order as the first a* search. fsa* restores the overall state of the first a* search at the point in time when the second a* search could possibly deviate from it  that is  when the second a* search encounters a cell whose traversability changed between the two a* searches. fsa* then restarts the first a* search at that point in time rather than performing the second a* search from scratch. the state of an a* search is given by the content of its open and closed lists and the g-values and parent pointers of the cells contained in them. fsa* executes the following steps.
¡¡step 1  restoration of the closed list : assume that there are two completea* searches and that expandedid s  is

indicate that the g-value of the cell is current. 1  rather than identifying the reusable cells s repeatedly by checking whether expandedid s    blockid expandediteration s    lines {1} set generatediteration s  = iteration for the reusable cells s that could otherwise get re-generated by the a* search. this way  the a* search knows that the g-values of these cells are current and  since it cannot decrease their g-values  will not re-generate the cells. lines {1} can be implemented very efficiently as part of identifying and traversing the relevant part of the fringe. 1  lines {1} can be efficiently implemented with a linked list to skip those elements blockid i  for which no cell s with expandedid s    blockid expandediteration s   exists. 1  to be more efficient  our implementation of fsa* traverses only the immediate outside of the continuous area of reusable cells between the borders of the gridworld in case the continuous area of reusable cells touches the border. to this end  fsa* traverses the immediate outside of the continuous area of reusable cells in the clockwise direction  starting with the anchor cell  until it is about to leave the anchor cell a second time in the same direction or reaches some cell of the border. in the second case  it then traverses the immediate outside of the continuous area in the counter-clockwise direction  starting again with the anchor cell  until it reaches some  potentially different  cell of the border. the fourth gridworld in figure 1 illustrates this process for the search problem from figure 1. 1  to be more efficient  our implementation of fsa* collapses the two variables generatediteration s  and expandediteration s  into one variable iteration s  although this requires code changes that make the pseudo code harder to understand.

figure 1: search problem 1  continued the sequence number of cell s after the first a* search  that is  that cell s was expanded expandedid s th during the first a* search.  the start cell was expanded first. if cell s was not expanded during the first a* search  then expandedid s  = ¡Þ.  assume further that only one cell s changed its traversability between the two a* searches. we now determine a value for m so that the second a* search expands at least every cell s with expandedid s    m in the same order as the first a* search. if cell s became blocked  then the second a* search expands at least every cell s with expandedid s    expandedid in the same order as the first a* search  that is  every cell up to but not including cell s. thus  we set
 expandedid.	if cell s became un-
blocked  then the second a* search expands at least every cell s with expandedidsucc expandedid
in the same order as the first a* search  that is  every cell up to and including the neighbor of cell s that was expanded first in the first a* search. thus  we set m :=
succ expandedid. if several cells changed their traversability between the two a* searches  then the second a* search expands at least every cell s with expandedid in the same order as the first a* search {1}  numbers in curly braces refer to line numbers in the pseudo code . thus  these cells  which are guaranteed to be unblocked  are in the new closed list. we refer to them as reusable cells. the first gridworld in figure 1 illustrates this process for the search problem from figure 1 after cell c1 with sequence number 1 became blocked. all cells with sequence numbers less than 1 are then reusable  as indicated in grey. it turns out that maintaining the sequence numbers is more complicated than discussed so far in case there are several searches in a row because fsa* might have to reuse cells from different searches. we would like a sequence number expandedid s  to mean that cell s would have been expanded expandedid s th during the immediately preceeding a* search if the immediately preceeding search had been a complete a* search. now consider the case where some cell s was expanded during the first search  but the cell was not reusable in the second search. then  some other cell might have received the same sequence number as cell s during the second search  and fsa* might have to determine during the third search that the sequence number of cell s has become invalid. fsa* addresses this problem by maintaining the following global variables: iteration is the number of the current search  that is  iteration = i during the ith search. fsa* also maintains a value blockid i  for the ith search and the values expandedid s  and expandediteration s  for every cell s  initialized as follows: blockid 1  = 1 and  for all cells s  expandedid s  = 1 and expandediteration s  = 1 {1-1}. fsa* then maintains the following invariant directly before the ith search: if expandedid s    blockid expandediteration s   then cell s would have been expanded as expandedid s th cell during the immediately preceeding search if it had been a complete search {1}. if fsa* determines that every cell s with expandedid s    m is reusable for the iterationth search  then it proceeds as follows: first  it invalidates all cells with sequencenumbersno smaller than m by setting blockid i  := min m blockid i   for all 1 ¡Ü i ¡Ü iteration  which is much faster than visiting all cells with invalid sequence numbers {1}. second  whenever it expands a cell s during the iterationth search it sets expandediteration s  := iteration 
expandedid s  := m and m := m + 1 {1}. finally  it sets blockid iteration  := ¡Þ{1} and iteration := iteration + 1 {1}.
¡¡step 1  early termination : if the goal cell is reusable  then fsa* does not need to replan because the shortest path from the start cell to the goal cell from the immediately preceeding search is also a shortest path for the current search {1}. if the start cell is not reusable and blocked  then fsa* terminates without replanning because there is no path from the start cell to the goal cell. if the start cell is not reusable and unblocked  then fsa* performs a complete a* search from scratch.
¡¡step 1  restoration of the open list : the unblocked and non-reusable cells that border one or more reusable cells are in the new open list. first  fsa* identifies the anchor cell  a non-reusable cell that borders one or more reusable cells  by following the parent pointers from the goal cell to the start cell until it transitions from a non-reusable cell to a reusable cell {1}.1 this non-reusable cell then is the anchor cell. the second gridworld in figure 1 illustrates this figure 1: search problem 1	figure 1: search problem 1
process for the search problem from figure 1  resulting in anchor cell c1. second  fsa* identifies the cells that belong to the relevant part of the new open list  = fringe . the reusable cells form a continuous area since they are all reachable from the start cell. fsa* can traverse the immediate outside of this continuous area  say  in the clockwise direction   starting with the anchor cell  and insert all unblocked cells that border one or more reusable cells into the relevant part of the new open list {1}. fsa* does not stop when it reaches the anchorcell a second time but only when it is about to leave the anchor cell a second time in the same direction. the third gridworld in figure 1 illustrates this process for the search problem from figure 1. the cells c1  c1 and b1 form the relevant part of the new open list  as indicated in the figure. figure 1 shows for a search problem different from our main one that the termination condition is indeed important. the start cell is e1 and the goal cell is b1. after cell c1 became blocked  fsa* visits cells c1  d1 and c1 again when it traverses the immediate outside of the continuous area of reusable cells  at which point it does not stop since the anchor cell c1 was first left towards the south but is now left towards the east. if it did stop  then it would not identify all cells that belong to the relevant part of the new open list. figure 1 shows for a search problem different from our main one that not all cells in the new open list are relevant. the start cell is d1 and the goal cell is f1. after cell f1 became blocked  cells e1  e1 and f1 are irrelevant  and thus not included in the relevant part of the new open list since the goal cell is not in the region of unblocked cells that they are part of and a shortest path from the start cell to a goal cell thus cannot pass through them. from now on  we just refer to the open list when we mean the relevant part of the open list.
¡¡step 1  restoration of the g-values and parent pointers : the g-values and parent pointers of all reusable cells are guaranteed to be correct. however  the g-values and parent pointers of cells in the new open list are not necessarily correct in the following two cases: first  if a cell in the new open list just became unblocked  then it was blocked before  and its g-value and parent pointer thus have not been updated in the preceeding searches and need to be corrected  case 1 . second  if the parent pointer of a cell in the new open list points to a cell that is not reusable  then the g-value and parent pointer need to be corrected  case 1 . to understand case 1  consider a complete a* search and assume that the g-value figure 1: search problem 1
and parent pointer of an unblocked cell changed during the a* search because the a* search first found a path from the start cell to the cell in question and then found a shorter path from the start cell to the cell in question. if the state of this a* search needs to be restored at a point in time after the first path was found but before the second path was found  then the g-value and parent pointer of the cell in question need to be corrected. figure 1  left and right  show for a search problem different from our main one that it is important to update the g-values and parent pointers of the cells in the new open list. the start cell is c1 and the goal cell is e1. figure 1  left  shows the first a* search. figure 1  right  shows the situation after cell c1 became blocked. the g-value and parent pointer of cell d1 are incorrect and need to be corrected from 1 and c1  respectively  to 1 and e1. for case 1 and 1  fsa* finds any reusable cell adjacent to the cell in question  sets the g-value of the cell in question to the g-value of the reusable cell plus one  and the parent pointer of the cell in question to the reusable cell {1}. it is correct for case 1 since a cell in the new open list that just became unblocked has exactly one adjacent reusable cell. we prove the correctness for case 1 in the next section.
¡¡step 1  sorting the new open list : this step is important if the open list is implemented as a binary heap because transforming a set in one step into a binary heap is more efficient than inserting the elements of the set one after the other into an empty binary heap  corman et al.  1 .
¡¡step 1  restarting a* : finally  fsa* restarts a* with the new open and closed lists {1}. a* is implemented by the function computeshortestpath.
1 theoretical results
the correctness of the restoration of the g-values and parent pointers of cells in the new open list is not easy to see for case 1. we thus prove it in the following  making use of the following theorem that is specific to the kinds of gridworlds used in this paper. the result also implies that the g-value and parent pointer of a cell in the new open list are correct if the parent pointer already points to a cell that is reusable.
theorem 1 the parent pointer of any cell s ¡Ê s can change at most once during an a* search from one cell to another. all expanded cells adjacent to a cell have the same g-value before the parent pointer of the cell changes.

procedure initialize  
blockid 1  := 1;
forall cells s
{1}	generatediteration s  := 1;
{1}	expandediteration s  := 1;
{1}	expandedid s  := 1;
{1} m := 1;
{1} open :=  ;
{1} g sstart  := 1;
{1} open.insert sstart ;
{1} generatediteration sstart  := 1; {1} iteration := 1; function computeshortestpath   {1} blockid iteration  := ¡Þ;
{1} while  open
{1}	s := open.pop  ;
{1}if  s = sgoal {1}return true;{1}else{1} expandediteration s  := iteration; expandedid s  := m; m := m + 1;
{1}	forall succ s 
{1}	if  generatediteration	iteration or g s  + 1   g s'  
{1}	 s'  :=     + 1;
{1}iteration;
{1}	parent
{1}	open.insert s  ;
{1} return false; function cellreusable s 
{1} if  expandedid s    blockid expandediteration s   
{1}	return true;
{1} return false; procedure updatemazetraversability   {1} tmpblockid := ¡Þ;
{1} forall cells s whose traversability has changed
{1}	if  s is blocked 
{1}	if  cellreusable s  
{1}	if  expandedid s    tmpblockid  {1}	tmpblockid := expandedid s ;
{1}	else
{1}	parent s  := null;
{1}	forall succ s 
{1}	if  cellreusable
{1}	if  expandedid s   + 1   tmpblockid
tmpblockid := expandedid s   + 1;
forall i = 1... iteration
{1} if  tmpblockid   blockid i   {1} blockid i  := tmpblockid; {1} m := blockid iteration ;
procedure retrievefringe  
{1} open :=  ;
{1} iteration := iteration + 1;
{1} s := sgoal;
{1} while  not cellreusable parent s   
{1}	s := parent s ;
{1}	if  s = sstart 
{1}	exit; /* there is no path */
{1} move s around the area that contains exactly the cells s with cellreusable 
{1}	forall with cellreusable
{1}	generatediteration iteration;
{1}	if  s is unblocked 
{1}	if  parent s  = null or  not cellreusable parent s    
{1}	forall
{1}
{1}
{1}	;
{1}break;{1}generatediteration s  := iteration;{1}open.insert s ;{1} until the initial cell is about to be left in the same direction again;
procedure main   {1} initialize  ;
{1} repeat
if  not computeshortestpath    exit; /* there is no path */
{1}repeat{1}identify the path using the parent pointers and use it;{1}wait for traversability changes;{1}updatemazetraversability  ;{1}until  blockid iteration  ¡Ü expandedid sgoal  ;¡¡retrievefringe  ; until false;
figure 1: fringe saving a*  fsa* 
   proof: consider any unblocked cell s ¡Ê s and any two unblocked cellsadjacent to cell is -1  1 or 1 since the h-values are the manhattan distances. this means that all cells adjacent to cell s together have at most two different h-values. now assume that cell s was expanded during an a* search and that cell s was generated during the expansion. thus  the parent pointer of cell s was set to cell s. assume further that cell s was expanded later during the same a* search and that the parent pointer of cell s changed during the expansion. thus  the parent pointerof cell s was set to cell s. then  since the sum of g-value and h-value of the sequence of expanded cells is monotonically nondecreasingover time. furthermore   since otherwise the parent pointer of cell s would not have changed. thus  for some c   1. put together   or  alternatively  .
 since  is -1  1 or 1  it must be the case that  and thus . this implies that  1 ¡Ü c   1. since the start distances and thus the g-values of cells s and s cannot differ by one  it must be the case that. this means that the parent pointer of cell s can change at most once during an a* search because c increases with every change. now consider any unblocked cell s adjacent to cell s that was expanded before the parent pointer of cell s changed. then   since the sum
of g-value and h-value of the sequence of expanded cells is monotonically nondecreasing over time. it holds that
. thus 
. since
all cells adjacent to cell s together have only two different h-
values  must equal either. thus 
must equal either cannot equal
since otherwise the parent pointer of cell s first had changed to celland later could no longer have changed to cell s. thus  must equal  which means that all expanded cells adjacent to cell s have the same g-valuebefore the parent pointer of the cell changes. 
¡¡we use this theorem as follows: during the course of an a* search  the g-value of a cell cannot increase. thus  when restoring the  earlier  state of an a* search  the g-value of a cell cannot decrease. assume that the parent pointer of a cell in the new open list points to a cell that is reusable. the g-values of reusable cells are correct. thus  the g-value of the cell in question does not need to increase. it remains the g-value of the reusable cell plus one. thus  the g-value and parent pointer of the cell in question remain correct. now assume that the parent pointer of a cell in the new open list points to a cell that is not reusable. clearly  the parent pointer needs to get corrected. directly before it was set to the nonreusable cell during the immediately preceeding a* search  it pointed to some other cell with a larger g-value. at that point in time  all expanded cells adjacent to the cell in question had the same g-value according to theorem 1  and the reusable cells adjacent to the cell in question are a subset of them since their sequence numbers are smaller than the sequence number of the non-reusablecell. fsa* can thereforefind any reusable cell adjacent to the cell in question and set the g-value of the cell in question to the g-value of the reusable cell plus one and the parent pointer of the cell in question to the reusable cell.
1 related work
incremental a*  ia*  by peter yap  unpublished  reuses the beginning of the immediately preceeding a* search tree that is identical to the current a* search tree  like fsa*. it restores the content of the open list of a* by repeating the a* search for the immediately preceeding search problem until it deviates from the a* search for the current search problem. since the order of the cell expansions is already known  ia* does not need to use an open list to determine the order of the cell expansions which makes the repeated a* search faster than the original one. fsa* restores the content of the open list of a* without repeating the a* search for the immediately preceeding search problem. the main difference of both search algorithms is that ia* traverses the expandedcells while fsa* traverses the generated but not yet expanded cells. the expanded cells form a continuous area of cells  and the generated but not yet expanded cells basically form the outside perimeter of this area. since an area can grow quadratically in the length of its perimeter  traversing the cells on the perimeter can potentially be much more efficient than traversing the cells in the area itself. there are three incremental versions of a* that operate according to principles different from fsa* and ia*. adaptive a*  koenig and likhachev  1  runs a* unchanged but makes the hvalues more informed. it cannot handle edge cost decreases and thus cannot always be used instead of fsa*. lifelong planning a*  lpa*   koenig et al.  1a  and differential a*  trovato and dorst  1  leave the h-values unchanged but modify a*. they can handle edge cost increases and decreases and thus can be used instead of fsa*. they can be viewed as transforming the a* search tree of the immediately preceeding search into the a* search tree of the current search. we use lpa* instead of differential a* because it is more advanced and available at idm-lab.org/project-a.html. lpa* can be slower than a* but tends to be more efficient than a* when the search problems change only slightly and the changes are close to the goal cell. it has been extended to moving agents and then used on robots as part of d* lite  koenig and likhachev  1   which is a version of d*  stentz  1  that is simpler to understand  implement and extend. we therefore compare fsa* against a*  ia* and lpa* experimentally.
1 experimental evaluation
we performed experiments in 1 gridworlds of size 1 ¡Á 1. their start and goal cells were randomly chosen and obstacle density ¡Á1 percent of the cells were randomly chosen to be blocked  where obstacle density was between zero and one. for each gridworld  we changed the traversability of some cells and then found again a shortest path from the start cell to the goal cell. if no path from the start cell to the goal cell existed or after we had changed the traversability of cells and found a new path for 1 times  we continued with the next gridworld.  the runtime includes the gridworlds without a path from the start cell to the goal cell.  the pseudo code in figure 1 exploits this assumption for simplicity  for example  does not handle the case where the start cell becomes unblocked. to maintain a constant obstacle density  we randomly changed the traversability of change rate /1¡Á1 percent of cells close to the goal cell from blocked to unblocked and an equal number of cells close to the goal cell from unblocked to blocked  where change rate was between zero and one.  this implies that change rate ¡Ü 1¡Á obstacle density.  a cell was close to the goal cell if its manhattan distance was no larger than closeness times the manhattan distance of the start cell  where closeness was between zero and one. this way of changing the terrain was inspired by realtime strategy games like warcraft where one player often repeatedly attacks some other player. during these attacks  the attacking player tries to reach the location of the defending player. in the process  the attacking player destroys buildings of the defending player while the defending player builds new buildings. thus  the traversability of the terrain changes around the destination of the attacking player  as simulated in our experiments. we compared the runtime of fsa* against the runtimes of a*  ia* and lpa* on a pentium d 1 ghz pc with 1 gbyte of ram. it is worth pointing out that runtime results always depend on the hardware  compiler and implementation  including the data structures  tie-breaking strategies and coding tricks used. however  there is currently no better testing methodology available since the three different search algorithms work according to very different principles and thus cannot be compared via proxies such as the number of expanded cells. all three search algorithms find shortest paths and  to be fair  were implemented in very similar ways. for example  they all used binary heaps to implement the open list. when deciding which cell to expand next  they all broke ties among cells with the same smallest sum of g-value and h-value in favor of a cell with the largest gvalue  since this tends to result in small runtimes. table 1 reports their total runtimes over all searches they performed  including the calculation of the traversability changes and so on  for obstacle density = 1  showing the fastest runtime in bold. we say x   y iff the following relationship holds:  x runs consistently faster than y for small values of closeness. on the other hand  y runs faster than x for larger values of closeness if the value of change rate is sufficiently large. this threshold decreases as the value of closeness increases.  the table then shows that fsa*   a*  fsa*   ia* and lpa*   fsa*. we can explain these observations as follows: first  the value of change rate increases as we go from top to bottom in the table  which increases the number of traversability changes. the overhead of preprocessing each traversability change tends to be the smallest for a*  = none   followed by ia*  fsa* and lpa*  roughly in that order. this overhead gets amplified by the value of change rate. second  the value of closeness increases as we go from left to right in the table  which decreases the part of the immediately preceeding a* search tree that can get reused.  similarly  the value of change rate increases as we go from top to bottom in the table  which to some extent also decreases the part of the immediately preceeding a* search tree that can get reused. 
change	closeness = 1	closeness = 1	closeness = 1	closeness = 1	closeness = 1	closeness = 1rate	a*	ia*lpa* fsa*	a*	ia*lpa* fsa*	a*	ia*lpa* fsa*	a*	ia*	lpa* fsa*	a*	ia*	lpa* fsa*a*	ia*	lpa* fsa*11 1111 1111 1111 1 111 1 1 11 1 111 1111 1111 1111 1 111 1 1 11 1 1 111 1111 1111 1111 1 111 1 1 11 1 1 111 1111 1111 1111 1 111 1 1 11 1 1 111 1111 1111 1111 1 111 1 1 11 1 1 111 1111 1111 1111 1 111 1 1 11 1 1 111 1111 1111 1 111 1 111 1 1 11 1 1 111 1111 1111 1 111 1 111 1 1 11 1 1 111 1111 1111 1 111 1 111 1 1 11 1 1 111 1111 1111 1 111 1 111 1 1 11 1 1 111 1111 1111 1 111 1 111 1 1 11 1 1 111 1111 1111 1 111 1 111 1 1 11 1 1 111 1111 1 111 1 111 1 111 1 1 11 1 1 111 1111 1 111 1 111 1 111 1 1 11 1 1 111 1111 1 111 1 111 1 111 1 1 11 1 1 111 1111 1 111 1 111 1 111 1 1 11 1 1 111 1111 1 111 1 111 1 111 1 1 11 1 1 111 1111 1 111 1 111 1 111 1 1 11 1 1 111 1111 1 111 1 111 1 1 11 1 1 11 1 1 111 1111 1 111 1 111 1 1 11 1 1 11 1 1 111 1111 1 111 1 111 1 1 11 1 1 11 1 1 111 1111 1 111 1 111 1 1 11 1 1 11 1 1 111 1111 1 111 1 111 1 1 11 1 1 11 1 1 111 1111 1 111 1 111 1 1 11 1 1 11 1 1 111 1111 1 111 1 111 1 1 11 1 1 11 1 1 11
table 1: experimental results  in seconds the part of the immediately preceeding a* search tree that actually gets reused tends to be the largest for lpa*  followed by ia*  fsa*  = same as for ia*  and a*  = none   roughly in that order. the overhead for identifying this part of the reusable a* search tree follows the same trend. overall  ia* is never the fastest search algorithm. as the value of closeness increases  there is a decreasing threshold for the value of change rate below which lpa* is the fastest search algorithm and a larger decreasing threshold for the value of change rate above which a* is the fastest search algorithm.  lpa* becomes very slow with respect to all other search algorithms if the values of change rate and closeness are large.  between the two thresholds  fsa* is the fastest search algorithm. thus  our first feasibility study demonstrates that fsa* can find shortest paths faster than a*  ia* and lpa* in some situations and the principle behind it is thus worth being studied further.
1 conclusions
in this paper  we developed fringe-saving a*  fsa*   an incremental version of a* that repeatedly finds shortest paths in a known gridworld from a given start cell to a given goal cell while the traversability costs of cells increase or decrease. our first feasibility study demonstrates that fsa* can find shortest paths faster than a*  ia* and lpa* in some situations. it is future work to characterize these situations better and improve the efficiency of fsa* further.
acknowledgments
we thank peter yap  with whom sven koenig collaborated in 1 during a visit to the alberta ingenuity centre for machine learning at the university of alberta. this collaboration on comparing ia* and lpa* inspired our development of fsa* three years later  at a time where no one seems to know the current whereabouts of peter. we also thank ariel felner for interesting discussions on fsa*. the intelligent decision-making group is partly supported by nsf awards to sven koenig under contracts iis-1 and iis-1. the views and conclusions contained in this document are those of the authors and should not be interpreted as representing the official policies  either expressed or implied  of the sponsoring organizations  agencies  companies or the u.s. government.
