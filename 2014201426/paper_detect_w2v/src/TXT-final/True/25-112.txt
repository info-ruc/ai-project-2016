 
this paper introduces new approaches to the conceptual design of electro-mechanical systems from qualitative specifications of behaviour and function. the power of these methods stems from the integration of techniques in qualitative physics  symbolic mathematics  computational geometry and constraint programming. this is illustrated with an effective kinematic synthesis method that integrates reasoning with configuration spaces and constraint-programming techniques. 
1 	introduction 
the broad goal of our research is to derive computational theories of conceptual or pre-parametric design. as manufacturing technologies change  as new materials are developed  as new design constraints emerge  designs with recyclable parts  and designs that assemble and disassemble easily   as products become more complex  as the need to build in continuous improvement into design processes emerges  basic conceptual design procedures for electro mechanical systems require broadening with effective use of computer tools in the early stages of design. our specific aim is to use methods from artificial intelligence  especially qualitative physics and constraint programming  with techniques from computational geometry and symbolic mathematics to build new computational prototyping tools for conceptual design. 
1 	a case study 
while the talk will present several case studies of effective tools for conceptual design in a variety of domains  the rest of this paper is devoted to an illustration in the context of mechanism synthesis1. mechanisms are an important part of most electro-mechanical systems. they transmit motion from one rigid body to another. our design system takes as input constraints on the motion of a mechanism in qualitative  mathematical form. as 
   *this work is supported by nsf-iri-1  the xerox design research institute  and the moore fund. 
   *this is joint work with my student cheuk-san  edward  wang. 
1 	invited speakers 

figure 1: design of a windshield wiper 
output  it produces a systematic enumeration of mechanism topologies and geometries that satisfy the given constraints. tt also performs high-level simulation to demonstrate the feasibility of the design. the conceptual designs produced by our system can be refined and optimized by constraint-solving systems that select candidate designs based on cost  material  manufacturing and assembly constraints. 
　the running example used in this paper is the synthesis of a windshield wiper whose input power is provided by a motor rapidly rotating around the z axis and whose output is an oscillation in the yz plane with low frequency. note that this a partial description of the input and output motions of this device. the first design enumerated by our system is shown in 
figure 1. it employs a worm spur which converts the uniform input rotation around the z axis to one about the x axis. the output of the spur gear drives a crank rocker. the overall output is tapped from the rocker. dimensions  positions and orientations of the gears and 

the crank rocker are calculated by the system. another design generated by our system satisfies the same motion specifications using a rack and gear pair  where the rack is driven by a slider crank with the crank being rotated uniformly by a worm spur pair. the worm itself is connected  in both cases  to a motor shaft. 
   there are several unique aspects of our method. we have a uniform representation for constraints  and can take them into account during the synthesis process. in this example  motion constraints as well as dimensional constraints are handled simultaneously. the synthesis process is very efficient. the example synthesis above was generated in about half a second on a sparc station. relevant constraints are enforced as soon as they become applicable. this is what makes the generation process efficient: we elaborate this point in section 1. 
   the synthesis process is grounded in a mathematical theory of motion composition that is based on configuration spaces. we compile the algebraic theory of motion synthesis into a qualitative form that preserves essential distinctions for the specification and solution of a large class of kinematic synthesis problems. we introduce a property called join preservation which is a constraint on a qualitative motion language that is needed to guarantee the generation of correct designs. our synthesis algorithms are actually implemented and are currently being field tested at the xerox webster design research center. our program has produced innovative designs for a number of common devices described in . an interesting set of egg-beater designs in shown in figure 1. 
1 	t h e p r o b l e m : m o t i o n synthesis 
we now describe the synthesis problem addressed in this paper in detail. kinematic synthesis is the problem of determining a three dimensional structure of rigid parts that implements a given motion specification. kinematics only considers motions and not the forces that cause the motions. conceptual kinematic synthesis is generally acknowledged to be a very difficult problem. a modern textbook in the area  states that 
the designer generally relies on intuition and experience as a guide to type and number synthesis. very little supporting theory is available in these areas. 
conceptual synthesis of mechanisms is difficult because designs are typically specified in incomplete terms and by their intended use  e.g.  a fruit-picker or a fuel-hose connector . there is no general theory that relates function and structure in mechanical devices. that is  the space of mechanisms that achieves a given functional specification is not exhaustively and systematically enumerable. compendia such as artobolevsky's catalog  provide a library of known mechanisms indexed by type  lever mechanisms  e.g.  and function  e.g.  indexing . they are a useful starting point for a designer who can then use systematic adaptation of these designs to create devices which meet the specified functionality. the derivation of the motions that accomplish a given function is an open problem that is not addressed in this paper. given the motions  we call the problem of designing a structure that generates them  the motion synthesis problem. 
this is also difficult to solve as it involves deriving geometry from motion. most of the current work on conceptual design of mechanisms focuses on this problem  1  1  1  1  1  1 . 
   previous work in this area falls under three major categories: structural  behavioural and functional theories of synthesis. structural theories generate mechanism topologies systematically  usually from specification of the number of links and the total number of degreesof-freedom of the mechanism. pure structural theories of synthesis result in a generate-and-test method for producing mechanisms given input-output motion specifications. this procedure is usually quite expensive  and it is generally difficult to exploit information about the desired motion to control the enumeration phase. behavioural theories derive the structure of a mechanism from specifications of its output and input motions. they fall into two categories: compositional and non-compositional. compositional theories of motion synthesis  1  1  1  1   assume the presence of primitive or atomic building blocks which implement simple input-output motion specifications. they provide methods for systematically breaking down a complex input-output specification in terms of the primitive ones. compositional theories typically address the synthesis of large scale electro-mechanical systems. noncompositional theories  1  1  build structures  from 
scratch  that satisfy given motion specifications. they are typically used for small-scale electro-mechanical systems or the synthesis of specific parts. functional theories are theories that work from intended function of a device and derive a structure that performs that function. functional theories of synthesis posit intermediate behavioural specifications and then design structures that generate those behaviours. few functional theories exist in the literature:  and  take kinematic function into account in the design of mechanism topologies. 
   this paper is organized as follows. in section 1  we formally define motion specifications in terms of configuration spaces and introduce abstract and concrete mechanisms. the operators which compose abstract mechanisms and their concrete counterparts are presented in section 1. the composition operators form the basis for a rigorous specification and solution of the motion synthesis problem in section 1. in section 1  we discuss tractable qualitative representations of the configuration space descriptions manipulated by our algebraic synthesis method. we then present efficient constraint solving algorithms that use the qualitative representations. these algorithms have been implemented in clp r   and we present examples of interesting syntheses in section 1. we conclude by reiterating the main contributions of our paper and provide a discussion of future work on the problem of automating motion synthesis  and more generally on the problem of conceptual design. 
1 	configuration spaces  motions  and mechanisms 
we briefly review the concept of a configuration space before formally defining the motion of an object. 	let 
	subramanian 	1 


1 	invited speakers 

	subramanian 	1 

1 	invited speakers 


figure 1: an example that shows join preservation violation 
of the crank rocker in figure 1 is a rectilinear translation  reciprocation  which is the input to the skotch-yoke mechanism. our construction unifies the two motions as long as their ranges  speed  and axes coincide. unfortunately  an analysis of the underlying c-space1 relations reveals that there is at most one possible position where the two motions would intersect  thus the mechanism would jam  become rigid . both the crank-rocker and skotch-yoke mechanisms are non-linear. 
　the specific developed above is inadequate for handling non-linear mechanisms in a general way. to guarantee preservation of joins for the specific and a combination introduced here  we ensure that non-uniform motions are not composed. this can be done with the restriction that non-linear mechanisms only take uniform motions as input. 
1 	efficient synthesis algorithms 
we reformulate the algebraic description of the abstract synthesis problem in terms of qualitative motion descriptions. 
given i  a qualitative specification of the input motion: o  a qualitative specification of the output motion  and constraints on i and o. 
find a sequence of abstract mechanisms a1 ... an which when composed will transform any motion described by i to some motion described by o. to be exact  we want 

where mi e i means that the motion mi  is in the class of motions described by the qualitative specification i. 
　to make the process efficient  we transform the naive generate-and-test scheme to a goal-directed procedure in section 1 that chains backward from the desired output o to i. we distinguish between single-input  singleoutput  siso  mechanism synthesis from single-input  multi-output mechanism  simo  synthesis because of the opportunity for optimization by function sharing in the latter case. we begin with the algorithm for the siso case. 
　the algorithms below are not committed to any particular abstraction language. for each language  we require 

procedures that test equality of motion descriptions  and regress constraints on motion through a primitive abstract mechanism. we will illustrate these in the context of the simple motion description system introduced in the previous section. 
1 	synthesizing single input  single output mechanisms 
the recursive algorithm for synthesizing single input  single output mechanisms is shown in table 1. we imple-
siso synthesize i o  

thus q describes the  largest  set of motions that can be transformed by t m  to motions in o. q is the most general qualitative description in the motion language which meets that the previous requirement. it is the regression or backprojection of o with respect to t m . 
1. return  t{m   siso-synthesize i q   
table 1: algorithm for synthesizing single input  single output mechanisms 
ment the synthesis method for our language as a depthbounded  goal-directed  depth-first backward chainer in clp r . the operational model of clp r  is similar to 
prolog  so the reader familiar with prolog can read the code below quite easily   however unification is replaced by a more general mechanism: solving constraints in the domain of functors over real arithmetic terms. 
　for a linear primitive mechanism  we store its name  a scaling factor for the input and output motions  and the types of input and output motion. for example  the abstract mechanism corresponding to a gear pair with gears of sizes 1 and 1 is represented as: 
mechanisrn gear-pair  linear -1    rotation  1 1   1 l      rotation   1 /1 1   1 l    . 
　for a non-linear primitive mechanism  we store its name  its input motion which must be uniform  and its output motion. for instance  the abstract non-linear mechanism corresponding to a crank rocker is represented as: mechanism crank-rocker  l   

　the top-level invocation of the synthesis function is: synthesize input motion  output motion  null design  depth bound . the base case of the synthesis occurs when the input motion i is equal to the output motion 
	subramanian 	1 


1 	invited speakers 

designs and the corresponding refinements of a windshield wiper found by our system include the composition of a worm-spur pair  a slider crank  and a rack and pinion mechanism; as well as a worm-spur  scotchyoke and a rack-and-pinion mechanism. this example shows how the backward chaining process accumulates simple algebraic constraints which are solved incrementally during the synthesis. the constraint programming language clp r   is used to implement the algorithm. clp r graphical outputs are produced via an interface to mathematica 1 
t h e o r e m 1 algorithm siso synthesize  i o   is sound: i.e  it designs concrete mechanisms that satisfy the qualitative motion specifications  qi q 1  -
this theorem can be proven by induction on the length of the generated solution. the worst case complexity of this algorithm is exponential in the length of the solution produced. the worst case branching factor for the search is around 1  corresponding to the number of primitive motion relations. in practice  the average branching factor is much smaller  around 1 for the examples in this paper  because the constraint accumulation process is a least-commitment strategy that minimizes backtracking in the space of compositions of primitive abstract mechanisms. in other words  we incrementally solve for the rigid transformation and dimensions of primitives during synthesis. we do not search for them discretely  which may be very time consuming. put another way  our constraint-based representation allow us to perform delayed instantiation of parameters. each search path encodes a whole class of solutions. pruning or accepting a path involves pruning or accepting a whole class of solutions. the algorithm synthesizes many of the designs for conversion of uniform rotation to reciprocation in  in a few seconds. the synthesis of the wiper shown in figure 1 and its variants was also completed in about two seconds on a sparc 1 + 
1 	synthesizing single i n p u t   m u l t i p l e o u t p u t mechanisms 
many useful mechanisms produce multiple outputs from a single source  e.g.  eggbeaters  cars. to design these single input multiple output  simo  mechanisms  we need to specify a sequence of output motions. 
g i v e n i  a qualitative specification of the input;  a sequence of output motions  and con-
straints on i and o's. 
f i n d a tree of abstract mechanisms  
	 which when 	composed 
satisfies the input-output specification. 
   the simo synthesis problem can be solved by a series of calls to siso synthesize as in  table 1 . calls to siso-synthesize produce a tree with isolated paths from i to each oj. however  this introduces a lot of redundancy in the form of common intermediate motions along these paths. the optimization algorithm in table 1 merges common motions in the paths: if 
1
mathematica is a trademark of wolfram research  inc. 

   we now present the class of mechanisms that are synthesizable by these algorithms. clearly the class is determined by the qualitative motion description language used  and the set of primitive abstract mechanisms and their associated implementations. for the specific motion language used in our current implementation  the class of mechanisms synthesizable are fixed-topology  single-degree of freedom mechanisms with at most one nonlinear mechanism on each path from the input to the outputs. the mechanisms we consider thus far are composed of rigid parts. the single-degree-of-freedom restriction applies in our case  because all of our primitive motion relations have only one degree of freedom. the composition of two or more mechanisms with single degree of freedom can only produce mechanisms with at most one degree of freedom. multi-degree of freedom mechanisms can be synthesized by our algebraic technique. the restriction on rigid parts obtains because our definitions of motions and mechanisms are grounded in configuration spaces of rigid bodies. by allowing definitions based on generalized configuration spaces  we can allow for some limited forms of non-rigidity. the restriction on the number of non-linear mechanisms in 
	subramanian 	1 

a design is needed for the correctness of the abstraction a that generates the qualitative motion language. the fixed-topology restriction can be eliminated by having a richer set of primitive relations as well as a richer motion specification language which allows for expression of when and how part contacts are made and broken. a limitation of our current approach is the lack of a component for shape design. if there is no sequence of primitive relations that satisfies the given specification  our method will fail to produce a design. we can integrate the methods of  for synthesizing novel shapes into our design system to automatically extend our library of primitive abstract mechanisms. 
	1 	conclusions 
this paper presented a case study of the integration of methods in qualitative physics and constraint programming with general algebraic reasoning with configuration spaces. the design domain studied is that of kinematic synthesis of mechanisms from specifications of input and output motions. two algorithms were presented that rapidly generate alternate behavioural decompositions and concrete refinements of a mechanism. we also identified the class of mechanisms which can be correctly synthesized within the qualitative framework. we have implemented our method in clp r  and all examples discussed in this paper are drawn from our implementation. our base set of examples are drawn from mechanisms in  and . we are presently enriching the language of qualitative motion specifications to handle richer classes of non-linear motions. this will allow us to 
obtain better coverage over the examples in the compendia listed above. future work involves extending the set of primitive relations  proving completeness properties for these relations  and integrating mechanism synthesis with multi-domain  including dynamics and optics  designs. 
　there are other approaches to mechanism synthesis that can be profitably combined with the first-principles approaches discussed above. expert system techniques  for synthesizing special classes of mechanisms e.g.  cam-follower mechanisms  occupy an interesting middle 
ground between p re-parametric design schemes which requires high-level qualitative specifications and the numerical optimization packages which require very detailed kinematic specifications. case-based methods  1  1  for synthesis of mechanical systems begin with a known library of designs and use the goal specification to index relevant designs. the retrieved designs are modified to meet the given specifications. the algorithm developed here can be used to design indices for the library of designs. this works by running the synthesis 
figure 1: conceptual designs for an eggbeater 
algorithm  in reverse  to parse or understand a design in terms of given primitive motion relations. 
　the class of conceptual design tasks that can profit from the integration we have effected are tasks with a 
significant geometric component. we have developed fast simulation methods for the class of mechanisms that can be synthesized by the algorithms presented here. space limitations preclude their inclusion in this document; a discussion of simulation methods will be present 
1 	invited speakers 

in the talk. all the physical prototyping of the designs presented in this paper were performed using technics lego. integrating conceptual design systems through detailed design and physical prototyping in a standard medium  will be discussed in the talk. the talk will focus on mechanical nano-technology designs because lowdimensional configuration spaces can be used to reason about shapes and motions in that domain. computational scale issues and our experience with the field testing of our tools at xerox will also be presented. 
