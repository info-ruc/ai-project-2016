
in open and distributed systems  agents must engage in interactions of which they have no previous experience. deontic models are widely used to describe aspects of permission  obligation  and trust anticipated by such agents  but no practical mechanism has been developed for testing deontic trust specifications against models of multi-agent interactions. this paper describes a way of doing this; an implementation of it via model checking; and some preliminary results on a realistic example.
1 introduction
in large-scale open distributed systems  trust remains a fundamental challenge. despite much research  the notion of trust remains vague and there is no consensus on what exactly trust is in systems such as multiagent systems  mas . this is because trust may be addressed at different levels. at the low system level  trust is associated with network security  such as authentication  determining the identity of the user entity   access permissions  deciding who has access to what   content integrity  determiningwhether the content has been modified   content privacy  ensuring that only authorised entities can access the content   etc. at higher levels  the focus is on trusting entities - these may be human users  software agents  services  directories  etc. - to perform actions as requested  provide correct information  not to misuse information  execute protocols correctly  etc.
모available research has mainly focused on analysing  improving  and developing strategies that address trust issues at various system levels. in this paper we focus not on the strategies  but on the possibility of specifying and verifying such strategies. we therefore inherit the general definition of trust; trust is defined as the problem of who to interact with  when to interact with them  and how to interact with them  ramchurn et al.  1 . we then show how the specification and verification methods of  osman et al.  1  may be used to specify and verify trust models at various system levels. we use the lightweight coordination calculus  lcc  of  robertson  1  for modelling global interaction models. local trust constraints  on the agents level  are modelled via a simple trust policy language introduced in section 1. these models may then be fed to a lightweight dynamic model checker  osman et al.  1  for verifying interesting trust properties  which go beyond liveness and safety properties verified by traditional verification techniques. the result is a powerful  yet simple  verification mechanism. the verifier itself is lightweight  delegating the complexity of managing the search space to the underlying xsb tabled prolog system  sagonas et al.  1 .
모we open with a motivating example in section 1. section 1 provides an overview of our system model and the languages used for specification. the verification process is introduced in section 1  before concluding with our results in section 1.
1 motivating example: an auction system
section 1 presents our 1-layered architectural approach for distributed open systems. similar to web service architectures  the basic idea is that a global interaction model is used to specify the rules of the interaction  irrespective of the agents engaged in this interaction. then each agent  based on its local constraints  tries to find the most suitable interaction protocol along with the most suitable group of agents to interact with. we call the agents' local constraints the deontic constraints  since they specify the agents permissions  prohibitions  and obligations.
모now let us consider the case where an agent is interested in engaging in an auction scenario for either selling or buying a specific item. trust issues automatically arise on two levels. these may be summarised by the following two questions:
 which interaction protocol should the agent engage in 
 in such an interaction  which agents does it engage with 
모for example  before selling its item  the auctioneer will have to pick the appropriate interaction protocol  where appropriateness is measured by the satisfiability of certain properties. traditional properties to check for are usually liveness and safety properties. for example  the auctioneer may decide that the interaction protocol is trusted only if it is deadlock free  trust issue ti1 of figure 1 . a much more interesting set of properties may be obtained when tackling domain specific issues. for example  a more challenging trust issue to verify is whether the interaction protocol enforces truthtelling by the bidders or not  trust issue ti1 of figure 1 .
모for a given interaction protocol  each agent will then have to select the appropriate agents for such an interaction. the goal is to achieve a set of agents that trust each other. for example  one bidder may trust auctioneer a in selling anything except dvds - possibly  due to previous experience  it now knows that these dvds are not original. it may also use socio-cognitive models of trust to learn that if the dvds are not original  then most probably the cds will not be too  trust issues ti1 and ti1 of figure 1 . another widely used trust mechanism is the use of ratings and reputations. the agents should be capable of collecting  or having access to  each other's rating. it is then up to each agent to aggregate these ratings as they see fit. for example  a bidding agent might decide not to trust new auctioneers with no selling history. an average rating is then required  possibly giving more importance to the latest ratings  trust issue ti1 of figure 1 .
모the trust issues of figure 1 cover a wide sample of the various trust mechanism in the literature  ramchurn et al.  1 : from socio-cognitive models  ti1 of figure 1   to evolutionary and learning models  ti1 of figure 1   reputation mechanism  ti1 of figure 1   trustworthy interaction mechanisms   ti1 of figure 1    etc. in this paper  we do not specify how trust is learned. we focus on the agent's individual aggregation mechanisms and their specification  which is essential for verifying trust. for example  while we do not focus on how the agent obtains the ratings of another  ti1 of figure 1   we do require the specification of how these ratings are aggregated.
모the main goal of this paper is to show how agents may answer these questions by using a dynamic model checker. in our running example  the agent's constraints used  or the trust constraints  are those of figure 1. the interaction protocol verified is presented by the state-space graph of figure 1.
모the interaction of figure 1 is that of a vickrey auction. the interaction starts at state s1 when the auctioneer a sends an invite to a set of bidders for bidding on item i with a reserve price r. the interaction remains at state s1 until invites are sent to all bidders. then the bidders send their sealed bids back to the auctioneer. this is represented by state s1 of figure 1. when all bids are collected  the interaction moves to the new state s1. the auctioneer informs the winner of the price v to be paid  moving the interaction to state s1. finally  the winning bidder sends its payment p  and the interaction is completed at state s1.
모before we present the verification mechanism used in section 1  section 1 introduces our system model  its architecture  and its specification languages.
figure 1: the auction scenario: the interaction's state-space
1 system modelling
we view mas as a collection of autonomous agents. the system is open and distributed. various agents may join or leave the system at any time. interactionsbecomethe backbonethat holds the system together. agents group themselves into different  and possibly multiple  interactions. figure 1 provides such an example  where a collection of agents are grouped into three different interactions  or scenarios : two auction scenarios and a trip planning scenario.
모due to the dynamic nature of the system  we believe interaction groups should be created dynamically and automatically by the agents. we also believe everything should be dis-
tributed. this implies that there should be no higher layer for
coordination  control  synchronisation  etc. it is the agents'
responsibility to group themselves into different scenarios.
as a result  we split the mas model into two layers: the interaction layer and the agents layer.
모the interaction model specifies the rules and constraints on the interaction. this indicates how exactly the interaction
may be carried out. the agents' models specify the rules and constraints on the agents. these are the agents' permissions  prohibitions  and obligations; we therefore call this model the deontic model  figure 1 . note that for one scenario there is one global interaction model and several local deontic models. while agents need to share the interaction model in order to know the rules of the interaction they're engaged in  each agent will have its own local constraints in its deontic model.
모in what follows  we introduce the languages used in specifying these models.
1 the interaction model
we choose the lightweight coordination calculus  lcc   robertson  1  for modelling the interaction's state-space graph  since it is the only executableprocess calculus for mas that we are aware of1. having an executable process calculus for modelling the interaction's state-space graph is very useful for dynamically verifying the executable models of interaction. figure 1 presents the syntax of lcc.
interaction:={clause ...}clause:=agent :: adefagent:=a role id adef:=null 뫹 c | agent 뫹 c | message 뫹 c |
adef then adef | adef or adef | adef par adefmessage:=m   agent | m   agentc:=term | c 뫇 c | c 뫈 crole:=termm:=term
figure 1: the mas model - a 1-layered architecture model
null denotes an event which does not involve message passing.
term is a structured term in prolog syntax.
id is either a variable or a unique agent identifier.

figure 1: lcc syntax
모agents  in lcc  are defined by their roles and identifiers. an interaction is defined by a set of clauses. a clause gives each agent role a definition that specifies its acceptable behaviour. an agent can either do nothing  usually used for internal computations   take a different role  or send/receive messages  m  a  m  a . agent definitions are constructed using the sequential  then   choice  or   parallel composition  par   and conditional  뫹  operators. the conditional operator is used for linking constraints to message passing actions.
example revisited
figure 1 presents the specification of the state-space graph of figure 1 via lcc. the auctioneer a - knowing the item i  the reserve price r  and the set of bidders bs - recursively sends an invite to all bidders in set bs. it then takes the role of auctioneer1 to collect bids  send the winner a message  collect payment  and deliver the item won. on the other side  each bidder agent receives an invite from the auctioneer and sends its bid based on its valuation. the winner receives a win message and then sends its payment p.
1 deontic models
in this paper  we focus on the trust constraints imposed by the agents. we propose a trust policy language for the specification of trust rules. the language is similar to other logicbased policy languages which are built on deontic concepts  such as asl  jajodia et al.  1   rdl  hayton et al.  1   and rei  kagal et al.  1 . the syntax of our language is presented by figure 1.
모the syntax states that trust rules might either hold in general or under certain conditions: trustspecs  뫹 condition . the interaction's trustworthiness is modelled by
a auctioneer i r bs  a  ::
  invite i r    a bidder b  뫹 bs =  b|t then a auctioneer i r t  a   
or a auctioneer1 bs   a  뫹 bs = .
a auctioneer1 bs v s  a  ::
append  b v   v s v n  뫹 bid b v     a bidder b  then
  a auctioneer1 bs v n  a  뫹 not allbid bs v n   or
  win b1 v 1    a bidder b1 
뫹 all bid bs v n  and highest v n b1    and secondhighest v n   v 1  then
deliver i b1  뫹 payment p    a bidder b1     .
a bidder b  ::
invite i r    a auctioneer        a  then bid b v     a auctioneer1      a 뫹 valuation i v   then win bi v i    a auctioneer1      a  then payment p    a auctioneer1      a  뫹 bi = b and payment p .

figure 1: lcc specification for the interaction of figure 1


action:=mpa | n-mpa | trustspecsmpa:=message   agent | message   agentcondition:=condition 뫇 condition |
condition 뫈 condition | temporal | termrole n-mpa  message:=termwhere   x  denotes zero or one occurrence of x  ip is an interaction protocol specified in lcc 
id is either a variable or a unique agent identifier 
temporal is a temporal property whose syntax is specified in  osman et al.  1   and
term is either a variable or a structured term in prolog syntax.

figure 1: syntax of our trust policy language
trust interaction ip  sign   where ip is the lcc specification of the interaction protocol in question  e.g. the interaction protocol of figure 1 . sign could take the values '+' and ' ' to model trust and distrust  respectively. the agent's trustworthiness is modelled by trust agent sign   where agent represents the agent in question. only if the agent is trustworthy  it can engage in an interaction. trusting or distrusting agents to perform specific actions is modelled by trust agent sign action . actions could either be message passing actions  mpa  - such as sending  message  agent  or receiving  message   agent  messages - or non-message passing actions  n-mpa  - such as performing computations. we also allow actions to take the form of another trust rule  note the trustspecs in the action definition . this supportsthe delegationof trust  since it permits the specification of whether an agent's trust itself is to be trusted or not.
example revisited
trust issues ti 1  ti 1  and ti1 of figure 1 address trust at the agent level. in what follows  we present the specification of the more complex trust rule  ti1  in our trust policy language. the rule is presented by figure 1 a . it specifies that agent a is trusted as an auctioneer only if it has a selling history of at least 1 items and an average rating above 1%  going up to 1% for the latest 1 transactions. the mechanism presented here distrusts new entrants and focuses on the agent's latest ratings rather than the overall one.
모trust issues ti1 and ti1 of figure 1 address trust at the interaction level. the conditions for trusting an interaction protocol are specified via a temporal language. since the 'deadlock free' property of ti1 is a straightforward property to model via a temporal language  we show how the more challenging property of 'enforcing truth-telling by the bidders'  ti1  may be specified.
모to prove the protocol enforces truth-telling by the bidders  we prove that  for the interaction protocol of figure 1  the bidders cannot do any better than bidding their true valuation v: the maximum value they are willing to pay. note that we do not verify whether the agent will actually bid v or not  but whether the interaction protocol provides an incentive for bidding a different value than v. for this  we study the two cases:  1  if the competing agent bids a higher value ch  and  1  if the competing agent bids a lower value cl. in figure 1  the grey circle represents the bidder and its valuation v. the other two circles represent the two cases of the competing agent  which may bid either a higher or a lower value: ch and cl  respectively. for each of these two cases  the bidder may either bid its true valuation  a value between its true valuation and that of its competitor  or a value beyond that of the competitor  figure 1 . the trust rule of figure 1 b  studies all 1 cases  respectively. for each bid  the winner and the price won at are computed through the tempo-
ral property  bid bidder bid1   bid competitor bid1    win winner price   tt1.
the bidder should  naturally  be expected to lose to its competitor in cases 1  1  and 1. it should win in cases 1  1  and 1  where case 1 would be the only case where the bidder bids its true valuation and wins the item for the price y. the trust rule requires that the bidder is not better off when winning in cases 1 and 1  i.e. where the item is won for prices x and z  respectively. this is expressed by the conditions x뫟y and z뫟y.
모the interactionprotocol of the trust rule presented by figure 1 b  is in fact the lcc protocol of figure 1. this rela-
trust a auctioneer a   +  뫹 ratingcount a auctioneer a   total  and total   1 and ratingaverage a auctioneer a   average  and average   1 and ratinglatest a auctioneer a   1  latest  and latest   1.
 a  trust rule ti1
trust a interaction interactionprotocol    +  뫹
vl' cl and cl vl and vl v and v vh and vh ch and ch vh' and
 bid bidder v   bid competitor ch    win competitor     tt and
 bid bidder vh   bid competitor ch    win competitor     tt and
 bid bidder vh'   bid competitor ch    win bidder x   tt and
 bid bidder v   bid competitor cl    win bidder y   tt and
 bid bidder vl   bid competitor cl    win bidder z   tt and  bid bidder vl'   bid competitor cl    win competitor     tt and
x뫟y and z뫟y.
 b  trust rule ti1

figure 1: specification of trust rules

figure 1: the bidding strategies: the 1 cases
tively complex lcc structure1 is passed entirely as a parameter to the trust rule. the interaction protocol is then said to be trusted if the condition - the collection of temporal properties - is satisfied. in this example  the condition verifies the possible occurrence of transmitting the bid      and win      messages in the lcc interaction protocol of figure 1.
모it is worth noting that the trust rule is restricted to the auctions domain  yet independent of the specific auction protocol it is verified upon. for example  the six cases of figure 1 are comprehensive  even for auction systems consisting of more than two agents. this is because verifying the utility of one agent should take into consideration only the competing agent's bid - all other agents' bids are irrelevant. furthermore  the verification of such a trust rule will terminate with correct results  whether positive or negative  for any auction protocol that requires agents to place their bids before a message is transmitted informing who the winner is. it will probably fail when verified against more complex auction protocols  such as those selling multiple items and having several winners. however  the verification will be successful in the most common auctions  such as the english  dutch  sealed first-price  and sealed second-price auctions. allowing agents to automatically verify such properties  which are relatively independent of the specific interaction protocol   aids the agents in making their protocol selection when faced with new and unexplored protocols.
1 the dynamic model checker
we believe it is solely the agents' responsibility to answer the question of how  when  and who to interact with. ideally  in a highly dynamic system  this should be done at run time by deciding which combination of interaction and deontic  trust  models is currently suitable. but is this feasible 
모we choose model checking from amongst other verification techniques because it provides a fully automatic verification process which could be carried out by the agents during interaction time. we show how interaction time verification is made possible with the use of a remarkably efficient  see figure 1  and lightweight model checker. the concerned agent can then feed the model checker with the system model: the combination of the global interaction model and agents' local trust rules. the model checker should then verify whether the trust rules are consistent amongst themselves as well as consistent with respect to the interaction model. it should be capable of detecting non-suitable  distrusted  agents and/or interaction protocols.
1 model checking: an overview
the model checking problem can be defined as follows: given a finite transition system s and a temporal formula 뷋  does s satisfy 뷋  the model checking process is divided into three stages: modelling  specification  and verification. the system to be verified must first be modelled in the language of the model checker s. the properties  뷋  to which the system model is verified upon should be specified using the model checker's temporal logic. both the system model and the properties specification are fed to the model checker for verification. the model checker is  essentially  an algorithm that decides whether a model s satisfies a formula 뷋. figure 1 illustrates the model checking process.

figure 1: the model checking process
1 model checking: the implementation
in traditional model checking  the system model represents a state-space graph. the constraints on a given state-space are then specified through temporal properties in the property specification section. in our case  the system model is a combination of the shared interaction's state-space and the agents' local trust constraints. trust constraints based on temporal properties  such as those constraining the interaction  e.g. ti1 of figure 1 b    are modelled in the property specification section. other trust rules constraining the agents  e.g. ti1 of figure 1 b  are kept on the deontic level of the system model. figure 1 provides an overview of our trust verifying model checker. the sample input data is that of the auction system scenario. the interaction model sample in figure 1 is a copy of that of figure 1. the deontic model sample  or the trust constraints on agents  is a copy of figure 1 a . the property specification is the trust constraint on the interaction protocol  figure 1 b  .

figure 1: the auction scenario: the model checker's input
모the model checker should then verify that the interaction model is trusted and that the agents are trusted to engage in the given interaction. to verify this  the concerned agent feeds the model checker with the appropriate interaction model along with the trust rules that are split between the deontic model and the property specification. the verification process is explained in the following section.
the verification process
in this section  we present an overview of the model checking algorithm - the black box of figure 1. we refer the interested reader to  osman et al.  1  for the details of the model checker and its operational semantics.
모the verification process is carried out as follows. the interaction model  the deontic model  and the temporal property to be verified are fed to the model checker. verification starts at the initial state s1 of the interaction model  and the model checker tries to verify that the temporal property 뷋 is satisfied at s1. if it succeeds  the verifier terminates and the property is said to be satisfied. otherwise  the verifier attempts to make a transition s  to the next state s  in the state-space1. if the transition s  violates any of the trust  deontic  rules  then the verification process terminates and the property is not satisfied. otherwise  the satisfaction of the property 뷋 is verified with respect to the new state s   and the whole process is repeated all over again.
모the result is a remarkably compact model checker built on top of the xsb system  sagonas et al.  1   a tabled prolog system. this compactness is achieved by placing the burden of searching the state-space on the underlying xsb system.
1 conclusion and results
trust is the key to the success of large-scale distributed systems. most of the work carried on in the field of trust has focused on the strategies for ensuring trusted interactions. in this paper  we have presented a mechanism for specifying and verifying such strategies. our mechanism allows the agents involved to dynamically and automatically invoke the model checker at run-time  when the conditions for verification are met  and verify that certain trust requirements will not be broken for a given scenario with a given set of collaborating agents.
모the complexity of verifying multi-agent systems depends on the complexity of the different roles in the interaction rather than the number of agents involved in such an interaction. as shown in section 1  interaction protocols are defined in terms of agents' roles instead of the individual agents that might be engaged in the interaction. for example  there are two roles for our auction scenario: the role of the auctioneer and that of the bidder. all bidders then share the same protocol specification  figure 1   irrespective of their different local deontic constraints. the complexity of verifying the five trust issues of figure 1 for the auction scenario of figure 1  or figure 1  depends on the complexity of the auctioneer's and bidder's role definitions. in our scenario  if the trust issues are verified for a set of one auctioneer agent and two bidder agents  then the results will hold for a set of one auctioneer agent and n bidder agents  where n 뫟 1. the trick is to know the minimum number of agents required for verifying certain properties of a given interaction protocol. we assume such information is provided with the interaction protocol.
모in our example  we set the scene to incorporate one auctioneer and two bidders. the dynamic model checker is then invoked for verifying the five trust issues of figure 1 against the auction scenario of figure 1. the cpu time and memory usage  from the moment the model checker is invoked until the results are returned to the user  are presented by figure 1.
cpu time  sec 11111memory usage  mb 11111figure 1: preliminary results
모note that results for ti1  in figure 1  differ drastically from others since ti1 is essentially constructed from 1 temporal properties  see section 1: example revisited   while the others are single temporal properties.
모the model checker presented in this paper has been tested on several benchmark scenarios  such as a variety of auction scenarios and a travel agency scenario  osman et al.  1 . these results were not presented in this paper since they are not concerned with the trust application  which this paper focuses on  but with more general deontic constraints. however  the cpu time in all cases never exceeded one second. these preliminary results prove that dynamic verification is made possible in such realistic scenarios. the limits of the model checker still need to be tested. this requires a comprehensive study of possible scenarios  their interesting temporal properties  and the level of complexity that these could reach.
모in conclusion  the novelty of our work is in introducing interaction time verification and applying it to the field of trust in multi-agent systems. this is made feasible by using a relatively compact  implemented in 1 lines of prolog code   yet efficient  as shown by the results of figure 1   dynamic model checker. this allows agents to invoke the model checker at run time for verifying various trust issues.
