 
this paper continues and extends previous work by the author in developing systems which provide the user with various forms of explicit and implicit assistance  and in general cooperate with the user in the development of his programs. the system described in this paper makes extensive use of a bit map display and pointing device  a mouse  to significantly enrich the user's interactions with the system  and to provide capabilities not possible with terminals that essentially emulate hard copy devices. for example  any text that is displayed on the screen can be pointed at and treated as input  exactly as though it were typed  i.e.  the user can say use this expression or that value  and then simply point. the user views his programming environment through a collection of display windows  each of which corresponds to a different task or context. the user can manipulate the windows  or the contents of a particular window  by a combination of keyboard inputs or pointing operations. the technique of using different windows for different tasks makes it easy for the user to manage several simultaneous tasks and contexts  e.g.  defining programs  testing programs  editing  asking the system for assistance  sending and receiving messages  etc and to switch back and forth between these tasks at his convenience. 
introduction 
lisp systems have been used for highly interactive programming for more than a decade.+ during that period  much effort has been devoted to developing tools and techniques for providing powerful interactive support to the programmer. the interlisp programming system  tei1  represents one of the more successful projects aimed at developing a system which could be used by researchers in computer science for performing their day to day work  and could also serve as a testbed for introducing and evaluating new ideas and techniques for pioviding sophisticated forms of programmer assistance. interlisp on the pdp-1 is currently used by programmers at over a do/en arpa network sites for doing research and development on advanced artificial intelligence projects such as speech and language understanding  medical diagnosis  computer-aided msiiuction  automatic programming  etc. implementations of interlisp on several other machines are cuirently planned or in progress. 
this paper describes a system written in interlisp which extends the inierlisp user facilities to take advantage of a display.tt the paper is not an  idea  paper in the sense that artificial intelligence papers usuallv are. instead  this 
f an excellent survey of the state of the art may be found in  san  
t the author would like to acknowledge and thank r. f. sproull and j strother moore  who designed and implemented critical support facilities without which this system would not have been possible  and whose ideas and intuitions provided extremely valuable guidance and inspiration during the development of the system.  i he form and capabilities of some of the display primitives in the current system were suggested by an earlier version of a display text facility for interlisp designed by terry winograd. finally  all of the work described herein depends heavily on th  leverage provided by the interlisp system itself  which is the result of the efforts of man  individuals over a period of almost a decade  made possible by continuing arpa support over that period. 
papcr describe'  a woiking sysiein which implements and inttrratcs a number of idvis and techniques previously reported in the liteiature by several dillyicnl individuals  including the author. the idea of a display composed of multiple  overlapping regions called  windows  is attributable to and an essential pail of the smallt.dk programming system designed and implemented by the learning research group at xerox reseaich  enter  1 rg . in particular  much of the way that windows are used in the system described here was influenced by the work of dan ingalls on the smalltalk user interface. the idea of using the display as a means for allowing the user to retain comprehension of complex program environments  and to monitor several simultaneous tasks  can be found in the work of dan swinehart  swi   the use of the  mouse  as a pointing device for selecting portions of a display goes back to the early work on nfs  eng . finally  the techniques used for automatic error correction and the idea of having the user interact with the system through an active intermediary winch maintains a history of his session  both of which appear in this paper  are parts of the standard interlisp system  tei1    tei1  . the work reported in this paper is of interest primarily in how the realization of these various ideas in a single  integrated  working system dramatically confirms their value.fit 
overview of the system 
the system described in this paper is implemented on a version of interlisp  tei1  running on maxc  a computer at the xerox research center in palo alto. this computer emulates a pdp-1   and runs the tencx operating system  so that from the standpoint of the user  the system he is using is interlisp-1. the raster-scan display used by the system described in this paper is maintained by a separate 1k 1 bit word mini-computer. the minicomputer is linked to maxc through an internal network  and implements a 
graphics protocol similar to the network graphics protocol  spr . but specialized for text and raster-scan images. all of the work described in this paper deals with the  high end  of the system  i.e.  the user interface  and is wutten entirely in interlisp. 
the user communicates with the system using a standard typewriter-like keyboard. in addition  he has available a pointing device commonly called a  mouse   eng  used for pointing at particular locations on the screen. for those unfamiliar with this device  the mouse is a small object  about 1  by 1  by 1   with three buttons on its top. the system gives the user continuous feedback as to where it thinks the mouse is pointing by displaying a cursor on the screen. the user slides the mouse around on his working surface  causing bearings of wheels on the bottom of the mouse to rotate   and the system moves the cursor on the 
! j t w h e n i first began woik in 1 on what was to become dwim. the automatic error correction facility of interlisp  by implementing a primitive spelling corrector which would automatically correct a certain class of user spelling errors  i discussed this project at length with a colleague over a period of months. one d:is soon after this facility was finally completed and installed in our f isp system  this same colleague rushed to my office and in i*rral excitement exclaimed that the system had corrected an error. i was surprised at his enthusiasm  since we had been discussing this system tor months. he replied   yes  but it really did it!  the system described herein implements ideas that many of us have long been sayinu would be a good thing to have. and they really are! 

lantfuaros a s y s t e m s - 1 : teitelman 
1 


why is such a facility useful  because most interactions with a prus.' raminim; system are not independent  i.e.  each  event  bears some relationship to what transpired before  usually to a fairly recent event. being able to point at  purlions o   these events effectively gives the user the power of pronoun reference  i.e.. the user can say use this expression or that value  and then simply point. this drastically reduces the amount of typing the user has to do in many situations  and results in a considerable increase in the effective  bandwidth  of the user's communication with his programming environment. 
the user views his environment through a display consisting of several rectangular display  windows . windows can be  and ficquenlly are  overlapped on the screen. in this case  windows that are  underneath  can be brought up on top and vice versa. the resulting conf igurauon considerably increases the user's effective working space  and also contributes to the illusion that the user is viewing a desk top containing a number of sheets of paper winch the user can manipulate in various ways. 
one facility provided by these windows that is not available with sheets of paper is the ability to scroll the window forward or backward to view material previously  but not currently  visible in the window. thus a single window can be used to view and manipulate a body of text that would icquire many sheets of paper. 
bach window corresponds to a different task or aspect of the user's environment. for example  there is a tylmscrirr window  which contains the transcript of the user's interactions with the lisp interpreter through the programmer's assistant  a work area window winch is used for editing and prettyprmting  a history. window  a backtracf window  a message: window  etc. using 
different windows for different tasks 
...makes it easy for the user to manage several simultaneous tasks and contexts  switching back anil forth between them at his convenience. 
being able to switch back and forth between tasks icsults in a relaxed and easy style of operating more similar to the way people lend to work in the absence of restrictions. to use a programming metaphor  people operate somewhat like a collection of coroutines corresponding to tasks in various states of completion. these coroutines are continually being activated by internally and externally generated interrupts  and then suspended when higher priority interrupts arrive  e.g.  a phone call that interrupts a meeting  a quick question by a colleague that interrupts a phone call  etc. our previous 
experience with interiisp supports the contention that it is of great value to the user to he able to switch back and forth quickly between related tasks. 1 he system described in this paper makes this especially convenient  as is illustrated in the sample se.smon presented in the body of the paper. 
one technique hcavib cmplovcd thioughoni the system is the use ol menus. a menu is a lypc of window that causes a specified operation to be p .; ioihhm! when a selection made in that window. menus scive a numhci of impottant functions.   hey make it easy for the ti.ser to specify an operation without having  o t ne. thev act as a prompt for the ircr by providing him with a repeiloire of commands from which to choose  tor example  often a user will not remember the name of a command  or may not even be aware of the existence ol' a command. 
however  most importantly  menus llv facilitate context switching. as with most systems  the interpretation of the user's keystrokes  with the exception oi interrupt characters which usually have a globallv detmed effect  depends on the state i   the system  f or example  when addressing the lisp interpreter  the characters that the user types are used to construct lisp expressions which are then evaluated. when using the editor  the characters are inserted in the indicated expression  etc. 1 he important point is that once the user starts typing  he normally has to complete the operation or abort it. however  by selecting a menu command using the mouse  even in the midst of typing  the user can temporarily suspend the operation he is pel forming  go off and do something else  and then return and continue with his current context. this is also illustrated in the sample session below. 
a samojr session vvitji tlie system 
since so much of the utility o ' the system desciibed in this paper rest on visual effects  it is difficult to transmit the feci and smoothness of the system through words. therefore  the form chosen for presenting  the system in this paper is to take the leader through a sample session with the system  using frequent  snapshots  of the display as a substitute for the actual display itself. this session is divided into two parts. the first part is a  toy  session  in that the user is not performing any serious work. it is included only to introduce the salient features of the system. the second part of the session shows some more sophisticated use of these features in the context of an actual working session involving finding and fixing bugs  testing programs  sending and receiving messages  etc. 
for readers not familiar with i isp  please ignore lisp related details  which we have tried to minimi/e . i he impoitant point is the way tic system allows the user to switch back and forth between several tasks and contexts. such a facility would be useful in any piogramining environment. 

lanrtunprps 	& 	s v s t f * m s - 1 : 	t   i t p l n a n 
1 

sample session   - part 1 
1. figure 1 shows the initial configuration of the screen. three windows are displayed: the typescrlpt window  which records the user's interactions with the programmer's assistant and the lisp interpreter; the prompt window  which is the black region without a caption at the top of the screen used for prompting the user; and a menu  which is the smaller window with caption menus to the right of the lypescript window.j a menu is just like any other 
window  except that whenever a selection is made in a menu  a specified operation is also performed. this particular menu is a menu of menus  hence its caption. if the user selects one of its commands  each of which is the name of a menu  the corresponding menu will be displayed at the location he indicates. he can then select  and thereby perform  commands on that menu. the crosshairs shape in the lower right hand portion of the typescript window is the cursor  and indicates the current position of the mouse. 
in figure 1  i have just typed in a lisp definition for the function fact  factorial . fisp has given me the error message  incorrect defining form   displayed in bold face to set it off . the system displays a blinking caretff to indicate where the next character that i type  or the system prints  will be displayed. in figure i  the caret now appears immediately following the  1 -   where 1 is the event number for my next interaction with the programmer's assistant  and  - is the  ready  character. 
1. i don't understand what caused this error  so i type   to the p.a.  programmer's assistant   requesting it. to supply additional explanatory information. the p.a. looks at the previous event to determine the nature of the error. in this case. tram: built-in information about the arguments to dl i ini¡ö ..   the p.a. tells me that the problem is that d i . h n r ; encount'-i'd an atom where it expected a list  i.e.  a left parentheses is missing from in front of the word  fact .!  | j since the programmer's assistant is maintaining a history of mv interactions with the system. i don't have to retype the l ! iini o expression. instead  i can edit what i have already typed  and simply insert the missing left parenthesis. the ! i ii menu will allow me to perform various editing opnations using  the mouse for pointing  and the keyboard  where necessary  for supplying text. in figure 1  i have alicady moved the mouse so that the cursor is positioned over the edit command on the mhniis menu  in preparation for  bringing up  the roil menu. 
i ! ik-  plaid  effeet of the hackground in the figures is an artifact of the pmdmtion/iedn-hon process. i he aelu.tl background wit  he display t.s 
a uniform grey. 
if in these figures   he tare! is always shown in ils  on  position. 
f i ' t l f i he p.a. did not know anything about this particular error  il would refer to the index of i he on-line inlerlisp reference manaial and present the toi respondmp text as:.ociated with the crro  message by way of 
explanation. i he user can also airmenl the bnill-in mini malum that the p.a has about syacm functions by mfoinnnj'  the p.a. about the requirements of his own functions. he ean then use the   command to explain errois in his own programs. 
lanfuiares & s y s t r m s - 1 : t p i t e l m a n 
1 

1. i press a button on the mouse to select the edit command in the menus menu. the system indicates the selection by displaying edit as white on black. the prompt window tells me to use the left button on the mouse to indicate where i want the center of the  edit  menu to 
appear. the cursor is changed to an icon of a menu with a cross in its center to suggest the operation that is pending. at this point  i don't have to complete this operation. i can type in other expressions to the programmer's assistant  perform other menu operations  etc. the process which is waiting for me to supply the indicated information is simply a co-routine which has been suspended.! however  since i want to fix up the dfelneq expression before going on to anything else. i move the cursor to the position at which i want the edit menu to appear  which is below the menus menu and to the right of the typescript window  as shown in figure 1. 
1. i press the left button on the mouse  causing the edit menu to appear at the location of the cursor. in this position  the edit menu slightly overlaps both the typescript window and the menus menu  so the system automatically adjusts the edit menu by sliding it off these windows to its location as shown in figure 1.|f 
'i'see description of the ''spaghetti stack  facility in  eob  and  tei1 . 
i t ' could force the edit menu to overlap the typf script window by positioning it exactly using one of the commands on the window menu. however  since in this case i only positioned the menu 
approximately  the system tries to  do what i mean   a philosophy of system design we have tried to follow throughout the interlisp system 
languages & systems-1: teiteiman 
1 
1. now i am ready to edit. i select the left parenthesis in the first line of the typescript window  and then select the insert command on the edit menu. the line of text in the 
typescript window is broken just before the selection  the left parenthesis   and the caret is moved to that location. the prompt window instructs me to input material. anything i type will appear at the location indicated by the caret. 
1. i type in a single left parenthesis  and terminate the insert operation. the line of text i have been editing is rejoined  and the caret returned to the appropriate location at the end of the typescript window. i now wain to cause the corrected text to be re-input in order to perform my original operation  i.e.  define my function. therefore  i select the text by first selecting the  d  in  ilttineq  and then extending this selection through the final       . then  using the same method as previously shown for bringing up the edit menu  i bring up the window menu in order to obtain the command for inputting selected material. 
languages & s stems-1: teitelman 
1 

1. i still don't understand why the error occurred  so i try typing the   command again. in this case  the programmer's assistant tells me that the problem is that one of the operands to *  the multiply operator  was  fact n-1  and that the value of  fact n-d is nil when n=1. in other 
words  when fact is called with n=o  it returns nil. the p.a. is able to generate this explanation because  1  it knows that all of the arguments to * must be numbers  and  1  it can examine the state of the computation on the stack. in this case  it found that the second operand to itlmts was nil  which is not a number  and that the expression that produced this particular value was  fact n-1  in the expression  n. fact n-1   which is contained in the function fact  and that at the time this call occurred  the value of n was 1. 
i now realize that the problem is simply that i neglected to specify the value of fact for n=o.f therefore  i prettyprint the definition of fact in preparation for editing it. figure 
ii shows the definition of fact prettyprinted in my work area 	window  	which 	automatically 	appeared 	when prettyprint was called. note that the definition of fact now 
shows the two misspelled words  greaterr and facct  spelled correctly. 
1. i select the right square bracket in the definition of fact in the work aria window  and then select the insert comand on the edit menu. the edit menu automatically moves so as to be close to the window that i am editing. i make the necessary correction by typing    else i   i.e. if n is not greater than 1  fact should return 1. figure 1 shows the display just before i complete the insert. note that the caret appears in the work area window where i am typing. the cursor is in the upper right hand portion of the screen at the location of the insert command before the edit menu moved to be close to the work area. 
f i n interlisp  if none of the predicates of ;tn if-then expression evaluate true  the value of the expression defaults to nil. 
languages & systems-1: teitelman 
1 

1. 1 complete the insert  and then select the done command on the edit menu to indicate that i am finished editing this expression. the prompt window reports that the definition of fact has been changed. note that i did not have to finish editing fact at this point: i could have typed in expressions to be evaluated  performed other menu operations  etc.. even edited other expressions  before selecting the done command for this expression. this is another example of being able to suspend different tasks in varying states of completion and go back to them at some later point. 
1. i now test out my change by typing fact 1   which works correctly. now i want to continue with the computation. note that i am still in the original break that followed the error. the arithmetic operation *  i.e.  the lisp function itimhs  is still waiting for a number to be used as a multiplicand. i therefore select the return command on the break menu. the prompt window tells me to input expression and the caret moves to the prompt window. i type 1 as the value to be returned from this error break. figure 1 shows the display at this point just after i type 1  which is echoed  displayed  in the prompt window. 
note: in actual practice  for a computation as trivial as fact 1   i would probably simply reset  abort back to the top  and reexecute fact 1   rather than bothering to continue the computation  since so little has been invested in getting to this point. however  
being able to continue a computation following; an error is especially useful when an error occurs following a significant amount of compulation  or when the computation has left things in an  unclean state  as a result of global side effects. such a facility is also essential for good interactive debugging. 
	languages & systems-1 	teitelman 
1 

1. i complete typing the expression for the return command  thereby causing 1 to be returned as the value of the break  which causes  1 * i  to be computed and returned as the value of facto   which then causes  1 * 1  to be computed  etc.  and finally the original computation of facto  finishes and returns 1 as its value as shown in figure 1. in the next to the bottom line of the typescript window. 
i now want to try fact on some other values  so i bring up the history menu  and select the usr. command  which is a command to the programmer's assistant to reexecute a 
previous event  or events  with new values. the prompt window instructs me to select the targets and to input the objects to be substituted. i select the  1  in facto   near the lop of the typescript window  and input  1 1   echoed in the prompt window   i.e.  i am requesting that fact 1   fac'io  and fact 1  be computed. 
1. the resulting history operation is equivalent to typing usf 1 in for 1 in  1  which the p.a. prints in the 
typfscript window to show me what is happening. this usf command now causes three computations to be 
performed  corresponding io the result of substituting 1 for 1 in fact 1 . the resuit of substituting 1 for 1 in facto   and the result of substituting jo for 1 in fact 1 . the values produced by these three compulations  1  1. and 1  
are printed in the typi-nckum' window  as shown in figure 1. finally  i ask for a replay of the history of my session  by selecting the    command in the 1 is i or y menu. the himoky window is brought up  and the history of my session  in reverse chronological order  is printed in this window  as shown in figure 1.ff 
f1 is the event number of the .-vein corresponding k  facto . 
ft in addition io seeing a replav of his history  the user can also scroll the  contents of the  'iypfsckipj window backward  m time to we the transcript of carlin interactions with the system. the difference between the history anil the iypfscript is that the typi script contains a record of all chaiailcrs input or output  e.g.  includes messages es printed by the system and by the user's prograions the histoiy contains a subset of these duracteis. orram/cd according' to events. for cample  1  the value returned by facto   actually appears ix lines below facto  in the imtscripi window  but in the history window  it would be shown as the value of event number a  regardless of the fact thai events 1 thru 1 occurred between the lime that event 1 was begun and the time it completed. . 
languages & systems-1: teitelman 
1 

this completes the  toy  session designed to illustrate some of the basic features of the system. note that at this point the display contains nine different windows. five of these windows are control windows  menus . the other four windows describe various processes. note that the windows have not been a burden on the user: he does not  manage  the windows  although he could perform explicit operations on them such as changing their position  or size  or shape  or editing their contents as we have seen. the feeling to the user is that the windows more or less manage themselves  and this contributes greatly to the smoothness of the system.f 
conclusions 
the system decribed in this paper has been in use by actual users other than the author only a few months. however  our conjectures about the usefulness of this kind of facility were if anything conservative. the ability to suspend an operation  perform other operations  and then return without loss of context is widely appreciated. the technique of using different windows for different tasks docs make this switching of contexts easy and painless. 
liven when the user is not switching contexts  the use of multiple windows is extremely helpful. for example  a standard complaint with conventional display terminals is that material that the user wants to refer to repeatedly  e.g.  a printout of some function  or a record of some complicated interaction  is displaced by subsequent  incidental interactions with the system. in this situation when using a 
hard copy terminal  the user simply tears off the portion he is interested in and saves it beside his keyboard. being able to freeze a portion of the user's interactions in a separate window  such as the work area. while allowing subsequent interactions to scroll off the screen seems to combine some of the best aspects of hardcopy and display terminals. 
finally  users just seem to enjoy aesthetically the style of interacting with the system  such as using menus  the feedback via the prompt window and changing cursors  being able to scroll the windows back and forth  etc. we think this is an area that will see an increasing amount of activity in the future as the cost of bit map displays and the necessary computing power to maintain them continues to drop. 
