ion/implementation model of problem reformulation 
michael r. lowry 
stanford artificial intelligence laboratory 
box 1  stanford ca 1 usa 
and kestrel institute 
1 page mill road  palo alto ca 1 usa 
     
abstract 
     a good problem representation incorporates important problem constraints while hiding superfluous detail. this paper presents methods for abstracting a problem representation by making implicit problem properties into explicit properties of the representation. the mathematics of the abstraction search space are given in terms of model theory and universal algebra. the behavioral abstraction method uses predefined representation maps to lift a problem representation to an abstract theory. the behavioral congruence method generates abstract theories and representation maps which incorporate problem constraints expressed as behavioral equivalences. two meta-level methods for generating behavioral equivalence theorems are given. the strata automatic programming system described in this paper is currently being implemented. 
	i 	introduction 
this paper1 and its companion aaai1 paper lowry  
1a  present a framework for problem reformulation and algorithm synthesis. in this framework  both specifications and algorithms are viewed as theories  where an algorithm is a theory about a sequence of state changes. reformulation is viewed as a representation map between theories. the mathematics of theory mappings can be found in goguen's work on abstract model theory  goguen and burstall  1 . this paper explores reformulation as implementation maps between theories  while the aaai1 paper explores reformulation as instantiation maps between parameterized theories. 

   this paper describes work done at stanford university under darpa contract n1-c-1  and at the kestrel institute under onr contract n1-c-1. 
1 	reasoning 
     the overall framework is presented in the diagram above. first  strata abstracts the specification in order to remove superfluous distinctions that are found in the user's initial conceptualization of the problem. this step is explained in this paper. second  strata designs an abstract algorithm by instantiating algorithm schemas which are formalized as parameterized theories. this step is explained in the companion aaai1 paper  which illustrates the design step by using the parameterized theory of local search to derive the simplex algorithm. third strata implements the abstract algorithm using stepwise refinement. most work in automatic programming addresses this third step. 
     strata uses the rainbow directed inference system developed by douglas smith smith  1  for theorem proving and theorem generation. the third step of implementation is carried out by the refine tm  compiler  which embodies a decade's research in automatic programming done at the kestrel institute. 
the subject of this paper is specification abstraction. 
given a problem specification in a problem domain theory  
strata finds an equivalent problem specification in a more abstract problem domain theory. globally  the space of theories and implementation mappings form an associative directed multigraph  i.e. a category . there is no global abstraction ordering on theories. however  with respect to each input-output behavior  there is an abstraction ordering on theories. for this reason  this overall process is called behavioral abstraction. the mathematical foundations for the search space of behavioral abstraction is explained in section 1. 
     there are two cases to consider for behavioral abstraction. in the first case  the multigraph of theories and implementation mappings is predefined  and strata performs behavioral abstraction by proving behavioral theorems and applying inverse theory maps. a behavioral theorem is a sentence about an important problem property  and is used as an enabling condition for applying an inverse implementation map. an important subclass of behavioral theorems are behavioral equivalences  that is two objects which behave equivalently with respect to the input-output 
relation. 
     when strata generates a behavioral theorem which does not correspond to a predefined inverse implementation map  then strata generates a new  more abstract 
     
theory and the implementation map between this new theory and the original theory. this new theory results from incorporating the behavioral theorem into the language and axioms of the new theory. when the behavioral theorem is a behavioral equivalence  generating the new theory is called behavioral congruence. behavioral congruence is the main technical result of this paper. 
the method of behavioral abstraction is given below: 
1. behavioral theorems: find important problem properties. 
1. is the behavioral theorem an enabling condition for applying a predefined inverse implementation map  
1. yes - apply the inverse implementation map to obtain a logically equivalent problem specification in a more abstract theory. 
1. no - generate the theory which incorporates the behavioral theorem. for the case of behavioral equivalences  this is called behavioral congruence. go to step 1. 
     the rest of this paper describes the methods used by strata to abstract a problem definition into an equivalent abstract reformulation that incorporates constraints of the io-relation. section 1 describes the abstraction hierarchy which is searched by behavioral abstraction. in section 1 a simple combinatorial example is introduced to illustrate the abstraction methods. section 1 describes behavioral equivalence. section 1 defines the method of behavioral abstraction. section 1 and 1 contain the main results of behavioral congruence  which is a method for turning a behavioral equivalence in a theory into an equality in a more abstract theory. only when behavior ally equivalent objects are made identical has the equivalence been incorporated into a new representation. 
     the pioneering work of amarel amarel  1  1 years ago showed the potential power of reformulation. about 1  a number of people began investigating methods for searching the space of logically equivalent problem reformulations. the abstraction space formalized in this model is similar to the homomorphic reformulations described in  korf  1 . another type of search heuristic is to find problem reformulations targeted to a particular problem solving schema such as divide and conquer smith  1   or heuristic search mostow  1 . in  lowry  1a   problem solving schemas are formalized as parameterized theories  and hence generalizes the work cited above. in the literature on abstract data types   goguen and meseguer  1  it has been shown that abstraction implementation commutes with problem solving schema instantiation. 
ii mathematics of the abstraction space 
     this section describes the mathematics of behavioral abstraction from a model theoretic viewpoint in order to understand the behavioral abstraction search space. the model theoretic viewpoint is closely related to the mathematics for the implementation relationship described in  goguen et o/.  1 . 
     the basic idea behind reformulation is that the class of models for the original problem formulation is isomorphic to the class of models for the reformulated problem definition. this key idea is extended for behavioral abstraction to allow merging models of the concrete theory which are identical with respect to the io-behavior. this merging comes in two flavors. first  a derivor forgets some of the relations and functions which are not directly of interest. for example  the io-derivor forgets everything except the input/output relation. this is in part how the most abstract problem formulation will be defined. the second flavor of merging is through equivalences. this is the main subject of this paper. objects which behave equivalently with respect to the io-relation are merged together into an identity. 
     the most abstract class of models for a given problem formulation is obtained by first forgetting everything except the io-relation  or io-relations/functions if there is more than one   and then identifying all objects which behave equivalently. this most abstract class is the top of a lattice structure whose bottom is the original problem formulation. some of the points in this lattice will not have finite axiomatizations  because taking a derivor does not necessarily preserve finite axiomatizability. 
     the space of tractable problem abstractions  corresponding to the classes of models which have finite axiomatizations  have a semi-lattice structure with the original problem formulation at the bottom.  lowry  1b  describes this structure in more detail. the objective of behavioral abstraction is to move upwards in this space of tractable problem abstractions. the diagram below shows the space of abstract problem reformulations  the circles denote tractable abstractions. the space of implementations is obtained by unwinding the multigraph of implementations. 

     
     the definition of an implementation link is as a representation map from an abstract theory to a concrete theory  with an abstraction function for mapping concrete ob-
jects to abstract objects. the diagram below shows an implementation link between bags and lists  where the abstract theory of bags and the concrete theories of lists are axiomatized using equational logic. 

     in general there are many implementation links between two theories  going in both directions. it is assumed that a knowledge base has some of these implementation links predefined. subsequent sections show how to automatically use predefined implementation links for behavioral abstraction when they are available  and also to generate new implementation links when given a novel problem constraint. the next page has the equational theory for lists. the equational theory for bags is obtained by renaming append to bagunion and making it commutative. the equational theory for sets is obtained by renaming bagunion to set union and making it idempotent  a set unioned with itself yields the same set . a different equational theory for sets is obtained by renaming bagunion to symmetric-set-difference and making it self-conjugate  a set differenced with itself yields the null set . this demonstrate how adding an equality to a theory can generate an abstract theory. these theories will be used in the example. 
equational theory of lists 

	iii 	a simple example 
   this example will be used to illustrate the methods described in subsequent sections. start string 
operator 
	goal 	string 
     the arrow puzzle 1 is a state space search problem where the states are bit strings and the operators are bit strings which are applied by bit-wise xoring with a state to yield a new state. the input sort is a startstring goalstring pair  and the output sort is a list sequence  of operators. the input /output relation solve is defined as: solv e {startstring  goalstring}  oplist  = 
apply reduce xor oplist   	startstring  	= 	goalstring 
     reduce takes a binary operator and a list of arguments  iteratively applying the operator to the accumulated result and the next element of the list. apply takes an operator and bitwise xors it with a bitstring. reduce and apply are defined using conditional equations as follows: 
if list = null then reduce binop hst  = identity if list / null then 
reduce bmopjist  	= 	car list binopreduce binop cdr hst   
apply  operator  bit string  	- 	operator 	xorbitstrtng 
     the properties of xor  denoted  1   assumed to be defined in the knowledge base  are used to reformulate the problem: 
commutative 
associative 
identity 
selfconjugate 
     the commutativity and associativity of xor means that a list of operators can be arbitrarily re-ordered  which is used to lift the output sort from list of operators to bags of operators. an alternative representation for a bag is an exponential notation  which maps each operator into its number of occurrences in the bag. the self-conjugate property of xor means that applying an operator twice is equivalent to not applying it at all. in other words  only the even/odd parity of the number of operator occurrences is relevant. thus the exponential notation is collapsed to the characteristic function for a set by mapping the nat-
     
1 	reasoning 
     
ural numbers to mod1. similarly  startstring goalstring pairs can be collapsed into a single bit-string by xoring them together. this single bit-string represents the class of startstring goalstring pairs that have the same solutions. the following transformations illustrate these abstractions: 
lists to bags 
exponents 
     
bags 
　　note that certain choices of operators might not span the space of all possible start string goalstring pairs. the search will not terminate unless the search space can be made finite. there are an infinite number of possible operator lists and operator bags. however  there are only a finite  but exponential  number of operator sets; thus the search is guaranteed to terminate for the abstract problem reformulation. 
iv 	behavioral equivalence theorems 
　　the first step in behavioral abstraction is to find a problem property which will then be incorporated in a 
　　new representation for the problem. behavioral equivalences are an important subclass of problem properties. two objects are behaviorally equivalent when they behave identically with respect to the 1 relation. in the schema given below  terms of the input sort are prefixed with /n  terms of the output sort are prefixed with out  and the 1 relation is designated r. the first schema is for input objects that behave identically  the second schema is for output objects that behave identically.1  the symbol =bth denotes equivalence with respect to the io-relation . 
behavioral equivalence schemas 

　　two general meta-level methods for generating behavioral equivalence theorems  the kernel method and the homomorphism method  are given in  lowry  1b . in universal algebra  the kernel of a function f whose domain is sort a and whose range is sort b is defined as the equivalence relation on a of elements which are mapped to the same element in b. a homomorphism is a function f from a to b that maps a function g on a to a function h on b. 
the kernel of g is mapped to the kernel of h  or a subset of the kernel of h . the generalization of homomorphism to many sorted logics can be found in  goguen ti a/.  1 . 
　　for the arrow puzzle  the kernel method yields a behavioral equivalence on the input sort  which is a startstring goalstring pair. the function xor maps a pair of bit-strings to a single bit-string. this defines an equivalence class on pairs of bit strings. the following behavioral equivalence theorem describes this equivalence class: 

　　for the arrow puzzle  the homomorphism method yields two behavioral equivalences on the output sort  which is a 

list of operators. the homomorphism function in this case is reduce  which maps a list of operators to a single bit string representing the composite operator. the homomorphism maps the properties of xor  particularly commutativity and self-conjugate  to behavioral equivalences of append: 

	v 	behavioral abstraction 
　　the basic idea of behavioral abstraction is to apply stepwise implementation in reverse. the representation map of an implementation link has all the primitive functions and relations of the abstract theory as its source and often derived functions and relations in the concrete theory as its target. stepwise implementation simply translates a complex relation in the abstract theory through the representation map to a complex relation in the concrete theory. in general  the representation map is only partially invertible  so a problem formulated in the concrete theory cannot always be simply mapped to the abstract theory. for example  in the bag theory to list theory representation map given in section 1  there is no inverse map for c a r or cdr. this is because c a r and c d r are non-determinate when applied to bags. 
　　when a problem formulated in the concrete theory is defined solely in terms of the image of a representation map  then the inverse map can be directly applied to derive an abstract problem reformulation. often  it is possible to prove that a problem has some abstract property which implies that it can be reformulated in a more abstract theory even though the problem definition is not in terms of the image of the appropriate representation map. in this case  it is necessary to derive an equivalent problem formulation stated in terms of the image of the representation map. this is in itself a reformulation or operationalization - the basic inference step is finding an equivalence. given this equivalent problem formulation and the appropriate predefined implementation link  by applying the inverse representation map the abstract problem reformulation is obtained. subsequent sections show how to generate a new implementation link when an appropriate one does not already exist in the knowledge base. 
abstracting through predefined implementation 
1. find properties of a problem. 
1. find an implementation link which uses some of these properties in the abstraction direction. 
1. find an equivalent problem formulation stated in terms of the image of the representation map. 
1. apply the inverse of the representation map to derive the abstract formulation. 
　　these steps are illustrated with the reformulation of the arrow puzzle from lists of operators to bags of operators. in step 1. the homomorphism method generates 
	lowry 	1 
several behavioral equivalence theorems including the comrautativity of append with respect to the 1-behavior  

　　in step 1. the knowledge base is searched for an appropriate implementation link which incorporates the problem constraint found in step 1. for behavioral equivalence constraints  this means finding an implementation link with an abstraction function whose kernel is a subset of the behavioral equivalences found in step 1. the abstraction function for the bag to list implementation that maps bagunion to append is: 
abs append  
　　since bagunion is append with commutativity  the kernel of the abstraction function contains the behavioral equivalence of commutativity of append. 
　　in step 1. the problem is reformulated to an expression in the target of the representation map. since cons is in the target whereas car and cdr are not  the car/cdr recursion which defines the reduce operator is replaced by an existential construction using cons: if list = null then reduce binoplist  = identity if list 
rcduct binop list  = x binop reduce binop  l  in step 1. this new problem formulation is mapped 
through the inverse implementation link: 
if bag = nullbag then reducebag  binop  bag  = identity if bag nullbag then addbag xyb  - bag and reduce binop bag  = x binop rtduct binop b  
solvebag {startstring. 	goalstring} opbag  	= apply rcducebag xoropbag   	start string  	= 	goalstring 
vi 	making the world safe for equality 
　　when a problem property does not correspond to a predefined implementation link  then for behavioral abstraction strata must generate a new representation theory which incorporates the property. from a mathematical viewpoint  the central issue*is how to turn an equivalence into an equality. in particular  a behavioral equivalence in the concrete theory is turned into an equality in the abstract theory. equal objects are identical - they can be freely substituted for each other everywhere. equivalent objects are not identical; by definition behaviorally equivalent objects can be substituted for each other in the io-relation  but not necessarily elsewhere. only when behaviorally equivalent objects are made identical has the equivalence been incorporated into a new representation. this is illustrated by the theories which are the abstract data types for lists  bags  and sets. 
　　in order to turn a behavioral equivalence into an equality  a new representation language is generated  so that behaviorally equivalent objects are freely substitutable. the requirement of free substitution is the constraint used in the generator of the new representation language. this section discusses some of the conceptual background needed 
1 	reasoning 
for generating the new representation language  further details can be found in  lowry  1b . a sort is protected against new congruences when a congruence would lead to identifying objects that are not behaviorally equivalent  a sort is separable into separate copies for different functions if the problem definition does not link the different functions. this is the basis of the splitting strategy. finally  a function is safe with respect to a behavioral equivalence if propagating the equiv-
alence through the function as an equality does not lead to defining new congruences on protected sorts. deleting unsafe functions is the basis of the protection strategy. 
definition: a sort is protected iff: 
case 1 it is in the input or output of the io-relation. 
case 1 it is a free parameter to the problem definition. 
　　in the arrow puzzle  the following sorts are protected by case 1: lists of operators  startstring goalstring pairs. case 1 protects the sort operators  because the arrow puzzle is defined with respect to any set of operators  bit strings which are xored with the states . the basic idea behind a protected sort is that no congruence can be defined on a protected sort unless it is a behavioral equivalence with respect to the io-relation. 
　　in general each sort is in the domain or range of many functions. congruences are propagated through sorts that are in the domain of a function to the sort which is the range of a function. this range sort is in turn the input to other functions  and in this way a congruence is propagated through the daisy chain of functions in the problem domain theory. however  only some of this daisy chaining is intrinsic to the axiomatization and definitions of the functions in the problem domain theory. this leads to the definition of a separable sort with respect to two functions: 
　　definition: a sort s is separable with respect to a function fl whose range is s and a function f1 which has an input argument of sort s iff fl does not appear as part of a term in an expression whose head is f1 in the definition of the problem domain theory. 
　　the intuition of this definition is that a separable sort can be split into two sorts  thus blocking the propagation of a congruence from fl to f1. another viewpoint is that sort s is separable if the problem domain theory could have been given with the output of fl being sort si and the input of f1 being a distinct sort s1  si equal s1  but si not eq s1 . the mathematical machinery for this viewpoint is described at length in  burstall and goguen  1  and  goguen and burstall  1 . definition: a function is safe iff: 
case 1 the range is the input or output sort of the iorelation. behaviorally equivalent inputs to the function result in behaviorally equivalent outputs. 
case 1 the range is not the input or output sort. behaviorally equivalent inputs have identical outputs. 
     
     car and cdr are not safe with respect to commutativity of append  because their respective output sorts  operators and list of operators  are protected. however  cons is safe because it is covered by case 1. 
	v i i 	behavioral congruence -
protection and splitting 
     the protection and splitting methods transform the language of the problem domain theory in minimal ways so that adding the behavioral equivalence theorem as a new equality preserves the problem semantics. the goal is to make the representation map as invertible as possible  so that the problem definition needs to be only minimally reformulated before being lifted to the new abstract problem domain theory. the protection method deletes functions whose range is a protected sort which are not safe. the splitting method makes copies of separable sorts so that functions which would not be safe after propagating the behavioral equivalence as a congruence become safe. 
     the protection method is illustrated above for the case of transforming the behavioral commutativity of append into an equality. in the diagram  sorts are represented by boxes  and functions are represented by ovals. the inputs and outputs of a function are represented by arrows leading from/to the appropriate sorts. the protected sorts are listofoperators and operators  labeled with a p. the sort listofoperators is used to define the behavioral equivalence theorems of commutativity and self-conjugate  any function which uses this sort as an input argument must be safe. the functions a p p e n d and cons are safe  and labeled with an s. in contrast the functions c a r and c d r are not safe and are surrounded by black to indicate that they are deleted by the protection method. the function makelist is safe because its input is the protected sort operators upon which no equality can be defined  as it is a free parameter. 
     to derive the abstract theory from the concrete theory of lists with the behavioral equivalence of commutativity of append  the protection method renames the behavioral sorts and the safe functions which reference them  copies the axioms and then adds the behavioral equivalence as an equality. the representation map takes a renamed function in the abstract theory into the corresponding function in the original theory. the protection method generates the theory of bags shown in section 1  along with the corresponding implementation link from bags to lists. note that behavioral abstraction must still be used to lift the problem definition solve into the new theory  as explained in section 1. 
     the protection method could be applied once again for the behavioral equivalence of self-conjugate of append. bag-union  previously append  becomes symmetric set difference. addbag  previously cons  is also transformed to xoradd  its new action is to delete an element if it already exists  otherwise it adds the element. 
   an alternative derivation path which uses the behavioral equivalence of self-conjugate of append is given by the splitting method. in this case  the theory of bags is first isomorphically transformed to exponential notation  as discussed in  lowry  1b . in this isomorphic theory given below  equality of bags is defined in terms of bag-member. bag-member is a function which takes an element and a bag and returns the number of occurrences of the element in the bag. 
i 
     in this new isomorphic representation  bag equality is defined with the sort natural numbers through the function bag-member. in the arrow puzzle  the natural numbers are used both as the range of bag-member and as an index into bit-strings. propagating the congruence of self-conjugate through the natural numbers causes them to collapse to mod1  isomorphic to the booleans . if this were then propagated to the index into bit-strings  it would cause a collapse of bit-strings into the even and odd indices. unlike the elements of operator-lists  which are protected  the natural numbers are not protected and can be split. this prevents the propagation of the congruence through the range of bag-member to the index of bit-strings. 
	lowry 	1 
     

     the splitting method is illustrated above  by the addition of the new sort natural numberst as the output of bagmember the output of bagmember is no longer the same sort as the input to indexstring the propagation of the behavioral equivalence of self-conjugate of bag-union through bag-member causes an additional axiom to be added to the sort natural numbers1  which results in a theory which is syntactically identical to the theory for mod1 or the booleans. the derivation below shows how the additional axiom which defines mod1  or the booleans  is obtained by propagating the behavioral equivalence through substitution: 
	bagunion 	  
	bagmcmber x  bagunion s  s   	= 
	bagmember x  	nullbag  
b agm ember  x s  + bagmember  

in the new theory bagunion becomes symmetric set difference and the behavioral equivalence of self-conjugate of bagunion becomes an equality. bagmember becomes setmember  and the sort naturalnumbers1 becomes the booleans through the addition of the equality 
	v i i i 	summary 
     a good representation incorporates the problem constraints. this paper has presented the abstraction implementation model of problem reformulation. the search space of abstract problem reformulations is formalized model theoretically as a lattice structure. behavioral abstraction is a general method for incorporating a problem constraint into an abstract problem reformulation  by reversing an implementation link. behavioral congruence is a method for generating new representations which incorporate behavioral equivalence constraints. the first step is to transform the representation language through protection and splitting so that all functions are safe. then the behavioral equivalence constraint is made into an equality  
1 	reasoning 
and propagated throughout the new representation language to generate new constraints. the kernel method and the homomorphism method are meta-level inference techniques for efficiently generating behavioral equivalence constraints. these methods are being implemented in an automatic programming system called strata. 
	ix 	acknowledgment 
     this paper benefitted from the technical and editing help provided by joseph goguen  laura jones  and douglas smith. discussions with the following people have also contributed to the development of these ideas: phil agre  tom binford  bruce buchanan  raul duran  mike genesereth  david macallester  patricia riddle  jeff schrager  david smith  steve tappel  and daniel weld. 
