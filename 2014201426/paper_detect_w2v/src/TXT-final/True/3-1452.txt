
current neural network learning algorithms are limited in their ability to model non-linear dynamical systems. most supervised gradient-based recurrent neural networks  rnns  suffer from a vanishing error signal that prevents learning from inputs far in the past. those that do not  still have problems when there are numerous local minima. we introduce a general framework for sequence learning  evolution of recurrent systems with linear outputs  evolino . evolino uses evolution to discover good rnn hidden node weights  while using methods such as linear regression or quadratic programming to compute optimal linear mappings from hidden state to output. using the long shortterm memory rnn architecture  the method is tested in three very different problem domains: 1  context-sensitive languages  1  multiple superimposed sine waves  and 1  the mackey-glass system. evolino performs exceptionally well across all tasks  where other methods show notable deficiencies in some.
1 introduction
real world non-lineardynamicalsystems are black-boxin nature: it is possible to observe their input/output behavior  but the internal mechanism that generates this behavior is often unknown. modeling such systems to accurately predict their behavior is a huge challenge with potentially far-reaching impact on areas as broad as speech processing/recognition  financial forecasting  and engineering.
¡¡artificial neural networks with feedback connections or recurrent neural networks  rnns;  werbos  1; robinson and fallside  1; williams and zipser  1   are an attractive formalism for non-linear modeling because of their ability  in principle  to approximate any dynamical system with arbitrary precision  siegelmann and sontag  1 . however  training rnns with standard gradient descent algorithms is only practical when a short time window  less than 1 time-steps  is sufficient to predict the correct system output. for longer temporal dependencies  the gradient vanishes as the error signal is propagated back through time so that network weights are never adjusted correctly to account for events far in the past  hochreiter et al.  1 .
¡¡echo state networks  esns;  jaeger  1a   deal with temporal dependencies by simply ignoring the gradients associated with hidden neurons. composed primarily of a large pool of neurons  typically hundreds or thousands  with fixed random weights  esns are trained by computing a set of weights analytically from the pool to the output units using fast  linear regression. the idea is that with so many random hidden units  the pool is capable of very rich dynamics that just need to be correctly  tapped  by adjusting the output weights. this simple approach is currently the title holder in the mackey-glass time-series benchmark  improving on the accuracy of all other methods by as much as three orders of magnitude  jaeger  1a .
¡¡the drawback of esns  of course  is that the only truly computationally powerful  nonlinear part of the net does not learn at all. this means that on some seemingly simple tasks  such as generating multiple superimposed sine waves  the method fails. according to our experience  it is also not able to solve a simple context-sensitive grammar task  gers and schmidhuber  1 . moreover  because esns use such a large number of processing units  they are prone to overfitting  i.e. poor generalization.
¡¡one method that adapts all weights and succeeds in using gradient information to learn long-term dependencies is long short-term memory  lstm;  hochreiter and schmidhuber  1; gers and schmidhuber  1  . lstm uses a specialized network architecture that includes linear memory cells that can sustain their activation indefinitely. the cells have input and output gates that learn to open and close at appropriate times either to let in new information from outside and change the state of the cell  or to let activation out to potentially affect other cells or the network's output. the cell structure enables lstm to use gradient descent to learn dependencies across almost arbitrarily long time spans. however  in cases where gradient information is of little use due to numerous local minima  lstm becomes less competitive.
¡¡an alternative approach to training rnns is neuroevolution  yao  1 . instead of using a single neural network  the space of network parameters is searched in parallel using the principle of natural selection. a population of chromosomes or strings encoding  for instance  network weight values and connectivity is evaluated on the problem  and each chromosome is awarded a fitness value that quantifies its relative performance. the more highly fit chromosomes are combined by exchanging substrings  crossover  and by randomly changing some values  mutation   producing new so-

figure 1: evolino network. a recurrent neural network receives sequential inputs u t  and produce the vector  ¦Õ1 ¦Õ1 ... ¦Õn  at every time step t. these values are linearly combined with the weight matrix w to yield the network's output vector y t . while the rnn is evolved  the output layer weights are computed using a fast  optimal method such as linear regression or quadratic programming.
lutions that hopefully improve upon the existing population. this approach has been very effective in solving continuous  partially observable reinforcement learning tasks where the gradient is not directly available  outperforming conventional methods  e.g. q-learning  sarsa  on several difficult learning benchmarks  moriarty and miikkulainen  1; gomez and miikkulainen  1 . however  neuroevolution is rarely used for supervised learning tasks such as time series prediction because it has difficulty fine-tuning solution parameters  e.g. network weights   and because of the prevailing maxim that gradient information should be used when it is available.
¡¡in this paper  we present a novel framework called evolution of recurrent systems with linear outputs  evolino  that combines elements of the three aforementioned methods  to address the disadvantages of each  extending ideas proposed for feedforward networks of radial basis functions  rbfs   maillard and gueriot  1 . applied to the lstm architecture  evolino can solve tasks that esns cannot  and achieves higher accuracy in certain continuous function generation tasks than conventional gradient descent rnns  including gradient-based lstm.
¡¡section 1 explains the basic concept of evolino and describes in detail the specific implementation used in this paper. section 1 presents our experiments using evolino in three different domains: context-sensitive grammars  continuous function generation  and the mackey-glass time-series. section 1 and 1 discuss the algorithm and the experimental results  and summarize our conclusions.
1 the evolino framework
evolino is a general framework for supervised sequence learning that combines neuroevolution  i.e. the evolution of neural networks  and analytical linear methods that are optimal in some sense  such as linear regression or quadratic programming. the underlyingprinciple of evolino is that often a linear model can account for a large number of properties of a problem. properties that require non-linearity and recurrence are then dealt with by evolution.
¡¡figure 1 illustrates the basic operation of an evolino network. the output of the network at time t  y t  ¡Ê rm  is computed by the following formulas:
¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡y t  = w¦Õ t  	 1  ¦Õ t  = f u t  u t   1  ... u 1     1  where ¦Õ t  ¡Ê rn is the output of a recurrent neural network f ¡¤   and w is a weight matrix. note that because the networks are recurrent  f ¡¤  is indeed a function of the entire input history  u t  u t 1  ... u 1 . in the case of maximum margin classification problems  vapnik  1  we may compute w by quadratic programming. in what follows  however  we focus on mean squared error minimization problems and compute w by linear regression.
¡¡in order to evolve an f ¡¤  that minimizes the error between y and the correct output  d  of the system being modeled  evolino does not specify a particular evolutionary algorithm  but rather only stipulates that networks be evaluated using the following two-phase procedure.
¡¡in the first phase  a training set of sequences obtained from the system  {ui di} i = 1..k  each of length li  is presented to the network. for each sequence ui  starting at time t = 1  each input pattern ui t  is successively propagated through the recurrent network to produce a vector of activations ¦Õi t  that is stored as a row in a n ¡Á pki li matrix ¦µ. associated with each ¦Õi t   is a target row vector di in d containing the correct output values for each time step. once all k sequences have been seen  the output weights w  the output layer in figure 1  are computed using linear regression from ¦µ to d. the column vectors in ¦µ  i.e. the values of each of the n outputs over the entire training set  form a non-orthogonal basis that is combined linearly by w to approximate d.
¡¡in the second phase  the training set is presented to the network again  but now the inputs are propagated through the recurrent network f ¡¤  and the newly computed output connections to produce predictions y t . the error in the prediction or the residual error is then used as the fitness measure to be minimized by evolution.
¡¡neuroevolutionis normally applied to reinforcementlearning tasks where correct network outputs  i.e. targets  are not known a priori. here we use neuroevolution for supervised learning to circumvent the problems of gradient-based approaches. in order to obtain the precision required for timeseries prediction  we do not try to evolve a network that makes predictions directly. instead  the network outputs a set of vectors that form a basis for linear regression. the intuition is that finding a sufficiently good basis is easier than trying to find a network that models the system accurately on its own.
¡¡in this study  evolino is instantiated using enforced subpopulations to evolve lstm networks. the next sections describe esp and lstm  and the details of how they are combined within the evolino framework.
1 enforced subpopulations
enforced subpopulations differs from standard neuroevolution methods in that instead of evolving complete networks  it coevolves separate subpopulations of network components or neurons  figure 1 . evolution in esp proceeds as follows:

figure 1: enforced subpopulations  esp . the population of neurons is segregated into subpopulations. networks are formed by randomly selecting one neuron from each subpopulation. a neuron accumulates a fitness score by adding the fitness of each network in which it participated. the best neurons within each subpopulation are mated to form new neurons. the network shown here is an lstm network with four memory cells  the triangular shapes .
1. initialization: the number of hidden units h in the networks that will be evolved is specified and a subpopulation of n neuron chromosomesis created for each hidden unit. each chromosome encodes a neuron's input  output  and recurrent connection weights with a string of random real numbers.
1. evaluation: a neuron is selected at random from eachof the h subpopulations  and combined to form a recurrent network. the network is evaluated on the task and awarded a fitness score. the score is added to the cumulative fitness of each neuron that participated in the network.
1. recombination: for each subpopulation the neurons areranked by fitness  and the top quartile is recombined using 1-point crossover and mutated using cauchy distributed noise to create new neurons that replace the lowest-ranking half of the subpopulation.
1. repeat the evaluation-recombination cycle until a sufficiently fit network is found.
¡¡esp searches the space of networks indirectly by sampling the possible networks that can be constructed from the subpopulations of neurons. network evaluations serve to provide a fitness statistic that is used to produce better neurons that can eventuallybe combinedto form a successful network. this cooperative coevolutionary approach is an extension to symbiotic  adaptive neuroevolution  sane;  moriarty and miikkulainen  1   which also evolves neurons  but in a single population. by using separate subpopulations  esp accelerates the specialization of neurons into different sub-

figure 1: long short-term memory. the figure shows an lstm memory cell. the cell has an internal state s together with a forget gate  gf  that determines how much the state is attenuated at each time step. the input gate  gi  controls access to the cell by the external inputs that are summed into the ¦² unit  and the output gate  go  controls when and how much the cell fires. small dark nodes represent the multiplication function.
functions needed to form good networks because members of different evolving sub-functiontypes are preventedfrom mating. subpopulations also reduce noise in the neuron fitness measure because each evolving neuron type is guaranteed to be represented in every network that is formed. this allows esp to evolve recurrent networks  where sane could not.
¡¡if the performance of esp does not improve for a predetermined number of generations  a technique called burst mutation is used. the idea of burst mutation is to search the space of modifications to the best solution found so far. when burst mutation is activated  the best neuron in each subpopulation is saved  the other neurons are deleted  and new neurons are created for each subpopulation by adding cauchy distributed noise to its saved neuron. evolution then resumes  but now searching in a neighborhood around the previous best solution. burst mutation injects new diversity into the subpopulations and allows esp to continue evolving after the initial subpopulations have converged.
1 long short-term memory
lstm is a recurrent neural network purposely designed to learn long-term dependencies via gradient descent. the unique feature of the lstm architecture is the memory cell that is capable of maintaining its activation indefinitely  figure 1 . memory cells consist of a linear unit which holds the state of the cell  and three gates that can open or close over time. the input gate  protects  a neuron from its input: only when the gate is open  can inputs affect the internal state of the neuron. the output gate lets the state out to other parts of the network  and the forget gate enables the state to  leak  activity when it is no longer useful.
the state of cell i is computed by: si t  = neti t giin t  + giforget t si t   1  	 1  where gin and gforget are the activation of the input and forget gates  respectively  and net is the weighted sum of the external inputs  indicated by the ¦²s in figure 1 :
	neti t  = h xwijcellcj t   1  + xwikcelluk t   	 1 
	j	k
where h is usually the identity function  and cj is the output of cell j:
             cj t  = tanh gjout t sj t  .  1  where gout is the output gate of cell j. the amount each gate gi of memory cell i is open or closed at time t is calculated by:
	gitype t  = ¦Ò xwijtypecj t   1  + xwiktypeuk t   	 1 
	j	k
where type can be input  output  or forget  and ¦Ò is the standard sigmoid function. the gates receive input from the output of other cells cj  and from the external inputs to the network.
1 combining esp with lstm in evolino
we apply our general evolino framework to the lstm architecture  using esp for evolution and regression for computing linear mappings from hidden state to outputs. esp coevolves subpopulations of memory cells instead of standard recurrent neurons  figure 1 . each chromosome is a string containing the external input weights and the input  output  and forget gate weights  for a total of 1    i + h  weights in each memory cell chromosome  where i is the number of external inputs and h is the number of memory cells in the network. there are four sets of i + h weights because the three gates  equation 1  and the cell itself  equation 1  receive input from outside the cell and the other cells. esp  as described in section 1  normally uses crossover to recombine neurons. however  for the present evolino variant  where fine local search is desirable  esp uses only mutation. the top quarter of the chromosomes in each subpopulation are duplicated and the copies are mutated by adding cauchy noise to all of their weight values.
¡¡the linear regression method used to compute the output weights  w in equation 1  is the moore-penrose pseudoinverse method  which is both fast and optimal in the sense that it minimizes the summed squared error  penrose  1 -compare  maillard and gueriot  1  for an application to feedforward rbf nets. the vector ¦Õ t  consists of both the cell outputs  ci  equation 1   and their internal states  si  equation 1   so that the pseudo-inversecomputes two connection weights for each memory cell. we refer to the connections from internal states to the output units as  output peephole  connections  since they peer into the interior of the cells.
¡¡for continuous function generation  backprojection  or teacher forcing in standard rnn terminology  is used where the predicted outputs are fed back as inputs in the next time step: ¦Õ t  = f u t  y t   1  u t   1  ... y 1  u 1  .
¡¡duringtraining  the correcttarget values are backprojected  in effect  clamping  the network's outputs to the right values. during testing  the network backprojects its own predictions. this technique is also used by esns  but whereas esns do not change the backprojection connection weights  evolino evolves them  treating them like any other input to the network. in the experiments described below  backprojection
training datagradient lstmevolino lstm1..1..1..1..1..1..1..1..1..1..1..1..1table 1: generalization results for the anbncn language. the table compares evolino-based lstm to gradient-based lstm. the left column shows the set of legal strings used to train each method. the other columns show the set of strings that each method was able to accept after training. the result for lstm with gradient descent are from  gers and schmidhuber  1 . averages of 1 runs.
was found useful for continuous function generation tasks  but interferes to some extent with performance in the discrete context-sensitive language task.
1 experimental results
experiments were carried out on three test problems: contextsensitive languages  multiple superimposed sine waves  and the mackey-glass time series. the first two were chosen to highlight evolino's ability to perform well in both discrete and continuous domains. for a more detailed description of setups used in these two problems  and further experiments  we direct the reader to  wierstra et al.  1 . the mackeyglass system was selected to compareevolino with esns  the reference method on this widely used time series benchmark.
1 context-sensitive grammars
learning to recognize context-sensitive languages is a difficult and often intractable problem for standard rnns because it can require unlimited memory. for instance  recognizing the language anbncn  i.e. strings where the number of as  bs  and cs is equal entails countingthe numberof consecutiveas  bs  and cs  and potentially having to remember these quantities until the whole string has been read. gradient-based lstm has previously been used to learn anbncn  so here we compare the results in  gers and schmidhuber  1  to those of evolino-based lstm.
¡¡four sets of 1 simulations were run each using a different training set of legal strings  {anbncn} n = 1..n  where n was 1  1  1  and 1. symbol strings were presented to the networks  one symbol at a time. the networks had 1 input units  one for each possible symbol: s for start  a  b  and c. an input is set to 1 when the corresponding symbol is observed  and -1 when it is not present. at every time step  the network predicts what symbols could come next  a  b  c  and the termination symbol t  by activating its 1 output units. an output unit is considered to be  on  if its activation is greater than 1.
¡¡esp evolved lstm networks with 1 memory cells  weights randomly initialized to values between  1 and 1. the cauchy noise parameter ¦Á for both mutation and burst mutation was set to 1  i.e. 1% of the mutations is kept within this bound. evolution was terminated after 1 generations  after which the best network in each simulation was tested.
¡¡the results are summarized in table 1. evolino-based lstm learns in approximately 1 minutes on average  but  more importantly  it is able to generalize substantially better than gradient-based lstm.

figure 1: performance of evolino on the triple superimposed sine wave task. the plot show the behavior of a typical network produced after 1 generations  1 evaluations . the first 1 steps  the data-points left of the vertical dashed line  were used as training data  the rest must be predicted by the network during testing. timesteps above 1 show the network predictions  dashed curve  during testing plotted against the correct system output  solid curve . the inset is a magnified detail that more clearly shows the two curves.
1 multiple superimposed sine waves
jaeger  jaeger  1b  reports that echo state networks are unable to learn functions composed of multiple superimposed oscillators. specifically  functions like sin 1x  + sin 1x   in which the individual sines have the same amplitude but their frequencies are not multiples of each other. esns have difficulty solving this problem because the dynamics of all the neurons in the esn  pool  are coupled  whereas truly solving the task requires an internal representation of multiple attractors due to the non-periodic behavior of the function.
¡¡we evolved networks with 1 memory cells to predict the aforementioned double sine  sin 1x  + sin 1x   and network with 1 cells for a more complex triple sine  sin 1x  + sin 1x  + sin 1x . evolino used the same parameter settings as in the previous section  except that backprojection was used  see section 1 . networks for both tasks were evolved for 1 generations to predict the first 1 time steps of each function  and then tested on data points from time-steps 1..1.
¡¡the average summed squared error over the training set was 1 for the double sine and 1 for the triple sine. the average error over the test set was 1 and 1  respectively. these error levels are barely visible out to time-step 1. figure 1 shows the behavior of one of the triple sine wave evolino networks out to time-step 1. the magnified inset illustrates how even beyond 1 times the length of the training set  the network still makes very accurate predictions.
1 mackey-glass time-series prediction
the mackey-glass system  mgs;  mackey and glass  1   is a standard benchmark for chaotic time series prediction. the system produces an irregular time series that is produced by the following differential equation: y¨b t  = ¦Áy t ¦Ó / 1+ y t   ¦Ó ¦Â    ¦Ãy t   where the parameters are usually set to ¦Á = 1 ¦Â = 1 ¦Ã = 1. the system is chaotic whenever the delay ¦Ó   1. we use the most common value for the delay ¦Ó = 1.
¡¡although the mgs can be modeled very accurately using feedforward networks with a time-window on the input  we compare evolino to esns  currently the best method for mgs  in this domain to show its capacity for making precise predictions. we used the same setup in our experiments as in  jaeger  1a . networks were trained on the first 1 time steps of the series using a  washout time  of 1 steps. during the washout time the vectors ¦Õ t  are not collected for calculating the pseudo-inverse.
¡¡we evolved networks with 1 memory cells for 1 generations  and a cauchy noise ¦Á of 1. a bias input of 1 was added to the network  and the backprojection values were scaled by a factor of 1. for testing  the outputs were clamped to the correct targets for the first 1 steps  after which the network backprojected its own prediction for the next 1 steps1. the cell input  equation 1  was squashed with the tanh function. the average nrmse1 for evolino with 1 cells over the 1 runs was 1¡Á1 compared to 1.1 for esns with 1 neurons  jaeger  1a . the evolino results are currently the second-best reported so far.
¡¡figure 1 shows the performance of an evolino network on the mg time-series with even fewer memory cells  after 1 generations. because this network has fewer parameters  it is unable to achieve the same precision as with 1 neurons  but it demonstrates how evolino can learn complex functions very quickly; in this case within approximately 1 minutes of cpu time.
1 discussion
the real strength of the evolino framework is its generality. across different classes of sequence prediction problems  it was able to compete with the best known methods and convincingly outperform them in several cases. in particular  it generalized much better than gradient-based lstm in the context-sensitive grammar task  and it solved the superimposed sine wave task  which esns cannot. these results suggest that evolino could be widely applicable to modeling complex processes that have both discrete and continuous properties  such as speech.
¡¡evolino avoids the problem of vanishing gradient and local minima normally associated with rnn training by searching the space of networks in parallel through evolution. furthermore  by using lstm memory cells  evolino searches in a weight space that is already biased toward extracting  retaining  and relating discrete events that may be very far apart in time. and  by borrowing the idea of linear regression from esns  evolino is capable of making very precise predictions in tasks like the mackey-glass benchmark.
¡¡apart from its versatility  another advantage of evolino over esns is that it produces more parsimonious solutions. esns have large pools of neurons that are more likely to overfit the data. evolino networks can be made much smaller and  therefore  potentially more general  less susceptible to noise  and more easily comprehensible by  for instance  rnn rule extraction techniques.
¡¡evolino is a template that can be instantiated by plugging in  1  alternative analytical methods for computing optimal linear mappings to the outputs  given the hidden state   1  different neuroevolution algorithms  and  1  various recurrent network architectures. in particular  our implementation used

figure 1: performance of evolino on the mackey-glass time-series. the plot shows both the mackey-glass system and the prediction made by a typical evolino-based lstm network evolved for 1 generations. the obvious difference between the system and the prediction during the first 1 steps is due to the washout time. the inset shows a magnification more clearly showing the deviation between the twocurves.
mean squarederrorand linearregression  but we couldas well use the maximum margin optimality criterion  vapnik  1  and use quadratic programming to find optimal linear mappings from hidden state to sequence classifications  obtaining a hitherto unknown species of sequential support vector machines.
¡¡we could also use neuroevolution methods that evolve network topology as well  so that network complexity is also determined through genetic search. other rnns  such as higher-order networks could be used instead of lstm. generalizations to nonlinear readout mechanisms  e.g.  nonlinear neural networks  with gradient-based search are obvious. we may also start training lstm by evolino  then fine-tune by traditional pure gradient search.
¡¡future work will further explore this space of possible implementations to provide potentially even more powerful predictors  classifiers  and sequence generators.
1 conclusion
we introduced evolution of recurrent systems with linear outputs  evolino   a general framework that combines evolution of recurrent neural networks and analytical linear methods to solve sequence learning tasks. the implementation of evolino in this paper combined the pseudo-inverse and enforced subpopulations algorithms to search a space of long-short term memory networks. this yielded a versatile method that can solve both tasks that require long-term memoryof discrete events such as context-sensitivelanguages and continuous time-series such as the mackey-glass benchmark and multiple superimposed sine waves.
acknowledgments
this research was partially funded by csem alpnach and the eu mindraces project  fp1.
