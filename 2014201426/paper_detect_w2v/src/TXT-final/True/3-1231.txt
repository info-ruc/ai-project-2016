
we give a clear picture of the tractability/intractability frontier for quantified constraint satisfaction problems  qcsps  under structural restrictions. on the negative side  we prove that checking qcsp satisfiability remains pspace-hard for all known structural properties more general than bounded treewidth and for the incomparable hypergraph acyclicity. moreover  if the domain is not fixed  the problem is pspace-hard even for tree-shaped constraint scopes. on the positive side  we identify relevant tractable classes  including qcsps with prefix    having bounded hypertree width  and qcsps with a bounded number of guards. the latter are solvable in polynomial time without any bound on domains or quantifier alternations.
1 introduction
quantified constraint satisfaction problems  qcsps  are a generalization of constraint satisfaction problems  csps   where variables may be existentially and universally quantified  and nested quantifications are allowed. this framework is clearly much more expressive than plain existential-csp  and may be fruitfully exploited for modeling a wide spectrum of problems from several domains.
¡¡a qcsp instance  or quantified constraint formula  ¦Õ is an expression of the form q1v¡¥1 ¡¤¡¤¡¤qmv¡¥m i  where i is a constraint network  denoted by cn ¦Õ    qi is a quantifier in
   and v¡¥i is a set of variables  for 1 ¡Ü i ¡Ü m. the string of quantifiers q1 ¡¤¡¤¡¤qm is called the prefix of ¦Õ. recall that a constraint network is a triple i =  var u¡¥ c   where var is a finite set of variables  u is the set of domains u v    for each variable v ¡Ê var  and c = {c1 c1 ... cq} is a finite set of constraints. a constraint ci =  si ri  consists of a list of variables si called constraint scope  and of a relation ri  called constraint relation  providing ci's allowed combinations of values for the variables in its scope. sometimes it is more comfortable to denote ci by its so called constraint atom ri si . then  the network i may be represented by the conjunction of all its constraint atoms. for simplicity  we limit our attention here to closed quantified constraint formulas  where all variables occurring in i are quantified. however  all our results may be easily extended to formulas with free variables.
¡¡as an example  consider the following quantified e y z  ¡Ä f r p v   ¡Ä g x y  . this formula is a qcsp instance  whose constraint network cn ¦Õe  is represented by the constraint atoms occurring in the conjunction. the quantifier prefix  short: prefix  of ¦Õe is the string    .
¡¡not surprisingly  the increased expressive power of qcsps comes at a cost. indeed  while deciding the satisfiability of traditional  i.e.  purely existential  csps is np-complete  this problem is pspace-complete  borner et al.  1   in the general quantified setting. hence  much effort has been spent to identify tractable classes of qcsps.
¡¡these approaches can be divided into two main groups: techniques that identify tractable classes of qcsps by exploiting particular properties of constraint relations  and techniques that identify tractable classes by exploiting the structure of constraint scopes  usually known as structural decomposition methods. while several deep results have been already achieved by techniques in the former group  see  e.g.   borner et al.  1; bulatov et al.  1; bunind et al.  1; chen  1a; creignou et al.  1; jeavons et al.  1    only a few papers focused on structural decomposition methods  though they were proven to be useful in the non-quantified setting  see  e.g.   dechter  1; gottlob et al.  1  .
recall that the structure of constraint network i is best rep-
v	and	|	  and
denotes the set of variables in the scope s of constraint c. some graph-based techniques are based on the primal graph g h i   =  v e  of h i   where two variables are connected in e if they occur together in some hyperedge  i.e.  in the scope of some constraint .
¡¡chen recently presented an interesting result about structurally tractable qcsps  chen  1b . he describes a
polynomial-time algorithm for classes of qcsps having  primal graphs with  bounded treewidth  fixed domain  and fixed prefix. in fact  the complexity of this algorithm depends dramatically on the number of quantifier alternations and on the size of the largest variable domain. as noted in  chen  1b   the same result has been independently derived by  feder and kolaitis  1   by exploiting courcelle's theorem about monadic second order logic on bounded treewidth structures.
¡¡notice that there is no indication that these results are optimal  and in fact several interesting questions arose  and will be the subject of this paper:
¡¡ 1  are qcsps having bounded treewidth tractable if domains are not fixed 
¡¡ 1  may we extend this result to other structural notions  possibly more general than bounded treewidth 
¡¡ 1  are there different kind of restrictions on quantified constraint formulas that make qcsps tractable 
¡¡the answers to these questions comprise both good news and bad news. we prove strong hardness results  but we also identify new tractable classes of qcsps  having neither fixed bound on domains nor fixed bound on quantifier alternations. our main contributions  shown in figure 1  are the following:  we prove that  without the fixed domain restriction  even qcsp instances whose structure is a tree and whose prefix is    are co-np-hard. moreover  adding further alternations we get complete problems for all levels of the polynomial hierarchy. it follows that this problem is pspace-complete if there are no bounds on the quantifier prefix.
 on the positive side  we prove that  if the prefix is     or some substring of it   then solving acyclic qcsps is feasible in logcfl and hence in polynomial time. moreover  this tractability extends to all known generalizations of acyclicity  and in particular to bounded hypertree-width qcsps  gottlob et al.  1 .
 we prove that  for fixed domains  the tractability result for bounded treewidth is almost optimal. indeed  solving qcsps over the binary domain {1} remains pspacecomplete even if the structure is an acyclic hypergraph  whose incidence graph has bounded treewidth  and whose primal graph has small  i.e.  logarithmic  treewidth.
 all these results show that traditional structural techniques do not help very much  but for some simple cases and with limited quantification. indeed  our hardness proofs show that the presence of quantifiers radically alters the structural properties of the constraint scopes. we thus realize that it is worthwhile taking into account how they interact with the scope structure  and in fact considering quantifiers as part of the scope structure itself. following this idea  we identify a different kind of restriction on quantified constraint formulas that ensure tractability and that is incomparable with the other structural classes. in particular  for any fixed k  we define the class k-gqcsp of k-guarded qcsps  that are solvable in polynomial time  without any restriction on domains or quantifier alternations.
1 quantified csps
let i =  var u c  be a constraint network. an assignment ¦Ò for a set of variables v¡¥   var is a function mapping each variable v ¡Ê v¡¥ onto its domain u v   ¡Ê u. if v¡¥ = var  ¦Ò is said complete  otherwise it is a partial assignment. we say that a complete assignment ¦Ò satisfies i  denoted by ¦Ò |= i 

¡¡figure 1: structural restrictions and  in tractable qcsps. if for each constraint  si ri  ¡Ê c  ¦Ò si  ¡Ê ri. an extension  to a set is an assignment such that ¦Ò  v   = ¦Ò v   for each v ¡Ê v¡¥. we denote by  the set of all the extensions of. for the trivial assignment ¦Ò for the empty set of variables  extis clearly the
¡¡  set of all assignments for.
let ¦Õ : q1v¡¥1v¡¥1v¡¥1 ...qmv¡¥m i be a qcsp instance 
mqand letany function  s  ¦Ò1 be the trivial assignments such that  for each pair¦Òq . ai ¦Òi strategyext1  with ¦Òi 1for v¡Ü¡¥i¦Õ ¡¥i  ifi¡Üis  
 qi ¦Òi
i =   or the whole set of possible extensions 1  is either one assignment in	ext ¦Òi 1 v
if qi =  . a complete assignment ¦Òm is derivable from a strategy¡Ês if there are qi ¦Òi 1m   for any  1 assignments1 ¡Ü i ¡Ü¦Ò1m ... ¦Ò. then m 1ssuchis a that ¦Òi s
solution for ¦Õ if all derivable assignments satisfy i. a qcsp instance is satisfiable iff it has a solution.
¡¡it is worthwhile noting that  in the definition of qcsps  different variables have different domains  in general. this is especially useful in the quantified setting. however  in the literature  qcsps are sometimes defined over a unique domain u or  equivalently  with the same domain u v   for each variable v . we say that such qcsps are untyped  in contrast to the general ones  called typed. the following proposition shows that the two formalisms are in fact logically equivalent.
proposition 1 for any qcsp instance ¦Õ  there exists an untyped equivalent instance ¦Õ. moreover  if cn ¦Õ  is a binary network  ¦Õ can be computed in polynomial time.
¡¡notice that going from typed to untyped instances may be exponential for non-binary networks  as the former setting allows more succinct and efficient representations.
¡¡we remark that all complexity results in this paper hold for both settings. indeed  we prove membership results and provide algorithms for the general typed setting  and prove hardness results by using either binary networks  or a unique binary domain for all variables.
¡¡we say that a class s of hypergraphs has the bounded hypertree width property  denoted by bhtw  if there is a k   1 such that every hypergraph in s has hypertree width at most k  gottlob et al.  1 . similarly  we define the property btw  meaning bounded treewidth  robertson and seymous  1  of the primal graph  of the constraint hypergraph   and the property bitw  meaning bounded treewidth of the incidence graph. moreover  we say that a class s of hypergraphs has the small hypertree width property  denoted by shtw  if the hypertree width of every hypergraph h ¡Ê s is at most log|h|. the small treewidth property stw of primal graphs is defined similarly. we also consider the property acyclic  resp.  trees  of any class of acyclic hypergraphs  resp.  primal graphs .
¡¡we study how the complexity of qcsps change as a function of quantifier alternations and of constraint structures. moreover  we distinguish the case of arbitrary domains  denoted by any  and of binary domains  denoted by {1}.
¡¡let q¡¥ be a string of quantifier alternations  s a hypergraphs property  and d a domain property in {any {1}}. then  qcsp q ¡¥ s d  is the problem of deciding whether an instance ¦Õ ¡Ê class q ¡¥ s d  is satisfiable  where class q ¡¥ s d  is any class of qcsp instances over domains of kind d  with alternation prefix q¡¥  and whose associated hypergraphs have property s.
1 structural methods do not help very much
1 some tractable instances
from	 gottlob	et	al. 	1  	we	already	know	that
qcsp   bhtw any  is in polynomial time  and the same holds for any structural restriction stronger than bounded hypertree-width. moreover  it is easy to see that qcsp   bhtw any  is even easier. we next show that also qcsp    bhtw any  is tractable.
¡¡let ¦Õ be a qcsp instance  i =  var u c  the constraint network of ¦Õ  and y¡¥ be a set of universally quantified variables. let a constraint of i over variable sets ¡¥ and  where is the set of y¡¥ variables occurring in the scope of r. denote by cart the relation containing all combination of values from the domains of variables in 
i.e.  cart.
¡¡then  define y¡¥-red r  as the relation containing all and only those tuples t of relation r such that  for any combination t of values for variables  . note that  for the special case  we get y¡¥-red r  = r; for the special case  we simply require all combinations of values for  that is  y¡¥-red r  = r  if r is precisely cart  otherwise it is the empty relation.
¡¡denote by y¡¥-red ¦Õ  the qcsp obtained from ¦Õ by replacing each constraint relation r by y¡¥-red r .
lemma 1 for any qcsp ¦Õ and set of universally quantified variables y¡¥  y¡¥-red ¦Õ  can be computed in logspace.
¡¡after the above lemma and exploiting the fact that no useful assignment is lost with this transformation  we can show the following.
theorem 1 qcsp    bhtw any  is in polynomial time. moreover  it is logcfl-complete  and hence tractable and parallelizable.
1 encoding boolean formulas as acyclic qcsps
to any cnf formula ¦µ = c1¡Ä...¡Äcm over boolean variables v¡¥ = {v1 ... vn}  we associate a binary acyclic constraint network i ¦µ  =  var u c  . this constraint network will be used hereafter for characterizing the complexity of acyclic and quasi-acyclic quantified csps.

figure 1: constraint network i ¦µ ¡¥ in theorem 1. in the right-bottom box  encodings of constraints in theorem 1.
¡¡consider the following cnf formula  that we use as a running example: ¦µ =  ¡¥ v1 ¡Åv1 ¡Åv1 ¡Ä v1 ¡Å v1 ¡Ä v1 ¡Åv1 ¡Å v1  ¡Ä  v1 ¡Å v1 . then  figure 1 shows the constraint structure  i.e. the constraint hypergraph  of i ¦µ ¡¥ . note that in this case hypergraph and primal graph representations coincide  as cn ¦µ ¡¥ contains only binary constraints. the set of variables var is the union of a set of clause variables c¡¥ = {cj | 1 ¡Ü j ¡Ü m} corresponding to the m clauses of ¦µ  of a set b¡¥ = {bi | vi ¡Ê v¡¥}  corresponding n	  and of two sets j  m   and i   n  
1} of special variables  called clause selectors and variable selectors  respectively.
¡¡for a variable vi of ¦µ  the domain of i ¦µ  contains literal constants vi and  vi associated with its truth-values. moreover  for any clause cj in which vi occurs  the domain of i ¦µ  contains a literal constant in {vij  vij} encoding the truth value for vi that makes cj true. we denote by li  resp.  lij  any of these  positive or negative  literals  and by  li  resp.   lij  its complement. moreover  we denote by satlit cj  the set of literals that make cj true. e.g.  for c1 =  v1 ¡Å  v1  in ¦µ¡¥  satlit c1  = {v1  v1}.
¡¡in more detail  the domains of i ¦µ  variables are the following: for any variable cj  corresponding to clause cj of ¦µ   u cj  = satlit cj ; for any boolean variable bi 
u bi  = {vi  vi}; for any clause-selector sjc  u sjc  =
; finally  for any variable-selector siv  u siv  =
.
¡¡intuitively  boolean variables encode a truth-value assignment to ¦µ  whereas any clause variable cj chooses some literal in satlit cj  that satisfies it. any selector variable may take a value coming from either variable connected to it. thus  any choice of all variable selectors corresponds to the propagation of a literal value li coming from some boolean variable bi in the left branch. similarly  any choice of clause selectors corresponds to the propagation in the right branch of some literal lkj satisfying some clause cj. if for all possible propagations from both branches  no pair li  lij of complementary literals meets at the topmost constraint of the network  then the values of boolean variables encode a satisfying truth-value assignment for ¦µ. we next describe the constraints in c that implement the above idea  where the indices  actually are values in the interval  1...n  and where
the indices j j are values in  1...m .
  the topmost constraint   called evaluate  has a constraint relation consisting of { li  lij  | lij ¡Ê satlit cj }. note that evaluate is satisfied only by assignments where its variables take complementary literals.
  for any constraint  siv bi  between a variable-selector siv and a boolean variable bi  its constraint relation consists of the tuples:.
  for any constraint between a pair of adjacent variableselectors  and for the constraint  siv bn  with
  the constraint relation is 
.
  for any constraint  sjc cj  between a clause-selector sjc and a clause variable cj  its constraint relation consists of the tuples:  lhj ¡Ê satlit.
  for any constraint between a pair of adjacent clauseselectors  and for the constraint  sjc cm  with j = m   1  the constraint relation consists of the tuples:  satlit satlitsatlit.
¡¡if ¦Ì is a truth-value assignment for all variables v¡¥ of ¦µ  then  ¦Ò¦Ì  denotes the assignment such that ¦Ò¦Ì bi  = vi if ¦Ì vi  = true  and ¦Ò¦Ì bi  =  vi if ¦Ì vi  = false.
lemma 1 let ¦Ì be a truth-value assignment for all variables v¡¥ of ¦µ and ¦Ò¦Ì the corresponding assignment for b¡¥. then  ¦Ì is a satisfying assignment for ¦µ if and only if there exists an assignment such that  for every  holds.
¡¡after this lemma  we immediately get that  even for acyclic binary constraint networks with just two quantifier alternations  solving a quantified csp is intractable.
theorem 1 qcsp    trees any  is co-np-hard. proof. from a cnf boolean formula ¦µ  we build in polynomial time qc ¦µ  =  b ¡¥ c¡¥  s i¡¥  ¦µ   where i ¦µ  is the acyclic constraint network associated with ¦µ. from lemma 1  satisfying assignments for ¦µ are in one-to-one correspondence with assignments to the variables in b¡¥ and c¡¥ such that all their complete extensions do not satisfy i ¦µ . thus  ¦µ is not satisfiable iff qc ¦µ  is satisfiable. 
1 intractable acyclic instances
after having shown in the previous section the tractability for    and the intractability for     we now settle the complexity of acyclic qcsps with arbitrary quantifier prefixes. theorem 1 for any natural number m ¡Ý 1 
1. qcsp     m  bhtw -complete  and hardness holds for qcsp     m trees   any   too;
1. qcsp     m   bhtw any  is -complete  and hardness holds for qcsp     m  trees any   too.
proof. for space limitations we only prove hardness for point 1  here. for any m ¡Ý 1  consider the -complete problem of deciding whether a quantified boolean formula  is satisfiable  where ¦µ is in cnf. from this formula  we build in polynomial time the following instance of qcsp     m  trees   b1 b1 ¡¤¡¤¡¤ b1m c¡¥  s i¡¥  ¦µ . from lemma 1  it can be seen easily that ¦· is satisfiable iff is satisfiable.
¡¡membership. the proof is by induction. first observe that  given any instance q =  v¡¥1 v¡¥1¦Õ of qcsp    bhtw any   its complementary problem qc  deciding whether for all assignment ¦Ò to v¡¥1 there exists an extension to v¡¥1 that does not satisfy ¦Õ  is in logcfl and hence in polynomial time  by theorem 1 and the fact that logcfl is closed under complementation. then  we prove the basis of the induction  m = 1. the problem qcsp     bhtw any  is in ¦°p1 = co-np. indeed  let q =  v¡¥1 v¡¥1 v¡¥1¦Õ be any instance of this problem. then  its complement can be decided in np: guess an assignment ¦Ò to v¡¥1 and check that for all assignment there is a complete assignment ext that does not satisfy all the constraints in ¦Õ. from the observation above  this check is feasible in polynomial time. moreover  qcsp      bhtw any    as any instance of this problem may be solved by a non-deterministic turing machine with an oracle for qcsp     bhtw any . the induction step is a simple adaptation of the above reasoning for any m   1. 
corollary 1 the quantified constraint satisfaction problem  on arbitrary domain  is pspace-complete  even if restricted on constraint networks whose structure is a tree.
1 fixed domain helps only with fixed arity
we now show that hypergraph acyclicity does not help in making easy the qcsp problem  even if we consider boolean domains only. the same holds even in case we additionally require that the incidence graph has bounded treewidth  and the primal graph has small  logarithmic  treewidth. this entails that the problem remains intractable as long as we have non-fixed arities  even for very simple constraint interactions.
theorem 1 for any natural number m ¡Ý 1 
  qcsp     m acyclic ¡É bitwcomplete;
  qcsp     m  acyclic ¡É bitwcomplete.
proof. let ¦µ be a boolean formula  and i ¦µ  =  var u c  its associated acyclic constraint network. we consider the network  defined as follows. for each variable contains |u x | distinct variables x1 ... xlog|u x |  with domain  for each xi. for each constraint contains a constraint  whose constraint relation is such that  for each tuple contains the tuple  enc xi  enc yj    where the string of bits enc xi   resp. enc yj   is the binary encoding of domain value xi  resp. xj . the right-bottom box in figure 1 shows a portion of the constraint network associated to the formula ¦µ¡¥ of our running example. observe that the constraint networkacyclic ¡É bitw ¡É stw. indeed  the hypergraph associated to is acyclic  and the number of variables in each hyperedge is bounded by 1logc  where c is the size of largest domain over all the variables in var. therefore  the treewidth of the primal graph is at most 1logc. moreover  it is easy to check that the treewidth of the incidence graph of. finally  observe that there exists a one-to-one correspondence between assignments to variables in i ¦µ  and in  and thus the result immediately follows from theorem 1.	
corollary 1 the quantified constraint satisfaction problem is pspace-complete  even if restricted on boolean constraint networks whose structure is in acyclic ¡É bitw ¡É stw.
1 guarded formulas and tractable csps
in this section  we describe a wide class of quantified constraint formulas that are tractable  even if there is no constant bound on domain sizes or quantifier alternations. recall that any qcsp instance ¦Õ may be represented by a logical expression  as shown in section 1 for qcsp ¦Õe. technically  let us denote the pure logical formula of ¦Õ  without the encoding of relations  domains  etc.  by form ¦Õ .
¡¡following  kolaitis et al.  1   we denote by fo¡Ä + the fragment of first order sentences where arbitrary quantifications and conjunctions are allowed  but where negations and disjunctions are forbidden. they observed that the existential fragment  fo¡Ä + of fo¡Ä + has the same expressive power as the constraint satisfaction problems. by allowing any kind of quantifiers  this observation may be clearly extended to the connection between general fo¡Ä + formulas and quantified constraint formulas. notice that  in this more general setting  there are different equivalent logical representation of the same instance. for example  one may use parentheses for distinguishing subformulas and delimiting quantifier scopes. in this section  we represent qcsps by fo¡Ä + formulas that are not necessarily in the traditional prenex form. notice  however  that each fo¡Ä + formula can be easily transformed into an equivalent prenex formula.
1 the fragment k-gqcsp of k-guarded qcsps
we show that  for each constant k  a simple and appealing fragment of fo¡Ä + is decidable in polynomial time. since we have no bound on the number of variables in a formula  we assume w.l.o.g. that each variable is quantified over only once  i.e.  quantified variables are not reused. in the following  we denote by free ¦×  the free variables of a logical formula ¦×.
definition 1 the class k-gqcsp of k-guarded qcsps consists of those qcsps instances ¦Õ whose formula form ¦Õ  belongs to the fragment gfo k ¡Äof +fosuch that:¡Ä + defined as follows. g k is the smallest subset of
  every atom belongs to g k;
  then;
  let ¦Á1 ... ¦Ái be atoms  where i ¡Ü k  and let ¦× be a formula in g k. if the free variables free ¦×    var ¦Á1  ¡È ¡¤¡¤¡¤ ¡È var ¦Ái   then  for each tuple of variables y¡¥ and each quantifier q ¡Ê {   }  the formula belongs to. the set of atoms {¦Á1 ... ¦Ái} is referred to as the guard of ¦× and is denoted by.  example 1 consider again qcsp instance ¦Õe presented in the introduction  and the following equivalent instance  where form ¦Õe  is rewritten as
¦× =  s x y t r u p  a s x t r  ¡Ä b s y u p  ¡Ä
 v f r p v   ¡Ä  z   g x y   ¡Ä c t u z  ¡Ä
 w d w x z  ¡Ä e y z     
this is a 1-guarded constraint formula  i.e.  . the guard of formula ¦× is guard ¦×  = {a s x t r   b s y u p }. for the formulas ¦×1 =  v f r p v    ¦×1 =  z   g x y   ¡Ä c t u z  ¡Ä  w d w x z  ¡Ä e y z    and ¦×1 =  w d w x z   we have the following guards: guard ¦×1  = {f r p v  }  guard ¦×1  = {g x y   c t u z }  and guard ¦×1  = {d w x z }. 
   note that the above definition of k-guardedness is congenial to the specific syntax of quantified csps and differs from that of k-guarded first order logic  andreka et al.  1; gradel  1¡§  . in the standard formalisms of the guarded fragment gf of first order logic or of the k-guarded fragment gfk of first order logic  gottlob et al.  1   the guards of an existentially quantified subformula ¦× are added conjunctively to ¦×  guard ¦×  ¡Ä ¦×   just as for. however  the guards of a universal formula ¦× are added in form of an implication: guard ¦×  ¡ú ¦×. this is much more natural  since these logics have negation and guardedness needs to be correctly preserved under negations. for example  the negation of a guarded formula   y¡¥ g y¡¥  ¡Ä ¦× y¡¥   is logically equivalent to  y¡¥ g y¡¥  ¡ú  ¦× y¡¥  . since the logic fo¡Ä + of constraint formulas has conjunction  ¡Ä  as unique binary connective  it is syntactically impossible to express an implication guard ¦×  ¡ú ¦× in fo¡Ä +  in fact  this is also semantically impossible . on the other hand  since negation is missing in fo¡Ä +  no problems involving  wrong guards  can arise through negation when using the natural  but nonstandard  guards introduced for the above defined fragments  of fo¡Ä +.
¡¡for the k-guarded fragment gfk of first order logic  i.e.  for the standard k-guarded fragment  the following tractability result was shown in  gottlob et al.  1 :
proposition 1 the combined complexity of evaluating a gfk formula ¦Õ over a set of finite relations d is in o |¦Õ| ¡Á |d|k .
¡¡let us now show that also the class k-gqcsp of kguarded qcsps is tractable  notwithstanding the  nonstandard  guards for universally quantified subformulas.
lemma 1 there is an algorithm transform which for each qcsp ¦Õ ¡Ê k-gqcsp computes a pair  d ¦Õ   where d is a finite database and ¦Õ  ¡Ê gfk  such that ¦Õ is satisfied iff d |= ¦Õ . the transform algorithm runs in logspace.
proof. let ¦Õ ¡Ê k-gqcsp  and let r be the set of constraint relations of cn ¦Õ . consider a subformula
 y¡¥ guard ¦× ¡Ä¦×  of form ¦Õ   where  y¡¥ is a maximal prefix of universally quantified variables  and where guard ¦×  is a conjunction of m atoms ri y¡¥i x¡¥i   with 1 ¡Ü i ¡Ü m ¡Ü k  where y¡¥i are the variables in its scope included in y¡¥  and x¡¥i its other variables  hence x¡¥i ¡É y¡¥ =  . for 1 ¡Ü i ¡Ü m  we denote by ri¡ý the relation obtained from the constraint relation ri by keeping all y¡¥i-columns and projecting out all x¡¥i columns  i.e. .
¡¡assume that for some 1 ¡Ü i ¡Ü m  ri¡ý is not equal to the cartesian product cart y¡¥i  of y¡¥i domains. that is  ri¡ý does not consist of precisely all possible combinations of constants for all y¡¥ variables occurring in ri. then one tuple a¡¥ of such constants is not in ri ¡ý and thus the atom ri y¡¥i x¡¥i  cannot be satisfied for the substitution y¡¥i = ¡¥a. since ri occurs positively in ¦Õ  ¦Õ cannot be satisfied. the key observation is thus that  whenever ¦Õ is satisfied  for 1 ¡Ü i ¡Ü m  ri ¡ý must be equal to cart y¡¥i . algorithm transform starts by checking whether this is true. from lemma 1  this check can be implemented to run in logspace: just compute y¡¥-red ri ¡ý   and check that it is not empty. if this test fails for at least one guard relation ri  then transform outputs the formula false. otherwise  let g¦× be a new constraint atom with constraint scope y¡¥  whose relation is the join of the ri¡ý relations. now  consider the set of free variables x¡¥ = free.
  since ¦Õ is a k-guarded formula  there are at most k atoms in ¦Õ that cover x¡¥. let be a new constraint atom with constraint scope x¡¥  whose relation is the projection over x¡¥ of the join of these guard atoms. moreover  let g be a new constraint atom with constraint scope x¡¥ ¡È y¡¥  whose relation is the join of g¦× and  or just g¦×  if x¡¥ is empty . note that  since k is fixed  transform may compute g from its input ¦Õ in logspace. then  transform replaces our subformula by the equivalent subformula. note that this transformation does not change the set of free variables  as free free. thus  the set of atoms that cover these variables and acts as the guard of ¦× in form ¦Õ  will be the guard of ¦× in the new formula.
¡¡after having done this for all universal guarded subformulas  transform has generated a formula ¦Õ  ¡Ê gfk. let d the database consisting of all constraint relations of cn ¦Õ  plus all relations like g computed for modifying the universal quantifications. it can be seen that ¦Õ is satisfiable iff d |= ¦Õ . moreover  the entire algorithm runs in logspace. 
theorem 1 for each fixed k  the satisfiability of any qcsp in the class k-gqcsp can be checked in polynomial time. proof. follows from lemma 1 and proposition 1. 
1 extending the k-gqcsp fragment
when looking at the fragment k-gqcsp  and even more generally  at qcsps in which universal quantifiers appear  we observe that the expressive power of universal quantification is rather poor. in fact  as already observed in the proof of lemma 1  a subformula  y r¡¥  y  ¡¥ x¡¥  can only be true if the projection over y¡¥ of r is equal to the cartesian product cart y¡¥  representing the set of all tuples that can be composed from all possible domain elements from the respective domains. this is a rather stringent condition. on the other hand  by standard k-guards of the form  r1 ¡Ä r1 ¡Ä ¡¤¡¤¡¤ ¡Ä rm  ¡ú ¦×  we can express some other interesting properties. for example by standard guards  one may express an inclusion dependency stating that part of one constraint relation must be contained in another constraint relation. to add expressive power  we thus suggest to allow the use of standard guards together with conjunctively specified guards  for universally quantified subformulas . we thus define the fragment k-gqcsp+ just as k-gqcsp in definition 1 with the following addition: if the free variables free ¦×    var ¦Á1  ¡È ¡¤¡¤¡¤ ¡È var ¦Ái   then  for each tuple of
variables y¡¥ the formula belongs to.
¡¡after the results in section 1  it is easy to see that  for each fixed k  the satisfiability of any qcsp in the class k-gqcsp+ can be checked in polynomial time. moreover  we are able to show that k-gqcsp+ is strictly more expressive than k-gqcsp  for space reasons  we defer the proof to the full paper .
