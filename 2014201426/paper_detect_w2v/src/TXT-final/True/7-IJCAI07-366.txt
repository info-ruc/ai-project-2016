
some statistical software testing approaches rely on sampling the feasible paths in the control flow graph of the program; the difficulty comes from the tiny ratio of feasible paths. this paper presents an adaptive sampling mechanism called exist for exploration/exploitation inference for software testing  able to retrieve distinct feasible paths with high probability. exist proceeds by alternatively exploiting and updating a distribution on the set of program paths. an original representation of paths  accommodating long-range dependencies and data sparsity and based on extended parikh maps  is proposed. experimental validation on real-world and artificial problems demonstrates dramatic improvements compared to the state of the art.
1 introduction
computer science is becoming a new application domain for machine learning  ml   motivated by the increasing complexity of current systems  rish et al.  1 . ideally  systems should be able to automatically adapt  maintain and repair themselves; a first step to this end is to build self-aware systems  using ml to automatically model the system behaviour. along these lines  various ml approaches have been proposed for software testing  bre뫣h뫣elin et al.  1   software modeling  xiao et al.  1  and software debugging  zheng et al.  1 .
모in this paper  we revisit a statistical software testing  sst  approach presented in  denise et al.  1 . this approach is based on the uniform sampling of the paths in the control flow graph of the program; to each path  a test case exerting this path can be associated if the path is feasible. a problem with this approach is that the control flow graph provides an overly general description of the program; in some cases  and very often for large programs  the fraction of feasible paths is tiny  ranging in 1  1 .
모after a discriminant learning approach failed to characterise the set of feasible paths because of the tiny support of the target concept  a generative learning approach was proposed. this approach  called exist for exploration exploitation inference for software testing  is inspired by both estimation of distribution algorithms  edas   baluja and davies  1  and online learning  auer et al.  1; cesa-bianchi and lugosi  1 . exist proceeds by iteratively generating candidate paths based on the current distribution on the programpaths  and updating this distribution after the path has been labelled as feasible or infeasible. exist was made possible by the use of an original representation  extending the parikh map  hopcroft and ullman  1  and providing a powerful propositional description of long structured sequences  program paths . another original contribution  compared to on-line learning  cesa-bianchi and lugosi  1; kocsis and szepesva뫣ri  1  or reinforcement learning  is that our goal is to maximise the number of distinct feasible paths found along the process  as opposed to learning a concept or a fixed policy.
모the paper is organised as follows1. section 1 briefly reviews some work relevant to machine learning and software testing. section 1 introduces the formal background and prior knowledge related to the sst problem  and describes the extended parikh representation. section 1 gives an overview of the exist system. section 1 describes the experimental setting and goals  and reports on the empirical validation of the approach on real-world and artificial problems. the paper concludes with some perspectives for further research.
1 related work
interestingly  while program synthesis is among the grand goals of machine learning  the application of machine learning to software testing  st  has seldom been considered in the literature.
모ernst et al.  aim at detecting program invariants  through instrumenting the program at hand and searching for predetermined regularities  e.g. value ranges  in the traces.
모brehelin et al.  consider a deterministic test procedure  generating sequences of inputs for a pla device. an hmm is trained from these sequences and further used to generate new sequences  increasing the test coverage.
모in  vardhan et al.  1   the goal is to test a concurrent asynchronous program against user-supplied constraints  model checking . grammatical inference is used to characterise the paths relevant to the constraint checking.
모xiao et al.  aim at testing a game player  e.g. discovering the regions where the game is too easy/too difficult; they use active learning and rule learning to construct a model of the program. a more remotely related work presented by  zheng et al.  1   is actually concerned with software debugging and the identification of trace predicates related to the program misbehaviours.
모in  ernst et al.  1; vardhan et al.  1   ml is used to provide better input to st approaches; in  bre뫣h뫣elin et al.  1   ml is used as a post-processor of st. in  xiao et al.  1   ml directly provides a model of the black box program at hand; the test is done by manually inspecting this model.
1 prior knowledge and representation
after  denise et al.  1   the program being tested is represented from its control flow graph  fig. 1 .

figure 1: program fct1 includes 1 nodes and 1 edges.
모formally  the control flow graph is a finite state automaton  fsa  based on some finite alphabet   where  includes the program nodes  conditions  blocks of instructions   and the fsa specifies the transitions between the nodes. a program path is represented as a finite length string on   obtained by iteratively choosing a node among the successors of the current node until the final node noted vf is found.
모while the length of program paths is not upper bounded in the general case  for practical reasons coverage-based approaches to software testing consider program paths with bounded length t. classical results from labelled combinatorial structures  flajolet et al.  1  can thus be used to uniformly sample the set of program paths with length in  1 t .
모each path sample is provided to a constraint solver and labelled as feasible or infeasible  see  denise et al.  1  and references therein . the infeasibility of a given path arises if it violates some subtle dependencies between different parts of the program. some general patterns of infeasibility can be identified; due to space limitations  only two most general such patterns will be considered in the rest of the paper.
xor pattern when two nodes are correlated  for instance two if nodes based on an unchanged expression   then their successors are correlated in every feasible path  if the program path includes the then successor of the first if node  it must also include the then successor of the second if node . this pattern is referred to as xor pattern  expressing the  possibly long-range  relations between the fragments of the program paths.
loop n  pattern the number of times a loop is executed happens to be restricted by the semantics of the problem; e.g. when the problem involves 1 or 1 uranium beams to be controlled  the control procedure will be executed exactly 1 or 1 times  gouraud  1 . this pattern is referred to as loop n  pattern.
모let us assume that some initial set e of labelled paths is available  and consider the supervised learning problem defined from e = { si yi  si 뫍 쑚 yi 뫍 { 1 +1} i = 1... n}  where si is a path with length at most t and yi is 1 iff si is feasible.
모this learning problem presents some specificities. firstly  it does not involve noise  i.e. the oracle  constraint solver  does not make errors1. secondly  the complexity of the example space is huge with respect to the number of available examples. in most real-world problems   includes a few dozen symbols; a few hundred or thousand paths are available  each a few hundred symbols long. the number of available paths is limited by the labelling cost  i.e. the runtime of the constraint solver  on average a few seconds per program path . thirdly  the data distribution is severely imbalanced  infeasible paths outnumber the feasible ones by many orders of magnitude ; our attempts for increasing the number of feasible paths through active learning were unsuccessful  as could have been expected from  dasgupta  1 . lastly  the label of a path depends on its global structure; a markovian representation  e.g.  begleiter et al.  1   would require many more examples to identify the desired long-range dependencies between the transitions.
모for these reasons  a frugal propositional representation of strings inspired by parikh maps  hopcroft and ullman  1  was considered. for t = 1...t  let s t  denote the t-th symbol in s  set to value vf if the length of s is less than t.
  to each symbol v  is associated an integer attribute av; av s  is the number of occurrences of symbol v in path s.
  to the i-th occurrence of a symbol v  is associated a categorical attribute av i. attribute av i s  gives the next informative1 symbol following the i-th occurrence of symbol v in s  or vf if s contains less than i occurrences of v .
1 overview of exist
this section presents a new learning framework devised for sst  called exist for exploration vs exploitation inference for software testing.
1 position of the problem
while  denise et al.  1  proceeds by uniformly sampling the bounded length paths  the efficiency of the approach is limited by the  high  ratio of infeasible paths. our goal in the present paper will thus be to provide a sampling mechanism  exist  able to retrieve distinct feasible paths with high probability based on a set e of feasible/infeasible paths. e is initially set to a small set of labelled paths  and it is gradually enriched with the paths generated by exist and labelled by the constraint solver.
모this goal differs from that of active learning  aimed at retrieving the most informative examples  roy and mccallum  1 . active learning is primarily interested in sampling the frontier of the classes to be discriminated  whereas exist is interested in sampling the feasible class only. further  as already mentioned active learning is hindered by the imbalanced class distribution  dasgupta  1 .
모our goal can also be viewed in the perspective of importance sampling and estimation of distribution algorithms  edas; see e.g.  baluja and davies  1    aimed at identifying the optima of some fitness function. edas iteratively proceed by i  sampling the search space after the current distribution; ii  computing the fitness of the samples; iii  updating and biasing the distribution towards the samples with maximal fitness. the difference relates to the exploration vs exploitation trade-off; while edas are supposed to gradually switch to exploitation at some point  the distribution converges towards one or a few optima of the fitness function   the exist goal is to gather examples which are all different. in particular  after a feasible path has been generated  the algorithm must be prevented from generating it again.
모the approach can also be compared to on-line learning and the multi-armed bandit problem  where the gambler must choose the next machine to play based on the past selections and rewards  cesa-bianchi and lugosi  1; kocsis and szepesva뫣ri  1 . the difference similarly relates to the exploration/exploitation trade-off; while  cesabianchi and lugosi  1; kocsis and szepesva뫣ri  1  are interested in identifying and running the best policy  we must explicitly avoid repeating our past moves.
1 the search space
borrowing from edas the principle of incrementally exploiting and updating a distribution  exist builds a probabilistic model on top of the extended parikh map representation  section 1 . formally  the probability of generating a feasible path conditionally to events such as  w is the successor of the ith occurrence of v and w occurs at least j times   denoted ev i;w j  is estimated from the set e of feasible/infeasible paths currently available.
모these estimate probabilities are used to graduallyconstruct the current path s  iteratively selecting the successor w of the current symbol v  conditionally to the current number of occurrences of v and w in s.
모this formalism is meant to avoid the limitations of probabilistic fsas and variable order markov models  begleiter et al.  1 . actually  probabilistic fsas  and likewise simple markov models  cannot model the long range dependencies between transitions involved in the prior knowledge  section 1 . variable order markov models can accommodate such dependencies; however they are ill-suited to the sparsity of the initial data available. rather  the probabilistic parikh map can be viewed as a most simple case of probabilistic attribute-grammars  abney  1   where the attributes only take into account the number of occurrences of the symbols.
모finally  the exist system involves two modules: i  the init module determines how the conditional probabilities are estimated; ii  the decision module uses these probabilities to iteratively generate the candidate path. let us first describe the decision module.
1 decision module
let s denote the path under construction  initialised to the start symbol. let v denote the last node in s and let i be the total number of occurrences of v in s.
모the decision module aims at selecting the successor w of the last node in s. in order to do so  some additional information can be exploited  look-ahead : if the w symbol is selected  then the total number of w symbols in the final path will be at least the current number of occurrences of w in s  plus one; let jw denote this number.
모formally  the probability p s w  of generating a feasible path conditionally to event ev i;w jw  the number of occurrences of v is i and the number of occurrences of w is at least jw  is provided by the init module; p s w  is conventionally set to 1 if there is no path satisfying ev i;w jw.
모the selection of the next node w aims at maximising the probability of ultimately finding a new feasible path. three options have been considered:
  the simplest option is the greedy one  that selects the successor node w maximising p s w .
  the roulettewheel option stochastically selects node w with probability proportional to p s w .
  the bandist option follows the ucb1 algorithm  auer et al.  1 ; in the standard multi-armed bandit problem this algorithmis shown to achieve logarithmicregret  reward loss compared to the optimal unknown policy  with respect to the number of trials. bandist deterministically selects the node w maximising

is the total number of paths satisfying
	v i w jw and e s    =	w successor of v e s w .
1 the init module
the init module determines how the conditional probabilities used by the decision module are estimated.
모the baseline init option computes p s w  as the fraction of paths in e satisfying ev i w jw that are feasible. however  this option fails to guide exist efficiently due to the disjunctive nature of the target concept  section 1   as shown on the following toy problem.
모let us assume that a path is feasible iff the first and the third occurrences of symbol v are followed by the same symbol  s feasible iff av 1 s  = av 1 s  . let us further assume that e includes s1 = vwvxvw  s1 = vxvwvx and s1 = vxvwvw; s1 and s1 are feasible while s1 is infeasible. consider the current path s = vwvxv; the next step is to select the successor of the 1rd occurrence of v. it can be seen that p s w  = .1 while p s x  = 1.  as the first event  the 1rd occurrence of v is followed by w and there are at least 1 occurrences of w  is satisfied by s1 and s1 while the second event  the 1rd occurrence of v is followed by x and there are at least 1 occurrences of x  only covers s1.
모therefore  a seeded init option is devised to remedy the abovelimitation. the idea is to estimate p s w  from a subset of e  called seed set  including feasible paths belonging to one single conjunctive subconcept.
모a necessary condition for a set of positive examples  feasible paths  to represent a conjunctive sub-concept is that its least general generalisation1 be correct  i.e. it does not cover any negative example. in our toy example problem  the lgg of s1 and s1 is not correct as it covers s1.
seeded procedure
e+: set of feasible paths; e : set of infeasible paths
let e+ = {s1 ... sn} be randomly ordered
let e = {s1}; h1 = s1
for
if h is correct wrt e 
ht = h; e = e 뫋{st}
else ht = ht 1
end for
return efigure 1: construction of a seed set.
모seed sets are stochastically extracted from e using the seeded procedure  fig. 1  inspired by  torre  1 . at the initialisation  the set e+ of feasible paths is randomly ordered and the seed set e is set to the first path in e+. iteratively  one considers the current feasible path st and constructs its lgg h with the previously selected paths; if h is correct  i.e does not cover any infeasible paths with respect to the extended parikh map representation  st is added to e. by construction  if the set of infeasible paths is sufficiently representative  e will only include feasible paths belonging to a conjunctive concept  a single branch of the xors ; therefore the probabilities estimated from e will reflect the long range dependencies among the node transitions.
모the exploration strength of exist is enforced by using a restart mechanism to construct another seed set after a while  and by discounting the events related to feasible paths that have been found several times; see  baskiotis et al.  1  for more details.
1 experimental validation
this section describes the experimental setting used to validate exist; it reports on the empirical results and discusses the sensitivity of exist wrt the initial amount of labelled paths.
1 experimental setting and criteria
exist is first validated on the real-world fct1 problem  including 1 nodes and 1 edges  fig. 1 . the ratio of feasible paths is about 1 for a maximum path length t = 1.
모a stochastic problem generator has also been designed  baskiotis et al.  1  to fully assess the exist performances. due to space limitations  three series of results will be presented  related to representative easy    medium  and  hard  sst problems  where the ratio of feasible paths respectively ranges in  1 뫄 1 1  for the easy problems  in  1 1  for the medium problems  and in  1 1  for the hard problems. the number of nodes varies in  1  and the path length varies in  1 . only 1 exist variants will be considered  greedy and seededgreedy sg   seededroulettewheel srw   and finally bandist  bst  and seededbandist  sbst .
모for each exist variant and each problem  the reported result is the number of distinct feasible paths found out of 1 generated paths  averaged over 1 independent runs. the baseline  uniform sampling  approach  outperformed by several orders of magnitude  is omitted in the following.
1 results
for a better visualisation  the results obtained by each exist variant are displayed in parallel coordinates for easy  fig. 1   medium  fig. 1  and hard  fig. 1  problems  starting from a 1 feasible/1 infeasible training set. the average results and the standard deviation of all seeded variants are shown in table 1.
모the computational time ranges from 1 to 1 minutes on pc pentium 1 ghz depending on the problem and the variant considered  labelling cost non included .

figure 1: number of distinct feasible paths generated by exist out of 1 trials on easy problems  starting from 1 feasible/1 infeasible paths.
모in the considered range of problems  the best exist variant is seededgreedy. on easy problems  bandist and seededroulettewheel are efficient too  fig. 1 ; but their efficiency decreases as the ratio of feasible paths decreases.

figure 1: exist results on medium problems  with same setting as in fig. 1.

figure 1: exist results on hard problems  with same setting as in fig. 1.
모the seeded option is almost always beneficial  especially so when combined with the greedy and roulettewheel options  and when applied on hard problems. for hard problems  the feasible region is divided among many tiny conjunctive subconcepts. as the probabilities estimated from examples belonging to different subconcepts are misleading  they most often result in generating infeasible examples. usefully  the seeded option allows exist to generate infeasible paths which separate the feasible subconcepts. the seeded option is comparatively less beneficial for bandist than for the other options  as it increases the bandist bias toward exploration; unsurprisingly  exploration is poorly rewarded on hard problems.
모the comparative performance of greedy and bandist depends on the type of problem. on easy problems  bandist dominates greedy. the reverse is true on hard problems 
problemssgsbstsrwfct1  1  1  1easyart1  1  1  1art1  1  1  1art1  1  1  1mediumart1  1  1  1art1  1  1  1art1  1  1  1hardart1  1  1  1art1  1  1  1table 1: average number of paths and standard deviation of seeded variants of exist.
where bandist is dominated due to its exploration bias. note that both of bandist and greedy will explore a transition which has not yet been explored in the current feasible paths  p s w  = 1 when there are no paths satisfying the current event  section 1 . however  if this trial does not lead to a feasible path  greedy will never visit the transition again  while bandist may  and usually will  retry later on.
모note also that seededgreedy displays a significantly lower standard deviation than the other seeded variants  table 1 .
1 sensitivity wrt initial conditions
the usability of exist would be compromised if a large initial training set were necessary in order to get good results. therefore experiments with various numbers of initial feasible and infeasible paths  independently selected in 1 1  have been conducted  and the results obtained on a representative medium problem are displayed in fig. 1.

figure 1: sensitivity analysis. average exist results on some representative medium problem  depending on the number of initial feasible and infeasible paths.
모a first remark is that increasing the number of infeasible paths does not improve the results  everything else being equal. concretely  it makes almost no difference to provide the system with 1 or 1 infeasible paths besides 1 feasible paths. even more surprisingly  increasing the number of feasible paths rather degrades the results  the 1 curve is usually well below the 1 curve in fig. 1 .
모both remarks can be explained by modeling the seeded procedure  fig. 1  as a 1-state automaton. in each step t  the seeded procedure considers a feasible path st  and the resulting lgg is tested for correctness against the infeasible paths. if st belongs to the same subconcept as the previous feasible paths  state a   the lgg will be found correct  and the procedure returns to state a. otherwise  state b   the test against the infeasible paths might reject the lgg  there exists an infeasible path covered by the resulting lgg   st is rejected and the procedure returns to state a. otherwise  state c   there exists no infeasible path enforcing st rejection and preventing the overgeneralisation of the seed set. as the seed set will from now on contain examples from different subconcepts  state c is absorbing  the probabilities estimated from the seed set are misleading and will likely lead to generate infeasible paths.
모the number and quality of infeasible paths governs the transition from state b to either a  probability q  or c  probability 1   q . although q should exponentially increase wrt the number of infeasible paths  it turns out that initial infeasible paths are useless to detect incorrect lggs; actually  only infeasible paths sufficiently close  wrt the parikh representation  to the frontierof the subconceptsare useful. this remark explains why increasing the number of initial infeasible paths does not significantly help the generation process.
모on the other hand  the probability of ending up in the absorbing state c  failure  exponentially increases with the number of steps of the seeded procedure  i.e. the number of feasible paths  fig. 1 . only when sufficiently many and sufficiently relevant infeasible paths are available  is the wealth of feasible paths useful for the generation process.
모complementary experiments   baskiotis et al.  1   done with 1 feasible vs 1 infeasible paths show that i  the limitation related to the number of initial feasible examples can be overcome by limiting the number of feasible paths considered by the seeded procedure  e.g. considering only the first 1 feasible paths ; ii  in orderto be effective  an adaptive control of the seeded procedure is needed  depending on the disjunctivity of the target concept and the presence of  near-miss  infeasible paths in e.
1 conclusion and perspectives
the presented application of machine learning to software testing relies on an original representation of distributions on strings  coping with long-range dependencies and data sparsity. further research aims at a formal characterisation of the potentialities and limitations of this extended parikh representation  see also  clark et al.  1    in software testing and in other structured domains.
모the second contribution of the presented work is the seeded heuristics first proposed in  torre  1   used to extract relevant distributions from examples representing a variety of conjunctive subconcepts. this heuristics is combined with exploration vs exploitation strategies to construct a flexible sampling mechanism  able to retrieve distinct feasible paths with high probability.
모with respect to statistical software testing  the presented approach dramatically increases the ratio of  distinct  feasible paths generated  compared to the former uniform sampling approach  denise et al.  1 .
모further research aims at estimating the distribution of the feasible paths generated by exist  and providing pac estimates of the number of trials needed to reach the feasible paths  hitting time . in the longer run  the extension of this approach to related applications such as equivalence testers or reachability testers for huge automata  yannakakis  1  will be studied.
