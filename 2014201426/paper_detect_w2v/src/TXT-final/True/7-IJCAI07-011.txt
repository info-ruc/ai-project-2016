
essence is a new formal language for specifying combinatorial problems in a manner similar to natural rigorous specifications that use a mixture of natural language and discrete mathematics. essence provides a high level of abstraction  much of which is the consequence of the provision of decision variables whose values can be combinatorial objects  such as tuples  sets  multisets  relations  partitions and functions. essence also allows these combinatorial objects to be nested to arbitrary depth  thus providing  for example  sets of partitions  sets of sets of partitions  and so forth. therefore  a problem that requires finding a complex combinatorial object can be directly specified by using a decision variable whose type is precisely that combinatorial object.
1 introduction
this paper describes essence 1 a new language for specifying combinatorial  decision or optimisation  problems at a high level of abstraction. essence is the result of our attempt to design a formal language that enables abstract problem specifications that are similar to rigorous specifications that use a mixture of natural language and discrete mathematics  such as those catalogued by garey and johnson .
﹛essence is intended to be accessible to anyone with a background in discrete mathematics; no expertise in constraint programming should be needed. our working hypothesis has been that this could be achieved by modelling the language after the rigorous specifications that are naturally used to describe combinatorial problems rather than developing some form of logical language  such as z  spivey  1  or np-spec  cadoli et al.  1 . this has resulted in a language that  to a first approximation  is a constraint language  such as opl  van hentenryck  1   f  hnich  1  or esra  flener et al.  1   enhanced with features that greatly increase its level of abstraction. most importantly  as a combinatorial problem requires finding a certain type of combinatorial object  essence provides decision variables whose domain elements are combinatorial objects of that type and constraints that operate on that type. this enables problems to be stated directly and naturally; without the decision variables of the appropriate type the problem would have to be  modelled  by encoding the desired combinatorial object as a collection of constrained decision variables of some other type  such as integers.
﹛as our motivations - and hence our methodology and results - for developing essence differ greatly from those that have lead to the development of other constraint languages it is important to consider these carefully at the outset.
﹛our primary motivation comes from our ongoing study of the automation of constraint modelling. constraint modelling is the process of reducing a given problem to the finitedomain constraint satisfaction or optimisation problem  csp  in which all the domains and constraints are supported by the intended solver technology. in current practice  this process is conducted manually and unsystematically - that is  it is still an art. as current solvers provide decision variables whose domains contain atomic values or  sometimes  finite sets of atomic values  models must always be in terms of these. we call such variables atomic and atomic set variables  respectively. as an example  consider the social golfers problem  sgp   which requires partitioning a set of golfers into equalsized groups in each week of a tournament subject to a certain constraint. thus  the goal is to find a multiset of regular partitions1 that satisfies the constraint. a model for the sgp must therefore represent this multiset of regular partitions by a collection of constrained atomic or atomic set variables. there are at least 1 ways that this can be done  frisch et al.  1c . to automatically generate models for a problem  one must start with a formal specification of the problem and this specification must be sufficiently abstract that no modelling decisions have been made in constructing it. thus  the formal language for writing specifications must provide a level of abstraction above that at which modelling decisions are made. we refer to such a language as a problem specification language and distinguish it from modelling languages  whose purpose is to enable the specification of models. thus  designing a problem specification language is a prerequisite to studying automated modelling and the goal of this paper is to put forward a language that makes a large step towards satisfying this challenging prerequisite.
﹛another motivation for designing essence is that formal problem specifications could facilitate communication between humans better than the informal specifications that are currently used and further benefits could accrue from standardising a problem specification language. for example  the informal problem descriptions in the csplib problem library  http://csplib.org  could be replaced or supplemented by formal ones  but doing so requires the availability of a problem specification language as the founders of csplib insisted on describing problems rather than models. using formal specifications for human communication imposes the requirement that the language is natural - that is  it is similar to the manner in which people think of problems and the style in which they specify them informally. naturalness is also an important property for the input language of an an automated modelling system; one cannot claim to have an automated modelling system if using it requires a major translation of the problem into the system's input language. finally  expertise in constraint modelling or constraint solving should not be needed for writing a formal problem specification  be it for human communication or for input to an automated modelling system.
three primary objectives have driven the design of
essence. this section has discussed two: the language should be natural enough to be understood by someone with a background in discrete mathematics and it should provide a high level of abstraction. these two objectives are related; providing an appropriate level of abstraction is necessary to achieve naturalness. the third design objective is that problems specified in the language can be effectively mapped to csps. as an illustration  one consequence of this objective is that every decision variable in essence is associated with a finite domain.
﹛the remainder of this paper introduces essence and argues that it largely meets its design objectives. this paper does not present a formal syntax  this can be found at  york web  1   or a formal semantics  this can be found in  frisch et al.  1a  .
1 an introduction to essence by example
through the presentation of examples  this section both introduces essence and demonstrates its naturalness.
﹛we begin by asking the reader to examine the first essence specification given in fig. 1. this is a specification of a wellknown problem. can you identify it 
﹛you should have been able to identify this as the knapsack decision problem because the essence specification is nearly identical to the specification given by garey and johnson  1  problem mp1  page 1 :
instance: finite set u  for each u ﹋ u: a size s u  ﹋ z+  a value v u ﹋z+ and positive integers b and k.
question: is there a subsetsuch that
 
﹛the similarity of this essence specification to the naturally-arising problem specification illustrates our main point: problems are often specified rigorously via discrete mathematics. essence is based on the notation and concepts
mystery problem:

	given	u enum ...   s : u ↙ int  1...  
﹛﹛﹛﹛﹛v : u ↙ int  1...   b k: int find u: setof u such thatgolomb ruler problem  grp : given n  put n integer ticks on a ruler of size m such that all inter-tick distances are unique. minimise m.

given n : int where n ≡ 1
letting	bound be 1n find	ticks : set  size n  ofint  1..bound  minimising max ticks  such that	 pair1 pair1:set  size 1  ofint	pair1 = 
	 	 	pair1 sonet problem: a sonet communication network comprises a number of rings  each joining a number of nodes. a node is installed on a ring using an adm and there is a capacity bound on the number of adms that can be installed on a ring. each node can be installed on more than one ring. communication can be routed between a pair of nodes only if both are installed on a common ring. given the capacity bound and a specification of which pairs of nodes must communicate  allocate a set of nodes to each ring so that the given communication demands are met. the objective is to minimise the number of adms used.  this is a common simplification of the full sonet problem  as described by frisch et.al.  1b  

given	nrings  nnodes  capacity : int  1...  letting	nodes beint 1..nnodes  given	demand : setofset  size 1  of nodes find	network : mset  size nrings  of set  maxsize capacity  of nodes
minimising pring﹋network |ring|
such that  pair﹋demand.  ring﹋network. pair   ringsocial golfers problem  sgp : in a golf club there are a number of golfers who wish to play together in g groups of size s. find a schedule of play for w weeks such that no pair of golfers play together more than once.  this transforms into a decision problem and parameterises problem number 1 in csplib. 

given	w g s : int  1... 
letting golfers benewtypeofsize g   s
find sched : mset  size w  ofrpartition  size s  of golfers such that  week1 week1
﹛﹛﹛﹛﹛﹛﹛ group1﹋week1 group1﹋week1.|group1 ﹎ group1|   1 alternative constraint:
such that  golfer1 golfer1:golfers.golfer1 =	golfer1 = 
 pweek﹋sched .together golfer1  golfer1  week     1figure 1: essence specifications of four problems.
of discrete mathematics. hence  someone able to understand rigorous problem specifications that employ discrete mathematics can  with little training  also understand essence specifications. this is a significant advantage as far more people are familiar with discrete mathematics than constraint programming.
﹛natural problem specifications  such as the one above  identify what is given  the parameters to the problem   what combinatorial objects must be found  the decision variables  and what constraints the objects must be satisfy to be a solution. the specification might also introduce some terminology  give an objective function if the problem is an optimisation problem  and identify conditions that must be met by the parameter values. essence supports these components of a problem specification with seven kinds of statements  signalled by the by the keywords given  where  letting  find  maximising  minimising and such that. letting statements declare constant identifiers and user-defined types. given statements declare parameters  whose values are input to specify the instance of the problem class. parameter values are not part of the problem specification. where statements dictate allowed parameter values; only allowed values designate valid problem instances. find statements declare decision variables. a minimising or maximising statement gives the objective function  if any. finally  such that statements give the problem constraints.
﹛an essence specification is a list of statements composed according to the regular expression:
 given|letting|where|find    minimising|maximising   such that  
﹛now consider the specification of the golomb ruler problem  grp  problem 1 in csplib  in fig. 1  and the instance obtained by letting n be 1. the domain of the decision variable ticks contains all sets of four elements drawn from {1 .. 1}. consider an assignment of ticks to {1 1}.
is this a solution to this instance  if we have succeeded in our goal of making essence specifications natural to those with a discrete mathematics background  then it should be clear that it is: given any two distinct pairs from {1 1}  the distance between one pair  max pair1    min pair1  is different from the distance between the other max pair1    min pair1 . we believe that the reader will concur that the
essence specification closely matches the given english description  and is substantially closer than a standard csp model of the problem.
﹛the grp specification first declares parameter n  valid when positive  and identifier bound. the declaration of bound uses n  so n must be declared first. identifiers must be declared before use  preventing cyclical definitions and decision variables from being used to define constants or parameters.
﹛constraints are built from parameters  constants  quantified variables and decision variables using operators commonly found in mathematics. essence also includes variable binders such as  x   x and 曳x  where x can range over any specified finite domain  e.g. integer range but not integer . the grp constraint can be read  for any two unordered pairs of ticks  pair1 and pair1  if the two pairs are different then the distance between pair1 is not equal to the distance between pair1. 
﹛now consider the specification of the sonet problem  fig. 1 . notice that nodes is declared to be a domain whose elements are the integers in the range 1..nnodes. the parameter demand is to be instantiated with a set of sets  where each inner set has cardinality two. the goal is to find a multiset  the rings   each element of which is a set of nodes  the nodes on that ring . the objective is to minimise the sum of the number of nodes installed on each ring. the constraint ensures that any pair of nodes that must communicate are installed on a common ring.
﹛finally  fig. 1 gives two versions of a specification of the social golfers problem  sgp . as the problem description does not refer to the golfers individually  they are specified naturally with an unnamed type. the decision variable is represented straightforwardly as a multiset  the fact that it is a set is an implied constraint  of regular partitions   regularity guarantees equal-sized partitions  each representing a week of play. the specifications differ only in the expression of the socialisation constraint. the first constraint quantifies over the weeks  ensuring that the size of the intersection between every pair of elements of the corresponding partitions is at most one  otherwise the same two golfers are in a group together more than once . the alternative constraint quantifies over the pairs of golfers  ensuring that they are partitioned together  via the global constraint together  over the weeks of the schedule at most once. note that here we make use of a facility common to constraint languages: treating booleans as 1 for the purpose of counting.
1 the features of essence
this section explains the most significant features of essence. the first two subsections discuss types and domains and the next two discuss expressions and quantification.
﹛essence is a strongly-typed language; every expression has a type and the parser that can infer the types of expressions and can perform type-checking. types are also important in determining the denotation of an overloaded operator. for example  the union operator can denote set union or multiset union depending on the types of its arguments.
﹛essence is a finite-domain language; every decision variable is associated with a finite domain of values. these domains can be quite intricate sets of values. for example a domain could be any finite subset of integers or it could be the set of two-element sets drawn from a given finite set of integers.
﹛types and domains play a similar role; they prescribe a range of values that a variable can take. it is tempting - and  indeed  we were tempted - to view types and domains as one and the same thing. however  this view leads to the difficult  if not unsolvable  problem that the intricate patterns used in constructing domains must be handled by the type system. for example  if every finite subset of the integers is a distinct type then the problem of assigning types to expressions is difficult  if not impossible.
﹛as we have desired to keep the type system of essence simple  we have reached the decision that types and domains are distinct  though closely related concepts. types are sets that contain all elements that have a similar structure  whereas domains are sets drawn from a single type. in this manner  each domain is associated with an underlying type. for example integer is the type underlying the domain comprising integers between 1 and 1; set of integers is the type underlying the domain comprising all sets of two integers between 1 and 1. type checking  type inference  and operator overloading are based only on types  not on domains.
﹛types our design goal has been to provide essence with a rich collection of types  yet a simple type system. the richness of the types comes from the large number of types and type constructors that are supported. the simplicity of the type system comes from the fact that typing is static and that all types are disjoint.
﹛the atomic types of essence are int  integer   bool  boolean   user-defined enumerated types and user-defined unnamed types. the two user-defined types are defined through letting or given statements such as the following:
letting players benewtypeenum {alan  ian  chris  berna} letting rings benewtypeofsize 1 given players newtypeenum  ... 
﹛the first statement defines a new type comprising four named atomic elements. as all types are disjoint  the elements of this type cannot be members of any other type  and the four names cannot be used to name anything else. the second statement also defines a new type comprising four elements; however these elements are not named. these four elements are distinct from the elements of all other types. the third statement is similar to the first except that the enumeration of the elements of the type is provided as input rather than as part of the specification.
﹛the elements of the integer and boolean types and of all enumerated types are totally ordered. the integers are ordered in the usual way  the booleans are ordered by f   t  and the elements of an enumerated type take on the order in which they are named in the letting statement or given as input. all other types - user-defined unnamed types and all compound types - are unordered.
﹛compound types are built with type constructors to form sets  multisets  functions  tuples  relations  partitions and matrices. if 而 而1 而1 ... are the names of any types  牟1 牟1 ... are the names of any ordered types  耳 is the name of a finite type  bool  an enumerated type or an unnamed type  and n is any positive integer then the following all name compound types:
setof 而 a finite set drawn from 而 msetof 而 a finite multiset drawn from 而 而1 ↙ 而1 a finite1 partial function with domain 而1 and codomain 而1 	tuple	 an n-tuple 
rel 而1 ℅ ﹞﹞﹞ ℅ 而n partitionof 耳 a finite n-ary relation 
 a partition of the elements of 耳 rpartitionof 耳 a regular partition of the elements of 耳 matrixindexed by   牟1 ... 牟n   of 而 an n-dimensional matrix for example  setofint and relint℅int are both types. the type constructors can be nested to arbitrary depth  thus allowing types such as
setofsetofsetofint relpartitionof players ℅ msetofsetofint
﹛notice that finiteness plays a central role in the semantic explanation accompanying each type constructor above. a consequence is that  although types may contain an infinite number of elements  each element is of a finite size or cardinality. this is necessary to achieve the objective that essence specifications can be mapped to csps.
﹛finally notice that the parameters and decision variables of a specification cannot enter the type names. this restriction is necessary to enable the type of every expression in a specification to be determined before the parameters are instantiated with values. this is why we say that essence is statically typed.
	domains	a domain is a set of values all of the same type.
in essence every type is a domain. essence also allows domains to be named by annotating the name of the type with restrictions that select particular values of the type. for example  int  1..1  and set  size 1  ofint  1..1  are both domains. as annotations are always written in parenthesis  the type underlying a domain can always be obtained by removing the parenthesised subexpressions. thus  the types underlying the above two domains are int and setofint  respectively.
﹛first consider how atomic types can be annotated to form atomic domains. atomic domains can be formed by taking subsets of the integer or boolean type or any enumerated type. these subsets are identified either by a list containing values and value ranges or by an arbitrary set expression. examples include:
players  alan..chris 	 the players from alan to chris inclusive  int  1  1  1..1 	 a mixture of values and ranges  int  1.. 	 the positive integers  int  ..-1.. 	 the non-zero integers  int  l..u 	 the integers from l to u inclusive  int  s ﹍ {1} 	 the integers in s and 1 and 1 
﹛in these last two examples  l  u and s can be parameters or identifiers declared by a letting statement. this illustrates another important distinction between domains and types. parameters can appear in the annotations of a domain but they cannot appear in a type. however  decision variables cannot appear in domains  a requirement that is needed if specifications are to be mapped to csps.
﹛now consider how type constructors can be annotated. the set  multiset  partition  regular partition and relation constructors can all be annotated by inserting  before the keyword  of   a size restriction of the form  size intexp  or  maxsize intexp   where intexp is an integer expression that contains no decision variables. thus  all the following are domains:
set  size n  ofint
mset  maxsize n+1  ofint  1..1  partition  size m  of mset  maxsize 1  of int
 1..1 
the second and third of these domains illustrate that the annotations can be attached not only to the outer constructor  but also to the nested constructors and atomic types. the essence syntax has been designed so that there is no ambiguity about where an annotation is attached.
﹛in addition to the size annotation  the relation constructor can also be annotated with multiplicities that specify  for example  that a relation is n-to-m. as we have modelled this feature on a similar feature provided by esra  we will not describe it further.
﹛the function constructor can have one annotation to indicate that the function is total or partial and another to indicate that the function is surjective  injective or bijective. for example  the following are domains: players ↙ total  players players ↙ injective  players players ↙ totalsurjective  players
﹛the matrix and tuple type constructors take no annotations  though  of course  the types nested in them can be annotated  as in these examples:
tuple  int  1..   set  size 1  matrixindexed by  players  int  1..1   of bool
in all uses of the matrix constructor the domains for the indices must be a single range of an ordered type  as illustrated in the second statement above.
﹛every domain is either finite or infinite and the domains associated with a decision variable must be finite  which is required to ensure that specifications map to csps. elsewhere  frisch et al.  1a  we have given a set of rules for generating all finite domains. this paper instead relies on the reader's intuition and understanding to determine if a domain contains a finite or infinite set of elements.
﹛expressions the expressions of essence are formed in a manner much as one would expect  bearing in mind that every expression has a type. constraints and the restrictions in where statements are expressions of type boolean and objective functions are expressions of any ordered type.
﹛the atomic expressions of essence are the constants  parameters  decision variables and quantified variables. other than the unnamed types  and compound types constructed from them  every value has a name. these names are the constants of the language.
﹛we shall not explain the syntax for naming constants  but note that our objective was to give every value a distinct name. a difficulty is that the emptyset is a member of every type of the form setof 而. our remedy is to explicitly attach the type to every emptyset. thus  for example {}:set ofint and {}:setof players are distinct names for distinct objects.
﹛compound expressions are formed by applying operators to expressions. essence provides a wide range of operators drawn from discrete mathematics  e.g.  intersection  function application  projection  set membership   logic  e.g.  conjunction  implication   and the global constraints found in constraint programming  e.g.  alldifferent  global cardinality  lexicographic ordering . whereas the global constraints of other constraint languages apply only to matrices of integers  those of essence apply to matrices of any reasonable type. for example  in essence  alldifferent applies to a matrix of any type and lexicographic ordering applies to two one-dimensional matrices of any ordered type.
﹛the type of a compound expression is a function of its operator and the types of its operands. some operators are overloaded. for example  the intersection operator can be applied to two multisets to produce a multiset and it can be applied to two sets to produce a set.
﹛quantification essence provides an exceptionally rich set of constructs for expressing quantification. examples can be seen in all of the constraints of fig 1 as well is in the  minimising  statement of the sonet specification. each quantification expression consists of three components: a quantifier  either p    or  ; followed by a non-empty list of variables  these are the quantified variables that are being  declared  ; followed by a binding expression that dictates a finite set of values over which the variables range. these values are all of the same type  and this is taken as the type of the associated quantified variables. the finiteness of the set of values over which a variable ranges is necessary to enable the mapping of specifications to csps.
﹛binding expressions employ two methods of dictating these values. the first is to give a finite domain  as in the the universal quantifier of the alternative constraint of the sgp specification in fig. 1. the second method is to obtain the values by taking all elements or  strict or non-strict  subsets of a set  partition or regular partition. all the quantification expressions in the knapsack and sonet specifications in fig. 1 draw their values from a set. the set  partition or regular partition can be denoted by an arbitrary expression  including expressions that contain decision variables  as seen in the examples mentioned. in quantification expressions of this kind there is no need to specify the types of the quantified variables as they can easily be inferred. for example  in the quantified expression of the knapsack specification it is clear that u must be of type u since u  is of type setof u. finally it is also possible to employ both methods to dictate the values taken by the quantified variables. an example is seen in the constraint of the grp specification. here pair1 and pair1 must each be a subset of ticks and must also be a set of size 1
1 abstraction in essence
this section explains how the features of essence  as introduced in the previous section  yield a language with a great deal of abstraction.
﹛a guiding principle in the design of essence has been that the language should not force a specification to provide unnecessary information or make unnecessary decisions. existing languages often force a specification to introduce unnecessary objects or to unnecessarily distinguish between objects. this typically introduces symmetry into the specification. as will be demonstrated  the facilities essence has for abstraction enable this to be avoided.
﹛the high level of abstraction provided by essence is primarily a consequence of four features  which we discuss in the next four subsections.
﹛wide range of types essence supports a wide range of types and type constructors  including sets  multisets  tuples  relations  functions and partitions  and decision variables can have domains containing values of any one of these types. for example  the knapsack problem requires identifying the set of objects that are to go in the knapsack  so this is readily represented by a decision variable of type setof u  where u is the set of all objects. the objects themselves are a given enumerated type; there is no need to identify them with  say  integers. notice that the specification of garey and johnson  does not identify the objects with integers and a specification language should not force one to do so.
﹛nested types essence allows type constructors to be nested to arbitrary depth. this is the most important and distinctive feature of essence  and could be considered our most important contribution to the design of constraint languages.
﹛to observe its importance  consider the sonet problem  which requires placing each of a set of communicating nodes onto one or more communication rings in such a way that the specified communication demand is met. thus  the goal is to find a set of rings  each of which is a set of nodes-and this can be stated directly and explicitly in essence by using a decision variable of type set of sets.
﹛many languages support variables of type set of integer  but not nested sets. in such a language one would have to model the decision variable of sonet by a matrix of set variables  and the indices of this matrix would be symmetric. thus  a limitation of the modelling language has forced the user to introduce a symmetry into the specification that is not present in the problem. notice that neither this symmetry  nor anything corresponding to it  is present in the essence specification of fig. 1.
﹛alternatively  one could model the sonet problem with a decision variable whose type is a relation between the rings and the nodes. but  again  this introduces a symmetry into the model as the individual rings are interchangeable.
﹛quantification over decision variables as we have seen  essence allows quantifiers to range over values determined by a decision variable. for example  notice that the constraint of the grp  see fig. 1  is of the form
 pair1  pair1 ticks.constraint  where ticks is a decision variable of type set. without this capability  the grp constraint would need to take the form
 pair1  pair1:set  size 1  ofint  1..1n .
 pair1 ticks ＿ pair1 ticks =  constraint
besides being awkward  this always leads to an implementation containing 成 1n  constraints  one for each way of drawing two pairs from a set of 1n elements. in contrast  the essence constraint that quantifies over the decision variable can be compiled to a model with 成 n1  constraints  one for each way of drawing two pairs from a set of n elements.
﹛unnamed types essence provides types containing unnamed  indistinguishable elements  a feature necessary for adequate abstraction. many problems involve some set of elements  yet do not mention particular elements. for example  we know of no specification or model of the sgp in which the constraints name any particular golfer  hence the golfers are indistinguishable. but since constraint languages do not have unnamed types  all models and specifications  other than the essence specification in fig. 1  name the golfers either in the specification itself or in giving the input values. naming  and hence distinguishing  the otherwise indistinguishable golfers introduces symmetry into the model  namely the golfer names can be interchanged.
1 implementing essence
at this point we have implemented in haskell a parser for all of essence 1.1; it performs complete syntactic analysis  including all necessary type checking and type inference. a second implementation of this same parser in java is nearing completion.
we have implemented a rule-based system  called con-
jure  frisch et al.  1c   that can translate -we say refine - specifications in a fragment of essence into model kernels at a level of abstraction supported by existing modelling languages. we call these  kernels  because they do not contain many of the enhancements that characterize the most effective models  such as symmetry-breaking constraints and implied constraints.
﹛the model kernels generated by conjure are expressed in essence  a subset of essence that has a level of abstraction that is supported by existing constraint solvers. as such  essence only supports atomic variables  atomic set variables  and matrices of these. it allows neither quantification over decision variables nor unnamed types. thus  essence can be thought of as a solver-independent modelling language and is somewhat similar to opl  another solver-independent modelling language.
﹛because essence has a level of abstraction similar to existing solvers it is not extremely difficult to translate essence models into existing languages. in particular  the translation can be performed without making any modelling decisions. we have implemented a translator for mapping essence to eclipse  wallace et al.  1  and are currently developing another one to map essence to minion  gent et al.  1 .
﹛one reason why new types of decision variables have been incorporated into constraint programming languages so slowly has been the difficulty of implementing the enhancements. frisch et.al.  1c  identify a difficult  fundamental problem in refining types that can be nested to arbitrary depth and they present a solution to it. with this breakthrough  and other techniques pioneered in the development of the conjure prototype  we believe we have all the technology needed to refine all of essence to kernel models.
﹛of course  our ultimate goal is to develop a refinement system that can refine any essence specification into a single  complete  effective essence model. we consider this to be the goal of achieving fully-automated modelling  something which we do not consider achievable in less than a lifetime. as explained earlier  the development of a suitable problem specification language is necessary to embark on the venture.
1 an evaluation of the use of essence
to evaluate essence we specified a large suite of problems in the language and here reflect on the process and results. a suite of 1 problems  both theoretical and practical  was selected  1 drawn from csplib  and 1 from the literature. specification was undertaken by an undergraduate in computer science with no previous experience of constraint or logic programming. he was easily able to adapt to essence by drawing on his understanding of discrete mathematics.
﹛specification began by obtaining an unambiguous natural language description of the problem. the flexibility of essence allowed specifications to be written directly from this description. the key decision concerned the representation of the decision variables; from this the constraints followed easily. attention had to be paid to abstraction in order to make full use of the language. some of the problems were described in the literature in terms of low-level objects such as matrices. with the goal of producing an abstract specification there was typically a single obvious choice for the type of the decision variable. this was not  however  always the case: in the sonet problem the configuration can be represented as a relation from rings to nodes or as a set of sets of nodes. the latter is preferable as it avoids having to name the rings.
specification grew easier with experience; many specifications contained reusable common idioms. another advantage of essence is that similarities are present in abstract specifications that would not necessarily appear in the concrete constraint programs due to differing modelling choices.
	the resulting catalogue  york web 	1  contains
essence specifications for the problem suite and  for comparison  previously-published specifications in z  esra  opl and f. the relative expressiveness and elegance of essence is clearly demonstrated. throughout  the specification length is proportional to the size of the problem statement  with larger examples being just as easy to read.
1 comparison with other languages
algebraic modelling languages  dating from the 1s and originating in the field of mathematical programming  e.g. gams  brooke et al.  1  and mgg  simons  1    made two significant advances. firstly they were developed to simplify the user's role in solving mathematical programming problems  providing a syntax much closer to the expression of these problems found in the literature. secondly  they are declarative  characterising the solutions to a problem rather than how the solutions are to be found. this lifts a burden from the user  and allows different solvers to be easily applied to the same problem. many other useful modelling languages have been created in other areas  for example ace  fuchs and schwitter  1   an english-like modelling language for reasoning about knowledge bases.
﹛the success of modelling languages suggests that a similar approach might be fruitful for constraint solving. from early in the development of the field  the alice language  lauriere  1  shares many features with algebraic modelling languages of the time  including its declarative nature.
﹛constraint programming languages have gradually evolved a greater range of types for decision variables. for example  eclipse  gervet  1  supports decision variables whose domain elements are sets; similarly f supports functions  esra supports relations and functions  and np-spec supports sets  permutations  partitions and integer functions. each increase in abstraction allows the user to ignore additional modelling decisions  leaving this to the compiler. essence makes a large leap in this direction by providing a range of types wider than previous languages and  uniquely  type constructors that can be arbitrarily-nested. the magnitude and importance of this leap cannot be over-emphasized; it is largely responsible for making essence a problem specification language rather than a modelling language. zinc  marriott et al.  1; de la banda et al.  1  is a new specification language that follows essence in providing arbitrarily-nested type constructors but also provides some features not found in essence  such as the ability to define predicates. the zinc language is still in development and a full implementation does not yet exist.
﹛to fully realise the abstraction provided by a rich type system a language must permit quantification over decision variables  rather than just fixed ranges of integers. other than essence we know of only three constraint languages that provide this feature: esra  f and localizer  michel and van hentenryck  1 . it is worth noting that these are all
sonet optimisation part solution : sonet objective : sonet
 s : sonet   objective s  = # s.rings-nodes  objective solution  = min objective sonet  
figure 1: part of a z specification of the sonet problem.
declarative languages. in contrast  programming languages that are augmented with constraint facilities  such as solver and eclipse  achieve quantification through iteration  which makes it impossible to support quantification over variables.
﹛further abstraction is obtained through the provision of unnamed types. as far as we know  essence is the only constraint language to provide such a facility.1
﹛another approach to problem specification is to employ a more-powerful  more-general specification language such as z. this approach has been explored thoroughly by renker and ahriz   who have built a toolkit of z schemas to support common global constraints and other common idioms and have used this to build a large catalogue of specifications  rgu web  1 . a shortcoming of this approach is that z is too general for the task as it allows specifications of problems that do not naturally reduce to the csp. for example  unlike essence  nothing prevents a decision variable from having no domain or an infinite domain and nothing prevents using a decision variable to specify the size of a matrix of decision variables. of course  one could try to identify a subset of z that is suitable for the task  but we believe doing this and enhancing the language with a suitable schema library would result in a language that approximates essence. furthermore  an inherent limitation of z is that it provides no mechanism for distinguishing parameters from decision variables  a distinction that is central to the notion of a problem. a further shortcoming of specifications in a language like
z is that they are far less natural than those in essence. to observe this  compare the equivalent specifications  available at  rgu web  1   of the sonet problem in the two languages. figure 1 shows part of that z specification  which is equivalent to the essence statement  minimising
|rings-nodes| .
﹛the alloy  jackson  1  language avoids some of these shortcomings of z by restricting itself to first-order logic. alloy gives a natural and expressive way of specifying problems in terms of relations and atoms and maps these specifications to efficient sat models. without a more expressive type system  however  it is not obvious how alloy could be mapped to constraint languages  and in particular make good use of global constraints  which are vital to efficient constraint models.
1 conclusion
essence is a formal language that is natural in that it accessible to someone with an understanding of discrete mathematics but not constraint programming. essence allows combinatorial problems to be specified at a high level of abstraction. the result is that problems can be specified without  or almost without  modelling them. the central  unique feature of essence is that it supports complex  arbitrarily-nested types. consequently  a problem that requires finding a complex combinatorial object can be directly specified by using a decision variable whose type is precisely that combinatorial object.
﹛we plan to continue the development of essence by specifying a much wider range of problems in the language and using this to guide the design of further features and enhancements. among other developments  we expect that this will lead to the incorporation of additional operators for constructing expressions and additional type constructors such as lists  trees and graphs.
acknowledgements
ian miguel is supported by a uk royal academy of engineeering/epsrc research fellowship. we thank andy grayland for his useful comments on the syntax of essence.
