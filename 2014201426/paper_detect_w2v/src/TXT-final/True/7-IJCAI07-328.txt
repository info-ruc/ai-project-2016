
most work on predictive representations of state  psrs  has focused on learning and planning in unstructured domains  for example  those represented by flat pomdps . this paper extends psrs to represent relational knowledge about domains  so that they can use policies that generalize across different tasks  capture knowledge that ignores irrelevant attributes of objects  and represent policies in a way that is independent of the size of the state space. using a blocks world domain  we show how generalized predictions about the future can compactly capture relations between objects  which in turn can be used to naturally specify relational-style options and policies. because our representation is expressed solely in terms of actions and observations  it has extensive semantics which are statistics about observable quantities.
1 introduction
models of dynamical systems that use predictive representations of state replace the traditional notion of state  which is usually a latent  unobservable quantity  by a set of statistics about the future. a number of results have been obtained about these predictive state representations  or psrs . in the case of discrete observations  for example  psrs  littman et al.  1  have been shown to be just as accurate  expressive and compact as unstructured partially observable markov decision processes  pomdps . in the case of continuous observations and linear dynamics  the predictive linear gaussian model  rudary et al.  1  is just as expressive and more compact than the celebrated kalman filter. predictive representations have shown to be good bases for generalization  rafols et al.  1   and can be learned directly from an agent's experience trajectories by a number of different algorithms  wiewiora  1; mccracken & bowling  1; james & singh  1 . to date  most work on psrs has focused on state tracking and parameter estimation in flat  unstructured worlds such as general pomdps and linear dynamical systems.
﹛we extend psrs in a different direction. our main contributions are several extensions to the current state-of-the-art of psrs that allow the sort of generalization that is captured by relational representations. our extensions allow psrs to deal with structured relational domains  and entail three natural benefits. first  we are able to express policies for a family of domains in a way that is independent of the size of the state space  for example  in a blocks world domain the description of a policy would be independent of the number of blocks . second  we can express abstract knowledge by ignoring irrelevant properties of observations  in a blocks world  the color of a block may not impact how it can be manipulated   which allows us to generalize across objects. third  we can parameterize policies so that they generalize over multiple tasks  in a blocks world  the policy for stacking block a on block b should be similar to stacking block c on block d .
﹛to accomplish this  we broaden the language that psrs use to represent knowledge. psrs represent knowledge as action-conditional predictions about the future  which is formally captured by the notion of a test. we generalize these tests to include multi-attribute observations  and define two new types of tests  called  set tests  and  indexical tests.  we show how policies and options  precup et al.  1  can be specified in terms of mappings from these generalized tests to actions  which allows the policies and options to generalize over whatever the tests generalize over. finally  we show how a nonlinear psr can be naturally specified with these generalized tests. our extensions to psrs maintain a key feature of psrs  which is that all knowledge  including relational knowledge  has extensive semantics based on statistics about observable quantities. furthermore  as we will show below  the form of our extensions will allow relational knowledge to be maintained and computed efficiently. in summary  this paper is about advancing the expressiveness of psrs and extending them to capture relational knowledge. we do not address relational learning or planning.
1 background and motivation
the key idea of a psr is to represent state as a set of tests  which represent possible future observations given possible future actions. a psr maintains a set of core tests  the predictions of which are state in any history  and which allow it to make correct predictions about any sequence of future events.
﹛in a controlled  discrete  dynamical system  for example  a pomdp   at each time step i  the agent executes an action ai ﹋ a and receives an observation oi ﹋ o  we occasionally use multi-attribute observations  which are tuples denoted by angle brackets .
﹛a history is a sequence of alternating actions and observations a1a1 ﹞﹞﹞amom describing an agent's experience through timestep m. an s-test  or  sequence test   which we will also just call a  test    denoted a1a1 ﹞﹞﹞anon  describes a possible sequence of future actions and observations  note the distinction between superscripts and subscripts . a test succeeds if the observations of the test are obtained  given that the test's actions are taken. a prediction for a test t = a1a1 ﹞﹞﹞anon starting in history h is the probability that t will succeed when its actions are executed immediately following h. formally  we define the prediction for a test from history h of length m to be p t|h  = pr om+1 = o1 om+1 = o1 ﹞﹞﹞ om+n = on|h am+1 = a1 ﹞﹞﹞ am+n = an . for ease of notation  we will use the following shorthand: for a set of tests t = {t1 t1 ﹞﹞﹞tn}  p t|h  =  p t1|h  p t1|h  ﹞﹞﹞p tn|h  t is a column vector of predictions for the tests in t from a history h.
﹛in a psr  state is represented by a set of predictions about core tests. the predictions of these core tests comprise a sufficient statistic for history  which can be used in two ways. first  they can be used to compute the prediction of an arbitrary test  littman et al.  1 . second  they can be used to maintain state  as follows. given a set of core tests q  their predictions p q|h   which constitute state   an action a and an observation o  the updated prediction for a core test qi ﹋ q is given by
 .
this means that to maintain state  we only need to compute the predictions of the one step tests  ao  and the one-step extensions  aoqi  to the core tests as a function of p q|h .
1 an example: blocks world
blocks world is a structured domain typical of relational settings. even in this simple world  there are many types of structure that s-test psrs cannot leverage because the tests they use are not expressive enough.
﹛we define a partially observable blocks world  in which the agent has an eye that can focus on different places  viewing the world from the side . the domain is like a grid world  with discrete positions; for a given position  the observation is either a block  the table  or nothing  represented by 耳 . for most of the paper  we will assume that each block has a unique observation  a number   but we will occasionally consider versions where each block yields a multi-attribute observation. in these cases  the blocks will have a color  a number  and a  marked  bit  explained in section 1 .
﹛actions are u  move the eye up   d  move the eye down   a耳  stay still  and find a   saccade to block a . the movecurr b  action moves whatever block the eye is looking at onto block b  both must be clear; b may be the table   and the eye stays where it was. since we do not specify preand postconditions for actions  we assume that if the agent executes an invalid action  it fails and the state is unchanged. the eye can be at most one space above any given stack.
1 structured questions
in order to exploit relational structure in domains such as the blocks world  we must be able to ask questions about the future that s-tests cannot pose. these questions will motivate our extensions to psrs  and will allow us to accomplish our goals of generalization across domains  generalization across tasks  and generalization across objects. here are some examples:
   what is the probability that if i move my eye down  i will not see block b   this negative question cannot be answered with an s-test because they are defined in terms of things that we do see  not things that we do not see. however  we can represent  not block b  with the set of all observations except b. this motivates  set tests   which aggregate multiple observations.
   what is the probability of seeing a red block on top of a blue block   this type of question motivates an ability to ignore irrelevant attributes of observations  which allows us to deal with objects in terms of their attributes  and not their identities. again  this motivates set tests.    what is the probability of seeing one block  moving up  and seeing a block that has the same  but unspecified  color   in this case  color is acting as a variable  which must have the same value for both blocks. this question motivates an ability to refer to previous observations  and is the inspiration for  indexical tests. 
asking  and answering  these sorts of questions helps us to capture knowledge of structure in a domain  but requires generalizing the language of s-tests. one possibility is to allow tests to contain arbitrary questions  represented by arbitrary functions of observations and action. however  the answers  or predictions  of such arbitrary tests may not be efficiently computable. we seek a simpler way: we will show that our generalized tests provide the needed capability for capturing relational knowledge  and are computationally efficient.
1 generalizing the language of tests
this section discusses two generalizations of standard s-tests. we will first define set tests  in which we replace a single possible observation with a set of acceptable observations  and will then discuss indexical and complemented indexical tests.
1 set tests
standard s-tests can only ask about one observation at each timestep  but to ask negative tests and to ignore irrelevant attributes we want to ask about arbitrary sets of observations. we accomplish this with set tests.
﹛suppose we have two tests t1 and t1  both of length m  that differ in a only a single observation. we could ask   what is the probability of t1 or t1   because only one of the tests could succeed from a given history  the answer is p t1|h  + p t1|h . set tests generalize this idea by replacing a single observation with an arbitrary set of observations. define a set of observations ok   o  and let 考jk ﹋ ok be the j-th member of ok. define a test t which replaces the k-th observation ok with the set ok: t = a1 ﹞﹞﹞akok ﹞﹞﹞anon. this test can be viewed as a set of |ok| tests  individually denotedk tj   where tj replaces ok with 考jk. then.
﹛there is considerable flexibility in defining these sets of observations. to ask about red objects  we construct a set of all observations with the attribute  red.  we are also not limited to replacing a single observation with a set; any  or all  observations could be replaced. if we replace multiple observations  the resulting test includes all combinations of the elements of those sets. for example  if o1 = {考1 考1} and o1 = {考1 考1}  the test t = a1a1  expands  to include four primitive tests: a1考1考1  a1考1考1  a1考1考1  and a1考1考1  and the prediction of t is the sum of their predictions.
﹛because the systems we consider have a finite set of observations  the complement of an observation is well defined. to ask negative tests  we let  ok = o  {ok}  which is the set of all observations except ok.
1 indexical tests
with a set test we can ask   what is the probability of seeing a red block on top of another red block    but a different kind of test is needed to ask  what is the probability of seeing two blocks on top of each other which have the same  but
unspecified  color  
﹛we call these tests indexical tests. in an indexical test  we replace a single observation ok with a variable xk  and then we replace some later observation of with the same variable  as in t = a1 ﹞﹞﹞akxk ﹞﹞﹞afxk ﹞﹞﹞anon. of course  multiple observations can be replaced  and indexical variables can be reused many times.
﹛by default  the variable xk will  match  any observation from o  but we can restrict it to match a subset of observations. in either case  we define dom xk    o to be the set of acceptable observations for xk. for multi-attribute observations  xk is a vector of variables
  any of which we can restrict. this allows us to test whether observations match on some attributes of interest  while ignoring the other attributes. for example 
  with no restriction on
the domains  will succeed if the first attribute is the same in both time steps. we do not allow indexical variables to bind across tests.
﹛let us contrast indexical tests and set tests. earlier  we showed a set test to = a1a1 that expanded to include four tests. suppose we let dom x1  = o1. then  the indexical test tx = a1a1 only includes two primitive tests  a1考1考1 and a1考1考1   and the prediction of tx is the sum of their predictions.
﹛it is natural to define the indexical analog of a complemented set test. a complemented indexical test asks the following kind of question:  what is the probability that if i take some action  see some observation  and take another action  i will see a different observation   to do this  we allow  xk in a test  in addition to xk.
1 linear psrs and efficient tests
one of the primary motivations for restricting the class of generalized tests we consider is computational. there are special efficiencies for our generalized tests in the case of linear psrs  which allow the predictions of the generalized tests to be computed in time that is independent of the  complexity  of the test. before explaining further  we will first review linear psrs.
﹛in a linear psr  for every s-test t  there is a weight vector mt ﹋ r|q| independent of history h such that the prediction p t|h  = mtt p q|h  for all h. this means that updating the prediction of a single core test qi ﹋ q can be done efficiently in closed-form. from history h  after taking action a and seeing observation o:
	|	|
we only need to know mao  which are the weights for the one-step tests  and the maoqi  which are the weights for the one-step extensions.
﹛an important computational aspect of set tests is the fact that their predictions can also be computed with linear operations. in particular  for any set test t  there is a weight vector mt such that p t|h  = mtt p q|h . let t = a1 ﹞﹞﹞akok ﹞﹞﹞anon  where ok is a set of observations. then it is easy to show that

where the i-th row of mao ﹋ r|q|℅|q| is mtaoqi. in the case that multiple observations are replaced with sets  we compute the weight vector by replacing the corresponding mao with the appropriate sum.
the prediction for an indexical test is also linear. let t =
mt	manon ﹞﹞﹞	ak考k ﹞﹞﹞	af考k ﹞﹞﹞	a1.
考k﹋dom xk 
in the case of multiple  reused or complemented indexicals  the weight vector equation generalizes in the obvious way: the outer sum is over all valid joint settings of the indexical variables.
﹛because the weight vectors for set and indexical tests are independent of history  they can be computed once and reused over and over again. thus  after a one-time cost of computing the weights  the complexity of using both set and indexical tests is independent of the length of the test as well as the number of observations being aggregated  equivalently  the number of s-tests being aggregated . the complexity does  however  depend on the number of core tests.
1 specifying options and policies with generalized tests
we will now show how generalized tests can be used to specify policies and options. two of the three criteria for success outlined in the introduction involve the use of compact  descriptive policies: first  the complexity of a policy should be independent of the size of our domain  and second  it should generalize over multiple  but similar  tasks. we show that by specifying options and policies in terms of generalized tests  both automatically generalize in the same way their constituent tests do.
1 specifying policies with tests
formally  a policy is a mapping from states to actions. states in a psr are represented as the predictions of core tests p q|h . this state will always be a vector in r|q|  so a policy must map r|q| to a.
﹛instead of mapping p q|h  directly to actions  we first use the state  p q|h   to compute the predictions of a set of additional generalized tests  and then map the predictions of those additional tests to actions. there are many possible ways to do this. one way is to create a list of expressions involving tests  associate an action with each expression  and execute the first action whose expression is true. for example: p u 耳|h  = 1	↙ movecurr table 
	p a耳 耳|h  = 1	↙ d
	default ↙ u	 1 
 this policy moves the eye to the top of the stack  and then pops blocks off the stack until it is empty. it operates independently of the number of blocks in the domain  as well as the number of blocks in the stack. to avoid notational clutter in deterministic domains  we will usually omit the p ﹞|h  = 1 associated with each test.
1 specifying options with tests
options are temporally extended actions. they could represent  for example   walk to the doorway   or  wait until the light turns green.  formally  an option is specified by a set of initiation states  in which the option is available   by a termination function  which specifies the probability that the option will terminate at each timestep  and which may be a function of state   and by a policy over states.
﹛we specify the initiation states  the termination function  and the option policy in terms of tests. an option policy is specified in the same way as a global policy. the initiation states and termination function are also specified in the same way  but each expression has an associated value in {1} or  1   respectively  rather than an associated action. for example  using the policy in eq.  1   allowing initiation in any state  and using
|
	default ↙	1
 as our termination condition  then we have an option that pops blocks off the stack until the top block matches the cri-
﹛﹛﹛﹛﹛﹛﹛﹛﹛﹛﹛﹛﹛. here we define p t1|h  ＿ p 1| √ p 1| p 1| .
1 connecting to relational knowledge representations
we have completed the development of our generalized tests  and will next demonstrate how they can be applied with a detailed example. first  we will define predictive equivalents to traditional relational predicates and will illustrate their use in several options and policies. the first goal we consider is on a b   but we will also develop a policy for the more complicated goal of on  which is satisfied when two blocks of the same color are stacked  regardless of what color they are . finally  we will show how predictive predicates can create a nonlinear psr to track the state of the world.
predicate	test	predicate	teston a b  = find a  a d beyeon a  = a耳 aclear a  = find a  a u 耳eyeabove a  = d a on a b  = find a  a d  b clear a  = find a  a u 	耳eyebelow a  = u a 	 
figure 1: table of predictive predicates used.
1 predictive predicates and core tests
a traditional relational representation of the blocks world defines several predicates such as clear a  and on a b . equivalent constructs  which we will call predictive predicates  can be defined predictively with generalized tests. predictive predicates form building blocks for defining policies and options whose semantics are entirely based on statistics about future observations.
﹛for example  the test ton a b  √ a1 = find a  o1 = a a1 = d o1 = b  can be used to define a predictive predicate on a b  that is is true whenever p ton a b |h  = 1. this test finds block a  moves the eye down and checks to see if it sees block b. similarly  the test tclear a  √ a1 = find a  o1 = a a1 = u o1 = 耳 can be used to define a predictive predicate clear a  that is true in a history h whenever p tclear a |h  = 1. for ease of exposition  we will omit the implied tests associated with each of these predictive predicates  and just write on a b  instead of p ton a b |h ; we will also omit the implied action and observation labels  writing on a b  = find a  a d b. to track the position of the eye  we define three predictive predicates: eyeon a  = a耳 a  eyeabove a  = d a  and eyebelow a  = u a. we can also discuss the complement of a predictive predicate in terms of a complemented set test. for example   on a b  = find a  a d  b.
﹛to emphasize that these predictive predicates are actually tests  fig. 1 summarizes the predicates and their corresponding tests.
1 options and policies
given those predictive predicates  we can now begin to define options and policies that accomplish abstract actions in our domain. for instance  the following option  popcurr  moves to the table the block at the top of the current stack. this option works independently of the number of blocks in the stack  which is important to deal with stacks independently of the size of the state space:

option: popcurr
available: eyeon 耳 termination:eyeon 耳 ﹛﹛﹛﹛eyebelow 耳 	↙ movecurr table  policy:	 eyebelow 耳 	↙ u
﹛given the popcurr option and the rest of our predictive predicates  we can define an option to satisfy on a b . the idea of this policy is to find block a  clear all of the blocks off the top of it  then find block b and clear it  then move block a onto block b:
option: on a b 
available: all termination:on a b policy:
eyeon a  ＿ clear a  ＿ clear b ↙movecurr b  eyeon a  ＿ clear a  ＿ clear b ↙find a eyeon b  ＿ clear a  ＿  clear b ↙popcurr eyeon b  ＿ clear a  ＿  clear b ↙find b eyeon a  ＿  clear a ↙popcurr eyeon a  ＿  clear a ↙find a 
﹛there are a few points worth noting about this policy. the policy is compact and independent of the size of the state space  that is  it works for any number of blocks . the existence of such a policy is not a surprise. indeed  the policy is a straightforward implementation of a standard relational policy in psr terms. what is interesting is that psrs allow one to write such a policy in purely observable quantities. note that the policy is only good for stacking a on b; later  we will parameterize this policy to generalize across similar tasks.
1 more sophisticated goal states
so far  we have only used set tests. to showcase the power of indexical tests  we will now develop policies for more sophisticated goal states. the first is on  which is satisfied when any two blocks of the same color are stacked. we now have a multi-attribute observations  which are color  number  and a  marked  bit. the agent is allowed to mark blocks as a form of visual memory; only one block can be marked at a time.
﹛we also need to make a few intuitive redefinitions and clarifications to actions and predicates. basically  we allow everything to take an observation set as an argument. for example  find oi  now moves the eye randomly to a block that satisfies oi  each satisfactory block has a nonzero probability of being reached . predictive predicates are similar: we define eyeon oi  = a耳 oi eyeabove oi  = d oi  and eyebelow oi  = u oi. the on predictive predicate is a little different because the generalized test find oi  oi d oj is no longer deterministic. we define on to be true when p find oi  oi d oj|h    1. in other words  it is an existential relational query that has nonzero probability when there is some object satisfying oi on top of some object satisfying oj. the clear predictive predicate is similar: clear oi  =  find oi  oi u 耳    1.
﹛to start constructing our policy  we will define an indexical test which is true whenever the marked block has the same color as the block the eye is looking at: sameasmarked =
 find
﹛this lets us define popuntilsameasmarked  which is an option to pop blocks off the current stack until the top block has the same color as the marked block:
option: popuntilsameasmarked
available: all termination:sameasmarkedeyebelow 耳 ＿
	eyebelow 耳 	↙ movecurr table 
policy:	eyeon 耳 	↙ d default ↙ u
﹛we define another option  popuntil  which is defined by eq.  1  and the termination condition in section 1. together  these two options help us create a policy for on. the idea is to find a block  mark it  and then clear all blocks off the top of it. then  find another block with the same color  clear it  then put them on top of each other:

option: on
available: all termination:on         policy: clear
sameasmarked＿
	eyebelow 耳 	↙ movecurr
clear
sameasmarked ↙ popuntilsameasmarked
clear find
eye popuntil eyeon table ﹍ 耳 	↙ find default ↙ mark

﹛we could easily extend this policy to solve for a goal like on by replacing the find action with an option that finds a red block.
1 parameterized policies and options
so far  our policies and options generalize across domains and across objects  but do not generalize across tasks. for example  the policy for achieving on a b  does not generalize to stacking other blocks on each other. however  since all of our tests and predicates are propositional in nature  we could parameterize the tests and actions and options in the obvious way: simply replace constant observations with variables. so  on a b  might become on a b  = find a  a d b for variables a and b. as long as actions can be similarly parameterized  the agent can bind these variables to specific blocks and obtain predictions and policies on-demand.
1 a nonlinear  relational psr
so far  we have tacitly assumed the existence of an underlying psr capable of predicting any test. we will now show how such a psr can be constructed using predictive predicates. two things are needed for a psr: a set of core tests and a state update mechanism.
﹛we represent our core tests as predictive predicates. if there are k blocks  one set of core tests is k1 predicates  representing each possible on a b  combination  plus o k  additional predicates tracking the eye and marker. practically  this is an overkill: since our domain is deterministic  we can compress to just o k  predicates by remembering one on a b  predicate for each a  this complexity is analogous to the fact that in a traditional relational system  the size of the knowledge base grows linearly with the number of blocks in the domain  although the policy description does not .
﹛to update the state of the system  we use a rule-based system. we associate a rule with every action  which describes how to update the prediction of each core test. an example of such a rule is shown below:

action: movecurr d  clear d  ↘ 1; eyeon 耳  ↘ 1
 xeye: if eyeon xon  ↘x1  1  x yclearon x y: if yeye  ↘↘on1 x  ＿ on x y   on x d  ↘
﹛this rule is run whenever the action movecurr d  is executed. it updates both the core tests representing what the eye sees  as well as all of the core tests representing the state of the blocks  the psr is nonlinear because of the nonlinear nature of these rules .
1 related work
this paper focuses on extending psrs to allow generalized tests  which can be used to build relational knowledge into psr models  as well as build generalizing policies and options. we do not yet address learning and planning with this new representation  however  see  dzeroski et al.  1  for an example of existing work on learning with logical relational representations . furthermore  the representations developed here are essentially propositional  and are at present unrelated to efforts to combine first-order relational knowledge with probability  milch et al.  1; richardson & domingos  1 . temporal difference networks  sutton & tanner  1  are perhaps the model closest in spirit to ours. while it is theoretically possible for a td-net to compute predictions for our generalized tests  they were not specifically designed for such a task and would require numerous modifications. in contrast  our generalized tests function very naturally in a psr setting: their predictions are linearly computable  they arise from a natural generalization of s-tests  and they can succinctly represent relational knowledge.
1 conclusions and future research
we have taken the first steps in extending psrs from their existing limitation to flat  unstructured domains into domains that have relational structure. we introduced set tests and indexical tests  which allow an agent to ask  and answer  questions that s-tests and e-tests cannot represent. we showed that policies and options can be defined in terms of these generalized tests. we have illustrated these policies and options  as well as how to build a psr model that captures relational knowledge  in a prototypical blocks world. we also discussed how all of these tests  policies  and options may be parameterized to further generalize.
﹛we connected our generalized tests to traditional relational representations  and showed how standard relational predicates can be defined in predictive terms. we used these predictive predicates to translate the traditional blocks world domain into a psr model  with a final form that is closely connected to a relational representation. our resulting relational psr model satisfies our three basic criteria for success: policy succinctness  policy generalization  and attribute irrelevance.
﹛as immediate future work  we are addressing the problem of learning psr models that use these generalized tests and then planning with them in relational domains.
acknowledgments
special thanks to matt rudary for generous help and insightful comments. david wingate is supported under a national science foundation graduate research fellowship. britton wolfe  vishal soni and satinder singh are supported by nsf grant iis-1  nsf grant ccf-1  and by a grant from darpa's ipto program. any opinions  findings  and conclusions or recommendations expressed in this material are those of the authors and do not necessarily reflect the views of the nsf or darpa.
