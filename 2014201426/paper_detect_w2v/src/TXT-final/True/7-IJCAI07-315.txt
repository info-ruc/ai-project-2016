
in this paper  we will provide a fast polynomialtime algorithm for solving simple temporal problems  stps  with piecewise linear convex preference functions and a utilitarian objective function. our algorithm is motivated by the study of the linear programming  lp -dual of a given mincost circulation problem  mccp . we will also show how this duality relationship between simple temporal problems with preferences  stpps  and mccps leads to fast incremental algorithmsfor solving the former. our algorithms bear important implications in planning  scheduling and execution monitoring scenarios where  partial  plans are subject to repeated changes  and the most preferred solutions to the underlying stpps have to be computed and updated fast  incrementally .
1 introduction
many applications in ai depend crucially on our ability to efficiently deal with combinatorial problems that involve both a satisfaction component and an optimization component- hence requiring us to reason about both hard and soft constraints.  the hard and soft constraints capture the satisfaction and optimization components of a problem respectively.  we are often required to express natural factors like fuzziness  probabilities  preferences and/or costs  and are subsequently interested in finding an optimal solution with respect to one or more criteria. important problems in planning and scheduling  for example  involve metric temporal constraints and various kinds of associated preferences.
모simple temporal problems  stps   dechter et al  1  constitute a well studied formalism used for reasoning with metric time. an stp is characterized by a graph  where x = {x1 x1 ...xn} is a set of events  x1 is the  beginning of the world  node and is set to 1 by convention   and  annotated with the bounds
 lb e  ub e    is a simple temporal constraint between xi and xj indicating that xj must be scheduled between lb e  and ub e  seconds after xi is scheduled  lb e  뫞
ub e  .1 the formalism of simple temporal problems with preferences  stpps   khatib et al  1  was introduced to deal with situations where the factors guiding the relative execution times of certain pairs of events are better modeled  and abstracted  using preference functions rather than hard constraints. roughly  an stpp is characterized by a graph   where x = {x1 x1 ...xn} is a set of events  x1 is the  beginning of the world  node and is set to 1 by convention   and  is either a hard simple temporal constraint annotated with  lb e  ub e    or a soft constraint annotated with a preference function fe t  : r 뫸 r indicating the preference associated with scheduling xj exactly t seconds after xi. given such local temporal preference functions  the objective function can be defined in a number of ways. one simple way is to maximize the minimum of all the local temporalpreferences; this is referredto as weakest link optimization  wlo . wlo in stpps has been shown to be tractable when all the preference functions are semi-convex1  khatib et al  1 . the wlo model  however  corresponds to egalitarianism in utility theory  and it is easy to illustrate its myopic focus. a much better optimization criterion is to maximize the sum of the preferences  corresponding to utilitarianism in utility theory .1
모a polynomial-time algorithm for solving stpps with piecewise linear convex preference functions and a utilitarian objective function is provided in  morris et al  1 . this algorithm  however  employs a general lp solver  and therefore does not tightly characterize the complexity of solving such problems. moreover  the algorithm is not incremental. we note that there is great value in designing simple and fast polynomial-time algorithms for solving metric temporal reasoning problems. this is evident  for example  even in the simple case of stps. although stps are characterized by a set of simple linear  difference  constraints amenable to a polynomial-time algorithm using a general lp solver  it is well understood that it is much better to solve a given stp using shortest path computations  say  by employing the bellman-ford algorithm . this is because the latter approach would lead to a simple and fast polynomial-time algorithm- tightly characterizing the complexity of solving stps. in the

koubarakis  1  or rdtps  kumar  1 . 1
g y  is semi-convex iff for any horizontal line l  the set of all
y  such that g y  is not below l  constitutes a single interval.
모모모1in  kumar  1   a polynomial-time algorithm for certain other useful classes of stpps is provided.
figure 1: illustrates how flow is augmented along negative cost cycles in the residual graph  for solving a given mccp . every edge is annotated with two numbers: the first one being the capacity  and the second one being the cost.  a   left-hand side  shows a scenario where a negative cost cycle bcdef is chosen to augment flow along. if a unit amount of flow is pushed along this cycle  then it leads to a situation as shown in  b   right-hand side  with the appropriate residual edges. we note that there exists a negative cost cycle even in  b -namely fab-therefore indicating that further flow has to be augmented to achieve optimality.
same spirit  it is imperative for us to develop simple and fast polynomial-time algorithms for solving stpps with piecewise linear convex preference functions and a utilitarian objective function-especially because these classes of stpps are fairly general and very useful in practice  see  morris et al  1  for motivating arguments . further  it is also beneficial to develop incremental algorithms that can readily update the solutions to  these kinds of  stpps when  small  changes are made to them  as in  say  a refinement planner .
모in this paper  we will first provide a fast polynomial-time algorithm for solving stpps of the above mentioned kinds. our algorithm is motivated by the study of the lp-dual of a given mincost circulation problem  mccp . we will then show how this duality relationship between stpps and mccps leads to fast incremental algorithms for solving the former. our algorithms bear important implications in planning  scheduling and execution monitoring scenarios where  partial  plans are subject to repeated changes  and the most preferred solutions to the underlyingstpps have to be computed and updated fast  incrementally .
1 brief overview of mccps
a class of linear programs that can be solved better  compared to employing a generic lp solver  using a specialized set of techniques is the class of flow problems; these include variants like the well studied maxflow problems  mincost circulation problems  generalized flow problems  etc. many insights about a given lp problem can be drawn from studying its dual. given a primal lp problem  one can construct its dual lp problem using a prescribed set of rules  sultan  1 . a number of interesting theorems guide the relationship between a given primal lp problem and its dual; these include the weak duality theorem  the strong duality theorem and complementary slackness  sultan  1 .1
모in this section  we will briefly review mccps and some of the well-known results/algorithms associated with solving them. an mccp is characterized by a directed graph
  where v = {v1 v1 ...vn} is the set of nodes  and e is the set of edges.1 an edgeis annotated with two numbers:  a  a positive real number u e  representing the capacity of the edge  maximum amount of flow that can be pushed through the edge   and  b  a real number  not necessarily positive  c e  representing the cost of pushing a unit amount of flow through the edge. the goal is to come up with a circulation  an amount of flow on each edge  such that:  a  the conservation constraints hold at every node  i.e. the total incoming flow is equal to the total outgoing flow at every node    b  the capacityconstraints hold true for every edge  i.e. the amount of flow pushed through any edge is less than or equal to the capacity of that edge   and  c  the overall cost of the flow is minimized.
모algorithms for solving mccps work by augmenting flow along negative cost cycles in the residual graph. given a candidate circulation f  its residual graph gf is defined by replacing each edge  by two edges:  a   of capacity and cost  and  b   of capacity and cost . a circulation f  can be shown to be optimal if and only if there are no negative cost cycles in the residual graph gf . figure 1 shows an example of flow augmentations in an mccp.
모although repeatedly pushing flow along any negative cost cycle  in the residual graph  leads us eventually to the optimal circulation  better runningtimes are achievedby pushing flow along the min-mean cost cycles  goldberg and tarjan  1 . the best known algorithms for solving mccps work in time o m log n  m + n log n     orlin  1 .  here  n is the number of nodes  and m is the number of edges.  we note  however  that when all the capacities are integers  there are two things that characterize the number of  flow-augmenting  iterations required to solve an mccp:  a  the strongly polynomial running time of o m log n  m+n log n     and  b  the amount of the flow itself; so  if the amount of the flow  not the cost of the flow  is itself small  we need only a few iterations. as we will allude to later  this can be exploited in designing incremental algorithms for solving stpps.
모the lp formulation of an mccp is as follows:  f e  for all e 뫍 e are the variables 

 1  maximize 
we note that the capacity constraints and the conservation constraints are reflected in  1  and  1  respectively. the dual of the above lp is as follows:  l e  for all e 뫍 e  and p v  for all v 뫍 v are the variables 

 1  minimize

figure 1:  a   left-hand side  illustrates a primitive kind of cost function for the time difference between two events xv and xu.  b   right-hand side  shows the corresponding cost and capacity annotations on the edgein the dual formulation of the problem.
모we note that each capacity constraint in the primal corresponds to a variable l e  in the dual; further  the l e s are non-negative because the capacity constraints are inequalities. similarly  each conservation constraint in the primal corresponds to a variable p v  in the dual; further  the p v s are unrestricted because the conservation constraints are equalities. each variable in the primal corresponds to an inequality in the dual. the left-hand sides of these inequalities follow from tracing which variables in the primal participate in which constraints  and what the respective coefficients are . the right-hand sides follow from the primal's objective function. finally  the coefficients of the variables in the dual's objective function come from the right-hand sides of the corresponding constraints in the primal.
모p u  is referredto as the potential of the node u  and p u +  is referred to as the reduced cost
of the edge. it is easy to see that the sum of the reduced costs along a cycle is equal to the sum of the costs  along the same cycle . further  it can be shown that a circulation f  is optimal if and only if there exists a potential function p such that for all e 뫍 gf : cp e  뫟 1  see  ahuja et al  1  .
1 lp-duality perspectives on stpps
examining the dual of an mccp more closely  we notice that the only constraints involving the potentials of the nodes are difference inequalities of the form:
. these
resemble the inequalities arising in stps  with a few beneficial differences . first  we notice that if is equal to 1 for all  then these inequalities directly correspond to simple temporal constraints.1 in the more general case that  we can reinterpret as indicating the  amount by which the simple temporal constraint  is violated.  further  the dual of an mccp allows us to minimize a positive linear combination of thes  with the weight corresponding to being the positive capacity . this can be reinterpreted as minimizing  a positive linear combination of how much we violate each of the specified simple temporal con-

figure 1:  b   right-hand side  shows a gadget where a 뫞 xv   xu 뫞 b  and the preference function in the feasible region has a positive slope of s between xv   xu = a and xv   xu = b.  a 
 upper left-hand side  shows the equivalent cost function  ignoring additive constants like  .  c   lower left-hand side  shows the required mccp representation  in the dual formulation .
straints by.  in principle  therefore  stpps with linear cost functions  as shown in figure 1  fit the lp-dual model of mccps. here  see figure 1   every edge is annotated with a cost function  instead of a preference function  that remains 1 as far as the difference  but begins to increase linearly with positive slope beyond this bound; and the objective is to minimize the overall cost  summed over all edges . figure 1 also shows that such a cost function translates to the edge with capacity  and cost in the dual formulation of the
problem as an mccp.
we note/recollect two things before proceeding further.
 first  a hard simple temporal constraint of the form p v     can be handled by modeling it as p v     with being practically
set to . second  although the flow-based techniques allow us to efficiently solve only the dual lp problem  mccp   the strong duality theorem yields the value of the optimal solution for the  original  primal lp problem  stpp . in the next section  where we will deal with stpps having piecewise linear convex preference functions and a utilitarian objective function   we will show that the value of the optimal solution alone can be used to iteratively construct the required optimal schedule in its entirety.
1 designing gadgets
we will now introduce combinatorial structures called gadgets that will be used later in the paper to handle stpps with piecewise linear convex preference functions. these gadgets are in turn built using the basic building block of figure 1
모consider designing the gadget where a 뫞 xv   xu 뫞 b  and the preference function in the feasible region is as indicated in figure 1 b   with a positive slope of s between
functions with negative slopes. the three diagrams shown above are in direct analogy with those of figure 1.
xv   xu = a and xv   xu = b . ignoring additive constants  such a preference function is equivalent to a cost function as shown in figure 1 a . this cost function is positive everywhere  and can be modeled using two hard constraints  namely  a 뫞 xv  xu and xv  xu 뫞 b   and one soft constraint  namely  xv   xu 뫟 b with a cost of violation by 1 unit being equal to s . from figure 1  therefore  the required mccp representation  in the dual formulation of the problem   is as shown in figure 1 c . using similar arguments see figure 1   we can design a gadget where a 뫞 xv   xu 뫞 b  and the preference function in the feasible region is as indicated in figure 1 b   with a negative slope of  s between
xv   xu = a and xv   xu = b .
1 stpps with piecewise linear convex preference functions
in this section  we will build the final algorithm for solving stpps with piecewise linear convex preference functions1 and a utilitarian objective function. a key idea in this algorithm involves the transformation of such a given stpp to one that has preference functions limited to the types in figures 1 and 1. the transformation works as follows. for every piecewise linear convex preference function fe t   and corresponding to every  intermediate  landmark of this function  we add a new variable. the difference between such consecutive variables is constrained to be between 1 and the length of the corresponding interval 1 and the associated preference function is designed to be in direct correspondence with the slope of fe t  within this interval. figure 1 illustrates this process for a single preference function. the mccp representation of the new problem can be built by simulating preference functions with positive and negative slopes using the gadgets in figures 1 and 1 respectively. figure 1 presents an

1
모모for simplicity  we will assume that every such preference function is defined to be within an interval; for example  figure 1 is taken to not only specify a preference function for xj  xi  but also implicitly constrain xj   xi to be within  r1 r1 . 1
note that we use hard constraints for this purpose.
figure 1: the top diagram shows an example piecewise linear convex preference function with the appropriate landmarks and lengths defined by it. the second diagram shows the intermediate variables we would introduce between xj and xi. it also shows the hard simple temporal constraints we would add between consecutive variables created for this edge. the third diagram shows the slopes of the line segments in the corresponding intervals  simply as defined in the original preference function . the bottom diagram shows two examples of the kinds of preference functions we would like to construct corresponding to each interval. in each case  the preference value is 1 at the origin  and either increases or decreases linearly up to a certain value; everywhere else  the preference value is assumed to be    directly corresponding to the gadgets in figures 1 and 1 .
elaborate example of the dual formulation of an stpp  with piecewise linear convex preference functions  as an mccp.
모we will now argue that an optimal solution for the new problem  with the additional variables  yields an optimal solution for the original problem. the key insight stems from the fact that in a piecewise linear convex preference function  the slopes of the line segments  defined by the function  are monotonically decreasing  from left to right . consider any edge with the associated preference function fe t . let the landmarks defined by fe t  be
  and let the corresponding intermediate variables be  see figure 1 for an example . the slopes of the lines segments  defined by fe t   in the intervals  are monotonically decreasing. because of this property  and from the standard arguments associated with the optimality of the greedy algorithm for solving the  fractional knapsack problem   it follows that the optimal setting of the intermediate variables for any values of
y e ;y  e 뫹 y  e + min re   re x   y  e ;...y  e 뫹
 see figure 1 for
an example . for any values of xi and xj  therefore  the best way to set the intermediate variables is to exhaust the slack in the difference between one consecutive pair of  intermediate  variables before going to the next pair  left to right . since

1
note thatis fixed to; see figure 1.
figure 1: the top-left diagram shows an example stpp with hard simple temporal constraints and two piecewise linear convex preference functions. the bottom-left diagram shows the intermediate variables introduced for each preference function and the hard simple temporal constraints between them  dark nodes indicate newly added variables . the right-hand side diagram shows the mccp representation of the problem. the dark lines indicate edges that encode different pieces of the corresponding preference functions. for clarity  some hard simple temporal constraints that flank the dark edges are not shown encoded explicitly.
the optimal setting of the intermediate variables is completely determined by the values assigned to the end-point variables xi and xj  and since the intermediate variables do not participate in any constraint of the original problem  an optimal solution to the original stpp can be obtained simply by taking the projection of an optimal solution to the new stpp.
모figure 1 presents the algorithm for reporting the value of an optimal solution to a given stpp  with piecewise linear convex preference functions and a utilitarian objective function .1 we will now arguethat in fact the value of the optimal solution alone is enough to efficiently construct the required optimal schedule. suppose we have k preference functions in the stpp; let us call them fe1 t  fe1 t ...fek t . let s  be an optimal schedule  and let the value of s  be v . the idea is to replace the preference functions in the stpp  one by one  by additional simple temporal constraints that would serve to rule out all the non-optimal solutions. in each iteration  we will replace an arbitrarily chosen preference function feh t  by a simple temporal constraint such that any optimal solution to the new problem  with one less preference function  has a value 뫟 v . in the remaining smaller problem  with respect to the number of preference functions   we will follow the same procedure to replace another arbitrarily chosen preference function by a simple temporal constraint  and so forth. after k iterations  therefore  we will be left with an stp-any solution to which has a value 뫟 v . that is  all the non-optimal solutions would have been ruled out  and an optimal solution to the original problem can be obtained simply
figure 1: illustrates that for any  values of  xi and xj  the optimal way to set the intermediate variables is to exhaust the slack in one consecutive pair of  intermediate  variables before going to the next  left to right . when xj   xi = 1  for example  the first way of setting the variables  third diagram from top  exhausts all the leftmost slacks  creating a total value of  1   1   1 /1  +  1   1   1 /1  +  1   1   1 /1  +  1   1   1 /1  = 1. this is indeed equal to the true value of the preference function at xj  xi = 1. we note that any other way of setting the intermediate variables leads to a non-optimal value. for example  in the second way  bottom diagram   the total preference is equal to  1   1 /1 + 1   1 1 /1 + 1   1  1 /1 + 1   1 1 /1 + 1   1.1 /1  = 1 which is less than the actual preference value at this point.
by solving the final stp using shortest path computations.
모the crucial step in the aboveprocess  however is to replace an arbitrarily chosen preference function feh t  by an appropriate simple temporal constraint such that an optimal solution to the new problemhas a value 뫟 v . this can essentially be done by a standard backtrack-free search algorithm that utilizes the procedure of figure 1 in every iteration. suppose feh t  is associated with the edge. it is easy to see that the requirement feh xj   xi  뫟 v is in fact equivalent to a simple temporal constraint between xi and xj  because of semi-convexity . now  suppose feh t  is always a nonnegative integer in the range  1 m .1 we can consider the simple temporal constraint equivalent to feh xj   xi  뫟 d  and examine whether d plus the value of the optimal solution to the smaller problem  that incorporates the new simple temporal constraint instead of feh t   is equal to the value of the optimal solution to the original problem. if it is  then the newly added simple temporal constraint is the one that can replace feh t . it is easy to see that ranging over all possible values of d  viz. from 1 to m   we will always be able to find an appropriate cutoff value-the corresponding simple temporal constraint of which can replace the function feh t .
모the running time complexity of figure 1 is dominated by that of solving the intermediate mccp  step 1 in figure 1 .
algorithm: solve-piecewise-linear-convex-stpp-value input: an stpp with piecewise linear convex preference functions and a utilitarian objective function.
output: value of an optimal schedule that satisfies all hard constraints  if possible  and maximizes sum of the preferences.
 1  for every preference function
 a  identify the landmarks r1 r1 ...rke+1  and introduce the corresponding new variables y1e y1e ...ykee  see figure 1 .  b  create simple temporal constraints between consecutive
points in	  between xi and	  and between and xj as shown in figures 1.
 c  for each of the linear preference functions thus defined  see figures 1   build gadgets as shown in figures 1.
 1  encode hard constraints as explained in the text.
 1  solve the resulting mccp using efficient  flow-based  techniques  see  orlin  1  and  goldberg and tarjan  1  .
 1  return: the value of the solution.
end algorithmfigure 1: a fast polynomial-time algorithm for reporting the value of an optimal solution to a given stpp with piecewise linear convex preference functions and a utilitarian objective function. we assume that a value of   is returned when the problem is infeasible.
this complexity is o m log n  m + n log n    where n  number of nodes  and m  number of edges  take into account the new variables and constraints/edges created for the landmarks of the preference functions. the total runningtime of the algorithm  for constructing the optimal schedule  is k.r.t where k is the total number of preference functions  r is the largest value of any preference function  and t is the complexity of figure 1  as analyzed above .
1 incremental computation
since our algorithms for solving stpps  of the foregoing kinds  are based on solving mccps  they can also readily be made incremental. incremental algorithms for flow problems can be found in  hartline and sharp  1   and incremental computation of resource-envelopes based on flow techniques can be found in  kumar  1  and  muscettola  1 . mccps can also be solved incrementally using techniques very similar to that in  kumar  1   as illustrated in figures 1 and 1 of that paper . the main idea is the same-reverse the flow on edges that are not present in the new instance of the mccp by first computingthe amount by which such a reverse flow would violate the conservation constraints at each of the nodes; after the excess at each node is measured  a maxflow is staged between two auxiliary nodes s and t to regain conservation consistency; a subsequent optimization phase is carried out that respects this consistency-hence solving the new instance of the problem. the running time of this incremental procedure depends on  how much flow remains to be augmented -andthis characterizesthe  difference between the original problem instance and the new problem instance  see  kumar  1  for more details .
모it is worth noting that an incremental procedure for solving mccps finds immense use in iteratively building the optimal schedule for an stpp  as explained before . further  incremental computation of solutions to stpps is extremely important for an active management of planning  scheduling  and execution monitoring. in a refinement planner  for example  an stpp might characterize the various preferences and temporal constraints in a partial plan-the optimal solution to which might provide a useful heuristic value in the search for a good plan. because refinement operators used to extend a partial plan include various kinds of incremental changes to it  an incremental algorithm for solving stpps is likely to be much more useful than recomputation  from scratch  at each node in the search tree.
1 conclusions and future work
we presented a fast polynomial-time algorithm for solving stpps with piecewise linear convex preference functions and a utilitarian objective function. our algorithm was motivated by the lp-duality relationships between stpps and mccps  and could be made incremental-thereby bearing important implications in many real-life applications. in future work  we are interested in identifying richer classes of stpps that can be analyzed and solved efficiently using lp-duality.
references
 ahuja et al  1  ahuja r. k.  magnanti t. l. and orlin j. b. 1. network flows: theory  algorithms  and applications. prentice hall  new jersey.
 dechter et al  1  dechter r.  meiri i. and pearl j. 1. temporal constraint networks. artificial intelligence  vol. 1.
 goldberg and tarjan  1  goldberg a. v. and tarjan r. e. 1. finding minimum-cost circulations by cancelling negative cycles. journal of acm 1   1.
 hartline and sharp  1  hartline j. and sharp a. 1. incremental flow. www.cs.cornell.edu/w1/ jhartlin/incflow.pdf
 khatib et al  1  khatib l.  morris p.  morris r. and rossi f. 1. temporal constraint reasoning with preferences. proceedings of ijcai'1.
 kumar  1  kumar t. k. s. 1. incremental computation of resource-envelopes in producer-consumer models. proceedings of the 1th international conference on principles and practice of constraint programming  cp'1 .
 kumar  1  kumar t. k. s. 1. a polynomial-time algorithm for simple temporal problems with piecewise constant domain preference functions. proceedings of the 1th national conference on artificial intelligence  aaai'1 .
 kumar  1  kumar t. k. s. 1. on the tractability of restricted disjunctive temporal problems. proceedings of the 1th international conference on automated planning and scheduling  icaps'1 .
 morris et al  1  morris p.  morris r.  khatib l.  ramakrishnan s. and bachmann a. 1. strategies for global optimization of temporal p