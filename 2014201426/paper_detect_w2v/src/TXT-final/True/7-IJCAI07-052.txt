
reversing actions is the following problem: after executing a sequence of actions  which sequence of actions brings the agent back to the state just before this execution  an action reversal . notably  this problem is different from a vanilla planning problem since the state we have to get back to is in general unknown. it emerges  for example  if an agent needs to find out which action sequences are undoable  and which ones are committed choices. it has applications related to plan execution and monitoring in nondeterministic domains  such as recovering from a failed execution by partially undoing the plan  dynamically switching from one executed plan to another  or restarting plans. we formalize action reversal in a logic-based action framework and characterize its computational complexity. since unsurprisingly  the problem is intractable in general  we present a knowledge compilation approach that constructs offline a reverse plan library for efficient  in some cases  linear time  online computation of action reversals. our results for the generic framework can be easily applied for expressive action languages such as c+ or k.
1 introduction
reasoning about actions is an important area within knowledge representation and reasoning. several logic-based languages for representing actions have been proposed  see e.g.   gelfond and lifschitz  1; giunchiglia et al.  1; son and baral  1; eiter et al.  1    and various reasoning problems about actions have been considered. the most prominent among them are temporal projection  inference about the state after a sequence of actions occurred   reasoning about the initial state after a sequence of actions occurred  and plan generation  generate a sequence of actions which takes the agent from an initial state to a goal state .
모we study another reasoning problemabout actions  namely the problem of undoing the effects of an execution of an action sequence  by executing other actions. for example  after doing the action go home office   the action go office home  may reverse its effects and bring the agent back to her previous state. if this holds regardless of the state in which the agent was before doing go home office  and afterwards  then go office home  is called a reverse action for go home office . if  more generally  a sequence of actions r = b1 ... bm is guaranteed to bring the agent back to the state before executing a sequence as = a1 ... bn  then r is called a reverse plan for as. for example  r = go office pub  go pub home  may be a reverse plan for as = go home bus stop  go busstop office .
모undo actions are well-studied in the area of databases  where they are a standard method for error recovery. in a more general context of plan execution and recovery   hayashi et al.  1; 1  use undo actions for execution of plans by mobile agents in a dynamic environment. however  the undo actions  one for each action  need to be specified  manually  by the user. it therefore is desirable to have tools which automatically generate undo actions  or more generally  reverse plans. this raises the following questions: given an action domain and an action a  does there exist a reverse action for a  more generally  given a sequence of actions as  does there exist a reverse plan for as  if so  how can a reverse action or plan be efficiently computed  from a computational point of view  can reverse actions or plans be fruitfully exploited for efficient backtracking in action execution 
모backtracking may be considered for various reasons  like to restart a plan  e.g.  when the execution of the plan fails due to some undesired effects of an action in a nondeterministic environment  or to switch from the current plan to one which is better  or safer  in the light of new information. when the current state and the state we want to backtrack to are known  then the problem amounts to a vanilla planning problem  which is intractable in general. however  the problem is different if the backtrack state is unknown.
모motivated by these questions  we study computational aspects of action reversals. the main contributions of this paper are as follows.
  we formally define the notions of a reverse action and a reverse plan for actions. rather than to commit to a particular action language capable of modelling nondeterministic effects  such as c+  giunchiglia et al.  1  or k  eiter et al.  1   we use here a generic transition-based framework for representing actions as in  rintanen  1; turner  1   using propositionallogic as a specification language. besides nondeterminism  it also accommodates concurrent actions and dynamic worlds. we extend the definitions to conditional reversals  considering also partial knowledge about the current state and the state before the execution.
  we thoroughly analyze the complexity of action reversals  and characterize the complexity of recognizing and deciding existence of reverse actions and plans  both for plain as well as for conditional reversals.
  unsurprisingly  action reversal is intractable in general. for monitoring applications  we therefore present a knowledge compilation method. it constructs offline a reverse plan library from which reversals can be online computed in polynomial  often  linear  time for important classes of instances.
모our results shed light on the complexity of action reversals  and can be easily customized to particular action languages like c+ or k. our algorithms for reverse plan assembly suggest action reversal as a complementary method for efficient backtracking  if no reverse plan exists  choose some other method . for further in-depth material and proofs for all results of this paper  we refer to  eiter et al.  1 .
1 action representation framework
following turner  1   let a be a set of action symbols and let f be a disjoint set of fluent symbols  which are viewed as propositional atoms. the set of states of an action domain is encoded by the models of a propositional formula state f  over f. let  be a formula over  where. then tr statestate encodes the set of transitions that corresponds to its models. that is  in a transition  the start state corresponds to an assignment s to f 1 the  concurrent  action execution  or occurrence  to an assignment a to a  and the end state to an assignment.
example 1  giunchiglia et al.  1  putting a puppy into water makes the puppy wet  and drying a puppy with a towel makes it dry. with the fluents f = {inwater wet}  and the action symbols a={putintowater  drywithtowel}  the states can be described by the formula state f  = inwater   wet. since there are three assignments to f satisfying state f   {inwater  wet}  { inwater wet}  { inwater   wet}  there are three states: {inwater wet} {wet} {}. the action occurrences can be defined through
act
 inwater 뫖 inwater 뫈 putintowater  뫇 drywithtowel  뫈 putintowater 
 drywithtowel     inwater 뫇  putintowater  
by the last line  drywithtowel is executable if inwater is false  but not concurrently with putintowater. for example  the assignment { inwater  wet  drywithtowel   putintowater   inwatersatisfies tr; therefore  it describes a transition from the state s	= {wet} to the state by executing the action a = {drywithtowel}. 
모the meaning of a domain description can be represented by a transition diagram  which is a directed labelled graph whose nodes are the states and whose edges correspond to action occurrences. a trajectory of length n is an alternating sequence s1 a1 s1 ... sn 1 an 1 snof states si
                                                   a1	a1 and action occurrences ai  such that s1 뫸 s1 뫸 ... 
an 1
sn 1 뫸 sn is a labelled path in the graph. the trajectory can be obtained from a corresponding model of the formula tr where each fi  resp.  each ai  results by adding time stamp i to each f 뫍 f  resp.  each a 뫍 a .
an action sequence of length n is a sequence 
  where each ai  1 뫞 i   n  is a  concurrent  action occurrence. we use |as| to denote the length of a. note that in general  |as| is different from the total number of single action occurrences in as.
in what follows denotes.
1 execution reversals
after an agent executes an sequence  it may be sometimes desirable that the effects of the whole or part of the action sequence be undone  such that the agent is back in the state sj  j   i  which she had reached after executing the actions a1 ... aj 1.
모an action can be undone by executing one of its  reverse actions  or by executing a  reverse plan . we define a reverse of an action below relative to a given action description.
 definition 1 an action a is a reverse action for a  if  for all and   the formula revact  defined as
tr
is a tautology  i.e. revact holds .
모the formulaabove expresses the following condition about actions. take any two states described by the assignments to fluents in respectively  such that executing a at s leads to s. then executing a at state s always leads to s.
모many of the benchmarks used in planning are from the transportation domain  logistics  blocks world  grid  etc. . e.g.  moving from x to y is the reverse action of moving from y to x  putting down an object is the reverse of picking it up.
definition 1 a reverse plan for an action a is a sequence
  of actions such that  for all f and   the following formula is true:
revplan tr the formulaabove expresses the following condition about an action a and an action sequence . take any two states   described by the assignments to fluents in f resp. f  such that executing a at s leads to s. then the action sequence is executable at state s  and it always leads to s. the executability condition ofis described above by the formula on the second line. note that revplan is equivalent to revact. for instance  a reverse plan for booking online a room may be first calling the hotel in which the room is reserved  and then cancelling the reservation.
모we can further generalize the notion of reversing by considering action sequences  rather than actions  to be reversed. there are two motivations for this generalization: it might not always be possible to find reverse plans for single actions  but only for sequences of actions. also  a reverse plan for an action sequence might be shorter than a reverse plan obtained by concatenating reverse plans for subsequences.
definition 1 a sequence   of actions is a reverse plan for an action sequence
 k   1   if  for all  the following formula is true: multirev

the formula above is very similar to revplan 
... am 1  . the only differenceis that  in the premise of the formula  a trajectory is considered instead of a single transition. note that multirev is equivalent to revplan.
모so far  a reverse plan has been defined for an action sequence at any state reachable by that sequence. however  at some such states  an action sequence may not admit any reverse plan. that is  an action sequence may have a reverse plan under some conditions  that do not necessarily hold at every reachable state. furthermore  if some information about the state which we want to reach by reversing actions is available  e.g.  values of some fluents obtained by sensing  then a reverse plan might be possible depending on this information. to make execution reversals applicable in such situations  we generalize reverse plans to  conditional reverse plans  as follows.
definition 1 a sequence   of actions is a 뷋;뷍-reverse plan for an action sequence   if  for any  the formula
multirev
is true  where is over f and and 뷍 f  over f.
모for the case where  we simply write 뷋-reverse plan for 뷋;뷍-reverse plan. for instance  a conditional reverse plan forbookinga roommay be first calling the hotel in which the room is reserved  and then cancelling the reservation  with the condition that another room is available at another hotel.
모a question which comes up naturally is whether it is possible to formulate conditions  which are necessary or sufficient for the existence of a reverse action for a given action. in the following  we briefly discuss two conditions  of which one is necessary  while the other one is sufficient.
모let us first focus on the necessary condition. imagine the following situation: the action a  which is to be reversed  results in the same state s when executed in two different
states  i.e.  tr and tr
it is then impossible to find a reverse plan 
for a. if we could  then if some s1 ... sm existed such that tr  then both and would hold  which is impossible  as we assumed that. this necessary condition can be stated more generally as follows:
 proposition 1 if a 뷋;뷍-reverse plan for  exists  then  for every two sequences s = s1 ... sn andof states such that  tr  and hold  it holds that.
모we have found also a sufficient condition  motivated by the following property of functions: a function f is involutory iff f f x   = x for each x in the domain of f. we say that an action sequence a1 ... am 1 is  뷍- involutory if  for every state s  satisfying 뷍   the following hold:
  for every sequence s = s1 ... sm of states such that trm s a  holds  there exist a sequence sm =  of states such that tr holds;
  for every two sequences s = s1 ... sm and sm =
 of states such that trm holds  it holds that.
therefore  an action is involutory  if executing the action twice in any state  where the action is executable  always results in the starting state. an example of an involutory action is a toggle action: if a simple light switch is toggled twice  it will always be in the same state as before. then a sufficient condition can be stated as follows:
 proposition 1 a 뷍-involutory action sequence as is always -reversible  and a-reverse plan is as itself.
1 complexity results
we study the complexity of the following problems related to the computation of execution reversals with respect to a given action domain description:
모 p1  for two given action sequences as and r  and given formulas 뷋 and 뷍 over fluent symbols  recognizing whether r is a 뷋;뷍-reverse plan for as;
모 p1  for a given action sequence as  deciding whether there exist an action sequence r of a polynomially bounded length  and formulas뷋 and 뷍 overfluent symbols  such that r is a 뷋;뷍-reverse plan for as  and that holds for some state s reached by as from some state s such that 뷍 s  holds;
모 p1  for a given action sequence as and formulas 뷋 and 뷍 over fluent symbols  deciding whether there exists an action sequence r of polynomially bounded length such that r is a 뷋;뷍-reverse plan for as.
problem|r| = 1|r| = 1|r|   1 p1 conp p1 쑗1쑗1쑗1 p1 쑗1쑗1쑗1table 1: complexities of  p1 - p1   in terms of completeness
모for our discussion of the computational complexities of these problems  recall the following sequence of classes from the polynomial hierarchy: first  = p; and for all k 뫟 1  쑗k = np = conp쑒 1. each complexity class at each level k  k 뫟 1  of the hierarchy  includes all complexity classes at lower levels. for further backgroundon complexity  we refer the reader to  papadimitriou  1 .
모the complexity results for problems  p1 - p1  are summarized in table 1. according to these results  checking whether an action sequence is a 뷋;뷍-reverse plan for another action sequence  i.e.   p1   is easier than finding a 뷋;뷍-reverse plan for an action sequence  i.e.   p1  and  p1  . finding a 뷋;뷍reverse plan  where 뷋 and 뷍 are given is harder than finding a 뷋;뷍-reverse plan for arbitrary 뷋 and 뷍 for |r| = 1  but is of the same complexity in all other cases. these problems get more difficult when the length of r increases: problems  p1  and  p1  get more difficult when |r| 뫟 1  while problem  p1  gets more difficult when |r|   1.
모intuitively  the -completeness of  p1  and  p1  is due to the following intermingled sources of complexity:
모 i  the exponentially many action sequences r of a polynomially-bounded length and  in case of  p1   the exponentially many formulas 뷋 and 뷍 which need to be considered 
모 ii  the test that for all states such that 뷍 s  hold and s is reached from s after execution of as  every execution of r which starts in s ends in s  and  iii  the test that each partial execution of r starting in some state s as in  ii  can be continued with the next action  i.e.  the execution is not  stuck. 
모membership of problem  p1  in 붫p1 is straightforward from definitions 1 and 1. the 뷋;뷍-reverse plan property is easily rewritten to a prefix quantified boolean formula  qbf  with    pattern; evaluating such a formula is well-known to be in 붫p1. problem  p1  is thus in 쑗1  since a 뷋;뷍-reverse plan can first be guessed and then checked with a  oracle. in problem  p1   뷋 and 뷍 are w.l.o.g. conjunctions of literals and can be guessed along with the plan; the extra condition is checkable with an np oracle. hardness is shown by suitable reductions of evaluating qbfs.
모when limiting the length of the reverse plan  some quantifiers vanish. informally  when |r| = 1  source  iii  disappears  and similarly when |r| = 1 for  p1 . the reason is that ifand if the current state s and the state s to which we want to get back are known  then in the light of  ii  we just need to check whether is a valid transition  which is polynomial. in the case of  p1  and  we similarly just need to check after reaching s from s by executing a1 whetheris a valid transition. combined with other properties  this yields the  upper bound.
모in problems  p1  and  p1   we do not check that the formulas 뷋 and 뷍 are actually satisfied at some states s and s  respectively  such that s is reached from s be execution of as  if no such states exist  the problem is trivially solved . checking this condition changes the complexity of  p1  when |r| = 1 from conp to dp  which is the  conjunction  of np and conp ; it does not change the complexity of  p1 .
모the complexity of problems can be lower under some conditions. for example  if the reverse plan is short  i.e.  has a length bounded by a constant  and contains no parallel actions  and 뷋 뷍 are formulas from a polynomial size set of formulas  then only a polynomialnumber of candidates for 뷋;뷍reverse plans need to be checked for  p1 . if the executability of actions can be determined in polynomial time then  p1  gets conp-complete  and  p1  and  p1  get 쑗1-complete.
tractable cases. also tractability can be gained in certain cases. for example  if 뷋 and 뷍 are conjunctions of literals which have a single model and the description of transitions tr is such that for given fluent values s  resp. 
and action occurrences a all fluent values s  resp.  s  such that tr holds can be determined in polynomial time  then finding a short 뷋;뷍-reverse plan without parallel actions for a short action sequence is feasible in polynomial time. thus in particular  reversal of the current state in the execution of an action sequence is possible in polynomial time under these conditions.
1 computation of reverse plans
we compute reverse plans in the spirit of knowledge compilation  cadoli and donini  1 : first we compute offline reverse plans for some action sequences  and then use this information online to construct a concrete reverse plan for a given action sequence. in the offline phase  the computed reverse plans for action sequences are collected in a library. this library may not contain all possible reverse plans for all action sequences  since exponentially many of them exist   but a polynomial number of reverse plans for short action sequences  typically  of a few steps  and the reverse plans are short themselves . from these short reverse plans  one might efficiently compose online reverse plans for longer action sequences. for example  a reverse plan for the action sequence  can be composed of the two reverse actions b1 and b1 that undo the effects of two actions a1 and a1  respectively. as we show later  such a construction of a reverse plan for an action sequence  from the reverse plan library  can be done efficiently.
we define reverse plan items and libraries as follows.
definition 1 a reverse plan item  rpi  is a tuple of the form  as r 뷋 뷍  such that r is a 뷋;뷍-reverse plan for the  nonempty  action sequence as  where 뷋 = 뷋 f  and 뷍 = 뷍 f . an rpi is single-step  if |as| = 1  i.e.  as consists of a single action  and unconditional  if 뷋 = 뷍 = true.
definition 1 a reverse plan library l is a  finite  set of rpis; it is called single-step  resp.  unconditional   if each rpi in it is single-step  resp.  unconditional .
모there are various ways to compute rpis to fill a reverse plan library. thanks to the logical framework and definitions of reverse actions and plans  it is fairly straightforward to encode the problem of actually finding an rpi  as r 뷋 뷍  by algorithm reverse as 붫 l 
input:	action sequence 
sequence of formulas  percepts  붫 = 뷇1 f  ... 
뷇i f   reverse plan library l;
output: reverse plan rp for as from 붫 and l or  no 
 1 	for each j = 1 ... i 1 do s j  := 뫐;
;	/* trivially  si is reversible to itself */
 1  rp := reverse1 i ;
 1  if rp =  no  then return  no 
 1  else return  rp s 
figure 1: algorithm reverse to compute execution reversals using a multi-step plan library.
solving qbfs  which has been proposed as a problem solving method in the planning domain earlier  e.g.   rintanen  1 . another possibility is to reduce the problem to solving conformant planning problems defined relative to a modification of d. due to space reasons  we cannot give the details  and instead focus on the more interesting problem of online reverse plan computation.
모at runtime  when we do try to assemble a reverse plan  we can think of three increasingly expressive scenarios  depending on available state information in form of percepts 뷇j about some states sj  j = 1 ... i  of the execution:
모1. there is no information about the current state  si  and past states s1  s1  ...  si 1. in this situation  only unconditional reversal plans  assembled from unconditional rpis  might be used.
모1.  partial  information about the current state si is available  expressed by a formula 뷇i f  such that si is one of its models  but no information about the past states. in this case  we can also make use of conditional rpis.
모1.  partial  information about the whole execution history is available  formalized in terms of a sequence 붫 = 뷇1  ...  뷇i of formulas over fluent symbols  such that the state sj is a model of 뷇j f   for each j = 1 ... i. here  we might exploit an even larger set of rpis.
모clearly  scenario 1 generalizes the other ones; due to space limitations  we thus focus here on this general scenario.
모when we consider a multi-step plan library  i.e.  not necessarily a single-step plan library  finding a reverse plan rp is trickier since rp may be assembled from l in many different ways  and state conditions might exclude some of them. for instance  take as = l =
 	 	1 	   	 	1 	   	 	1 	  
. we can assemble the action sequence  and   or from  and.
however  in the former case  뷋1 might be false at the state resulting from reversing c by e  while  in the latter case  뷋1 might be true at the state resulting from reversing the action sequence by the action g. thus  we need to consider choices and constraints when building a reverse plan.
모fortunately  this is not a source of intractability  and a reverse plan from l can be found in polynomial time  if one exists  by the algorithm reverse in figure 1.
the auxiliary array s in the algorithms is used for keeping algorithm reverse1 j 
input:	integer j  1 뫞 j 뫞 i  =|as| ;
output: reverse plan from 뷇1 ... 뷇j  or  no  if none exists
 1  if ; /* empty plan */
 1  for each  as r 뷋 뷍  뫍 l s.t. as is a suffix
do
 1  if 뷇j   뷋 and 뷇j |as|   뷍 then
 1  begin
 1  ;	/* reversing to sj possible */
 1  rp := reverse1 j |as| ;
 1  if   then return r + rp
 1  end
 1  return  no 
figure 1: algorithm reverse1  in the scope of reverse.
information to which states sj a reversal is established. the main algorithm  reverse  initializes every s j   j   i  of s to 뫐 since this is false initially. the recursive algorithm reverse1 updates s whenever new knowledge is gained. for instance  if the action ai 1 can be reversed at state si  then we know that a reversal to si 1 exists and modify s i 1  accordingly. having this information available in s helps us to find a reverse plan for the action sequence as from l. also  it prevents us to explore the same search space over and over. the algorithm reverse starts constructing a reverse plan for an action sequenceby considering its suffixes as. for efficiently determining all as in l  we can employ search structures such as a trie  or indexed trie  to represent l: consider each node of the trie labelled by an action  so that the path from the root to the node would describe an action sequence in reverse order. if the node describes an action sequence as such that  as r 뷋 뷍  is in l  then the node is linked to a list of all rpis of form .
모the next theorem bounds the running time of algorithm reverse and states its correctness.
theorem 1  i  reverse as 붫 l  has running time o |as| |l| 몫 evalmax a  + min asmax l   |as|     where evalmax 붫 l  bounds the time to evaluate 뷇j   뷋 and 뷇j   뷍 for any 뷇j in 붫 and formulas 뷋  뷍 in l; and asmax l  = max{|as| |  as r 뷋 뷍  뫍 l}.
 ii  reverse as 붫 l  correctly outputs  relative to l  a reverse plan rp for as and 붫 or it determines that such a reverse plan does not exist.
corollary 1 reverse as 붫 l  is polynomial  if all percepts in 붫 are dnfs and all formulas in l are k-term dnfs  i.e.  where k is bounded by a constant  or cnfs.
모we remark that in an application setting  |as| as well as reverse plan r are expected to be small  bounded by a constant  and percepts 뷇i and the formulas 뷋  뷍 consist of a few literals. in this case  the running time is o |l|  i.e.  linear in the size of the reverse plan library l. if  moreover  only few of the entries in the reverse plan library match  then the running time can be drastically shorter.
1 related work
our work on undoing the execution of an action sequence has been partly motivated by  hayashi et al.  1; 1   where the user has to provide the reversal information. here  we describe a method which allows for automatic discovery of this knowledge. moreover  we describe a flexible online assembly of reverse plans from a reverse plan library. while  hayashi et al.  1; 1  just consider single actions and associated reverse actions  this library may contain arbitrary conditional action sequences  which the reverse plan algorithm can flexibly use. our work is further motivated by approaches to plan recovery in logic-based monitoring frameworks  de giacomo et al.  1; soutchanski  1; 1; fichtner et al.  1 . however  they either do not consider action reversals or define it in a different way  usually combined with goal reachability.
모the idea of backtracking for recovery in execution monitoring is similar in spirit to  reverse execution  in program debugging  zelkowitz  1; agrawal et al.  1   where all actions are undone to reach a  stable  state. our method is more general  since no execution history is required a priori. undoing and redoing actions on the database is at the heart of recovery in database management systems. however  also in this context  a log of the action history is available  and so the problem is significantly different.
모the complexity of planning in different action languages and the framework considered here has been studied e.g. in  baral et al.  1; liberatore  1; turner  1; rintanen  1; eiter et al.  1 . conformant planning is deciding  given an action domain and formulas init f  and goal f  describing the initial state  not necessarily unique  and a goal state  respectively  whether there exists some action sequence as whose execution in every initial state makes goal true. this problem is related to finding a reverse plan  and has similar complexity for plans of polynomial length  completeness . however  the problem is different: in action reversal  we lack a  known  goal to establish. moreover  conformant planning is 쑗1-complete already for plans of length 1  and recognizing conformant plans of this length is 붫p1-complete  turner  1   differing from the results in table 1.
1 conclusion
we formally defined undo actions and reverse plans for an action sequence  in the logic-based framework for action representation from  turner  1 . as we have shown  determining an undo action or reverse plan for an action sequence is intractable in general  more precisely  complete for the class  respectively  in the polynomial hierarchy . the intractability is explained  on the one hand  by the intractability of propositional logic underlying the framework  and  on the other hand  by the intrinsic complexity of non-determinism; nonetheless  tractability is gained under suitable restrictions. to cope with intractability  we presented a knowledge compilation approach by which undo actions and reverse plans can be efficiently constructed  under suitable conditions  in linear time  from a reverse plan library. an implementation of the compilation algorithms  including the generation of conditional reverse plan libraries  is currently in progress.
