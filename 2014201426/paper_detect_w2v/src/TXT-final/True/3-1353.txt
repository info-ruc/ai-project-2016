
we introduce hex programs  which are nonmonotonic logic programs admitting higher-order atoms as well as external atoms  and we extend the wellknown answer-set semantics to this class of programs. higher-order features are widely acknowledged as useful for performing meta-reasoning  among other tasks. furthermore  the possibility to exchange knowledge with external sources in a fully declarative framework such as answer-set programming  asp  is nowadays important  in particular in view of applications in the semantic web area. through external atoms  hex programs can model some important extensions to asp  and are a useful kr tool for expressing various applications. finally  complexity and implementation issues for a preliminary prototype are discussed.
1	introduction
answer-set programming  asp   gelfond and lifschitz  1  has recently attracted increasing interest as a declarative problem solving paradigm. in this approach  a problem is encoded in terms of a nonmonotonic logic program such that the solutions of the former can be extracted from the answer sets of the latter. due to the availability of efficient answer-set solvers  like smodels  simons et al.  1  or dlv  leone et al.  1   and various extensions of the basic language with features such as classical negation  weak constraints  or aggregates  asp has become an important kr formalism for declaratively solving ai problems in areas including planning  diagnosis  information integration  and reasoning about inheritance. for the challenging area of semantic web reasoning  extensions of asp have been proposed  facilitating interoperability with description logic reasoners  rosati  1; eiter et al.  1  or aiming at handling infinite  tree-structured models  heymans and vermeir  1 .
모however  for important issues such as meta-reasoning in the context of the semantic web  no adequate support is available in asp to date. motivated by this fact and the observation that interoperability with other software is  not only in this context  an important issue  we extend in this paper the answer-set semantics to hex programs  that is  higher-order logic programs  which accommodate meta-reasoning through higher-order atoms  with external atoms for software interoperability. intuitively  a higher-order atom allows to quantify values over predicate names  and to freely exchange predicate symbols with constant symbols  like in the rule
c x  뫹 subclassof  d c  d x .
an external atom facilitates to determine the truth value of an atom through an external source of computation. for instance  the rule reached x  뫹 #reach edge a  x 
computes the predicate reached taking values from the predicate #reach  which computes via #reach edge a  all the reachable nodes in the graph edge from node a  delegating this task to an external computational source  e.g.  an external deduction system  an execution library  etc. .
our main contributions are summarized as follows.
모 1  we define the syntax and answer-set semantics of hex programs  extending asp with higher-order features and powerful interfacing of external computation sources. while answer-set semantics for higher-order logic programs has been proposed earlier by ross   further extension of that proposal to accommodate external atoms is technically difficult since the approach of ross is based on the notion of unfounded set  which cannot be easily generalized to this setting. our approach  instead  is based on a recent notion of program reduct  due to faber et al.   which admits a natural definition of answer-set semantics.
모 1  external atoms are a useful abstraction of several extensions to asp including  among others  aggregates  description logic atoms  or agent programs. external atoms thus facilitate investigating common properties of such extensions  and can serve as a uniform framework for defining semantics of further similar extensions of asp. moreover  hex programs are a basis for the efficient design of generic evaluation algorithms for such extensions in this framework.
모 1  by means of hex programs  powerful meta-reasoning becomes available in a decidable context  e.g.  for semantic web applications  for meta-interpretation in asp itself  or for defining policy languages. for example  advanced closed world reasoning or the definition of constructs for an extended ontology language  e.g.  of rdf-schema  is wellsupported. due to the higher-order features  the representation is succinct.
모 1  a simple prototype implementation of the language is available  based on a reduction to ordinary asp.
모note that other logic-based formalisms  like triple  sintek and decker  1  or f-logic  kifer et al.  1   feature also higher-order predicates for meta-reasoning in semantic web applications. however  triple is low-level oriented and lack precise semantics  while f-logic in its implementations  flora  florid  ontoweb  restricts its expressiveness to well-founded semantics for negation  in order to gain efficiency. our formalism  instead  is fully declarative and offers the possibility of nondeterministic predicate definition with higher complexity. this proved already useful and reasonably efficient for a range of applications with inherent nondeterminism  such as diagnosis  planning  or configuration  and thus provides a rich basis for integrating these areas with meta-reasoning.
1 hex programs
1	syntax
let c  x  and g be mutually disjoint sets whose elements are called constant names  variable names  and external predicate names  respectively. unless explicitly specified  elements from x  resp.  c  are denoted with first letter in upper case  resp.  lower case   while elements from g are prefixed with  # . we note that constant names serve both as individual and predicate names.
모elements from c 뫋 x are called terms. a higher-order atom  or atom  is a tuple  y1 y1 ... yn   where y1 ... yn are terms; n 뫟 1 is the arity of the atom. intuitively  y1 is the predicate name  and we thus also use the more familiar notation y1 y1 ... yn . the atom is ordinary  if y1 is a constant.
모for example   x rdf :type c   node x   and d a b   are atoms; the first two are ordinary atoms. an external atom is of the form
모모모모모모#g y1 ... yn  x1 ... xm  	 1  where y1 ... yn and x1 ... xm are two lists of terms  called input and output lists  respectively   and #g 뫍 g is an external predicate name. we assume that #g has fixed lengths in #g  = n and out #g  = m for input and output lists  respectively. intuitively  an external atom provides a
모모모모모모way for deciding the truth value of an output tuple depending on the extension of a set of input predicates. example 1 the external atom #reach edge a  x  may be devised for computing the nodes which are reachable in the graph edge from the node a.	here  we have that in #reach =1 and out #reach =1.	1 a rule r is of the form 붸1 뫈 몫몫몫 뫈 붸k 뫹 붹1 ... 붹n not붹n+1 ... not붹m   1 
where m k 뫟 1  붸1 ... 붸k are atoms  and 붹1 ... 붹m are either atoms or external atoms. we define h r  = {붸1  ...  붸k} and b r  = b+ r  뫋b  r   where b+ r  = {붹1  ...  붹n} and b  r  = {붹n+1  ...  붹m}. if h r  =   and b r  1=    then r is a constraint  and if b r  =   and h r  1=    then r is a fact; r is ordinary  if it contains only ordinary atoms.
모a hex program is a finite set p of rules. it is ordinary  if all rules are ordinary.
1	semantics
we define the semantics of hex programs by generalizing the answer-set semantics  gelfond and lifschitz  1 . to this end  we use the recent notion of a reduct as defined by faber et al.   referred to as flp-reduct henceforth  instead of to the traditional reduct by gelfond and lifschitz . the flp-reduct admits an elegant and natural definition of answer sets for programs with aggregate atoms  since it ensures answer-set minimality  while the definition based on the traditional reduct lacks this important feature.
모in the sequel  let p be a hex program. the herbrand base of p  denoted hbp  is the set of all possible ground versions of atoms and external atoms occurring in p obtained by replacing variables with constants from c. the grounding of a rule r  grnd r   is defined accordingly  and the grounding of program p is given by grnd p  = sr뫍p grnd r . unless specified otherwise  c  x  and g are implicitly given by p.
example 1 given c = {edge arc a b}  ground instances of
e x b  are edge a b   arc a b   and arc arc b ; ground instances of #reach edge n  x  are #reach edge edge  a  
#reach edge arc  b   and #reach edge edge  edge   etc.1
모an interpretation relative to p is any subset i   hbp containing only atoms. we say that i is a model of atom a뫍hbp  denoted i |=a  if a뫍i.
모with every external predicate name #g 뫍 g  we associate an  n+m+1 -ary boolean function f#g assigning each tuple
 i y1 ... yn x1 ... xm  either 1 or 1  where n = in #g   m   i   and x 뫍 c.
of a ground external atom
a = #g y1 ... yn  x1 ... xm   denoted i |=a  if and only if f#g i y1 ...  yn  x1 ... xm =1.
example 1 let us associate with #reach a function f#reach such that f#reach i e a b  = 1 iff b is reachable in the graph e from a. let i = {e b c  e c d }. then  i is a model of #reach e b  d  since f#reach i e b d  = 1. 1 let r be a ground rule. we define  i  i |=h r  iff there is some a 뫍 h r  such that i |=a   ii  i |=b r  iff i |=a for all a뫍b+ r  and i 1|=a for all a뫍b  r   and  iii  i |=r iff i |=h r  whenever i |=b r . we say that i is a model of a hex program p  denoted i |=p  iff i |=r for all r 뫍grnd p . we call p satisfiable  if it has some model.
모given a hex program p  the flp-reduct of p with respect to i  hbp  denoted fpi  is the set of all r 뫍 grnd p  such that i |= b r . i  hbp is an answer set of p iff i is a
모minimal model of fpi.
we next give an illustrative example.
example 1 consider the following hex program p:
subrelation brotherof  relativeof   뫹 ; brotherof  john al  뫹 ; relativeof  john joe  뫹 ; brotherof  al mick  뫹 ;
invites john x  뫈 skip x  뫹 x    john 
모모모모모모모모모모#reach relativeof  john  x ; r x y   뫹 subrelation p r  p x y  ;
뫹 #degs invites  min max  min   1;
뫹 #degs invites  min max  max   1.
모informally  this program randomly selects a certain number of john's relatives for invitation. the first line states that brotherof is a subrelation of relativeof   and the next two lines give concrete facts. the disjunctive rule chooses relatives  employing the external predicate #reach from example 1. the next rule declares a generic subrelation inclusion exploiting higher-order atoms.
모the constraints ensure that the number of invitees is between 1 and 1  using  for illustration  an external predicate #degs from a graph library  where f#degs i e min max  is 1 iff min and max is the minimum and maximum vertex degree of the graph induced by the edges e  respectively. as john's relatives are determined to be al  joe  and mick  p has six answer sets  each of which contains one or two of the facts invites john al   invites john joe   and invites john mick .	1
we now state some basic properties of the semantics.
theorem 1 the answer-set semantics of hex programs extends the answer-set semantics of ordinary programs as defined by gelfond and lifschitz   as well as the answerset semantics of hilog programs as defined by ross .
모the next property  which is easily proved  expresses that answer sets adhere to the principle of minimality.
theorem 1 every answer set of a hex program p is a minimal model of p.
모a ground external atom a is called monotonic relative to p iff i  i1  hbp and i |=a imply i1 |=a. for instance  the ground versions of #reach edge a  x  are all monotonic.
theorem 1 let p be a hex program without  not  and constraints. if all external atoms in grnd p  are monotonic relative to p  then p has some answer set. moreover  if p is disjunction-free  it has a single answer set.
모notice that this property fails if external atoms can be nonmonotonic. indeed  we can easily model default negation not p a  by an external atom #not p  a ; the hex program p a  뫹 #not p  a  amounts then to the ordinary program p a  뫹 not p a   which has no answer set.
1	modeling asp extensions by external
atoms
by means of external atoms  different important extensions of asp can be expressed in terms of hex programs. 1 programs with aggregates
extending asp with special aggregate atoms  through which the sum  maximum  etc. of a set of numbers can be referenced  is an important issue which has been considered in several recent works  cf.  e.g.   faber et al.  1  . a nontrivial and challenging problem in this context is giving a natural semantics for aggregates involving recursion. the recent proposal of a semantics by faber et al.  is an elegant solution of this problem. we show here how it can be easily captured by hex programs.
모an aggregate atom a y t  has the form f{s}   t  where f is an aggregate function  sum  count  max  etc.   term  and s is an expression
  where x and y are lists of local variables  z is a list of global variables  and e~ is a list of atoms whose variables are among x  .
모for example  #count{x : r x z  s z y  } 뫟 t is an aggregate atom which is intuitively true if  for given y and t  at least t different values for x are such that the conjunction r x z  s z y   holds.
모given a y t  = f{s}   t as above  an interpretation i  and values y for y and t for t  f is applied to the set s i y  of all values x for x such that i |= e x y z  for some value z for z. we then have i |= a y t   i.e.  i |= f{x:e x y z }   t  iff f s i y     t.
모using the above notion of truthhood for a y t   faber et al.  define answer sets of an ordinary program plus aggregates using the reduct fpi.
모we can model an aggregate atom a y t  by an external atom #a y   t  such that for any interpretation i and ground version #a y  t  of it  f#a i y t =1 iff i |=a y t . note that writing code for evaluating f#a i y t  is easy.
모for any ordinary program p with aggregates  let #agg p  be the hex program which results from p by replacing each aggregate atom a y t  with the respective external atom #a y   t . the following result can then be shown:
theorem 1 for any ordinary program p with aggregates  the answer sets of p and #agg p  coincide.
1	description logic programs
the aim of description logic programs  or dl-programs   due to eiter et al.   is to combine a rule language under the answer-set semantics with description logics. informally  a dl-program consists of a description logic  dl  knowledge base l and a generalized normal program p which may contain queries to l  realized by means of special atoms  called dl-atoms  appearing in the body of rules. a dl-atom allows for specifying an input from p to l  and thus for a bidirectional flow of information between p to l  and for querying whether a certain dl axiom or its negation logically follows from l. the dl knowledge bases in dl-programs are theories in the description logics shif d  and shoin d   which represent the logical underpinnings of the web ontology languages owl lite and owl dl  respectively  bechhofer et al.  1 .
formally  a dl-atom is an expression dl x  of form
   dl s1 op1 p1 ... sm opm pm;q  x   m뫟1  where each si is a dl concept or role name  opi a change operator  pi a unary resp. binary predicate symbol  q a unary resp. binary predicate  and x a list of terms matching the arity of q. for space reasons  we confine here to opi =   and q being a possibly negated unary predicate name  for which x is a single term. intuitively  si   pi increases si in l by the extension of pi. for example  the dl-atom
         dl hascolor  color;whitewine  w  queries a wine ontology if w is known to be a white wine  after augmenting the ontology about wine color  hascolor  with facts about color from a program p.
모an interpretation i of p is a model of a ground instance dl c  of dl-atom dl x  with respect to dl knowledge base l  denoted  where |= is the entailment operator of the given description logic. that is  i |=l dl c  iff c belongs to concept q after augmenting l.
모eiter et al.  define answer sets of an ordinary nondisjunctive program p relative to a dl knowledge base l through a reduct spli  which extends the traditional reduct of gelfond and lifschitz . assuming that each ground dlatom dl c  is monotonic  i.e.  i |=dl c  implies i1 |=dl c   for i   i1; this is the predominant  treats negated dl-atoms like negated ordinary atoms. the resulting ground programhas a least model . then  i is a strong answer  holds.
모we can simulate dl-atoms by external atoms in several ways. a simple one is to use external atoms #dl x  where f#dl i c =1 iff i |=ldl c . let #dll p  be the hex program obtained from a dl-program  l p  by replacing each dl-atom dl x  with #dl x . we can then show:
theorem 1 let  l p  be any dl-program for which all ground dl-atoms are monotonic. then  the strong answer sets of  l p  and #dll p  coincide.
모note that we can extend the strong answer-set semantics to disjunctive dl-programs by simply extending the embedding #dll p  to disjunctive programs. this illustrates the use of hex programs as a framework for defining semantics.
1	programs with monotone cardinality atoms
marek et al.  present an extension of asp by monotone cardinality atoms  mc-atoms  k x  where x is a finite set of ground atoms and k 뫟1. such an atom is true in an interpretation i  if k 뫟 |x 뫌i| holds. note that an ordinary atom a amounts to 1{a}. an mca-program is a set of rules
       h 뫹 b1 ... bm not bm+1 ... not bn  1  where h and the bi's are mc-atoms. answer sets  stable models  for an mca-program p are interpretations i which are derivable models of an extended reduct pi  in the sense of gelfond and lifschitz    which treats negated mcatoms like negated ordinary atoms. informally  a model of pi is derivable  if it can be created from the empty set by iterative rule applications in which the heads of firing rules are nondeterministically satisfied.
모we can embed any mca-program p into a hex program #mc p  as follows. each mc-atom k x is modeled by an external atom e k x  = #k x    where f#kx i =1 iff k 뫟|x 뫌i|. in each rule of form  1   we replace h with a new atom th and all bi with e bi   and add the following rules  for h = k {a   ...  am} :
where  globally  n a is a new atom for each atom a. informally  these rules simulate the occurrence of the mc-atom in the head. then  the following correspondence holds.
theorem 1 for any finite mca-program p over atoms at  the answer sets of p and #mc p  projected to at coincide.
모as shown by marek et al.   asp extensions similar to mca-programs can be modeled as mca-programs. hence  these extensions can be similarly embedded into hex programs.
1	agent programs
eiter et al.  describe logic-based agent programs  consisting of rules of the form
       op1붸1 뫹 뷌    op1붸1 ...    opm붸m  governing an agent's behavior. the opi are deontic modalities  the 붸i are action atoms  and 뷌 is a code-call condition. the latter is a conjunction of  i  code-call atoms of the form in x f y    resp. notin x f y     which access the data structures of the internal agent state through api functions f y   and test whether x is in the result  and  ii  constraint atoms. for example  the rule
모모모do dial n  뫹 in n phone p   o call p  intuitively says that the agent should dial phone number n if she is obliged to call p.
모a semantics of agent programs in terms of  reasonable status sets   which are certain sets of ground formulas op붸  is defined by eiter et al. . they show that the answer sets of a disjunction-free logic program p correspond naturally to the reasonable status sets of a straightforward agent program ag p . conversely  code-call atoms as above can be modeled by external atoms #inf y   x  resp. #notinf y   x   and deontic modalities by different propositions and suitable rules. in this way  a class of agent programs can be embedded into hex programs as a host for evaluation.
1	applications
in this section  we show the usage of hex programs for different purposes  in which the joint availability of higher-order and external atoms is beneficial. for space reasons  the exposition is necessarily superficial and details will be omitted.
1	semantic web applications
hex programs are well-suited as a convenient tool for a variety of tasks related to ontology languages and for semantic-web applications in general  since  in contrast to other approaches  they keep decidability but do not lack the possibility of exploiting nondeterminism  performing metareasoning  or encoding aggregates and sophisticated constructs through external atoms.
모an interesting application scenario where several features of hex programs come into play is ontology alignment. merging knowledge from different sources in the context of the semantic web is a very important task  calvanese et al.  1 . to avoid inconsistencies which arise in merging  it is important to diagnose the source of such inconsistencies and to propose a  repaired  version of the merged ontology. in general  given an entailment operator |= and two theories t1 and t1  we want to find some theory rep t1 뫋 t1  which  if possible  is consistent  with respect to |= . usually  rep is defined according to some customized criterion  so that to save as much knowledge as possible from t1 and t1. also  rep can be nondeterministic and admit more than one possible solution.
모hex programs allow to define |= according to a range of possibilities; in the same way  hex programs are a useful tool for modeling and customizing the rep operator. in order to perform ontology alignment  hex programs must be able to express tasks such as the following ones:
importing external theories. this can be achieved  e.g.  in the following way:
triple x y z  뫹 #rdf uri  x y z ; triple x y z  뫹 #rdf uri1  x y z ;
proposition p  뫹 triple p rdf :type 
rdf :statement .
모모we assume here to deal with rdf theories.1 we take advantage of an external predicate #rdf intended to extract knowledge from a given uri  uniform resource identifier   in form of a set of  reified  ternary assertions. searching in the space of assertions. this task is required in order to choose nondeterministically which propositions have to be included in the merged theory and which not  with statements like pick p  뫈 drop p  뫹 proposition p .
translating and manipulating reified assertions. e.g.  for choosing how to put rdf triples  possibly including owl assertions  in an easier manipulatable and readable format  and for making selected propositions true  the following rules can be employed:
 x y z  뫹 pick p  triple p rdf :subject x   triple p rdf :predicate y    triple p rdf :object z ; c x  뫹  x rdf :type c .
filtering propositions. this way  it is possible to customize criteria for selecting which propositions can be dropped and which cannot. for instance  a proposition cannot be dropped if it is an rdfs axiomatic triple:1pick p  뫹 axiomatic p .
defining ontology semantics. the operator |= can be defined in terms of entailment rules and constraints expressed in the language itself  like in:
d x  뫹  c rdf :subclassof  d  c x ;
모모모모뫹 owl:maxcardinality c r n  c x   #countr r x  m  m   n  where the external atom #countr r x  m  expresses the aggregate atom #count{y : r x y  }=m. also  semantics can be defined by means of external reasoners  using constraints like
             뫹 #inconsistent pick   where the external predicate #inconsistent takes for input a set of assertions and establishes through an external reasoner whether the underlying theory is inconsistent.
1	closed world and default reasoning
reiter's well-known closed-world assumption  cwa 1 is acknowledged as an important reasoning principle for inferring negative information from a logical knowledge base kb: for a ground atom p c   conclude  p c  if kb 1|= p c . description logic knowledge bases lack this possibility.
모using hex programs  the cwa may be easily expressed on top of an external kb which can be queried through suitable external atoms. we show this here for a description logic knowledge base l. assuming that a generic external atom #dl1 c  x  for modeling a dl-atom dl c  x  is available  the cwa principle can be stated as follows:
c1 x  뫹 not #dl1 c  x  concept c   cwa c c1  o x  
where concept c  is a predicate which holds for all concepts  cwa c c1  states that c1 is the complement of c under the cwa  and o x  is a predicate that holds for all individuals occurring in l. for example  given that
l = {man v person  person lee }
for concepts man and person  the cwa infers  man lee .
모as well known  the cwa can become inconsistent. if in the above example  l contains a further axiom
person = man t woman 
with the concept woman  then the cwa infers  man lee  and  woman lee ; this is inconsistent with l.
모we can check inconsistency of the cwa with further rules  though:
set false c x  뫹 cwa c c1  c1 x  
inconsistent 뫹 #dl1 set false 뫐  b  
where #dl1 n c  x  effects a check whether l  augmented with all negated facts  c a  such that n c a  holds  entails c x   and 뫐 is the empty concept  entailment of 뫐 b   for any constant b  is tantamount to inconsistency .
모minimal-model reasoning  as under circumscription and the extended closed-world assumption  ecwa   for instance  avoids the problem of cwa inconsistency. we can foster the minimal herbrand models of l with respect to all concepts and individuals in l elegantly with the following hex rules:
set false c x  뫹 concept c  o x  not c x ; c x  뫹 #dl1 setfalse c  x .
here  the first rule intuitively expresses that if c x  is not included in an answer set m of p  then it should be set to false. the second rule states that c x  is in m  if c x  can be proved in l after setting all atoms in l to false according to m. by the minimality of answer sets  c x  can only then be in m. thus  in l no c x  can be switched to  c x  without raising inconsistency. hence  m corresponds to a minimal model of l. applied to our example  we obtain two answer sets  showing here only the interesting atoms :
m1 = {person lee  woman lee   set false man lee  ...} 
모모모모모m1 = {person lee  man lee   set false woman lee  ...}  corresponding to the minimal models of l.
모roles in l may be handled similarly. furthermore  one can easily restrict minimization to a subset of concepts and roles  and accommodate the general setting of ecwa and circumscription  dividing the predicates into minimized  fixed  and varying predicates p  q  and z  respectively. on top of minimal models  e.g.  reasoning tasks may then be performed.
모by maximizing rather than minimizing extensions  default reasoning  as in the approach by poole   on top of a dl knowledge base l may be supported. for example  the rules
white w  뫹 #dl1 null sparklingwine  w   not n white w  
n white w  뫹 #dl1 sparklingwine white  whitewine  w 
on top of a wine ontology l  express that sparkling wines are white by default  where #dl1 c u q  x  checks whether l  together with all facts c a  such that a뫍u  entails
 q x . given
모l = {sparklingwine veuvecliquot   lambrusco v  sparklingwine u  whitewine }  we then can conclude white veuvecliquot .
1	computational aspects
1	complexity
it appears that higher-order atoms do not add complexity compared to ordinary atoms. indeed  for finite c  the grounding of an arbitrary hex program p is  like for an ordinary program  at most exponential in the size of p and c. since hex programs with higher-order atoms subsume ordinary programs  we obtain by well-known complexity results for ordinary programs  dantsin et al.  1  the following result. recall that nexp denotes nondeterministic exponential time  and that for complexity classes c and d  cd denotes complexity in c with an oracle for a problem in d.
theorem 1 deciding whether a given hex program p without external atoms has some answer set is nexpnp-complete in general  and nexp-complete if p is disjunction-free.
모classes of programs with lower complexity can be identified under syntactic restrictions  e.g.  on predicate arities. furthermore  if from the customary asp perspective  p is fixed except for ground facts representing ad-hoc input  the complexity exponentially drops to npnp resp. np.
모on the other hand  external atoms clearly may be a source of complexity  and without further assumptions even incur undecidability. viewing the function f#g associated with an external predicate #g 뫍 g as an oracle with complexity in c  we have the following result:
theorem 1 let p be a hex program  and suppose that for every #g 뫍 g the function f#g has complexity in c. then  deciding whether p has some answer set is in nexpnpc  and is in nexpc if p is disjunction-free.
모however  there is no complexity increase by external atoms under the following condition on the cardinality of c:
theorem 1 let p be a hex program. suppose that for every #g 뫍 g  the function f#g is decidable in exponential time in |c|. then  deciding whether p has some answer set is
nexpnp-complete  and nexp-complete if p is disjunctionfree.
모informally  the reason is that a possibly exponential-size grounding compensates the exponentiality of external atoms  whose evaluation then becomes polynomial in the size of grnd p . the hypothesis of theorem 1 applies to external atoms modeling aggregate atoms and  under small adjustments  to dl-atoms  if |= is decidable in exponential time. some complexity results by faber et al.  on asp with aggregates and by eiter et al.  on interfacing logic programs with the description logic shif d  therefore follow easily from theorems 1  1  and 1.
1	implementation
an experimental working prototype for evaluating hex programs is available. several technical issues in an implementation arise  and we can only briefly address them here. in particular  higher-order and external atoms must be handled.
as for higher-order atoms  a polynomial reduction 붦 from
hex programs p to ordinary programs 붦 p  is possible if p has no external atoms. indeed  each higher-order atom y1 y1 ... yn  in p can be substituted with an ordinary atom an y1 y1 ... yn . since hex programs conservatively extend ordinary programs  cf. theorem 1   the answer sets of any hex program p without external atoms then correspond one-to-one with the answer sets of 붦 p . thus  hex programs without external atoms can be efficiently evaluated by using an existing asp solver.
모the presence of external atoms makes matters more complex. 붦 can still be applied to eliminate higher-order atoms from a hex program p  and a similar correspondence holds. we may further replace external atoms #g x~   y~   in 붦 p  by ordinary atoms p#g x ~ y~  . in the absence of negation as failure and for monotone external atoms  the answer sets of 붦 p  can be computed by a bottom-up fixpoint computation  which in case of disjunction is nondeterministic   in which ground atoms p#g ~a ~b  are evaluated with the external function f#g.
모in the presence of negation as failure  a notion of e-stratification  which generalizes the usual notion of stratification and exploits further dependency information supplied for external atoms  can be used to identify a substantial fragment of hex programs evaluable on the basis of a suitable operational semantics. in the unstratified case  guessing clauses

may be added for generating candidate answer sets of p. for monotone external atoms  the candidates can be verified by a fixpoint computation. for the general case  however  efficient checking methods are needed.
1	conclusion and further work
hex programs are a natural and powerful evolution of answer-set programming  asp   which fulfills interoperability needs with other software and supports at the same time abstract problem modeling by higher-order features. these features are needed for a wide range of applications but missing in asp systems today. in particular  user-defined libraries can be integrated  and thus customization to specific applications is enabled. our further and ongoing work includes implementation beyond the working prototype  for which suitable algorithms and techniques are currently under development. this and the prototype will be discussed in detail elsewhere. furthermore  an application in the context of an ongoing project for a personalized web information system is targeted.
references
 bechhofer et al.  1  s. bechhofer  f. van harmelen  j. hendler  et al. owl web ontology language reference. http://www.w1.org/tr/owl-ref/.
 calvanese et al.  1  d. calvanese  g. de giacomo  and m. lenzerini. a framework for ontology integration. in proc. swws-1  pp. 1  1.
 dantsin et al.  1  e. dantsin  t. eiter  g. gottlob  and a. voronkov. complexity and expressive power of logic programming. acm comp. surveys  1-1  1.
 eiter et al.  1  t. eiter  v.s. subrahmanian  and g. pick. heterogeneous active agents  i: semantics. artificial intelligence  1-1 :1  1.
 eiter et al.  1  t. eiter  t. lukasiewicz  r. schindlauer  and h. tompits. combining answer set programming with description logics for the semantic web. in proc. kr-1  pp. 1  1.
 faber et al.  1  w. faber  n. leone  and g. pfeifer. recursive aggregates in disjunctive logic programs: semantics and complexity. in proc. jelia-1  pp. 1  1.
 gelfond and lifschitz  1  m. gelfond and v. lifschitz. classical negation in logic programs and disjunctive databases. new generation computing  1-1  1.
 heymans and vermeir  1  s. heymans and d. vermeir. integrating semantic web reasoning and answer set programming. in proc. asp-1  pp. 1  1.
 kifer et al.  1  m. kifer  g. lausen  and j. wu. logical foundations of object-oriented and frame-based languages. j. acm  1 :1  1.
 leone et al.  1  n. leone  g. pfeifer  w. faber  t. eiter  g. gottlob  s. perri  and f. scarcello. the dlv system for knowledge representation and reasoning. acm transactions on computational logic  1. to appear.
  ukaszewicz  1  w.  ukaszewicz. non-monotonic reasoning: formalizations of commonsense reasoning. ellis horwood  1.
 marek et al.  1  v. marek  i. niemela 몮 and m. truszczynski.뫣 logic programs with monotone cardinality atoms. in proc. lpnmr-1  pp. 1  1.
 poole  1  d. poole. a logical framework for default reasoning. artificial intelligence  1-1  1.
 rosati  1  r. rosati. towards expressive kr systems integrating datalog and description logics: preliminary report. in proc. dl-1  pp. 1  1.
 ross  1  k. a. ross. on negation in hilog. journal of logic programming  1 :1  1.
 simons et al.  1  p. simons  i. niemela  and t. soininen.몮 extending and implementing the stable model semantics. artificial intelligence  1-1  1.
 sintek and decker  1  m. sintek and s. decker. triple - a query  inference  and transformation language for the semantic web. in proc. iswc-1  pp.
1  1.
     1 this work was partially supported by the austrian science fund  fwf  under grant p1-n1  and by the european commission through the ist networks of excellence rewerse  ist1  and colognet  ist-1   and the ist working group in answer set programming  ist-1 wasp .
모모모1 see http://www.w1.org/tr/rdf-mt/ for information about rdf.
모모모1 in a language enriched with weak constraints  we could maximize the set of selected propositions using a constraint of form
:몲drop p .
모모모1 throughout this section  we refer to  ukaszewicz  for 