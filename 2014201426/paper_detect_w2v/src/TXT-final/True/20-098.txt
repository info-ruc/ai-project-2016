: the plan or program for a manufacturing cell may be seen either from the workpiece  describing the successive operations that it wants to undergo during its track through the cell  or from the perspective of the workcell  describing its quasi-parallel operation on several workpieces which are processed simultaneously in the cell}. this paper addresses the question of how to verify tnat a proposed cell program implements a given workpiece program. the verification method is described informally using an example  and then formulated in precise and formal terms. 
1. 	the 	planning 	problem 	in 	factory 
automation. 
one of the important research problems in factory automation is improved methods for programming production cells. the flexible manufacturing environment has high demands on easy development and update of programs  and requires convenient  application- level dialogue between the engineer or operator who is in charge of the production cell  and the controlling computer system. it is not practically possible to satisfy these requirements only using conventional software engineering techniques. 
good software systems for programming production cells should make it possible to describe the desired behavior of the cell in terms of the objects which are present there  e.g. nc machines  robots  and conveyors   and in terms of the natural  elementary actions that those objects can perform  e.g. elementary move operations performed by an industrial robot . the techniques of knowledge based programming  often known as expert systems techniques  are well suited for realizing such a problem- oriented programming style. 
if artificial intelligence techniques are therefore likely to be useful for factory automation in this particular respect  it is equally true that the factory automation domain offers important and interesting problems for artificial intelligence. in particular  the production cell is a 'world' of non-trivial but limited complexity  where current techniques for planning and problem-solving can be further developed and refined. the present paper  hows how a method for planning and for reasoning about actions  suitably extended  can be used for a practically significant planning problem in production cells. 
this research was supported by the swedish board of technical development. 
1. pipelining of manufacturing plans. 
consider a simplified production cell for automatic manufacture  as illustrated in figure 1. successive workpieces arrive on the incoming conveyor  fl  and are processed by the three successive machines  x y  and z . a handling robot  r  moves the workpieces from i to x  movement operation a   from x to y  movement operation b   from y to z  movement operation c   and from z to outgoing conveyor  1  movement operation d . each of the machines may be for example an nc machine tool  a machine for finishing surfaces on the workpiece  or a machine for checking tolerances. 
we will use x also as a name for the operation performed by machine x  and similarly for y and z. we can usually assume that each of the operations x y z a b c d has a constant duration in time  and that the x y  and z operations take significantly longer time than the movement operations a-d. successive work cycles can be assumed to use the same  program  or  plan   which implies that the whole production cell has a well defined cycle time. one needs to determine the time-optimal plan  both in order to maximize the throughput of the production cell  and in order to balance the total production line which consists of several cells. 
the program or plan for the production cell may be seen from two different perspectives. for a particular workpiece  one will have the plan shown in figure 1. it says that the workpiece at hand first undergoes the a  movement  operation  then the x  processing  operation  etc. 
from the perspective of the production cell  we will instead have the plan shown in figure 1  where full-line arrows indicate steps in one work-cycle  and broken-line arrows indicate steps in the preceeding and succeeding work-cycles. the best way to understand the plan is by analogy with a 1-puzzle: when all machines contain a workpiece each  the only empty slot to which a workpiece may be moved is on the outgoing conveyor belt. the 'first* operation must therefore be for r to move a workpiece from z to o  operation d . after that  the workpiece that has finished operation y may be moved from y to z  operation c . after that again  the new workpiece in z may be processed  and at the same time the empty slot in machine y may be filled using operation b  and so the analysis continues. 
	sandewall 	1 
both these perspectives are legitimate and useful; we shall call them the workpieee program and the cell program  respectively. the cell program is significant because it is the program that the control software for the production cell primarily executes; it is the program on which the cell's cycle time must be calculated; and it describes the behavior of the cell as seen by the operator in charge. 
the workpieee program  on the other hand  represents an underlying and more fundamental plan. along the path of successive transformations  from the information in the cad system to the automatic manufacture  one would expect to go first from cad system information to the workpieee program  and then by another transformation to the cell program. in particular  if the configuration of the production cell is changed  for example by having a robot with two hands instead of one   then the cell program may change but the workpieee program remains constant. 
in the long run  we would therefore like to have methods which can determine an optimal cell program for a given workpieee program and a given cell configuration.  practical programs have a lot more complexity than this simple example shows . as a first step  we look for methods for verifying that a proposed cell program correctly implements a given workpieee program in a given cell configuration. the present paper addresses that problem. 
in our example  the workpieee program is entirely sequential  whereas the cell program involves parallelism. in more general cases  the workpieee program may also contain parallellism  e.g. in an assembly task where several sub-assemblies may be put together independently of each other  and then be finally mounted together. the transformation from workpieee program to cell program may sometimes impose constraints on the parallel execution of operations  namely if there is competition for shared resources such as  typically  the handling robot or the workpieee. on the other hand  the transformation may also introduce additional possibility for parallel execution of operations if the cell program handles several workpieces concurrently  in successive stages of completion. that latter aspect is similar to the concept of pipelining in computer architectures  and we shall use the term pipelining in the case of production cells as well. 
1. the solution through an example. 
we first show through the example how the workpieee program and the cell program may be related  in order to convey the general idea in an informal way. in the following sections we proceed to the formal treatment. 
consider the proposed cell program for the example  as represented graphically in figure 1. assume that the workpieces that flow through the production cell are assigned serial numbers  so that the first object to be manufactured obtains serial number 1  etc. within one cycle of the program  we label each operation which involves a workpieee  with the serial number of the workpieee that is processed there during the cycle in question. 
in figure 1  we see the results of the labeling  together with the continuation of the same labeling. in the next cycle  all operations have their serial numbers increased by 1  and so on in later cycles. we think of the cell program as a sequence of very many repeated occurrences of the same cycle  rather than as a formula saying * repeat the following cycle n times  . however  in spite of the arbitrary length of the cell program  those operations which are labeled with a given serial number will clearly be limited to five consecutive cycles of the cell program  corresponding to the number of cycles during which a workpieee stays within the production cell. 
now select from the cell program in figure 1  the substructure of those operations labeled with a certain serial number  as shown in figure 1. the resulting sub-structure represents the operations performed on a certain workpieee  and the relative ordering on those operations in time. we will call it the workpieee rogram that has been extracted from the cell program modulo the initial serial number labeling . we can see how figure 1 re-appears in figure 1  i.e. the original workpieee program is re-obtained by extraction from the cell program. 
the basic criterium on the relationship between the workpieee program and the derived cell program can now be expressed: for the proposed cell program  there must exist some serial-number labeling such that the resulting  extracted workpieee program is equal to  or a temporal strengthening of the given workpieee program. we say that p' is a temporal strengthening of p if p and 
p' contain the same operations  and every temporal ordering in p occurs also in p  but not necessarily the other way. 
in the example  p and p' are identical. in other examples where the given workpieee program contains parallel operations  it may happen that the cell program introduces additional temporal constraints due to shared resources  whereby also p' contains additional temporal orderings besides those found in p. 
besides this necessary relationship between the workpieee program and the cell program  there are also some other constraints on those programs  namely the familiar precondition/ postcondition constraints and the constraints of shared resources. we will get back to those issues in the next section. 
1. formal preliminaries. 
the previous section gave an intuitive notion of the method through an example  but it remains to cast it in precise and general form. the formal methods for reasoning about time and actions are legio. we will use the method previously described in  ref. 1   and we also refer to that paper for an overview of alternative approaches. 
in the approach we will be using  the world in which the plans are executed is characterized by a number of features  each of which may have either of a number of values  often a choice of two  boolean . a partial state assigns either of those values  or undefined  to each of 

1 	reasoning 

the features. the possible values of a feature are allowed to be chosen from a flat lattice  with undefined as the 


	sandtwall 	1 

1 	reasoning 

and the following three outgoing states: 
- c1 and c1 full - c1 and c1 full 
- cl full  join of prevail conditions of outgoing action occurrences  
the same feature does not occur in several incoming states  which means that the incoming states are anti-dimensional. also  if there were a conflict among the prevail conditions  the last incoming  resp. outgoing  state would be inconsistent. finally  the balancing condition is that each incoming feature assignment is also an outgoing feature assignment  and vice versa.  end of example . 
the requirements that have been specified here are not entirely sufficient; there is also an additional condition which is needed in order to avoid conflicting change of the same feature  by actions which are in the middle of two parallel actions sequences. for details please refer to ref. 1. 
1. 	representing 	concatenation 	of 	action structures. 
we can now proceed to those extensions to the formalism which are needed in order to formulate the relationship between the workpiece program and the cell program in general terms. we shall need formal ways to concatenate action structures  for example those representing individual cycles  into larger structures. we shall also need a way of assigning  and dealing with the 'serial numbers' of the workpieces. 
let it be assumed  then  that a workpiece program and a cell program are given as action structures  using states from the same state space and actions from the same set a of valid actions. the states should not register the serial number or other identification of workpieces  but there may be features which e.g. signify the presence or absence of a workpiece in a machine  or which signify whether a machine has finished processing the workpiece that it is currently holding. 
in order to analyze the cell program as in the example  we must first concatenate several cycles for the cell. there are well known formalisms which allow sequential composition of 'programs' in the sense of 'composite action descriptions'  for example dynamic logic  ref. 1  and the programming language occam  ref. 1 . these notations however work only if the cycle has a single starting point and end-point  i.e. if the partial order   in the action structure  t     p  has a smallest and a largest element. 
in our applications it is not possible to build up a cell program within the limits of single starting-points and end- points for all intermediate structures. we therefore need a structure which has several  entry points  and  exit points   in a way which resembles the concept of ports in programming languages. the concept of action structure is generalized as follows: 
an action fragment is a fivetuple  t     m  p  r   where t     p are like for action structures; m and r are sequences of members of t; m and r have equal length. 
also  the identity of the members of t is unimportant  so that if some other time-points are substituted throughout all five elements of the action fragment  we still have the same action fragment.  in other words we are really using the quotient structure w.r.t. the equivalence operation of permutation of time-points . 
consider two action fragments g1 = |t1   1 m l   p1  r1  g1 =  t1   1  m1  p1  r1  
intuitively  ml contains the time-points along the  left edge  of gl  and r1 the time-points along its  right edge . two fragments are concatenated by matching the right edge of one against the left edge of the next. 
the concatenated action fragment gl;g1 is therefore obtained as follows: rename the time-points in t1 in such a way that rl=m1  the elements in the two sequences are pairwise equal   and so that t1 and t1 are disjoint sets outside rl or m1. then form 
gl;g1 =  tl u t1     m l   p1 u p1  r1  
where the relation   is obtained so that x   y iff either of the following conditions holds: x   1 y x 1y for some z in r l   x   1 z and z  1 y 
it is easily seen that this definition corresponds to intuitions about the successive execution of  equal or different  cycles  and that the composition operation ; is associative. 
besides the criteria that have just been given  there must be additional conditions on the incoming and outgoing features in the edge nodes. we will show these conditions through a concrete example. 
1. representing the repeated cycle formally  in the example. 
figure 1 shows how the work cycle in the workcell example can be characterized as an action fragment  with the preconditions  postconditions and prevail conditions of the various action instances written out. the following graphical notations are used: 
full arrows   -   represent actions. the feature transitions of the action are written underneath the arrow. for example  'lx:1' under the x arrow means that while x is performed  the feature lx should have the value 1 as a prevail condition  i.e. throughout the action. '1 li e' means that the li feature should have the value 1 as a precondition and the value e as a ostcondition. the operation marked in this way 
namely a  changes the value of li from 1 to e. 
for each 'place' where a workpiece may be  there is a corresponding feature whose value is the serial number of the current workpiece in that place  or e if the place is empty. for example  the feature lx represents the serial number of the workpiece that is currently in the x machine. therefore the value of the feature lx must be kept constant while x is performed. also  we see in the figure how the move operations  a b c  and d  are characterized simply by how they change the values of the place features. thus if the lx place contains a 
workpiece with serial number 1  the ly place contains no object  feature value e   and the b operation is performed  ly receives the value 1 and lx reverts to the value e. 
	sandewall 	1 

timepoints are represented as nodes in the graph. square nodes represent timepoints on the left edge; triangle nodes represent timepoints on the right edge  and circular nodes represent other timepoints. solid black nodes represent duplicate copies of the same timepoint in the graph  and dotted connections  ....  connect one or more duplicates with the node they are duplicating. 
arrows with a broken line  -  represent the partial order   between nodes in those cases where there is no action connecting one to the other.  when there is such an action  the ordering   always follows . broken/dotted arrows  finally   -.-.-  represent additional persistence or 'noop' actions whicn have been inserted artificially in order to transfer the postcondition of one time-point to be a pre-condition of a later time-point. the broken/dotted line is omitted  and the persistence operations are understood  when there is already a broken line connecting the same nodes. 
the lower part of the figure summarizes  for each node  which are the incoming and outgoing values of each of the features. for example  the node at the end of the b 
1 	reasoning 
operation has the incoming values  1  e  1  for the three features  li  lx  ly   and the same outgoing values. this is an example of the node balancing condition on the action structure which was introduced at the end of section 1. 
if two action fragments have been concatenated  then the nodes on their common edge must also satisfy the node balancing condition when actions from both the two fragments are used. however  if one only considers the action occurrences inside one fragment  then the edge nodes of that fragment usually do not satisfy the node balancing condition. 
for those action fragments which are intended to be concatenated with themselves  in order to obtain cyclic behavior  and which we shall call rtpcatable action fragments  the balancing condition on the edge nodes can be obtained by combining corresponding left-edge and right-edge nodes. as is easily seen in figure 1  we can take the left-edge nodes  increase all serial-number values with 1  form the join with the corresponding right-edge node  where the join is taken separately for 

the incoming state and the outgoing state of the node  and then the node balancing criterium is satisfied. 
consider for example the second left-edge node  between the actions d and c in the figure. for the features  ly  lz  lo   this node has incoming values  -  e  l  and outgoing values  1  e  1   or the value pairs 
1 . the second right-edge node has the value pairs for the same features. incrementing all left-edge values by 1  except e which remains unchanged  we obtain  combining with the right- edge node we obtain  1  e/e  1  which satisfies the node balancing criterium.  here we let represent 'undefined' . 
most of the features  represent the various positions in the cell where a workpiece may 'be'  and most of the actions represent either the movement of a workpiece  or the operation on a workpiece inside one of the machines. the last feature  lgen  is used as the counter that assigns serial numbers. we see how the operation i  which advances the incoming conveyor  changes the contents of the li location from e to 1 in the figure  and at the same time it increases lgen from 1 to 1. in general  valid i actions are those where lgen is increased by one  and li changes from e to the new value of lgen. the auxiliary  'persistence' arrows transmit the value of lgen from the third left-edge node to the beginning node of the i action  and from the end node of the i action to the third right-edge node. 
in summary  then  figure 1 shows how the simple action-plan from figure 1 could be 'decorated' with feature values for preconditions  postconditions  and prevail conditions  and how it is extended with auxiliary persistence actions  so that the resulting action-plan satisfies a revised node balancing criterium which also takes the edge nodes into account. 
1. relationship between workpiece program and cell program in general and formal terms. 
we are now ready for the goal of this article  namely to formulate in precise terms the relationship between a workpiece program and a proposed cell program. we assume that the workpiece program is given as an action structure 
	gw =  tw    w   pw  	t 
and that the proposed cell program is given as a 
repeatable action fragment 
gc =  tc    c   mc  pc  re  
the same feature domains should be used for gw and gc  with the following exceptions: - the 'counter' feature lgen is omitted in gw; 
- the defined values of the position features is e or serial number in gc  but e or t  e = empty  t = taken  in gw. 
let succ gc  be the modified action fragment obtained from gc by increasing all numerical feature values with 1  and leaving the others  e and undefined  unchanged. it follows from the construction  and the criterium for well-formedness and repeatability for fragments  that succ gc  is also a correctly formed  and repeatable action fragment.  in fact a number of fairly routine constraints must also be satisfied  such as the existence of arcs that forward the current value of the lgen 'counter' to the next cycle  but this is not of any particular interest . 
therefore the cyclically repeated action fragment  ; succ gc  ; succ succ gc   ... 
is well formed. 
if  f b v e  is an action  and k is an integer  then the corresponding purged action 
purge 
is obtained in the following fashion: first remove from f  b  and e the lgen feature and all features which have a numerical value different from k in either of f  b  or e. the only remaining values are then k  e  and undefined. then change all occurrences of the k value to the value t. 
for example  a feature which has the value e in b and k in e is retained  but with the value t in e. a feature which has the value k+1 in b and the value e in e is removed from both b and e  i.e. obtains the value undefined in both. 
the purge of an action occurrence  t   is obtained by purging its middle element. 
if k is an integer  and  mc  pc  re   let the extracted action extr gc k  be defined as that action 
structure 

where: pk consists of purge a k  for those action occurrences 

in pc where some feature except lgen is defined and has the value k in either f  b or e; 
tk consists of those t in which occur in at least one action occurrence in  is the restriction of to tk. 
it is easily seen that 
¡¡¡¡extr gc*  k  is independent of k if k is   some small n  whose value is a function of how the lgen feature values were chosen in gc to begin with . this extr gc* k  for sufficiently large k will be written extr gc* . 
the requirement on correspondence between gw and gc is now that  if extr gc*  =  tr   *  prl  after suitable permutation of the time-points  we snail nave: 

if the other  previously mentioned conditions are satisfied  i.e. gw and gc are coherent etc.  and gc is repeatable  and if the correspondence condition is satisfied  then the cell program gc will correctly implement the workpiece program gw on successive workpieces in pipeline fashion. 
1. discussion  limitations. 
the most obvious limitation on the result above is that it only applies to the 'steady state' when the production process is running  all machines contain a workpiece each  etc. the analysis does not cover the start-up and shut-down stages  or the handling of exceptional cases 
	sandewall 	1 
such as when a workpiece breaks and has to be taken out of the cell. the analysis of those situations is a natural next step. 
the analysis also depends on the peculiar characters of the processing and move operations. if one would add e.g. an atomic 'swap1 operation which exchanges the contents of two locations  then the definition of the 'purge' function and the subsequent analysis would have to be revised. 
the formal treatment here only considers one type of workpieces  and requires non-trivial extensions for mixed-mode production where several types of workpieces are mixed in the same flow. 
a number of formal details have had to be omitted in this version of the paper  which is only intended for overview. the more precise version of the paper must be consulted by the reader who is interested in the exact and complete formulation of the conditions for correspondence between workpiece program and cell program. 
for similar reasons  the detailed aspects of how to generalize the requirements at the end of section 1 for edge-nodes in action fragments have been omitted here. 
related work. the theories and languages for concurrent programming address the issue of specifying 'two or more sequential programs that may be executed concurrently as parallel processes'  ref. 1 . their goal is therefore different from the goal of the present work  
which is to characterize parallel processes in the world outside the computer  but evidently the techniques may sometimes be interchangable. 
the method of path expressions  ref. 1  is similar in some respects to the approach taken in this paper. in particular  path expressions also separate the specification of operations from the the specification of constraints on the execution order. however  the analysis of preconditions/ postconditions/ prevail-conditions does not  to our knowledge  have a counterpart in path expressions. also the use of 'action fragments' whose left and right edges are sequences of time-points or execution states  are believed to be novel. 
a more extensive survey of methods from concurrent programming  and their relevance to the description of action structures is given in section 1 of  ref. 1 . 
1 	reasoning 
pipelining is a well known technique also in computer architectures. the classical technique for analysis of such pipelines is based on 'reservation tables'  ref. 1  which specify which resource s  are needed in each stage of processing  but which do not easily lend themselves to the analysis of the three types of logical conditions which are at the core of our approach. 
intentions for continued work. our own plans  for a longer perspective  is that we would like to have a formal characterization of all the essential steps when going from the product information in the cad system  to the production cell program  including also the formal description of the production equipment  the procedures for dealing with exceptional situations  etc. furthermore  the formal characterization should be usable as a specification and/or as a knowledge base for the actual software that controls the production cell. the work in this paper is one of the steps towards that goal. 
