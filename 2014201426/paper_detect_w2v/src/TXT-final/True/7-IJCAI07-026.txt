
the problem of most probable explanation  mpe  arises in the scenario of probabilistic inference: finding an assignment to all variables that has the maximum likelihood given some evidence. we consider the more general cnf-based mpe problem  where each literal in a cnf-formula is associated with a weight. we describe reductions between mpe and weighted max-sat  and show that both can be solved by a variant of weighted model counting. the mpe-sat algorithm is quite competitive with the state-of-the-art max-sat  wcsp  and mpe solvers on a variety of problems.
1 introduction
constraint satisfaction problems  csp  have been the subject of intensive study; many real-world domains can be formalized by csp models and solved by either complete or incomplete reasoning methods. beyond classic csp  where a solution must satisfy all hard constraints  some csp models are capable of handling both hard and soft constraints. the definition of constraints and the measurement of the quality of a solution vary from model to model  and the goal is usually to find a best solution to the constraints  rather than simply a solution. for example  the constraints can be associated with probability  cost  utility  or weight; the goal can be to minimize costs of violated constraints  or to maximize the likelihood of a variable assignment  etc. however  all fit in a general framework for soft constraints  namely  semi-ring based csps  bistarelli et al.  1 . in this paper  we focus on two specific models: mpe and weighted max-sat.
모max-sat extends sat to the problem of finding an assignment that maximizes the number of satisfied clauses  in case the formula is unsatisfiable. weighted max-sat extends max-sat by adding a weight to each clause  with the goal of finding an assignment that maximizes the sum of weights of satisfied clauses. max-sat and weighted max-sat problems are solved by either incomplete local search methods or complete branch-and-boundbased exhaustive search. for most max-sat problems  local search methods exhibit better speed and scaling than complete methods. local search methods  unfortunately  do not provide a proof that the returned solution is optimal.
모the success of modern complete sat solvers has inspired a numberof researchersto developimprovedcompletemaxsat algorithms. recent developments include using unit propagation for strong bound computation  li et al.  1; 1 ; adapting local consistency methods developed for csp to max-sat  de givry et al.  1 ; and using fast pseudo-booleansolvers to check the optimality of max-sat bounds  aloul et al.  1 .
모in probabilistic reasoning  the problem of most probable explanation  mpe  is to find an assignment to all variables that has the maximum likelihood given the evidence. exact methods for mpe on probability distributions represented by bayesian networks include well-known methods such as the join tree algorithm  jensen et al.  1   as well as a recent branch-and-bound algorithm  and/or tree search  marinescu and dechter  1 . since solving mpe exactly is nphard  local search algorithms have been introduced for approximation  park  1 . in this paper  we consider mpe on cnf formulas with weighted literals  where the goal is to find a solution with maximum product or sum of its literal weights. this cnf-based mpe problem is strictly more general than mpe for discrete bayesian networks  because any discrete bayesian network can be converted to a cnf with weighted literals whose size is linear in the size of conditional probability tables  cpts  of the network  sang et al.  1b .
모mpe on cnf can be viewed as a special case of weighted model counting  wmc   sang et al.  1b   and is likely easier than wmc because we may apply branch-and-bound based pruning techniques to reduce the search space. we choose cachet  sang et al.  1   a state-of-the-art model counting system  as a platform on which to build our mpe solver  and we extend pruning techniques for subproblems with components. as a result  we present mpesat  a decomposition-based branch-and-bound algorithm that works on top of wmc and prunes the search space effectively. furthermore  we are able to use the dtree algorithm of  huang and darwiche  1; darwiche  1  to boost the performance on problems with good decomposability.
모in general  mpe and weighted max-sat illustrate two complementary ways of representing soft constraints: either having weight on variables or having weight on constraints  clauses . although they have apparently different representations of weight and goals  they can be converted to each other by adding auxiliary variables or clauses  possibly at some loss in efficiency. in addition to describing these reductions  we show how to formulate cnf-based mpe as an iterative pseudo-boolean satisfiability  pbsat  process.
모in our experiments we compare our mpe solver mpe-sat with other state-of-the-art complete mpe/max-sat solvers as well as a pseudo-boolean solver on a variety of mpe and max-sat problems. our approach is quite competitive on most problems and is significantly faster than each of the other solvers on at least one of the classes of benchmarks.
1 mpe and weighted max-sat
the mpe problem originated in research on bayesian networks  one of the most popular graphical models. a bayesian network is a dag  where each source node has a prior probability distribution on its values and each non-source node has a conditional probability table  cpt  specifying the probability distribution of its values given the values of its parents. most probable explanation  mpe  is the problem of finding a complete assignment of values to nodes that has the maximum likelihood given some node values as evidence. the likelihood of a complete assignment is the product of the corresponding entries in the conditional probability tables and the prior probabilities. to solve mpe exactly  one can either compile the bayesian network into a junction tree and then propagate the evidence  jensen et al.  1   or perform a branch-and-bound search  e.g.  and/or tree search  marinescu and dechter  1 . alternatively  one can convert mpe to weighted max-sat and solve it by any local search algorithm  park  1 .
we begin with some definitions:
definition 1 a cnf formula with weighted literals is a cnf formula plus a function weight that maps literals to realvalued non-negative weights.
definition 1 given a combination operator  defined on the reals  the problem of mpe on cnf formulas with weighted literals is to find a complete satisfying assignment s that has the maximum 뇰weight vi   where vi is either the positive or negative form of the ith variable in s. to be convenient  we also define the inverse operator . mpe of an unsatisfiable cnf formula is defined to be 1.
모this cnf-based mpe can represent bayesian-networkbased mpe because there are linear reductionsfrom bayesian networks to cnf formulas with weighted literals  sang et al.  1b; chavira and darwiche  1 . practically  setting  to arithmetic + or 뫄  then  is either   or /  suffices our purposes . for example  뫄 is used for likelihood-originated mpe and + is used for weighted max-sat-originated mpe. in the rest of the paper  we will use the short term mpe for  mpe on cnf formulas with weighted literals   when there is no confusion.
모the problem of weighted max-sat on a cnf formula is to find an assignment that has the maximum sum of weights of all clauses satisfied by that assignment. when every weight is 1  weighted max-sat reduces to max-sat.
모both mpe and weighted max-sat optimize a metric of the weight  the only difference is that mpe has a weight on each literal and weighted max-sat has a weight on each clause. not surprisingly these two representations are equivalent in that they can be directly converted to each other.
mpe to weighted max-sat
we give a simple conversion for mpe on cnf to weighted max-sat  which is different from the encoding in  park  1  translates mpe on bayesian networks to weighted max-sat. assuming the combination operator is + 
  for each literal in mpe  a unit clause is added with weight equal to the weight of the literal.
  all original clauses in mpe are assigned an  infinite  weight  which is a number chosen to be at least as large as the sum of the weights added in the previous step.
모since all original clauses have an infinite weight  any optimal solution in weighted max-sat must satisfy them and maximize the sum of weights of satisfied unit clauses  which obviously maximizes the sum of literal weights in mpe and therefore is an optimal solution in mpe as well  and vice versa. the converted formula has a mixture of hard and soft constraints  which is a challenge for exact weighted maxsat solvers: to be efficient  they must take advantage of the hard constraints.
weighted max-sat to mpe
givry et. al. described a pseudo-boolean encoding for max-sat. although that does not explicitly refer to mpe  it can be modified for mpe by adding proper weights. our conversion is as follows:
  for every variable x in weighted max-sat  let weight x  = weight  x  = 1.
  for every clause ci in weighted max-sat  an auxiliary literal  yi is added to ci  with weight  yi  = 1 and weight yi  = weight ci .
모while the original formula for max-sat may be unsatisfiable  the converted formula is guaranteed to be satisfiable because one can always obtain a trivial solution by setting all auxiliary y variables to false. when the combination operator is fixed to sum  solving mpe on the converted formula finds a solution with a maximum sum of weight of y variables  which is equivalent to maximizing the sum of weights of satisfied clauses in weighted max-sat. this encoding does not add any clause  but needs as many auxiliary variables as the number of clauses. the inflated number of variables makes solving mpe more difficult  especially since auxiliary variables make every clause trivially satisfiable and thus unit propagation and conflict-driven learning become unavailable.
mpe and pseudo-boolean sat
 since the encoding in  de givry et al.  1  converts maxsat to pseudo-boolean sat and  weighted  max-sat and mpe are equivalent  we observe that there is a close relationship between mpe as pseudo-boolean sat as well. definition 1 given a cnf formula 뷋 and a set c of linear constraints over variables in 뷋  pseudo-boolean sat  pbsat  is to find a total assignment that satisfies both 뷋 and linear constraints in c. a linear constraint has the form  where vi is a variable that takes value 1 or 1  ai and d are real-valued constants and n is the number of variables.
모we show how to convert a likelihood-based mpe to an iterative pbsat process. in the context of likelihood  the combination operator  becomes 뫄  and a variable vi has weight vi  = pi and weight  vi  = 1   pi. without loss of generality  we assume 1   pi   1  otherwise if pi = 1  1  we solve the simplified formula with vi instantiated to 1  1 . the mpe goal is to find a complete satisfying assignment that maximizes
.
since  is a constant and log is an increasing function  this is equivalent to maximizing
.
this linear expression can be used as the left side of a linear constraint in pbsat  but we still need to figure out what bound d to put on the right side. by definition of mpe  we know that the optimal value must be in
. now we can iteratively search
for the bound d using binary search. at each step when d is set  we solve pbsat with a single linear constraint

in this way  we can get d arbitrarily close to the optimal value in a bounded number of steps.
1 algorithms and the implementation
in this section  we first examine a simple mpe algorithm and then show how to enhance it with some advanced techniques.
1 dpll for mpe
the na몮 ve algorithm 1 is a simple modification of the classic dpll search. first if the formula is empty  already satisfied   dpll-mpe returns the optimal value  e.g.  sum or product  of weights of unassigned variables  which becomes part of the current value; if the formula is unsat  dpll-mpe returns 1 by definition; otherwise it selects a variable to branch  recursively solves each branch and then returns the best value  which is the better one found in the two branches.
모unlike dpll for sat where the search halts when a sat leaf is found  dpll-mpe performs an exhaustive search over all possible sat leaves for the optimal value. it can be very slow without proper pruning  and that is why branch-andbound algorithms are widely used for many similar optimization tasks including max-sat and weighted csp.

algorithm 1 dpll-mpe

dpll-mpe 뷋  // returns mpe of cnf formula 뷋 if 뷋 is empty  return optimal value of unassigned variables if 뷋 has an empty clause  return 1 select an unassigned variable v 뫍 뷋 to branch return max dpll-mpe 뷋|v=1   weight  v   
dpll-mpe 뷋|v=1   weight v  

algorithm 1 mpe-sat

mpe-sat 뷋 lb  // returns mpe of cnf formula 뷋 if 뷋 is empty  return optimal value of unassigned vars if 뷋 has an empty clause  do nogood learning and return 1 do dynamic component detection: solve each separately do cache lookup: reuse previously computed values do dynamic bounding: if e 뷋  뫞 lb return 1 // pruning select an unassigned literal v 뫍 뷋 by branching heuristics
lresult = mpe-sat update lb according to lresult rresult = mpe-sat
result = max lresult  weight  v  rresult  weight v   do caching: addtocache 뷋  result  return result

1 branch-and-bound and decomposition
branch-and-bound is the underlying mechanism for most exhaustive search algorithms that find an optimal solution. the branch-and-bound algorithm maintains a global best solution found so far  as a lower bound. if the estimated upper bound of a node is not better than the lower bound  the node is pruned and the search continues with other branches.
모previous research has shown that decomposition and caching techniques are critical for such exhaustive search to be efficient  darwiche  1; bacchus et al.  1; sang et al.  1; marinescu and dechter  1 . however  with dynamic decomposition the simple form of branch-and-bound must be modified. during the search  a problem may decompose into several independent sub-problems  components  that  for efficiency  one would like to analyze separately. the branch-and-boundalgorithm must include a way of allocating portions of the global bounds to the individual components.
1 mpe-sat
to address the above issues  we develop mpe-sat  a new decomposition-based branch-and-bound algorithm with dynamic decomposition and caching. mpe-sat extends dpll-mpe with the following function blocks. since there are a number of similarities with the related and/or tree search algorithm  marinescu and dechter  1   we briefly compare our methods with that algorithm.
모dynamic component detection a connected component detection is performed dynamically for every non-trivial 뷋 in the search. since components of 뷋 are independent subproblems with disjoint variables  they are solved separately and then their results are combined to get the result for 뷋  though algorithm 1 does not show details of these obvious steps due to space limitation .  in and/or tree search  components are determined statically using the pseudo tree constructed before the search. 
모caching and cache lookup when the value of a component is known  the component with its value is stored in a hash table  caching  for later reuse  cache lookup   which avoids repeated computation. a component to store can be its corresponding clauses or a short signature of the clauses to save space. even when the exact value of a component is unknown because of pruning in its subtree  a proper bound can be cached for reuse too. the purpose of this bound caching is to save the partial work already done for a component that is to be pruned. a cached bound can be used as an estimated upper bound of the component for pruning and it is updated whenever a tighter bound or the exact value of the same component is found.  and/or tree search caches the context instead of the component itself. 
모dynamic bounding the parameter lb  initially  or given by local search  is the lower bound for 뷋 when 뷋 is created. e 뷋  is an upper bound estimation of the true value of 뷋  which can be simply 뇼뫍뷋max weight v  weight  v    a cached bound or a result by special computation  as described in section 1 . if e 뷋  is at most lb  the current branch is pruned for it will not yield a better result. note that for a subproblem  lb for its right branch may be better than lb for its left branch  because solving the left branch may improve the previous lb. when a sub-problem  component  is being solved  only local information is needed for pruning; i.e.  the bound from its parent and the bounds from sibling components  which are updated dynamically. a parent's lb is immediately broken and passed into its sub-problems for pruning
 top-down . for example  if sub-problem s splits into s1 and
s1 then . and . however  since s1 is solved after s1  lbs1 should be dynamically updated with the exact value of s1 replacing e s1 .  and/or tree search uses dynamic bounding as well but collects bounds from sub-problems  bottom-up . 
모branching heuristics any dynamic heuristic good for dpll search will work  and it turns out that decompositionbased heuristics are often very useful  as discussed in section 1 .  and/or tree search uses the statically-constructed pseudo-tree heuristic  which also aims at decomposition. 
모nogood learning the well-known conflict-driven clause learning technique for satisfiability testing  e.g.   zhang et al.  1   can be directly used for cnf-based mpe. learned clauses implicitly prune the infeasible search space.
모comparison since the top-down scheme passes the best known lower bound to a sub-problem once it is available  mpe-sat may examine fewer nodes than and/or tree does when pruning occurs. mpe-sat benefits from nogood learning that dynamically changes its variable ordering  with vsids or vsads heuristic   while nogood learning is likely less useful for the static pseudo-tree variable ordering. the dynamic component detection in mpe-sat is more powerful than the static detection in and/or tree search because the latter may miss some decomposition due to dynamic effects; however  the overhead of the former is much higher. finally  the more expensive component caching in mpe-sat is more powerful than context caching in and/or tree search  because different contexts may lead to the same component.
1 the implementation
the problemof modelcounting  countingthe numberof solutions of a cnf formula shares many features with mpe  both requiring exhaustive search. in dpll-mpe if we replace the max operation by sum  and the optimal value of a sat leaf is one  we will get a na몮 ve model counting algorithm. using the weighted model counting system cachet  sang et al.  1  as a platform  we have implemented the mpe-sat algorithm and the following to better support it.
모component processing components are processed in a depth-first order and the search stays within a component until it is finished. this component processing strategy is well suited to dynamic bounding for sibling components  but it is different from that for model counting. in cachet  once a component is found sat during search  the work on the rest of that component will be temporarily suspended and an unexploited component  if available  will be processed next. that strategy works well for finding unsat components as soon as possible  which is good for model counting; but in mpe-sat we want to continue working on a sat component until it is fully done  because the known value of a finished component yields better lower bounds for its siblings when they are checked for pruning.
모optimal solution retrieval in order to get the optimal solution as well as the optimal value  we need to maintain all partial solutions associated with all the active components on the current search path  from which we can compose the optimal solution at backtracking. the optimal partial solution of a component must be cached together with its exact value.
모branching heuristics the dynamic branching heuristics for sat and model counting such as vsids  vsads and eupc  moskewicz et al.  1; sang et al.  1a  work well for mpe too. these heuristics aim at maximizing the effect of unit propagation or avoiding the infeasible search space by learning from conflicts. however for max-sat problems  we have found that the dtree-based semi-dynamic branching heuristic  huang and darwiche  1; darwiche  1; 1  is often better  because in those problems unit propagations and conflicts that guide dynamicheuristics are no longer available whereas structural decomposition based heuristics are affected less. the dtree program by  huang and darwiche  1  computes a static variable group ordering based on dtree decomposition  darwiche  1   which is fed to mpe-sat. the semi-dynamic branching heuristic makes choices by dynamic heuristic for variables in the same group  but prefers variables in a group with higher priority and the group priorities are determined statically by dtree. the time for running dtree is usually insignificant compared to the time for solving the problem. a nice property of dtree is that after each group of variables is instantiated  from high to low priority   the problem is guaranteed to decompose. however  if a problem has a large tree-width  the sizes of the high priority groups by dtree can be so large that the search space blows up before the problem decomposes.
모upper bound computation we are able to extend the up heuristic  li et al.  1  to weighted max-sat in our solver. computing an upper bound on the weight of the satisfied clauses of formula 뷋 is equivalent to computing a lower bound on the weight of violated clauses of 뷋. the weight of violated clauses of 뷋 can be estimated as follows:
costlb = 1
for each unit clause of 뷋
simplify 뷋 by setting the current unit clause to true if there is an empty clause  conflict 
increment costlb by the minimum weight of the empty clause and the clauses for deriving it  and remove clauses for deriving the empty clause from 뷋
costlb is the lower bound of violated clauses at the end.
모we also adopt a trick from previousmax-sat solvers that when the value of a known solution and the current estimated value differ only by one  unit clauses are safely propagated.
1 experimental results
we tested with both cnf-based mpe and max-sat. the cnf-based mpe problems are either from random 1-cnf or structured cnf formulas with random literal weights  equivalent to weighted max-sat   or translated from bayesian networks  special because of the ad-hoc bayesian-network-to-cnf encoding . the maxsat problems are structured ones used in previous literature and fault diagnosis problems generated from standard circuit benchmarks that are challenging for many solvers. more details of these problems can be found at www.cs.washington.edu/homes/sang/benchmarks.htm we used the following state-of-the-art solvers:
모toolbar  de givry et al.  1; 1  : an exact weighted csp solverthat integrates efficient algorithmsformaintaining various levels of local consistency. it is a generic solver for weighted csp and weighted max-sat. we used version 1.
모up  li et al.  1  : an exact branch-and-bound maxsat solver using unit propagation and distinguishing independent conflicts for powerful lower bound computation.
모maxsatz  li et al.  1  : an exact branch-and-bound max-sat solver extending up with sophisticated lower bound computation techniques. highly optimized for maxsat  it was the winner of the 1 max-sat evaluation.
모pb1  aloul et al.  1  : a pseudo boolean sat solver that takes linear constraints. it can prove the optimality of encoded max-sat problems. basically  an auxiliary variable is added for each clause and there is a linear constraint limiting the sum of these added variables to the given bound.
모aotree  marinescu and dechter  1 : the and/or tree implementation that works for mpe of bayesian networks and weighted csp.
모mpe-sat: our solver that implements the mpe-sat algorithm. it is for cnf-based mpe and weighted max-sat.
모all experiments were done on a linux machine with 1 ghz pentium 1 cpu and 1 gb memory  except that we ran aotree on a windows machine with 1 ghz pentium 1 cpu and 1 gb memory. the runtime cutoff is 1 seconds. since not all solvers apply to the same domains  for each domain  we show the results only for the solvers that apply.
random mpe  1 variables 

figure 1: mpe of random 1-cnf  median runtime 
	problems	#vars	#clauses	toolbar	pb1	mpe-sat
ra11.1.1rb1x11rc1x1.1bitcomp11111bitmax11x11rand11xx1figure 1: mpe of circuit cnf and runtime in seconds.
problems#nodeinduced widthaotreempe-sat111.1-11111x111x111x1figure 1: mpe of grid bayesian networks and runtime in seconds.
모the first domain is mpe on satisfiable random 1-cnf formulas with random weights between 1 and 1 on each positive literal and 1 weight on each negative literal. the problems were converted to weighted max-sat via the encoding in section 1  introducing only positive unit clauses . since we use + as the combination operator  for mpe here  a direct translation to pbsat is adding a linear constraint where the weighted sum of all positive literals is at least a given bound. in principle we should run pb1 iteratively to optimize this bound  but we just set the bound as opt  for proving sat  and opt + 1  for proving unsat   because pb1 is not efficient enough on this domain.  the valueof opt was that found by other solvers.  for mpe-sat  we used the weight-based dynamic heuristic  where variable selections with good unitpropagated weights are preferred before a solution is found  to get a good bound early  and bad unit-propagated weights are preferred afterwords  to get prunings early .
모in figure 1  each point represents the median runtime on 1 instances. on the pb1 curve  the data point of ratio 1 is actually a timeout  median   1 seconds . compared to the other two  pb1 is very inefficient at low ratios  frequently timed out. however  as the problem gets more and more constrained with ratio increasing towards 1  pb1 improves significantly. mpe-sat has a similar trend: it is about two times slower than toolbar at low ratios  but gains a dramatic speedup at high ratios. apparently at high ratios mpe-sat and pb1 benefit a lot from clause learning by the underlying sat engine  which prunes most infeasible search space. the curve of toolbar is rather flat before ratio 1. for low ratio under-constrained problems  toolbar prunes the search space very effectively using advanced bounding techniques; however  without nogood learning  it is not effective at pruning using the constraints and so does poorly on well-constrained high ratio problems. this effect is amplified with 1 variables and ratio 1: toolbar often cannot solve an instance in an hour but mpe-sat can solve it in a few seconds.
모figure 1 shows the results of mpe on structured circuit cnf formulas with random variable weights. clearly most problems are easy to mpe-sat but hard or non-solvable to toolbar. we also ran pb1 with a na몮 ve binary search for the optimal value. pb1 works fine on all problems but one. it appears that cnf-based mpe suits mpe-sat and pb1 better than toolbar  which is optimized for weighted csp.
in figure 1  we compared with and/or tree search on
problemstoolbarpb1maxsatzupmpe-satpret11.11.1pret11.11.1pret1x1xx1pret1x1xx1dubois1111dubois1111dubois111x1dubois1x11x1dubois1x1xx1dubois1x1xx1dubois1x1xx1aim-1 1-n1111aim-1 1-n1111aim-1 1-n1x111aim-1 1-n1x111aim-1 1-n1111aim-1 1-n1111aim-1 1-n1111aim-1 1-n1111hole1.1.1.1.1.1hole1.1.1.1.1.1hole11111hole1111figure 1: max-sat problems from dimacs unsat instances and runtime in seconds  x = time   1 .
grid mpe problems on bayesian networks. an n 뫄 n grid network has binary-valued nodes indexed by pairs  i j   with node  1  as a source and  n n  as a sink. each node  i j  has parents indexed by  i 1 j  and  i j  1   and a fraction of nodes have deterministic cpts  sang et al.  1b . the sink is set to true as the evidence for mpe. the induced width of a bayesian network is a measure of its density. it is clear that mpe-sat dominates on all these highly deterministic problems by a large margin and aotree has difficulties on grid networks with large induced width. mpe-sat is not very sensitive to the induced width because the underlying sat engine can explore the local structures  introduced by deterministic entries  efficiently.
모the remaining experiments were on structured max-sat problems: examples considered in  de givry et al.  1; li et al.  1  and fault diagnosis problems. our mpe solver is competitive with the other solvers on most classes.  we do not show results for unstructured random max-sat problems where mpe-sat is not at all competitive because mpe-sat spends significant time on dynamic decomposition checking and caching  which is wasted because the problems have very dense constraints and hardly decompose.  for each problem  we gave all solvers the initial bound found by borchers' local search program for max-sat  borchers and furman  1   and the optimal value is defined as the minimum number of clauses violated. in fact  local search can quickly find the optimal bound of 1 for every problem in figure 1. all the solvers will find a solution value at least as good as the given bound.
모in figure 1  pb1 dominates on all problems  and mpesat is also quite good  outperforming toolbar and up on most problems. unlike other branch-and-bound solvers  pb1 proves the optimality of a given bound that becomes a single linear constraint. when the upper bound is 1  the problem is probably under-constrained  note that the encoding for pb1 is trivially satisfiable without the linear constraint   so pb1 can easily find a solution. it is also easy for pb1 to prove that all problems in figure 1 are unsat using sat techniques
	problems.	opt	bound	toolbar	pb1	maxsatz	up	mpe-sat
c1111111c11x11.1.1c11x11.1.1c11x1111c111.1.1.1.1c111.1.1.1.1c11xx111c11xx111c11111.1.1c11xxx11c11xxx11c11xxx11c11xxx1.1c11xxx1.1c11xxx11c11xxx11figure 1: max-sat problems from fault diagnosis and runtime in seconds  x = time   1 .
such as clause learning and non-chronological backtracking  which are unavailable for other max-sat solvers including mpe-sat  because of the max-sat-to-mpe encoding .
모mpe-sat works very well on pret and dubois problems  because they decompose quickly-they usually have small separator sets by dtree based heuristics. after those critical variables are instantiated  the problem decomposes into independent sub-problems and mpe-sat can solve them efficiently. for the same reason  mpe-sat works less well on some aim-1 and hole problems-the sizes of root separator sets vary from 1 to 1  large enough to be hard.
모toolbar and up have somewhat similar behaviors over problems in figure 1  in that they can solve all aim  except one  and hole problems and all fail on large pret and dubois problems  thoughup is faster up to a factor. for largepret and duboisproblemsthey seem to havedifficulty in finding a good solution matching the given upper bound  but for hole problems finding a good solution is easy: removing any clause makes the formula satisfiable.
모next  we show that pb1 is indeed not universally good for all max-sat problems. in figure 1  the fault diagnosis problems were generated from iscas-1 combinational circuits  brglez and fujiwara  1 . in a circuit we make some gates have stuck-at faults such that the output is inconsistent with the given input  so a mpe solution is a sound explanation with the least number of faulty gates. this problem can be solved by a sat based method that enumerates possible explanations  smith et al.  1 . an optimal solution often falsifies quite a few clauses. each entry in the /bound column is the initial upper bound  for solvers  returned by local search. it is interesting that local search cannot find any optimal value. pb1 at least takes one run to prove unsat  given bound = opt 1  and another run to prove sat  given bound = opt . so each number for pb1 is the sum of these two runtimes  and we ignore the insignificant portion of time for other runs.
모only up and mpe-sat can successfully solve all fault diagnosis problems  and up is faster by a constant factor. up is extremely efficient probably because of its lower bound computation: there are many binary clauses in these formulas and up may get a very tight lower bound by applying the unit literal rule iteratively. it is a little surprising that maxsatz  which is supposed to use more sophisticated lower bounding techniques than up  has serious difficulties on many problems. mpe-sat is efficient because it takes advantage of decomposition: the problems often decompose after a few instantiations when dtree heuristic is used. toolbar fails on most problems  while pb1 can solve problems with small optimal values  뫞 1  but fails on most problems with large optimal values  뫟 1 . we guess that in general pseudo-boolean solvers become very inefficient for max-sat when the optimal value is reasonably large  where it is hard to prove both sat and unsat.
1 conclusion
mpe and weighted max-sat are complementary representations for problems with soft constraints and we have described natural reductions between them. to solve these optimization tasks efficiently  we have presented an algorithm mpe-sat which incorporates various techniques with a dynamic flavor: including dynamic problem decomposition dynamic bounding  caching  a form of dynamic programming   and clause-learning. as a result  our approach is quite competitive with other solvers on a wide range of problem domains from mpe and max-sat and significantly outperforms each on at least one of the domains.
