
mitchell and ternovska  proposed a constraint programming framework based on classical logic extended with inductive definitions. they formulate a search problem as the problem of model expansion  mx   which is the problem of expanding a given structure with new relations so that it satisfies a given formula. their long-term goal is to produce practical tools to solve combinatorial search problems  especially those in np. in this framework  a problem is encoded in a logic  an instance of the problem is represented by a finite structure  and a solver generates solutions to the problem. this approach relies on propositionalisation of high-level specifications  and on the efficiency of modern sat solvers. here  we propose an efficient algorithm which combines grounding with partial evaluation. since the mx framework is based on classical logic  we are able to take advantage of known results for the so-called guarded fragments. in the case of k-guarded formulas with inductive definitions under a natural restriction  the algorithm performs much better than naive grounding by relying on connections between k-guarded formulas and tree decompositions.
1 introduction
np search and decision problems occur widely in ai; modelling these problems as sat  csp and asp and then using a corresponding solver are perhaps the most successful declarative approaches  in practice  to solving these problems. while each approach has made valuable contributions  they also have limitations. modelling in propositional logic and then using a sat solver is the oldest and the most developed of these approaches; the simplicity of the semantics has been the key driver in its success. however  propositional logic provides a poor modelling language in which there are no quantifiers  nor recursion. moreover  in modelling a problem as sat  there is no clear separation of instance and problem description. csp provides somewhat better modelling capabilities  and csp solvers rely on a number of solution techniques such as no-good learning and backjumping. csp solvers  however  have found success primarily as components of general purpose programming languages  and are thus not purely declarative. asp emerged from logic programming  and is based on the stable model semantics  gelfond and lifschitz  1 . the main advantage of asp is that its language allows an implicit use of quantifiers and has a built-in recursion mechanism. however  some concepts that are natural in classical logic are difficult to express in asp.
모mitchell and ternovska  proposed a declarative constraint programming framework based on classical logic extended with inductive definitions. they cast search problems as the classical problem of model expansion  mx   which is the problem of expandinga given structure with new relations so that it satisfies a given formula. their long-term goal is to developtools for solvinghard combinatorialsearch problems  especially those in np. in this framework  a problem is encoded in a logic such as first-order logic  fo  or an extension of fo  a problem instance is represented by a finite structure  and a solver generates extensions of initially unspecified predicates  which represent solutions to the problem.
모the mx framework combines many strengths of these three mentioned approaches  as well as addresses their limitations. its features include: a high-level modelling language that supports quantification and recursion  and a clear separation of the instance  a finite structure  from the problem description  a formula . most importantly  the framework is based on classical logic  making it possible to exploit the many existing results from finite model theory and descriptive complexity  kolokolova et al.  1 . in addition  axiomatizations are easier to understand  and we need not rely on stable model semantics to imitate the 'classical' part of the program  a common practice in asp.
모a key component in building practical solvers for the mx framework is propositionalisation  or grounding  of highlevel specifications and the use of efficient sat solvers. the idea is to first obtain a ground formula that contains only initially unspecified predicates and is satisfiable iff the original mx problem has a solution  and then call a propositional satisfiability solver. two prototype solvers for propositional formulas with inductive definitions have been developed  pelov and ternovska  1; marie몮n et al.  1 .
모the goal of this paper is to develop an efficient grounding algorithm for the mx framework. since the framework is based on classical logic  we take advantage of results known for the guarded fragments  andre뫣ka et al.  1; gottlob et al.  1 . we present a polytime algorithm for grounding k-guarded fo sentences with inductive definitions providedthat all predicatesin the guardsare initially specified  a fragment which we call igfk . as explained later  this restriction is necessary for polytime grounding  and igfk contains  in terms of expressive power  sentences with treewidth at most k. in practice  most sentences have small treewidth and thus can be put into igfk with small k. our algorithm runs in time  where  is the size of the sentence  and n is the size of the structure.
1 grounding for model expansion  mx 
we formulate search problems as the problem of model expansion  mx .
definition 1  mx  given a sentence 뷋 and a finite structure a with vocabulary    vocab 뷋   find a structure b that is an expansion of a to vocab 뷋  such that b |= 뷋.
example: let a be a graph g =  v ;e   and let 뷋 be:
	 	r	b	g	r	b
let b be an expansion of a to vocab 뷋 . then b |= 뷋 iff it corresponds to a 1-coloring of g.
모in the mx framework  there is a clear separation between problem instance  finite structure  and problem description  a formula . in grounding  we bring domain elements into the syntax by expanding the vocabulary and associating a new constant symbol with each element of the domain. for domain a  we denote the set of such constants by a . as notational conventions  we use  to denote the instance vocabulary and 붼 the expansion vocabulary.
definition 1  reduced grounding for mx  a formula 뷍 is a reduced groundingof a formula 뷋 over a -structure a =  a 효  if  1  뷍 is a ground formula over 붼 뫋 a ; and  1  for every expansion structure b =  a 효 붼b  over vocab 뷋   b |= 뷋 iff  b a b  |= 뷍  where a b denotes the interpretation of the new constants a .
during grounding the symbols of the instance vocabulary are  evaluated out  and a reduced grounding is obtained.
obviously  by the above definition  we have
proposition 1 let 뷍 be a reduced grounding of a formula 뷋 over a -structure a. then a can be expanded to a model of 뷋 iff 뷍 is satisfiable.
thus  through grounding  the model expansion problem is reduced to the satisfiability problem.
모in our grounding algorithm for a sentence  we must deal with subformulas 뷋 of the original sentence  뷋 may contain free variables . for a -structure a  we compute a formula 뷍 for each instantiation of the free variables of 뷋  such that each 뷍 is a reduced grounding of 뷋 under the corresponding instantiation. we call such a representation an answer to 뷋 wrt a. we compute an answer to a formula  by computing answers to its subformulas and combining them according to the connectives. to represent such answers  we introduce the concept of an extended relation  extending the notion of a relation from relational database theory .
definition 1  extended x-relation  let a =  a;효   and x be the set of free variables of formula 뷋. an extended x-relation r over a is a set of pairs  붺 뷍  s.t.  1  뷍 is a ground formula over 붼 뫋 a  and 붺 : x 뫸 a;  1  for every 붺  there is at most one 뷍 s.t.  붺 뷍  뫍 r.
an extended x-relation r is intended to represent a unique mapping  denoted by 붻r  from all possible instantiations of variables in x to ground formulas. for 붺's not appearing in r  the associated formula is false. we write 붺 뫍 r to mean that there exists 뷍 such that  붺 뷍  뫍 r.
definition 1  answer to 뷋 wrt a  let 뷋 be a formula in  뫋 붼 with free variables x  a a -structure with domain a  and r an extended x-relation over a. we say r is an answer to 뷋 wrt a if for any 붺 : x 뫸 a  we have that 붻r 붺  is a reduced grounding of 뷋 붺  over a. here  뷋 붺  denotes the result of instantiating free variables in 뷋 according to 붺.
as an example  letwhere
e x y  뫇 e y z    = {p}  and 붼 = {e}. let a be a -structure such that pa = { 1 1   1 1 }. then this extended relation r
xyz뷍11e 1  뫇 e 1 11e 1  뫇 e 1 is an answer to . it is easy to see  for example  that 붻r 1 1  = e 1  뫇 e 1  is a reduced grounding of  and 붻r 1 1  = false is a reduced grounding of.
the following extended relation is an answer to
xy뷍1e 1  뫇 e 1 1e 1  뫇 e 1 here  for example  e 1  뫇 e 1  is a reduced grounding of. finally  the following represents an answer to 뷋  where the single formula is a reduced grounding of 뷋.
뷍 e 1  뫇 e 1   뫈  e 1  뫇 e 1  모just as relations in databases have an algebra  i.e.  a set of operations whose semantics correspond to the connectives of fo logic  we define an algebra for extended relations. our algebra consists of join  join with complement  projection  intersection and union.
definition 1  join  join with complement  let r be an extended x-relation and s an extended y -relation  both over domain a. then
1. the join of r and s is the extended x 뫋 y -relation
	r	s	{ 붺 뷍 |	x	y	a 붺	뫍 r 
;
1. the join of r with the complement of s is the extended x 뫋 y -relation 붺|x 뫍 r  and 뷍
proposition 1 suppose that r is an answer to 뷋1 and s is an answer to 뷋1  both wrt structure a. then  1 is is an answer to
1 뫇   1 wrt	.
definition 1  y -projection  let r be an extended xrelation and y   x. the y -projection of r  denoted
by 뷇y  r   is the extended y -relation 붺|y for some.
proposition 1 suppose that r is an answer to 뷋 wrt a  and y is the set of free variables of  z뷋몬 . then 뷇y  r  is an answer to  z뷋몬 wrt a.
definition 1  intersection  union  let r and s be extended x-relations. then
1. the intersection of r and s is the extended x-relation
r 뫌 s = { 붺 뷍  | 붺 뫍 r and 붺 뫍 s  and 뷍 = 붻r 붺  뫇 붻s 붺 };
1. the union of r and s x r뫋s =     or   and = r    s    .
proposition 1 let 뷋1 and 뷋1 be formulas with the same set of free variables. suppose that r is an answer to 뷋1 and s is an answer to 뷋1  both wrt a. then  1  r 뫌 s is an answer to 뷋1 뫇 뷋1 wrt a;  1  r 뫋 s is an answer to 뷋1 뫈 뷋1 wrt a.
모in traditional relational algebra  projection can be done in linear time  and join can be done in time linear in the sum of the size of the input and output relations. detailed algorithms and proofs for this can be found in the appendix of  flum et al.  1 . the essential idea is this: first encode domain elements appearing in the input relations by natural numbers; then sort the encoded input relations using the bucket sort algorithm; next  compute the projection or join of the encoded input relations; finally  decode the resulting output relation. in our implementation of the operations on extended relations  we use the same idea except that we also need to copy formulas from the input relations to the output relation.
let r be an extended x-relation. the size of r  denoted
  is the sum of the size of each pair  붺 붻r 붺   in
  where |r| de-
notes the cardinality of r as a set  and is the size of the formula associated with 붺. it is easy to see that projection takes time  and intersection and union take time
. in general  join and join with complement take time. however  in our grounding algorithm in the next section  whenever we perform anor operation  it is always the case that the set of variables of s is a subset of that of r  every formula in r is true  and every formula in s is of size  where  is the size of the formula to be grounded. so the relation part  the set of tuples  of the resulting extended relation is a subset of that of r. thus both operations can be done in time  where n is the size of the relation part of r.
1 an algorithm for grounding fo formulas
the guarded fragment gf of fo was introduced by andre뫣ka et al. . here  any quantified subformula 뷋 must be relativized by a guard  i.e.  an atomic formula over all free variables of 뷋. gottlob et al. extendedgf to the k-guarded fragmentgfk where the conjunctionof up to k atoms may act as a guard  and proved that k-guarded sentences can be evaluated in time where  is the size of the formula  and n is the size of the structure. the proof is by transforming gfk-sentences into k-guarded non-recursive stratified datalog  nrsd  programs.
모a fragment related to gfk is the bounded variable fragment of fo - fok  which denotes fo formulas that use at most k distinct variables. kolaitis and vardi  showed that conjunctive queries in fok have the same expressive power as conjunctive queries of treewidth at most k. gottlob et al.  obtaineda similar logical characterizationfor the notion of hypertreewidth  a generalization of treewidth. they noted that hypertreewidth is bounded above by treewidth and showed that gfk has the same expressive power as fo sentences of hypertreewidth at most k.
definition 1  gfk  the k-guarded fragment gfk of fo is the smallest set of formulas s.t.  1  gfk contains atomic formulas;  1  gfk is closed under boolean operations;  1  gfk contains  x몬 g1 뫇...뫇gm 뫇뷋   if the gi are atomic formulas  m 뫞 k  뷋 뫍 gfk  and the free variables of 뷋 appear in the gi. here g1 뫇 ... 뫇 gm is called the guard of 뷋.
모note that this definition also includes universal quantification  since by  1   gfk is closed under negation. also note that the above mentioned complexity result only applies to k-guarded sentences  not k-guarded formulas in general. to see why  by the definition   r x y z  is a 1-guarded formula  but it cannot be evaluated in o n  time. however  the same complexity result applies to strictly k-guarded formulas  defined as follows:
definition 1  sgfk  the strictly k-guarded fragment sgfk is the fragment of gfk with formulas of the form  x몬 g1 뫇 ... 뫇 gm 뫇 뷋 .
here  we are including the degenerate cases where x몬 is empty  no leading existential quantifier   m = 1  no free variables and therefore no guards   or 뷋 is true. thus any k-guarded sentence is strictly k-guarded  take x몬 as empty and m = 1 .
모liu and levesque  presented a polytime algorithm for evaluating strictly k-guarded formulas: given a structure a and a formula 뷋 뫍 sgfk  the algorithm computes the answer to 뷋 wrt a  that is  {붺 | a |= 뷋 붺 }  in time.
a reason that they considered strictly k-guarded formulas instead of just k-guarded sentences is that their algorithm is recursively defined. in this section  we adapt their algorithm for grounding formulas in the following fragment:
definition 1  rgfk  rgfk denotes the set of strictly kguarded formulas such that no expansion predicate appears in any guard.
모note that the restriction that  no expansion predicate appears in any guard  is necessary for polytime grounding. indeed  there is no polytime grounding algorithm for 1-guarded sentences; otherwise  we would have a polytime reduction to sat from mx for 1-guarded sentences  and hence the combined complexity of this problem would be in np. however  it is nexp-complete since mx for fo can be reduced to mx for 1-guarded sentences  kolokolova et al.  1   and the combined complexity of mx for fo is nexp-complete.
모it is easy to see that any fok formula can be rewritten in linear time into an equivalent one in rgfk  by using atoms of the form x = x as parts of the guards when necessary. for example  the formula  x y r x 뫇e x y   can be rewritten into  x y r x  뫇 y = y 뫇 e x y    where r is an instance predicate  and e is an expansion predicate. extending the result of  kolaitis and vardi  1   flum et al.  showed that fok has the same expressive power as fo formulas of treewidth at most k. thus any fo formula with treewidth at most k can be put into an equivalent one in rgfk. in practice  most formulas have small treewidth and thus can be put into rgfk with small k.
모our grounding algorithm uses extended relations and operations on them. if 뷋 is an atomic formula r t몬   we use 뷋 a  to denote the extended relation { 붺 true  | t몬 붺  뫍 ra}.
procedure gnd a 뷋 
input: a structure a and a formula 뷋 뫍 rgfk output: an answer to 뷋 wrt a
suppose 뷋 몬x  =  y몬 g1 뫇 ... 뫇 gm 뫇 뷍 . return 뷇x몬gnd  where  and 뷍 is the result of pushing  's in 뷍 inward so that they are in front of atoms or existentials.
procedure gnd a r 뷋  is defined recursively by:
1. if 뷋 is a positive literal of an instance predicate  then gnd;
뷋 is an atom of an instance predicate 
then gnd;
1. if 뷋 is a literal of an expansion predicate  then gnd a r 뷋  = { 붺 뷋 붺   | 붺 뫍 r};
1. gnd a r  뷋 뫇 뷍   = gnd a r 뷋  뫌 gnd a r 뷍 ;
1. gnd a r  뷋 뫈 뷍   = gnd a r 뷋  뫋 gnd a r 뷍 ;
1. gnd a r  y뷋몬   = r  gnd a  y뷋몬  ;
1. gnd.
모unfortunately  the running time of gnd is not anymore. the reason is that gnd may generate intermediate extended relations whose size is not o nk . to see why  let 뷋 be the 1-guarded formula  x r x  뫇  y s y  뫇 e y     where e is an expansion predicate  and let a be a structure such that
ra = {1i + 1 | 1 뫞 i 뫞 m}  and sa = {1i | 1 뫞 i 뫞 m}.
obviously  the formula m is a reduced groundingof 뷋 over a  and it has size o n . however  when we use gnd  the intermediate extended relation corresponding to the subformula r x  뫇  y s y  뫇 e y   has size o n1   as shown in the following table  on the left :
x뷍x뷍11p1wmi=1 e 1i 1p...w
.........1m + 11m + 1pw
모to solve this problem  we let ignd be the algorithm which is the same as gnd except for the following: after each projection operation  we replace each formula in the resulting extended relation by a new propositional symbol. we also save the definitions of these new symbols. the output of the algorithm is the final extended relation together with the definitions of all the new symbols. for instance  in the above example  we will introduce a new propositional symbol p and save the definition. then the intermediate extended relation corresponding to the subformula r x  뫇  y s y  뫇 e y   will be as in the table on the right  and it has size o n .
to illustrate the algorithm  let 뷋 be the formula
 yzuv.r x y z  뫇 s z u v  뫇  {t x u v 뫇

 fgh.a x y f  뫇 b z g h  뫇   c f z  뫈 d x g  뫇 e y h  } 

where t and e are expansion predicates  and let a be
ra = { 1 1   1 1   1 1   1 1 } 
sa = { 1 1   1 1   1 1   1 1 } 
aa = { 1 1   1 1   1 1 }  ba = { 1 1   1 1 } 
                            
thenrgf1  where the underlined parts are guards. first  we push negation symbols inward until they are in front of atoms or existentials. the following figure represents the resulting formula by a tree  where rectangular internal nodes stand for guarded existentials  circular internal nodes for disjunctions or conjunctions  and leaves for literals.

now we process existentials from bottom to top. to process the bottom existential  we first evaluate the guard by a join operation. then we process leaves c  d and e wrt this guard relation using rules 1  1 and 1 of ignd respectively. the result of the guard relation joined with the complement of c is
xyfzgh뷍111true111truenext  we perform an intersection for conjunction  a union for disjunction  and a projection for existential  resulting in
xyz뷍11p11p11p1p1 뫖	e 1  p1 뫖	e 1  p1 뫖	true
now that we have an answer to this bottom existential  we process the top existential in a similar way forthe final answer
x뷍1q1q1q1 뫖   t 1 1  뫈  p1  뫈   t 1 1  뫈  p1  q1 뫖   t 1 1  뫈  p1  뫈   t 1 1  뫈  p1 
theorem 1 given a structure a and a formula 뷋 뫍 rgfk 
ignd returns an answer to time  where
 is the size of 뷋  and n is the size of a.  hence if 뷋 is a sentence  ignd returns a reduced grounding of 뷋 over a. 
proof sketch: rewrite 뷋 into an equivalent formula 뷋 by pushing negations inwards. correctness then follows by induction on the formula according to the algebra for extended relations. as to complexity  for each intermediate extended relation  there are o nk  tuples  each guard is composed of at most k atoms   and each formula has size  due to the introduction of new propositional symbols. by the complexity analysis from section 1  each of the operations on extended relations can be done in time. 
1 grounding inductive definitions
while fo mx is often sufficient  modelling often requires recursion and recursion through negation. the solution is to use fo id  logic  which is fo extended with inductive definitions  denecker  1; denecker and ternovska  1 . fortunately  adding inductive definitions does not violate the main complexity-theoretic results  mitchell and ternovska  1; kolokolova et al.  1 .
모the syntax of fo id  is that of fo extended with a rule saying that an inductive definition  id  is a formula. an id 붟 is a set of rules of the form  x몬 x t몬  뫹 뷋   where x is a predicate symbol  t몬is a tuple of terms  and 뷋 is an arbitrary fo formula. the connective 뫹 is called the definitional implication. in the rule  x몬 x t몬  뫹 뷋   x t몬  is called the head and 뷋 the body. a defined predicate of an fo id  formula is a predicate symbol that occurs in the head of a rule in an id. the semantics of fo id  is that of fo extended with one additional rule saying that a structure a satisfies an id 붟 if it is the 1-valued well-founded model of 붟  as defined in the context of logic programming  van gelder et al.  1 .
모for example  the problem of finding the transitive closure of a graph can be conveniently represented as an mx problem for fo id . the formula consists of a definition with two rules  defining the predicate t. the instance vocabulary has a single predicate e  representing the binary edge relation.

this states that the transitive closure of edge set e is the least relation containing all edges and closed under reachability.
모when it comes to mx for fo id   the expansion vocabulary usually includes all the defined predicates. all the definitions from section 1  namely definitions of mx  reduced grounding  extended relation  and answer  directly apply to fo id . also  through grounding  the mx problem for fo id  is reduced to the satisfiability problem of pc id   which stands for propositional calculus with inductive definitions. currently  two prototypes of such solvers have been developed: one  pelov and ternovska  1  reduces satisfiability of pc id  to sat  and the other  marie몮n et al.  1  is a direct implementation that incorporates sat techniques. while  both solvers deal with a restricted pc id  syntax  a solver for the general syntax is under construction in our lab.
모nonetheless  some important problems are represented as mx for fo id  where some defined predicates are in the instance vocabulary. the interpretation of these defined predicates is used to apply restrictions on the possible interpretations of the expansion predicates. in such a case  we will first do groundingtreating all defined predicates as expansion predicates. let 뷍 be the resulting ground formula. then we add to 뷍 an extra constraint that encodes the interpretation of the defined predicates. suppose g is the set of ground atoms of interpreted defined predicates that appear in 뷍. let   be the conjunction of literals of g that are true according to the interpretation. then 뷍 뫇   is the final ground formula to be passed to the satisfiability solver. thus we can restrict our attention to grounding where all defined predicates are expansion predicates.
모in this section  we extend the algorithm from section 1 to ground fo id  formulas in the following fragment:
definition 1  igfk  igfk is the extension of rgfk with inductive definitions such that for each rule  the body is in rgfk and all free variables of the body appear in the head.
as with rgfk  any fo id  formula with at most k distinct variables can be rewritten in linear time into an equivalent one in igfk. here we show how to rewrite each rule so that it satisfies the restriction of the above definition. first  for each x that appears in the head but not the body  add x = x to the body. now since the body still uses at most k distinct variables  it can be rewritten into rgfk.
we first present a procedure for grounding ids:
procedure gndid a 붟 
input: a structure a and an id 붟 뫍 igfk output: an answer to 붟 wrt a
for each rule r of 붟  suppose r is  x몬 x t몬  뫹 뷋   let 붟r be {x t몬  붺  뫹 뷍 |  붺 뷍  뫍 ignd a 뷋 }. return.
to illustrate the procedure  let 붟 be the id

where t is an expansion predicate. then 붟 뫍 igf1. note that for the purpose of illustration  we use c y  instead of y = y as a part of the second guard so that we can produce a small grounding. let a be ea = { 1   1 }  and ca = { 1 }. gndid a 붟  would proceed as follows:
1. call ignd a e x y   to get r
1. call ignd a  z c y  뫇 e x z  뫇 t z y    to get s
xy뷍1t 1 1t 1 1. replace rule 1 with {t x y  붺  뫹 뷍 |  붺 뷍  뫍 r}
1. replace rule 1 with {t x y  붺  뫹 뷍 |  붺 뷍  뫍 s}
the resulting ground id is
t 1  뫹 true
t 1  뫹 true 1 =
  t 1  뫹 t 1 
 : t 1  뫹 t 1   ;
모we now extend the grounding algorithm ignd from section 1 by adding the following clause. we call this enhanced algorithm for grounding igfk formulas ignd+.
1. if 뷋 is an id 붟 or its negation  붟  then ignd a r 뷋  = { 붺 p  | 붺 뫍 r} or { 붺  p  | 붺 뫍 r}  where p is a new propositional symbol with the definition p 뫖 gndid a 붟 .
the following is the main theorem of this paper:
theorem 1 given a structure a and a formula 뷋 뫍 igfk 
ignd+ returns an answer to time  where
 is the size of 뷋 and n is the size of a.
1 related work
our grounding algorithm is inspired by the grounding part of the model-checking algorithm of datalog lite  gottlob et al.  1   which is essentially 1-guarded datalog and admits model checking in time linear in both the size of the structure and the size of the formula. however  our grounding is aimed for the more general problem of model expansion. our algorithm also has similarity with the grounding techniques of the asp systems smodels  syrja몮nen and niemela몮  1   cmodels-1  lierler and maratea  1   and dlv  leone et al.  1   and the constraint programming system np-spec  cadoli and schaerf  1 . these systems produce efficient groundings in practice  however  they use logic programming syntax  which is much more restrictive. the precise complexity of grounding for these systems has not been determined  while we give an apriori time bound. finally  ramachandran and amir  proposed polytime algorithms to propositionalise certain classes of fo theories so that satisfiability is maintained. their goal is to solve satisfiability problem  not mx.
1 conclusions
classical logic is perhaps the most natural language for axiomatizing and solving computational problems. it has a long history  and sophisticated techniques have been developed. classical logic has intuitive and well-understood semantics  convenient syntax  and it is widely used by both theoreticians and practitioners. we therefore believe that tools based on classical logic to the highest degree possible will have a strong appeal. the mx frameworkof mitchell and ternovska  is a constraint programmingframework based on classical logic extended with inductive definitions. this paper represents an important progress in making this framework practical by developingan efficient groundingalgorithm. the algorithm performs well on k-guarded fo sentences with inductive definitions under the restriction that all predicates in the guards are initially specified; it runs in time   where  is the size of the formula  and n is the size of the structure. to this end  we have proposed the concept of extended relations and defined an algebra on them. the essence of our work is to exploit the structure of fo formulas: indeed  k-guarded formulas have the same expressive power as formulas with hypertreewidthat most k. a grounderbased on the data structure of extended relations has been implemented in our group. it performs comparablyon similar inputs to systems mentioned in related work. 