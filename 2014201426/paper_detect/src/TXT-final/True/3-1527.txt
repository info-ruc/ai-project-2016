
the treatment of exogenous events in planning is practically important in many domains. in this paper we focus on planning with exogenous events that happen at known times  and affect the plan actions by imposing that the execution of certain plan actions must be during some time windows. when actions have durations  handling such constraints adds an extra difficulty to planning  which we address by integrating temporal reasoning into planning. we propose a new approach to planning in domains with durations and time windows  combining graph-based planning and disjunctive constraint-based temporal reasoning. our techniques are implemented in a planner that took part in the 1th international planning competition showing very good performance in many benchmark problems.
1 introduction
in many real-world planning domains  the execution of certain actions can only occur during some predefined time windows where one or more necessary conditions hold. for instance  we can refuel a car at a gas station only during specific period s  of the day  when the gas station is open . the truth of these conditions is determined by some exogenous events that happen at known times  and that cannot be influenced by the actions available to the planning agent  e.g.  the closing of the fuel station .
모several frameworks supporting durations and time windows have been proposed  e.g.   vere  1; muscettola  1; laborie & ghallab  1; schwartz & pollack  1  . however  most of them are domain-dependent systems or are not fast enough on large-scale problems. in this paper  we propose a new approach to planning with these temporal features  that combines graph-based planning and constraintbased temporal reasoning.
모the last two versions of the language of the international planning competition  pddl1 and pddl1  support planning with action durations and deterministic exogenous events  fox & long  1; 1; edelkamp & hoffmann  1 . in particular  in pddl1  deterministic exogenous events can be represented by timed initial literals  one of the new pddl features on which the 1 competition focused. timed initial literals are stated in the description of the initial state of the planning problem through assertions of the form   attl    where t is a real number  and l is a ground literal whose predicate does not appear in the effects of any domain action. the obvious meaning of  attl  is that l is true from time t. a set of these assertions involving the same ground predicate defines a sequence of disjoint time windows over which the timed predicate holds. an example in the known benchmark domain   zenotravel  is
 at1 open-fuelstationcity1  
 at1 not open-fuelstationcity1   
 at1 open-fuelstationcity1    at1 not open-fuelstationcity1   
모these assertions define two time windows over which  open-fuelstation city1  is true. a timed initial literal is relevant to the planning process when it is a precondition of a domain action  which we call a timed precondition of the action. each timed precondition of an action can be seen as a temporal scheduling constraint for the action  defining the feasible time window s  when the action can be executed.
모when actions in a plan have durations and timed preconditions  finding a valid plan is a complex task that requires integrating planning and reasoning about time  to check whether the execution of the planned actions can satisfy their scheduling constraints. if an action in the plan cannot be scheduled  the plan is not valid  and it must be revised.
모the main contributions and organization of this work are:  i  a new representation of temporal plans with action durations and timed preconditions  integrating disjunctive constraint-based temporal reasoning into a recent graphbased approach to planning  section 1 ;  ii  a polynomial method for solving the disjunctive temporal reasoning problems that arise in our context  section 1 ;  iii  some new local search heuristics to guide the planning process using our representation  section 1 ;  iv  an experimental analysis evaluating an implementation of our approach  showing good performance with respect to other recent domain-independent temporal planners  section 1 .
1 temporally disjunctive action graph
in our approach  we represent a  partial  plan for a domain with timed initial literals through an extension of the linear action graph representation  gerevini  et al.  1   which we call temporally-disjunctive action graph  tda-graph .
1 background: linear action graph
a linear action graph  la-graph  a for a planning problem 붫 is a directed acyclic leveled graph alternating a fact level  and an action level. fact levels contain fact nodes  each of which is labeled by a ground predicate of 붫. each fact node f at a level l is associated with a no-op action node at level l representing a dummy action having the predicate of f as its only precondition and effect. each action level contains one action node labeled by the name of a domain action that it represents  and the no-op nodes corresponding to that level.
모an action node labeled a at a level l is connected by incoming edges from the fact nodes at level l representing the preconditions of a  precondition nodes   and by outgoing edges to the fact nodes at level l+1 representing the effects of a  effect nodes . the initial level contains the special action node astart  and the last level the special action node aend. the effect nodes of astart represent the positive facts of the initial state of 붫  and the precondition nodes of aend the goals of 붫.
모a pair of action nodes  possibly no-op nodes  can be constrained by a persistent mutex relation  i.e.  a mutually exclusive relation holding at every level of the graph  imposing that the involved actions can never occur in parallel in a valid plan. such relations can be efficiently precomputed using an algorithm given in  gerevini  et al.  1 .
모an la-graph a also contains a set of ordering constraints between actions in the  partial  plan represented by the graph. these constraints are  i  constraints imposed during search to deal with mutually exclusive actions: if an action a at level l of a is mutex with an action b at a level after l  then a is constrained to finish before the start of b;  ii  constraints between actions implied by the causal structure of the plan: if an action a is used to achieve a precondition of an action b  then a is constrained to finish before the start of b.
모the effects of an action node can be automatically propagated to the next levels of the graph through the corresponding no-ops  until there is an interfering action  blocking  the propagation  or the last level of the graph has been reached.
1 augmenting the la-graph with disjunctive temporal constraints
let p be a timed precondition over a set w p  of time windows. in the following  x  and x+ indicate the start time and end time of x  respectively  where x is either a time window or an action. we will describe our techniques focusing on action preconditions that must hold during the whole execution of the action  except at the end of the action  as for pddl1  over all  conditions   and on operator effects that hold at the end of the action execution.1
모in order to represent plans where actions have durations and time windows for their possible scheduling  we augment the ordering constraints of an la graph with  i  action duration constraints and  ii  action scheduling constraints. duration constraints have form a+   a  = dur a   where dur a  denotes the duration of an action a.1 duration constraints are supported by the representation presented in  gerevini  et al.  1   while the representation and treatment of scheduling constraints are a major contribution of this work.
모let 뷇 be the plan represented by an la-graph a. it is easy to see that the set c of the ordering constraints in a  extended with the duration constraints of the actions in 뷇  can

figure 1: an example of la-graph with nodes labeled by t values. square nodes are action nodes; circle nodes are fact nodes. dashed edges form chains of no-ops blocked by mutex actions. the t -values are the numbers inside round brackets. the action durations are the numbers inside square brackets. unsupported precondition nodes are labeled   -  .
be encoded into a simple temporal problem  stp   dechter  et al.  1   i.e.  a set of constraints of form y   x 뫞 t  where y and x are point variables and t is a real number. for instance  if ai 뫍 뷇 is used to support a precondition node of aj  then a+i   a j 뫞 1 is in c; if ai and aj are two mutex actions in 뷇 and ai is ordered before aj  then a+i   a j 뫞 1 is in c. moreover  for every action a 뫍 뷇  the following stpconstraints are in c: a+   a  뫞 dur a   a    a+ 뫞  dur a .
모a scheduling constraint imposes that the execution of an action must occur during the time windows associated with a timed precondition of the action. syntactically  it is a disjunctive constraint c1 뫈 몫몫몫 뫈 cn  where ci is of the form
모모모모모 yi1   x1i 뫞 ki1  뫇  yi1   x1i 뫞 ki1   yi1 x1i yi1 x1i are action start times or action end times  and ki1 ki1 뫍 r. for every action a 뫍 뷇 with a timed precondition p  the following disjunctive constraint is added to c:
 
.
w뫍w p 
definition 1 a temporally disjunctive action graph  tdagraph  is a 1-tuple ha t  p ci where
  a is a linear action graph;
  t is an assignment of real values to the nodes of a;
  p is the set of time point variables corresponding to the start times and end times of the actions labeling the action nodes of a;
  c is a set of ordering constraints  duration constraints and scheduling constraints involving variables in p.
모a tda-graph ha t  p ci represents the  partial  plan formed by the actions labeling the action nodes of a with start times assigned by t . figure 1 gives the la-graph and t -values of a simple tda-graph. the ordering constraints and duration constraints in c are:1
  .
assuming that p is a timed precondition of a1 with windows  1  and  1   the only scheduling constraint in c is:
 a+start   a 1 뫞  1 뫇 a+1   a+start 뫞 1  뫈  a+start   a 1 뫞  1 뫇 a+1   a+start 뫞 1 .
모the pair hp ci defines a disjunctive temporal problem d  dtp   stergiou & koubarakis  1; tsamardinos & pollack  1 .1 let ds be the set of scheduling constraints in d. we have that d represents a set 붣 of stps  each of which consists of the constraints in d ds and one disjunct  pair of stp-constraints  for each disjunction in a subset of ds. we call a consistent stp in 붣 an induced stp of d. if an induced stp contains a disjunct for every disjunction in ds  we say that such a  consistent  stp is a complete induced stp of d. an stp is consistent iff it has a solution. a solution of an stp is an assignment of real values to the variables of the stp that is consistent with every constraint in the stp. given an induced stp  we can compute in o n 몫 c  time a solution where each variable has the shortest possible distance from a+start  dechter  et al.  1; gerevini & cristani  1   for n variables and c constraints. we call such a solution an optimal solution for the induced stp under consideration.
모the values assigned by t to the action nodes of a are the action start times corresponding to an optimal solution of an induced stp. we call these start times a schedule of the actions in a. the t value labeling a fact node f of a is the earliest time t = ta + dur a  such that a supports f in a  and a starts at ta.
모if the induced stp from which we derive a schedule is incomplete  t may violate the scheduling constraint of some action nodes  that we say are unscheduled in t .
모the following definition gives a notion of optimality over the complete induced stps of a dtp that will be used in the next section.
definition 1 given a dtp d with a point variable p  a complete induced stp of d is an optimal induced stp of d for p  iff it has a solution assigning to p a value that is less than or equal to the value assigned to p by every solution of every other complete induced stp of d.
모an optimal schedule is an optimal solution of an optimal induced stp for a end. note that an optimal solution minimizes the makespan of the represented  possibly partial  plan.
1 solving the dtp of a tda-graph
in general  computing a complete induced stp of a dtp  if it exists  is an np-hard problem that can be solved by a backtracking algorithm  stergiou & koubarakis  1; tsamardinos & pollack  1 . however  given the particular structure of the temporal constraints forming a tda-graph  we show that this task can be accomplished in polynomial
solve-dtp x s 
1. if x =   then stop and return s;
1. x 뫹 selectvariable x ; x1 뫹 x   {x};
1. while d x  1=   do
1. d 뫹 selectvalue d x  ; d x  뫹 d x    {d};
1. s1 뫹 s 뫋 {x 뫹 d};
1. d1 x  뫹 d x ;	/* saving the domain values */
1. if forwardchecking-dtp x1 s1  then
1. solve-dtp x1 s1 ;
1. d x  뫹 d1 x ;	/* restoring the domain values */
1. return fail;	/* backtracking */
forwardchecking-dtp x s 
1. forall x 뫍 x do
1. forall d 뫍 d x  do
1. if not consistency-stp s 뫋 {x 뫹 d}  then
1. d x  뫹 d x    {d};
1. if d x  =   then return false; /* dead-end */ 1. return true.
figure 1: basic algorithm for solving a dtp. the input is the set x of the meta-variables in the meta csp of the dtp  and a  partial  solution s of the meta csp. d x  is a global variable storing the current domain of the meta variable x.
time with a backtrack-free algorithm. moreover  the algorithm computes an optimal induced stp for a end.
모without loss of generality  we can assume that each action has at most one timed precondition. it is easy to see that we can replace a set of timed preconditions of an action a with a single equivalent timed precondition  whose time windows are obtained by intersecting the windows forming the different original timed preconditions of a.
모as observed in  stergiou & koubarakis  1; tsamardinos & pollack  1   a dtp can be seen as a  meta csp   where the variables are the constraints  and the values of the meta-variables are the disjuncts forming the constraints. the constraints of the meta csp are not explicitly stated. instead  they are implicitly defined as follows: an assignment 붿 of values to the meta-variables satisfies the constraints of the meta csp iff 붿 forms a consistent stp  an induced stp of the dtp . a solution of the meta csp is a complete induced stp of the dtp.
모figure 1 shows an algorithm for solving the meta csp of a dtp  tsamardinos & pollack  1   which is a variant of the forward-checking backtracking algorithm for solving general csps. by appropriately choosing the next meta-variable to handle  function selectvariable  and its value  function selectvalue   we can show that the algorithm finds a solution  if one exists  with no backtracking. moreover  by a simple modification of the basic algorithm  we can derive an algorithm that is backtrack free even when the meta csp has no solution. this can be achieved by exploiting the information in the la-graph a of the tda-graph for decomposing its
dtp d into a sequence of  growing dtps . i.e. 
d = dlast   dlast 1   ...   d1 
where  i  last is the number of the levels in a   ii  the variables vi of di  i = 1..last  are all the variables of d corresponding to the action nodes in a up to level i  and  iii  the constraints of di are all the constraints of d involving only variables in vi. from the decomposed dtp  we can derive an ordered partition of the set of meta-variables x in the meta
csp of the original dtp
x = x1 뫋 x1 뫋 ... 뫋 xlast 
where xi is the set of the meta-variables corresponding to the constraints in di   di 1  if i   1  and in d1 otherwise.
모this ordered partition is used to define the order in which selectvariable chooses the next variable to handle  which is crucial to avoid backtrack: every variable with a single domain value  i.e.  an ordering constraint or duration constraint  is selected before every variable with more than one possible value  i.e.  a scheduling constraint with more than one time window ; if xi 뫍 xi  xj 뫍 xj and i   j  then xi is selected before xj.
모also the order in which selectvalue chooses the value for a meta-variable is important: given a meta-variable with more than one value  we choose the value corresponding to the earliest available time window. e.g.  if the current domain of the meta-variable is
 
then selectvalue chooses the j-th value  time window  such that   for every h 뫍 {1 ... m}  h 1= j.
모by using these techniques for selecting the next variable to handle and its domain value in the algorithm of figure 1  we can derive the following result.1
theorem 1 given a dtp d for a tda-graph  if the meta csp x of d is solvable  then solve-dtp finds a solution of x with no backtracking. moreover  this solution is an optimal induced stp of d for a end.
모as a consequence of the previous theorem  we have that  if solve-dtp performs backtracking  step 1   then the dtp under consideration has no solution. thus  we can obtain a backtrack free algorithm by replacing step 1 with
1. stop and return fail.
모it is easy to see that in the modified algorithm  called solvedtp+  every variable is instantiated at most once with the same value. it follows that  under the assumptions that we have a constant maximum number of action preconditions and  for every scheduling constraint  a constant maximum number of windows  the total runtime complexity of solvedtp+ is polynomial.
theorem 1 given a tda-graph g with dtp d  solve-dtp+ processes the meta csp corresponding to d in polynomial time with respect to the number of action nodes in g.
모the actual algorithm that we developed for our planner to find an induced stp for the dtp of a tda-graph contains some improvements making it more efficient. for lack of space and simplicity of presentation  we omit a detailed description of the improved algorithm  and we indicate only the main differences  which are the following ones:
  the consistency of the stp formed by the values of all the variables of the meta csp x with single-valued domains can be checked at the beginning of solve-dtp  using a single-source shortest-path algorithm: if such an stp is inconsistent  then x has no solution;
  forward checking is performed only once for each metavariable: if the first value chosen by selectvalue is not feasible  i.e.  forwardchecking-dtp returns false   then x has no solution  and thus we can stop the algorithm;
  finally  the improved algorithm is incremental since  as we will see in the next section  at each search step the dtp of the tda-graph is updated as a consequence of adding a new action node to the graph  or removing an existing one.
모moreover  in order to use the local search techniques described in the next section  we need another change to the basic algorithm: when the algorithm detects that x has no solution  instead of returning failure   i  it processes the next meta variables  and  ii  when it terminates  it returns the  partial  induced stp s formed by the stp-constraints of the dtp and the values assigned to the meta-variables. the optimal solution of s defines the t -assignment of the tda-graph. in the next section  sg denotes the induced stp for the dtp of a tda-graph g computed by our method.
1 local search techniques for tda-graphs
a tda-graph ha t  p ci may contain two types of flaw: unsupported precondition nodes in a  propositional flaws   action nodes in a that are unscheduled in t  temporal flaws . if a level of a contains a flaw  we say that this level is flawed. a tda-graph with no flawed level represents a valid plan  and it is called a solution graph.
모in this section  we present new heuristics for searching a solution graph in the space of tda-graphs. these heuristics are used to guide a local search procedure  called walkplan  that was originally proposed in  gerevini  et al.  1   and that is the heart of search engine of our planner.
모the initial tda-graph contains only astart and aend. each search step identifies the neighborhood n g   successor states  of the current tda-graph g  search state   which is a set of tda-graphs obtained from g by adding a helpful action node or removing a harmful action node in the attempt to repair the earliest flawed level of g.1 in the following  ai denotes an action node a at level i of a  and la the level of a.
모given a flawed level l of g  an action node ai is helpful for l if its insertion into g at a level i 뫞 l removes a propositional flaw at l; ai is harmful for l if its removal from a level i 뫞 l of g  i  would remove a propositional flaw at l  or  ii  would decrease the t -value of al  if al is unscheduled  intuitively  al is unscheduled if c forces it to start  too late  .
모the addition/removal of an action node a requires us to update the dtp of g by adding/removing some ordering constraints between a and other actions in the la-graph of g  the duration constraints of a  and the scheduling constraint of a  if any . from the updated dtp d  we can use the method described in the previous section to revise t   and to compute a possibly new schedule of the actions in g  i.e.  an optimal solution of sg .
모the elements in n g  are evaluated using a heuristic evaluation function e consisting of two weighted terms  estimating the additional search cost and temporal cost of the elements  i.e.  the number of search steps required to find a solution graph and the plan makespan  respectively . an element with the lowest cost is then selected from n g  using a
모 noise parameter  randomizing the search to escape from local minima  gerevini  et al.  1 . for lack of space  in the rest of this section we focus only on the search cost term of e. the search cost of adding an helpful action node a to g is estimated by constructing a temporal relaxed plan 뷇 achieving  1  the unsupported precondition nodes of a   1  the propositional flaws remaining at l after adding a  and  1  the supported precondition nodes of other action nodes in g that would become unsupported by adding a. moreover  we count the number of:  1  action nodes that would become unscheduled by adding a to g   1  unsatisfied timed preconditions of a   1  actions of 뷇 with a scheduling constraint that we estimate cannot be satisfied in the context of g. the search cost of adding a to g is the number of actions in 뷇 plus  1    1  and  1 .
모the evaluation of a tda-graph derived by removing an harmful action node a is similar  with 뷇 achieving the precondition nodes supported by a that would become unsupported by removing a and  when la precedes the flawed level l under reparation  the unsupported precondition nodes at level l that would not become supported by removing a.
모뷇 is constructed using a polymomial backward process similar to the algorithm proposed in  gerevini  et al.  1   giving in output two values: a set of actions forming a  sub relaxed plan  and its estimated earliest finishing time. the initial state i is the state obtained by applying the actions of g up to level la   1  ordered according to their levels.
모the main difference in the extended algorithm concerns the choice of the actions forming the relaxed plan. the action b chosen to achieve a  sub goal g is an action minimizing the sum of  i  the estimated minimum number of additional actions required to support its propositional preconditions   ii  the number of supported precondition nodes in the la-graph that would become unsupported by adding b to g   iii  the number of timed preconditions of b that we estimate would be unsatisfied in g extended with 뷇  timedpre b  ; and  iv  the number of action nodes scheduled in t that we estimated would become unscheduled by adding b to g  timethreats b  .  i - ii  are computed as described in  gerevini  et al.  1 ;  iii - iv  are new components of the action selection method  and they are computed as follows.
모in order to compute timedpre b   we estimate the earliest start time of b  est b   and the earliest finishing time of b  eft b  . using these values  we count the number of the timed preconditions of b that cannot be satisfied. eft b  is est b  + dur b   while est b  is the maximum over
  the lowest earliest start time of b computed by an extension of the reachability analysis algorithm given in  gerevini  et al.  1   which derives a lower bound on the start time of each domain action;
  the t -values of the action nodes ci  with i   la  that are mutex with b  because the addition of b to g would determine the addition of c+i   b  뫞 1 to g ;
  the maximum over an estimated lower bound on the time when all the preconditions of b are achieved in relaxed plan  this estimate is computed from the causal structure of the relaxed plan  the duration and scheduling constraints of its actions  and the t -values of the facts in the initial state i .
모in order to compute timethreats b   we use a notion of time slack between action nodes.
definition 1 given two action nodes a1 and a1 of a tdagraph ha t  p ci such that c |= a1+   a1   slack a1 a1  is the maximum time by which the t -value of a1  can be consistently increased in sg without violating the time window chosen for scheduling a1.
모to estimate whether b is a time threat for an action node ak  l 뫞 k   we check if   뷇b al    slack al ak  holds  where 뷇b is the portion of the relaxed plan computed so far  and   뷇b al  estimates the delay of the start time of al that the addition of the actions in 뷇b to g would determine.
1 experimental results
we have implemented our approach in a planner called lpgtd  which obtained the 1nd prize in the suboptimal metrictemporal track of the 1th international planning competition  ipc-1 . lpg-td performed especially well in the domain variants with timed initial literals  in terms of both cpu-time to find a plan and quality of the best plan computed with a cpu-time limit of 1 minutes  lpg-td is an incremental planner finding a succession of valid plans . in this section  we present some experimental results using the test problems of ipc-1 the problems in the airport domain specify at most 1 time windows for each timed precondition  the problems in the satellite domain at most 1 windows  while those in the other domains only one time window. additional results are available from the web sites of our planner and of ipc-1  and in a technical report including an experimental analysis on solving problems with many windows associated with the timed preconditions  gerevini  et al.  1 .
모figure 1 shows the cpu-time of lpg-td in three ipc-1 domains with respect to the best among the other three planners of ipc-1 that support timed initial literals: sgplan  p-mep  and tilsapa.1 in these domains  lpg-td is generally faster than the other planners and solves more problems.
모table 1 gives a summary of the results for all the ipc-1 domain variants with timed initial literals  1 test problems in total . we compare lpg-td's results with the best results over the corresponding results of all the other ipc-1 planners   allothers  . in general  lpg-td solves more problems than allothers; the percentage of problems in which it is faster is higher than the one in which it is slower; and the percentage in which it produces better quality plans is much higher.
모finally  it is worth noting that  if in the cpu-time comparison we consider only problems where lpg-td is at least one order of magnitude faster  slower  than allothers  then the results in the 1rd column of table 1 are even more favorable to lpg-td. lpg-td is faster in 1% of the problems  and it is slower in 1% of the problems.
ipc-1problemscpu-timeplan qualitydomainsolvedbetter  worse better  worse airport1  1 1  1 1  1 pipesworld1  1 1  1 1  1 sat-complex1  1 1  1 1  1 sat-time1  1 1  1 1  1 umts-flaw1  1 1  1 1  1 umts1  1 1  1 1  1 total1  1 1  1 1  1 
figure 1: cpu-times of lpg-td  p-mep  sgplan  and tilsapa in three ipc-1 test domains with timed initial literals. on the x-axis we have the problem names simplified by numbers. on the y-axis  we have the cpu-times in logarithmic scale.table 1: a comparison of lpg-td and the best over the results of all the other ipc-1 planners. summary results in terms of: % of problems solved by lpg and allothers  in brackets ; % of problems in which lpg-td is faster  slower in brackets ; % of problems in which lpg-td produces a plan with shorter makespan  longer in brackets .
1 conclusions
we have presented an approach to temporal planning for domains where actions have durations and must be executed during certain time windows. this allows us to deal with deterministic exogenous events  which is important in many real-world planning domains. our approach combines constraint-based temporal reasoning and a recent graph-based method for planning. we propose a new plan representation and search space  a polynomial algorithm for temporal constraint reasoning during search  and some local search techniques for planning that exploit temporal information. an analysis of the ipc-1 results show that our planner performs very well compared to other recent temporal planners. we believe that our temporal reasoning results can be exploited also in the context of other approaches to planning.
모like our planner  sapa uses a relaxed plan heuristic to guide the search  do et al.  1 . however  sapa uses a time slack analysis for selecting these actions that is limited to the actions of the relaxed plan  while our heuristics consider also the actions of the  real  plan under construction. other very recent planners supporting time windows include dt-pop and mips. edelkamp proposes a method for handling timed preconditions in mips with only one time window  edelkamp  1 . dt-pop extends pop-planning with dtps  schwartz & pollack  1 . dt-pop supports more temporal features than lpg-td  but it is less efficient  and it does not exploit the plan representation that we use for achieving tractable temporal reasoning during planning. for a more detailed discussion of related work see  gerevini  et al.  1 .
