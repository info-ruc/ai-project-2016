using active connection graphs for 
reasoning with recursive rules 
donald p. mokay and stuart c. shapiro 
department of computer science 
state university of new york at buffalo 
amherst  new york 1 

abatraot 
　　　raouralva rules  such as  your parents' ancestors are your ancestors   although vary uaaful for theorem proving  natural languaga understanding  question-answering and information retrieval systems  present problems for many such systems  either causing i n f i n i t e loopa or requiring that a r b i t r a r i l y many copies of them be made. snip  the snaps inference package  oan use reouralva rulas without either of these problems. a raouralva rule oauaaa a cycle to ba b u i l t in an 
active connection graph* each pass of data through the cycle results in another answer. cycling stops as soon as either the desired answer is produoed  no more answers oan be produoed or resource bounds are exceeded. 
this work 	was aupportad 	in part 	by tha 	national 
science 	foundation 	under 	grants 	mcs1 and mcs1. 
1. introduction 
　　　raouralva rules  such aa  your parents' anoestors are your ancestors   occur naturally in infaranoe systems used for theorem proving  question-answering  natural languaga undaratandlng and information r e t r i e v a l . transitive relations  
a.g. v x y z   ancestor x y  a ancbstor y z  -  ancestor x z j  inheritance rulaa  e.g. v x y p  isa x y  1 has y p  -  has x p    circular definitions  e.g.  a limb la a lag or arm  and  a leg la a limb   and equivalences  e.g.  x y z   receive x y z   =  ptrans z y z x    are a l l ocourranoaa of raouralva rules. yet  raouralva rulaa present problems for system implementors. inference systems which use a  naive chaining  algorithm oan go into an i n f i n i t e loop  like a l e f t - t o - r i g h t top-down parser given a l e f t raouralva grammar  1  1  1  1 . soma systems f a l l to uaa a raouralva rule more than onoe  i . e . are incomplete  1  1 . other systems build tree like data structures containing branches tha length of which depend on the number of times the recursive rule la to be applied   1   1 . since some of theae build the struoture before using i t   the correct langth of these branohaa la problematic. some ayatama eliminate reouralva rules by deriving and adding to tha data baaa a l l implications of the reouralva rulaa in a apaclal paaa before normal infaranoe la dona . another measure taken to avoid the problem of circular definitions and equivalences in one system was to use  a depth f i r s t expansion policy and to l i m i t the total depth of the expansion    1   . this is essentially the same solution proposed by blaok  and by simmons and chester . 
　　　not too surprisingly  recursive rules cause problems for many programming languages developed for a r t i f i c i a l intelligence  ai  research. ai languages  such as mlcroplanner   fuzzy   and prolog   have differing approaches to a baalc problem: there exist well formed statements in the language which cause i n f i n i t e loopa in the language interpreter when some theorem  procedure or clause is used. using the terminology from mlcroplanner  these languages are sensitive to the order of assertion  or equivalently the order of retrieval of theorems  and to the application of a theorem aa a subgoal of i t s e l f . both interaot to 
make a collection of theorems incomplete  i.e. statements which are logically implied by i t s data baae of assertions and theorems are not derivable beoauae the system gets into an i n f i n i t e loop. 
　　　a typioal example would be the ancestor example mentioned previously. in a mlcroplanner like ayntax  such a statement can be represented as the consequent theorem:  consequent  ancestor  x  y   z  
	 goal 	 ancestor 	$x 	 z   g1al 	 ancestor 	$z 
$y    
the use of this theorem for solving some goal introduces a problem. if there la no other way in which to deduce instanoea of ancestor  either by finding assertions in the data baaa or through application of some other rule  or if the order of application of theorem a picks this theorem first regardless of any other available theorem a then the above theorem reuses i t s e l f without making any progress towards finding a solution  i . e . uae of the theorem causes the interpreter to enter an i n f i n i t e loop. 
　　　mlcroplanner provides a primitive  thunique  which oan be uaad to check whether a theorem has previously been entered with the current bindings and doaa solve the i n f i n i t e regress problem for recursive theorems. however  the user must e x p l i c i t l y inolude the appropriate statement  so the possibility exists that tha uaer may not in fact notice that a theorem w i l l be uaad recursively. this could happen when olroular definitions or equivalences are inadvertently 

1 

introduced into a collection of theorems. fuzzy suffers from a similar problem and compounds it by not providing an operator equivalent to thunique. two points should be noted. first  apparently the developers of fuzzy did not need to represent recursive procedures  lefalvre  personal communication  and second  thunique can be simulated in fuzzy. pure prolog also does not explicitly oontain a thunique primitive - using recursive rules properly is a problem with the procedural semantics of seme implementations of prolog  but it is not a problem of the declarative semantics. some implementations of prolog include an equivalent primitive. since a primary mode of definition is recursive definition by l i s t i n g clauses  this is a potential source of problems for users of prolog. 
　　　snip  1  1  1 was designed to use rules stored in a f u l l y indexed data base. when a question is asked  the system retrieves relevant rules and builds an active connection graph which attempts to derive the answer from the rules and other information stored in the data base. since a semantic network is used to represent a l l declarative information available in the system  we differ from the basic assumption of several data base question-answering systems  1  1  1  by not making a distinction between  extensional  and  intensional  data bases    i . e . non-rules and rules are stored in the same data base   nor do we distinguish  base  from  defined  relations. specific instances of ancestor may be stored as well as rules defining ancestor. in addition  the inferenoe system described here does not restrict the l e f t hand side of rules to oontaln only one l i t e r a l which is s derived relation   1     does not need to reoognlze cycles in a graph  1  1  1  and does not require that there be at least one exit from a cycle . 
　　　the active connection graph may be viewed as an and/or problem reduction graph in which the root code represents the original question and rules are problem reduction operators. partly influenced by kaplan's producer-oonsumer model   1     the system is designed so that if a node representing some problem is about to create a node for a subproblem and there is another node already representing that subproblem or some more general instance of i t   the parent node oan reuse the extant node and avoid solving the same problem again. in addition  if the extant node is a more specific instance of the proposed subproblem then the results produced by the extant node are immediately made available and the extant node cancelled. the method employed handles reourslve rules with no additional mechanism and  as w i l l be seen below  the size of the resulting graph does not depend on the number of times a recursive rule w i l l be used. 
　　　this paper describes how snip handles recursive rules. aspects of the system not relevant to this issue are abbreviated or cmitted. in particular  neither the details of the match routine which retrieves formulas unifiable with a given formula   the representation of logioal connectives and formulas in sneps  nor the implementation of snip is f u l l y described. 
1 . p r e d i c a t e c o n n e c t i o n g r a p h s 
　　　others have described predicate connection graphs  1  1  1  or clause interconneotlvity graphs  which have been used in resolution theorem proving systems and question answering systems. 

　　　a predicate connection graph  pog  is a 
　　　collection of statements in predloate calculus with unifiable l i t e r a l s linked together by edges. labelled with the most general unifying substitution  agu  of the l i t e r a l s . in systems which use peg's  the inference algorithms may impose constraints on which l i t e r a l s aay have an edge between thea. por example  systeas whloh use resolution as the only rule of inference  1  1  1  require that the predloate oaloulus statements be represented in clause fora and that only complementary l i t e r a l s be joined by an edge  i.e. 
1 

a l i t e r a l l is linked to a l i t e r a l ~l. in a system which does not represent statements in clause form  
e.g.   1     and which uses the standard connectives of predicate calculus  the edges usually link an instanoe of a l i t e r a l in the antecedent of some statement with a unlflable instance of the same l i t e r a l in the consequent of some other statement. in such a system which uses both backward chaining and forward chaining  an edge between p x  and p y  asserts that to show p x  use the statement in which p y  appears and that if p y  for some y is ever deduoed then the result can be used to further satisfy the statement in which p x  appears. 
　　　the match operation specifies a pog of a slightly different form. instead of labelling the edge with the mgu  a directed edge linking a source node  s  to a target node  t  labelled with the target binding  t  and the source binding  a  is used. figure 1 shows a pog consisting of five rules  labelled r1 through r1. while the rules considered in the remainder of this paper are of the form a 1 . . . a -  c where j 1 and a l l variables are universally quantlfed   i . e . horn clauses   snip is not so limited  see  * the edges are labelled with the pair  ♀. &  where 1 is the target binding and s la the souroe binding. the souroe node is the l i t e r a l at the t a l l of the edge and the target node is at the head of the edge. for example  the edge labelled  a  in figure 1 has p a y x  as the source l i t e r a l and p x y z  as the target l i t e r a l . snip does not e x p l i c i t l y store the pog but uses the match function described above to compute the edges on demand. the remainder of this paper is ooncerned with peg's of this last form. 
1. actiive connection graphs 
　　an active connection graph  aog  is a connection graph in which edges link l i t e r a l s and are labelled with a target binding and source binding. these graphs are active because instances of l i t e r a l s flow from one formula to another formula via the edges. using the producer-consumer 

analogy  a rule instance can be considered a producer of instances of its consequents and a 
consumer of instances of i t s antecedents. furthermore  the acg contains instances of the rules in the peg  the edges in the acg point in the opposite direction to the corresponding edges in the peg and the bindings play an active role  see below . the target binding f i l t e r s the flow of instances of l i t e r a l s . the source binding translates between variable contexts. 
　　　suppose a consequent reasoning system has been asked to deduoe a l l instanoes of q using the peg of figure 1. it can use r1 and r1 to deduoe instanoes of q if appropriate instances of p can be deduced. thus  rules r1-r1 oan be used. a f u l l aog for this scenario la presented in figure 1. rectangles enclose formulas. the partitions contain l i t e r a l s instances. antecedents appear on the l e f t of the double l i n e   consequents to the right. the rectangle at the top of figure 1 represents the request to deduoe a l l instanoes of q and as such has an empty consequent part. in this example  eaoh acg rule labelled a. is an instance of the peg rule labelled r . these labels are arbitrary and the reader should not infer anything about the construction of the acg based on the labels alone. the remainder of this section expands this simple notion of active connection graphs using the acg of figure 1 as an example. 
　　　target bindings and source bindings operate on the bindings flowing through the aog. a target binding is a f i l t e r which only lets through those bindings which have the binding of the f i l t e r as a subset. for example  in the active connection graph of figure 1  if g1 produced the bindings {a/x  b/y  c/z  and {a/x  d/y  c/z}  only {a/x  b/y  c/z  would be allowed to paaa through the f i l t e r  a/x  b/y  to a1. the source binding la uaed to switch variable contexts. a1 contains only 
the variable u while g1 produoea bindings with 	the 


1 

variables x  y and z  so in order for g1 to send bindings to a1  the variable z must be mapped to the variable u. continuing with the example above  since the binding {a/x  b/y  c/z} passed through the f i l t e r it next encounters the switch   z / u   . the switch uses the binding application operation defined in section 1 to generate a new binding. in this case  {z/u}   {a/x  b/y  o/z} yields {c/u}  which is an appropriate binding in the oontext of 
a1. 
　　　to deduoe a l l instances of q requires back chaining through the peg u n t i l only ground l i t e r a l s are found or a l l possible rules are t r i e d . i n i t i a l l y   a request is created which contains a l i t e r a l . in figure 1  q q1 q1  is that request. the next step is to create a goal node for the l i t e r a l . the goal node matches i t s l i t e r a l with the peg to find a l l l i t e r a l s which unify with i t . if there are ground instances then the source bindings of those matches are answers and the goal node produces them immediately. other matches can be l i t e r a l s which are antecedents or consequents of rules in the peg. for every l i t e r a l in the consequent of some rule  a new rule instance is added to the acg using the target bindings  and the instance is connected through a switch containing the source binding to the goal node. the same process of creating goal nodes is applied to each of the antecedents of the new rule instances created in the previous step. this process is repeated u n t i l either no more rules apply or only ground instances are found. however  a new goal node need not be oreated if an existing one w i l l suffice. the remainder of this section describes how to find adequate extant goal nodes without doing extra matching and how to use results previously generated by a goal node. 
　　　suppose a goal node is about to be created for some l i t e r a l in a rule instance of an acg. which other l i t e r a l s are l i k e l y to have goal nodes which should be checked  namely  those other l i t e r a l s in the peg unifiable with the l i t e r a l which are in the antecedent of some rule of the peg and which have already had goal nodes created for them. thus  when a new goal node performs i t s match as described above  the matched antecedent l i t e r a l s are marked with a pointer to the newly created goal node. these pointers  which link antecedent peg l i t e r a l s to goal nodes in the acg  are called goal pointers. just like peg edges  eaoh goal pointer is marked with a target binding and source binding. when a new goal node is about to be created  if its l i t e r a l has no goal pointer then no existing goal node w i l l be useful. if it does  it is possible that one of the goal nodes pointed to could be used instead of the proposed goal node. 
　　　let's consider as an example the process of building the acg of figure 1 using the pog of figure 1. recall that the request was for a l l instances of q . a goal node is created for q q1 q1  and a match performed. the results of the match of q q1 q1  are the tuples  q a u   {u/u}   a/q1  u/q1}  and  q x y    x/x y/y   {x/q1  y/q1} . both q a u  and q x y  are consequents of rules  so rule instances are created for them in the aog connected through the appropriate switones to 1 . there are no goal pointers oreated beoause q q1 q1  does not matoh any l i t e r a l in an antecedent of a rule. continuing to expand the aog using the anteoedents of a1 and a1 requires picking one of them to expand f i r s t . whichever order is picked  the same aog is constructed. 
　　　suppose a1 is picked for expansion. first  the l i t e r a l p x y z  is ohecked for a goal pointer. there are none  so a new goal node is b u i l t for 
p x y z . 	the result of the match are the tuples 
 p a b u   {u/u}  {a/x  b/y  u/z}   
 p x u v   {x/x  u/u  v/v}  {x/x  u/y  v/z}   
 p a y x   {y/y  x/x}  {a/x  y/y  x/z}   
 p a c v   {v/v}  {a/x  o/y  v/z}  and  p x y z   {x/x  y/y  z/z}  {x/x  y/y  z/z} . p a b u  is an antecedent of r1  so p a b u  gets a goal pointer to the goal node for p x y z . also  p x y z  is given a goal pointer to i t s own goal node. we draw a goal pointer as a dashed line labelled with the target binding and souroe binding of the match. figure 1 shows the acg and part of the pog with goal pointers after this step. the remaining target l i t e r a l s are each consequents of some rule and the rules are added to the acg as before. next  a goal node is to be oreated for p a b u  of a1. but the pog l i t e r a l p a b u  in r1 has a goal pointer. thus  some instanoe of the old goal l i t e r a l   p x y z   unifies with the l i t e r a l which nas the goal pointer but the binding of the current aog rule instanoe is not necessarily compatible with the binding of the old goal l i t e r a l . 
　　　in the current example  the old target binding from the goal pointer is identical to the binding associated with a1. however  g1 is not identical to the proposed goal for p a b u . rule instanoe a1 is interested in a subset of a l l instances of 
1 p x y z   namely those instances whioh have a/x and b/y. it is important to note that q1 w i l l produce a l l that the proposed goal node for p a b u  would produce and more. also  above g1 a l l instances are in terms of the variables of r1. instead of creating a new goal node for p a b u  and the edges associated with i t   g1 is reused. the results from g1 must be f i l t e r e d by  a/x  b/y  and variable contexts switched by   z / u   . the f i l t e r is computed from the application of the current binding to the old source binding. this assures that the f i l t e r 

contains variables which the old goal node produces. the swltoh is obtained by considering the binding pairs of the old source binding for which the term is a variable as a  variable bap . discarding those binding pairs for which the tens is a constant and inverting the remaining pairs yields the appropriate binding for the switch. for example  discarding pairs with constant terms and then inverting  a/x  b/y  u/z} yields u / u   . figure 1 shows the acg after the f i l t e r and swltoh have been b u i l t . 
　　　if a1 were expanded before a1 then a goal node would have been created for it and goal pointers established from the antecedents of r1 and r1 to the goal node. to obtain the same acg requires that the goal node created for p a b u  in a1 be superseded by the goal node eventually created for p x y z . when a goal node is superseded  it is erased from the acg and a l l the consumers of the superseded goal nodes become consumers of the new  more general goal node with an appropriate f i l t e r and switch between the superseding node and the old consumers. 
　　　we stated above that rule instances in the acg consume instances of antecedents and produce instances of consequents but have t o t a l l y ignored what constitutes such an instance. there are basically two alternatives. an instance of a l i t e r a l can be either a separate l i t e r a l or a reference to a l i t e r a l and a binding which when applied to the l i t e r a l would yield an lnstanoe of i t . we prefer the second alternative because the inference algorithms need not produce extra l i t e r a l s and because the match operation mentioned above returns such information. furthermore  information about l i t e r a l s is superfluous in communication between rule instances in the acg because the l i t e r a l s are known to unify  that's why there is an edge in the peg  and therefore  only bindings need be communicated along the edges of the active connection graph. 
　　　finally  we mentioned above that the acg contains rule instances but the previous examples use the pog rules directly. in general  rule instances in the aog are pairs - a rule from the peg and an associated binding. the rule lnstanxes in the examples a l l have an identity binding  i.e. a binding in which each variable of a binding pair is bound to i t s e l f . the binding is used to restrict the rule instances to generating just those l i t e r a l instances which are requested. in other words  it is used as an internal f i l t e r in the rule instances in order to keep the inference 
more focussed. 
　　　in summary  an acg contains lnstanoes of rules which are linked to each other through f i l t e r s   switches and goal nodes. the separation of the target and source bindings allow rule instances to work in their own variable environment  relying on the source binding of the peg to enable switching of variable oontexts and on the target bindings to allow more general producers to be used by less general consumers. the goal nodes are the production site of lnstanoes of l i t e r a l s and so are useful to more than one consumer. finally  goal nodes are indexed on antecedent l i t e r a l s using goal pointers. 
1.racuraive rule a cause cycles 
　　　a set of recursive rules is of the form a1 &......& a -  b   b &.......& b k -   . . . -  c  with c unlflable with at least one of the antecedents  a1 say. in an acg  this means that the goal node for c can be used instead of creating a new goal node for a   as an example  consider the pog of figure 1 which contains the recursive ancestor rule. the two rules represent the predicate calculus statements v x y z  ancbstor x y  & ancestor y z     ancestor x z   and v x y  parent x y  -  ancestor x y  . the remainder of the entries represent the ground l i t e r a l s parent bill  john   parent john  mary   ancestor b i l l   bob   
ancestor john  mary  and ancestor mary  sarah . since the ground l i t e r a l s are never a source node in a match  the edges from the ground l i t e r a l s to l i t e r a l s in rules are omitted. 
　　　consider a request  ancest1r q1 q1   for a l l lnstanoes of the ancestor relation. inference proceeds by creating a goal node for the request  creating rule instances for a l l rules in the peg whloh have the l i t e r a l as a consequent and creating a goal pointer for each l i t e r a l in the antecedent of some rule. figure 1 shows the acg at this point. here  lnstanoes which are produoed are shown in terms of the variables of the goal l i t e r a l 


1 

next to the goal nodes which collect then. when such an instance is produoed  it flows through the acg u n t i l either it encounters the top level request or it is consumed by a goal node which has previously produced i t . thus  the bindings { b i l l / q 1   bob/q1}   john/q1  mary/q1} and {mary/q1  sarah/q1}  representing the ground l i t e r a l s 
ancestor bill  bob   ancestor john  mary  and ancestor mary  sarah  respectively  are stored by g1 and consumed by the top level request. picking one rule instance  a1 or a1  to expand f i r s t has no significant impact because if a1 were expanded f i r s t then any results derived from a1 would be stored in the goal node just as these are. the order of the creation of the goal nodes in a1 is insignificant for this example because both reuse 
g1. 
　　　consider ancestor x y  as the f i r s t goal l i t e r a l . ancestor x y  has the goal pointer  {x/x  y/y}   x/q1  y/q1}   and the binding associated with it in a1 is {x/x  y/y . thus  the goal pointer's old target binding is identical to the rule instance binding and g1 can be used. this is accomplished by giving g1 another consumer  the ancestor x y  antecedent  connected through the switch  q1/x  q1/y . the bindings from g1 are produced for this new consumer but further processing by a1 is not possible because the other antecedent of a1 has not yet consumed any instances of ancestor y z . 
　　　goal nodes act as data collectors  1  1 . a data collector stores a l l l i t e r a l s it has consumed and never produces a l i t e r a l it has previously produced. when an old goal node is given an additional consumer  a l l l i t e r a l s previously produced are immediately available to the new consumer. also  the new consumer receives any new l i t e r a l s produced by the goal node. the fact that data collectors never produce the same l i t e r a l twice protects snip from getting into an i n f i n i t e loop by prohibiting the passing of the same l i t e r a l around a cycle in the acg. 
　　　next  consider trying to create a goal node for ancestor y z . again  g1 is found using the goal pointer and as before the old target binding and the binding of the rule instanoe are identical. 

a new consumer is added 	to g1 through a switoh 	of 
 y/q1  z/q1  and the three instances stored by g1 are produced for this new consumer. since a1 has now received the bindings {john/x  mary/y} for one antecedent and and  mary/y  sarah/z} for the other  it oan produoe  john/x  sarah/z} and pass it to g1. again  g1 produces  john/q1  sarah/q1} to a l l consumers because it has not produoed it before. now  a1 cannot produoe any further instances. 
	finally  	a 	goal 	node 	is 	created 	for 
parent x y   call it g1. since there are no goal pointers for parent x y   a match is performed resulting in the ground instanoes of   b l l l / x   john/y} and  john/x  mary/y}. figure 1 shows the acg after g1 has matched these instanoes. these are stored by g1 and produoed to a l l consumers. a1 now has i t s antecedent satisfied in the bindings above. since these instances are next passed to g1 and   b i l l / q 1   john/q1} has not been produoed before  it is produced to the top level request and the other consumers. after passing through the switches  the appropriate binding arrives in a1 which produces ancestor bill  mary . again  g1 has not produced   b l l l / q 1   mary/q1  previously  so it passes it on to a l l consumers. a1 in turn produoes   b i l l / x   sarah/z} to g1. since g1 has not previously produoed   b i l l / q 1   sarah/q1}  it produces this binding to a l l consumers. now  no further results can be produced by a1 and slnoe there are no other rules l e f t to expand  inference terminates. 
　　　this example demonstrates that recursive rules can be productively used in an acg and not cause an i n f i n i t e loop. the reason no i n f i n i t e loop is encountered is that no further results oould be produced and that the acg oontalns a cycle as opposed to continually trying to use the recursive ancestor rule. this example also demonstrates the accessing of data stored by a goal node previous to adding a new consumer. this is a property of the goal node acting as a data collector. finally  this example suggests how rule instanoes produce bindings  waiting u n t i l sufficient instances have been consumed in the appropriate binding. snip 


1 

allows other logical connectives so that other schemes for rule instanoes to produoe instances of their consequents are required  see  . note  this kind of structure is b u i l t for indirectly recursive rules as well as the directly recursive rule in the above example  the resulting active connection graph is a directed graph and neither a tree nor a directed aoyclic graph  and once it is b u i l t i t s size is constant. 
1.summary 
　　　in snip  recursive rules cause cycles to be b u i l t in an active connection graph. the key features of active connection graphs which allow recursive rules to be handled are: 1  goal nodes are data oolleotors; 1  data collectors never produce the same answer more than once; 1  the data oollector may report to more than one consumer; 1  a new consumer may be assigned to a data colleotor at any time - it w i l l iimmediately be given a l l previously oollected data; 1  variable contexts are localized  switches change contexts dynamically as data flows around the graph; 1  f i l t e r s allow more general producers to be used by less general consumers; 1  goal nodes are indexed on antecedent l i t e r a l s which were 
matched by the goal l i t e r a l . 
