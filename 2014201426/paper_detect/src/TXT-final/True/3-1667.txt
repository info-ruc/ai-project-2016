
many and diverse combinatorial problems have been solved successfully using finite-domain constraint programming. however  to apply constraint programming to a particular domain  the problem must first be modelled as a constraint satisfaction or optimisation problem. since constraints provide a rich language  typically many alternative models exist. formulating a good model therefore requires a great deal of expertise. this paper describes conjure  a system that refines a specification of a problem in the abstract constraint specification language essence into a set of alternative constraint models. refinement is compositional: alternative constraint models are generated by composing refinements of the components of the specification. experimental results demonstrate that conjure is able to generate a variety of models for practical problems from their essence specifications.
1 introduction
to employ finite-domain constraint programming technology to solve a problem  the problem first must be characterised  or modelled  by a set of constraints on decision variables that solutions must satisfy. modelling can be difficult and requires expertise  thus limiting widespread use of constraint technology. the vast majority of research on constraint modelling presents alternative models to a particular problem and evaluates these alternatives through analysis and/or experiment. the process by which the alternative models are generated is rarely  if ever  discussed. each constraint programmer must learn the art of modelling by forming generalisations from these studies.
﹛we show that a set of rules can formalise the generation of alternativemodels. doing this requires a languagein which to express the abstract problem structure of which models are a function. if all modelling choices are to be open to the rules  the language must have a level of abstraction above that at
which modelling decisions are made. we have designed such a language and call it essence.
﹛the rules are embedded in the conjure system  which  givenan essence specification  generates models of the type supported by existing constraint solvers. hence  we refer to our rules as refinement rules. our current focus is on generating a set of correct models that includes those that a human expert would generate. future work will focus on generating only good models.
1 challenges and contributions
a central task  arguably the central task  of modelling most combinatorial problems is choosing a representation of complex decision variables. current finite-domain constraint solvers provide decision variables whose domains contain atomic elements  which we call atomic variables.1 yet  combinatorial problems often require finding a more complex combinatorial structure. for example  the social golfers problem  sgp  see  problem 1  requires partitioning a set g of golfers in each week of play. thus  the goal is to find a multiset of partitions of g  i.e. a multiset of sets of sets of g. modelling the sgp requires deciding how to represent this complex decision variable as a constrained collection of atomic variables.
﹛in concert with choosing a representation of complex decision variables is the task of representing the constraints of the problem. in its natural form  a combinatorial problem imposes constraints on the combinatorial structure that is sought. these constraints must be  translated  so that they are imposed on the representation of the decision variables.
﹛this paper shows how these two central tasks of modelling can be formalised and automated  and in doing so reports two principal contributions. first  we have designed a language  called essence  that enables combinatorial problems to be stated at a high level of abstraction. this level of abstraction is a consequence of three features:  1  the language supports a wide range of types  including sets  multisets  relations  functions  partitions  and decision variables can be of these types.  1  all types can be nested to arbitrary depth; for example  a decision variable can be of type set  set of sets  set of set of sets  and so forth.  1  constraints can contain quantifiers that range over decision variables. for example  if a decision variable x is of type set of sets  a constraint can be of the form  x ﹋ x.耳. the essence language is outlined in sec. 1  though only in enough detail to enable the presentation of our second principal contribution.
﹛our second major contribution is the formulation and automation of a set of rules that can refine constraints on complex variables in an essence specification into constraints on atomic variables  which is the level of abstraction provided by existing constraint languages and toolkits. our formal rules are presented in sec. 1.
﹛an attempt to formulate such a set of refinement rules confronts two primary difficulties and many secondary ones. before proceeding it is worth considering the primary ones.
﹛the first difficulty arises because expressions  particularly decision variables of non-atomic type  can usually  if not always  be refined in multiple ways. furthermore  the refinement of an operator depends on how its operands are refined. for example  in refining the constraint s1 = s1  where s1 and s1 are atomic set variables  the treatment of equality is different for every combination of ways that s1 and s1 can be refined. indeed  it is possible that an operator is inapplicable to certain refinements of its operands.
﹛the second major difficulty arises from arbitrary nesting of types. refining an operator that is applied to expressions whose types are nested provides the biggest challenge. consider refining the constraint a = b  where a and b are decision variables of some type 而 that is nested arbitrarily deep. the generated constraint must involve all components of both a and b. since there is no bound on the nesting of 而  this complex constraint would have to be generated through recursive rule applications  none of which can look arbitrarily deep into the nesting of 而. furthermore  we wish to produce refinements in which a and b do not have the same kind of representation. an especially tricky case is when a quantifier ranges over a decision variable of a nested type  such as  x a 耳  where a is as above.
﹛modelling in constraints involves more than just representing decision variables and problem constraints. constraint models often contain many symmetries  often enormous numbers of them  which result in redundancies in the search space. expert modellers are able to identify such symmetries and break them  either by introducing symmetry-breaking constraints or using a symmetry-aware search method. it has been argued that detecting symmetries in a model is as hard as graph isomorphism. we maintain that symmetries enter a model from two sources: either a symmetry is inherent to the combinatorial problem or it is introduced by the modelling process. an automated modelling system ought to identify the symmetry that it introduces into a model. sec. 1 explains how this can be integrated into our architecture for model generation.
﹛another technique used by expert modellers is to represent a complex decision variable with multiple representations simultaneously and impose channelling constraints to keep the representations consistent with each other  1; 1; 1 . this sometimes yields more propagation  and therefore reduced search  than a single representation. as will be seen  the rules of conjure generate models with multiple representations. sec. 1 explains how our refinement rules can generate the information that is needed to automatically generate
given n  put n integer ticks on a ruler of size m such that all inter-tick distances are unique. minimise m.

given	n: int where	n ≡ 1
	letting	bound be 1n
find	ticks: set  size n  of 1..bound minimising max ticks  such that	 {i j} ticks. {k  l} ticks.
{i j} 1= {k l} ↙ |i   j| =1 |k   l|figure 1: essence specification of the golomb ruler problem.
the appropriate channelling constraints.
﹛we conjecture that the good models of a problem can be generated automatically by formulating the problem in essence and then refining the specification using rules of the kind presented in this paper. we have implemented a program  called conjure  that currently refines a subset of essence  called mini-essence. this gives us a platform with which we have experimentally tested our conjecture  as reported in in sec. 1.
1 an introduction to essence
this section briefly introduces the abstract specification language essence. it is an evolving and growing language; version 1 is used within this paper. a full specification of the language can be found at www.cs.york.ac.uk/aig/constraints/automodel/.
﹛let us begin by considering the specification of the golomb ruler problem  grp  problem 1 at www.csplib.org   shown in fig. 1 . a specification is a list of statements  of which there are seven kinds  signalled by the keywords given  where  letting  find  maximising  minimising and such that. statements are composed into specifications according to the regular expression
 given | letting | where   find+
 minimising | maximising   such that  
﹛identifiers in conjure come in four categories: constant  parameter  quantified variable  and decision variable.  letting  statements declare constant symbols and give their values.  given  statements declare the problem's parameters; the values of the parameters are provided to specify the instance of the problem class. parameter values are not part of the problem specification; as in other modelling languages  they are provided elsewhere.  where  statements impose restrictions on the parameter values; only parameter values meeting the restrictions specify a problem instance.  find  statements declare decision variables. a  minimising  or  maximising  statement gives the objective function  if any. finally   such that  statements give the problem's constraints.
﹛the grp specification begins by declaring n to be a parameter  restricting it to be non-negative and declaring bound to be a constant. since n is used in the declaration of bound  the declaration of bound must come after the declaration of n. every symbol must be defined before it is used. this restriction prevents cyclical definitions and means that decision variables cannot be used in the definitions of constants and parameters.
﹛the specification language is strongly typed and every expression and subexpression has a type. the type of the decision variable ticksindicates that the goal of the problem is to find a set containing n elements  each of which is an integer in the range 1 to bound. the types supported by essence include the atomic types int  integer   bool  boolean  and l..u  an integer range type   where l and u are integer expressions. essence also provides enumerated types and a new and very useful atomic type: type  size 汐   a type of 汐 unnamed elements.
﹛essence is the first constraint language to support fullycompositional type constructors. so  for example  a decision variable may be of type integer  set of integer  set of set of integer  and so forth. if 而 is a type  汐 is an integer expression  and i1 ... in are expressions of type range then the following are types that appear in this paper:
set  size 汐  of 而  set  maxsize 汐  of 而two kinds of setmset  size 汐  of 而  mset maxsize 汐  of 而two kinds of multisetmatrix  indexed by i1 ... in  of 而matrixalso among the types of essence are relations between any two types  partial and total functions from any type to any type  partitions of a set of any type and permutations of any type.
﹛constraints in this specification language are built from the parameters  constants and decision variables using operators commonly found in mathematics and in other constraint specification languages. the language also includes variable binders such as  x   x and px  where x can range over any specified finite type  e.g.  integer range but not integer . the constraint in the grp can be paraphrased as  for any unordered pair {i j} of ticks and any unordered pair {k l} of ticks  if the two pairs are different then the distance between i and j is not the same as the distance between k and l.  to clarify the notation  the expression{i j}   ticksmeans that two distinct elements are drawn from ticks and  without loss of generality  one is called i and the other is called j.
﹛now consider the specification of the sonet problemshown in fig. 1. notice that nodes is declared to be a range. a subtle point is that the third line of the specification is declaring two parameters. when the demand parameter is instantiated to a particular set of sets  the size of the outer set will be known. hence  the value of m is given indirectly. this declaration also requires the inner sets to have cardinality two. the goal is to find a multiset  representing the rings   each element of which is a set of nodes  representing the nodes on that ring . the objective is to minimise the sum of the number of nodes installed on each ring. the constraint ensures that any pair of nodes that must communicate are installed on a common ring.
the target language: essence1
essence specifications are refined into a target language called essence1  which is a subset of essence with a level of abstraction similar to that of existing constraint languages  opl  being the closest. the only types essence1 has are integers  integer ranges  booleans and matrices; it does not have enumerated types or types of unnamed elements. binders  such as quantifiers and summations  range only over integer ranges. from this generic constraint language  it is
a sonet communication network comprises a number of rings  each joining a number of nodes. a node is installed on a ring using an adm and there is a capacity bound on the number of nodes that can be installed on a ring. each node can be installed on more than one ring. communication can be routed between a pair of nodes only if both are installed on a common ring. given the capacity bound and a specification of which pairs of nodes must communicate  allocate a set of nodes to each ring so that the given communication demands are met. the objective is to minimise the number of adms used.  this is a common simplification of the full sonet problem  as described in  

given nrings:int  nnodes:int  capacity:int where nrings≡ 1  nnodes≡ 1  capacity≡ 1 letting nodes be 1..nnodes
given	demand:set  size m  ofset  size 1  of nodes find	rings: mset  size nrings  ofset  maxsize capacity  of node minimisingp ﹋	|r| r rings
such that  pair﹋demand.  r﹋rings . pair   rs
figure 1: essence specification of the sonet problem.
a short step to an established constraint language  such as opl  solver  or eclipse. to perform this step  we are developing a suite of back-end translators. in future  we also intend to translate to more restricted languages  such as sat and pseudo-boolean formulations.
1 the architecture of conjure
this section discusses the refinement rules conjure uses to refine an essence expression into a set of essence1 expressions. for concision we give only a small subset of all the refinement rules1; the remainder follow a similar pattern.
refining a simple essence specification
refinement of an essence specification begins by refining each constraint and the objective function in turn. let us begin by considering the single-constraint microsonet1 specification  fig. 1   where the goal is to fill two rings with the same nodes.
﹛a key consideration in refining microsonet1 is the representation of each ring  each of which is a fixed-size set. this paper uses two representations of fixed-size sets. the explicit representation is a one-dimensional matrix of nodes indexed by 1..capacity. each element of the matrix corresponds to an element of the set. to represent the set properly  the elements of the matrix are constrained to take distinct values. the occurrence representation is a one-dimensional boolean matrix indexed by nodes  where a true entry indicates that the corresponding node is in the set. to represent the set properly  the number of true entries must be equal to capacity  for counting we treat true/false as 1 . fig. 1 gives essence1 models using both representations. note that some symbols of essence  such as     and  曳   can also be written textually  such as  forall  and  sum . in writing essence1 we use the textual version.
﹛the refinement operator  老  is a function that maps every essence expression to a set of essence1 expressions. as explained later  each of these essence1 expressions is tagged with further information necessary to construct the
given	nnodes:int  capacity:int where	nnodes ≡ 1  capacity ≡ 1 letting	nodes be 1..nnodes
	find	ring1:set size capacity  of nodes
ring1:set size capacity  of nodes
such that ring1 = ring1given	nnodes:int  capacity:int where	nnodes ≡ 1  capacity ≡ 1 letting	nodes be 1..nnodes find	ring :matrix indexed by 1.. capacity  of nodes
ring1:matrix indexed by 1.. capacity  of nodes
such that forall  i:1..capacity  exists  j:1..capacity  ring
alldifferent ring
alldifferentgiven	nnodes:int  capacity:int where	nnodes ≡ 1  capacity ≡ 1 letting	nodes be 1..nnodes
	find	ring1 :matrix  indexed by nodes  ofbool
ring1 :matrix  indexed by nodes  ofbool
such that forall  i:nodes 
sum  i:nodes capacity sum  i:nodes  ring1 i = capacityfigure 1: essence specification and two essence1 models of the microsonet1 problem.
final model. 老 is defined inductively by a set of uniquelynamed equations of the form  where r is the name of the equation  e is an essence expression and each e1i is a set of essence1 expressions  usually given via set comprehension. for perspicuity  each equation is split into rules  written:  ... 
.
﹛the sizedsetequality equation is responsible for refining expressions of the form s1 = s1  where both s1 and s1 are expressions of type fixed-size set. fig. 1 gives two rules of this equation. the complete version of sizedsetequality gives one rule for for each combination of a representation of s1 and a representation of s1 and a constraint for imposing equality between the them.
﹛to illustrate the operation of a rule  we now discuss how the sizedsetequality1 rule refines ring1 = ring1. sizedsetequality1 refines s1 and s1 into explicit onedimensional matrices denoted by . the sizedsetequality1 rule proceeds similarly. the reader may wonder at the strategy of refining the arguments of the equality constraint inside the equality rule itself. this is explained in the next sub-section.
﹛when a rule needs to introduce a new identifier  such as that denoted by   it does so by making use of the gensymbol function. this function takes two arguments. the first is either an explicit category  see sec. 1   or an identifier from which the category information is copied. the second is the type of the new identifier  such as a one-dimensional matrix used for the explicit representation. the gensymbol function creates a new identifier of the required category and type that appears nowhere else in the essence1 model being constructed. when  for example  refining ring1 with sizedsetequality gensymbol ring1 matrix  indexed by nodes  of 1..n   and so s1 will denote a unique identifier for a matrix of decision variables  since ring1 is a decision variable .
﹛definitions via gensymbol and type information  except for the input expression  are given on the right of the long vertical bar. the bar itself has no meaning beyond separating the details of the rule from the types and definitions.
﹛since sizedsetequality1 chooses to represent both sets explicitly  the expression
  n1 = n1   is used to constrain the two explicit matrices to represent the same set  note the introduction of the quantified variables denoted by i and j . since  in general  it may be the case that e is not yet in essence1  it is refined further and the result  denoted by 耳  is returned. in this example   ring  is in essence1  so 老 e  = e. for brevity  the model shown in fig. 1 omits capacity = capacity; a simplifier could easily remove it. this convention is followed in all subsequent models generated by sizedsetequality1.
﹛recall that the explicit representation of a set size n  of 而 is a matrix of n distinct elements  each of type 而. thus  when a rule generates this explicit representation  it must introduce into the generated model a constraint that the elements of the matrix are all different. in particular  the sizedsetequality1 rule must introduce two such constraints: alldifferent  and alldifferent  and  since the elements of s1 and s1 have not been refined  老 must be applied to these two constraints  resulting in the essence1 constraints named 聿 and 肉 in the rule.
﹛consider where 聿 and 肉 should occur in the generated model. from the essence1 model of fig. 1 it might appear that 聿 and 肉 should be conjoined to 耳  returning 耳 ＿ 聿 ＿ 肉. to see that this is incorrect  observe that this treatment would refine   ring1 = ring1  to   耳 ＿ 聿 ＿ 肉   whereas the desired refinement is   耳  ＿ 聿 ＿ 肉. the correct refinement is obtained by returning 耳 as the refinement  tagging the refinement with 聿＿肉  and once the essence1 model is generated  adding 聿 ＿ 肉 to its constraints. since  in this case  the tag is a constraint  it is labelled by such that.
﹛when a rule builds a refinement r  a part p of which has been generated from a recursive call to 老  the tags of p are  by default  added to the tags of r. hence  in
sizedsetequality1  the tags attached to a refinement of 耳  聿 and 肉 are implicitly added to the such that tag explicitly given in the rule. as will be seen later  this default can be overridden.
﹛space precludes giving the full derivation of the explicit essence1 model  fig. 1 . the refinements triggered via sizedsetequality1 in the example are  however straightforward. universal quantification over a finite range of integers is in essence1 and can be viewed as a conjunction or simple 'for' loop. similarly  existential quantification over a finite range of integers can be treated as disjunction. hence  the first constraint in the explicit essence1 model comes directly from sizedsetequality1. the occurrence model follows similarly.
﹛after refining the constraints and the objective function of an essence specification  the given find and letting statements are generated. this is done by scanning the set of constraints and adding an appropriate definition for each unique identifier. where statements are refined in the same
ref
sizedsetequality1 老 s1 :set size n1  of 而 = s1:set size n1  of 而  ↙
{	耳gensymbol s1 matrix  indexed by 1..n1  of 而  such that 聿 ＿ 肉gensymbol s1 matrix  indexed by 1..n1  of 而 
|i = gensymbol  quantified variable   1..n1 
j = gensymbol  quantified variable   1..n1 
聿 ﹋ 老 alldifferent
肉 ﹋ 老 alldifferent}
ref
sizedsetequality1 老 s1 :set size n1  of 而 = s1:set size n1  of 而  ↙
{	耳而 is  a..b  or bool
such that 聿 ＿ 肉s1 = gensymbol s1 matrix indexed by 而 ofbool 
|s1 = gensymbol s1 matrix indexed by 而 ofbool 
i = gensymbol  quantified variable  而 
}
ref
forallrange1 老  i:n1..n1 耳:bool  ↙
{ forall  i:n1..n1  耳1 such that forall  i:n1..n1  忙
|
 耳1 with such that 忙  ﹋ 老 耳  }
ref
forallsizedset1 老  i:而 ﹋ s:set size n  of 而.耳:bool  ↙
{	forall  j:1..n  耳1j = gensymbol i 1..n 
such that 聿＿ forall  j:1..n  忙s1 = gensymbol s matrix  indexed by 1..n  of 而 
|
 耳1 with such that 忙  ﹋ 老 耳 i 1↙ s1 j   
	聿 ﹋ 老 alldifferent s1  	}
sizedsubset1 老 s1 :set size n1  of 而   s1:set size
{	耳而 is  a..b  or bool
such that 聿 ＿ 肉1 gensymbol s1 matrix  indexed by 1..n1  of 而 
gensymbol s1 matrix  indexed by 而  ofbool 
gensymbol  quantified variable  1..n1 
gensymbol  quantified variable  而 
肉 ﹋ 老 alldifferent
figure 1: example refinement rules.way that constraints are.
refining nested types: a simple example
to see how expressions of a nested type are refined  consider the microsonet1 specification  fig. 1   where the goal is to generate two identical sets of rings. the key decision is the representation of rings1 and rings1  two sets of sets. refinement begins with 老 rings1 = rings1   requiring sizedsetequality. of the rules given in fig. 1  only sized-
setequality1 is applicable  since  set  size capacity  of nodes  is neither a range of integers nor boolean: indexing a matrix by a complex type  here each index would correspond to one of the possible sets of nodes  would often lead to unfeasibly large matrices. future work will consider relaxing this condition in certain cases.
﹛the justification for refining the arguments of the equality constraint inside the equality rule itself becomes clear in the context of nested types. a seemingly more-natural approach to refining s1 = s1 would be to refine s1 and s1 and constrain the results to be equal. however  given unbounded nesting of types and multiple possible refinements of each type  constraining the results to be equal is not straightforward. consider the case where s1 and s1 are not sets of integers  but sets of sets of ... sets of integers. having refined s1 and s1 there is no fixed constraint on their refinements that enforces equality on s1 and s1. instead of this approach  our rules are designed to  peel off  a layer of nesting so that the associated constraint/operator can be formed without looking arbitrarily deep inside a refined expression.
performing sizedsetequality1 requires refining the two such that tags  both of which impose that all the elements of a matrix of sets must be different. since these elements may be of a non-atomic type  this alldifferent constraint must be refined. for space reasons the definition of the alldifferent refinement rules are omitted.
﹛the main constraint generated by sizedsetequality1 is 老  i jrings rings. the forallrange equation is now applicable  fig. 1 gives forallrange1 . this rule works by refining 耳  which contains the free variable i. each resulting refinement 耳1 and its tag 忙  both of which contain the free variable i  are wrapped in  forall i : n1..n1.  refinement continues with 老  j rings rings. ex-
istsrange operates in the same way as forallrange  so we omit the details.
we now have 老 rings rings  for which sized-
setequality is used. both rules are applicable  since rings and rings are sets of nodes. the refinement in fig. 1 uses sizedsetequality1 to generate an occurrence representation of the inner sets. the rule operates as described earlier  but we highlight how gensymbol treats indexed matrices. gensymbol respects the index structure of its first argument. hence  given the indexed one-dimensional array rings  gensymbol rings matrix...  creates a two-dimensional boolean matrix  rings1  see fig.1   and returns the partially-indexed rings1 i   which is the refined version of an element of the set of sets.
﹛the remaining refinements are straightforward. note that rings1  rings1 are not in the model. these are intermediate representations which  although more concrete than rings1
given	nrings:int  nnodes:int  capacity:int where	nrings ≡ 1  nnodes ≡ 1  capacity ≡ 1 letting	nodes be 1..nnodes
find	rings1:set  size nrings  ofset  size capacity  of nodes rings1:set  size nrings  ofset  size capacity  of nodes
such that rings1 = rings1given nrings:int  nnodes:int  capacity:int where nrings ≡ 1  nnodes ≡ 1  capacity ≡ 1 letting nodes be 1..nnodes find rings1 :matrix  indexed by 1..nrings nodes  ofbool rings1 :matrix  indexed by 1..nrings nodes  ofbool
such that forall  i:1..nrings  exists  j:1..nrings  forall  k:nodes 
forall  i:1..nrings  sum  j:nodes capacity forall  i:1..nrings  sum  j:nodes capacity
forall  i j:1..nrings  i j implies exists  k:nodes 
forall  i j:1..nrings  i j implies exists  k:nodes figure 1: essence specification and an essence1 model of the microsonet1 problem.
given nrings:int  nnodes:int  capacity:int where nrings ≡ 1  nnodes ≡ 1  capacity ≡ 1 letting nodes be 1..nnodes
given demand:set  size m  ofset  size 1  of nodes find rings: set  size nrings  ofset  size capacity  of nodes such that  pair﹋demand.  r﹋rings . pair   rgiven	nrings:int  nnodes:int  capacity:int where	nrings ≡ 1  nnodes ≡ 1  capacity ≡ 1
letting	nodes be 1..nnodes
given	demand 1 :matrix indexed by 1..m 1..1  of nodes
find rings1:matrix  indexed by 1..nrings nodes  ofbool such that forall  i:1..m  exists  j:1..nrings  forall  k:1..1  rings1 j  demand1 i  k  
forall  i:1..nrings  sum  j:nodes   rings1 i  j   = capacity forall  i j:1..nrings  i j implies exists  k:nodes  rings1 i  k  1= rings1 j  k figure 1: essence specification and an essence1 model of the microsonet1 problem.
and rings1  are matrices of sets  and so not in essence1.
refining nested types: a complex example
our final example illustrates a difficult case when refining nested types: quantification over nested types. consider microsonet1  fig. 1   a variant of a large piece of sonet  where the goal is to fill a given number of rings such that the inter-nodecommunicationdemand is met. refinement begins with 老  pair ﹋ demand. r ﹋ rings.pair   r   using the forallsizedset1 rule  fig. 1 . the first step is to refine the binding expression  pair ﹋ demand  which is  in turn  dependent on the refinement of the given set demand. forallsizedset1 represents demand explicitly in the same way as
sizedsetequality1. the returned expression quantifies over the indices of this matrix.
﹛the quantified expression 耳  which is  r ﹋ rings.pair   r in the example  is refined in the context of the decision to represent the set s explicitly as the matrix s1. in doing so  s1 j  is substituted for i via 耳 i 1↙ s1 j    in the example demand1 j  is substituted for pair . as per forallrange1  the tags associated with this refinement must also be quantified to hold for each possible value of j. having highlightedthis case  space precludes giving further details of the refinement. one particular rule  sizedsubset1  which is central to this specification  is presented in fig. 1. this rule shows two expressions  s1 and s1  of the same type being refined to two different representations. the design of conjure means this is no more complicated than the previously presented rules  which produce identical representations.
refining nested operators
none of the refinement examples considered so far have used an essence specification with nested operators. we have avoided the extremely difficult task of formulating refinement rules that recur on both the type of an expression and its syntactic structure. each recursive rule either works recursively on syntactic structure and handles only atomic types or it works recursively on nested types and handles only expressions that are syntactically  primitive   in a sense not defined here . a constraint containing both nested types and nonprimitive syntactic structure is refined by first rewriting it to an equivalent one containing only primitive syntactic structure. for example  the constrainta﹎ b﹍c    d is rewritten to  x y  x= b ﹍c  ＿  y = a﹎x  ＿  x   d . each conjunct of the resulting constraint is a primitive constraint that has a dedicated refinement rule. conjure performs this rewriting in a preprocessing stage called flattening.
1 some symmetry detection is free
refinement often introduces symmetries into the models it generates; that is  the generated model contains symmetries that do not correspond to symmetries in the original specification. this always happens when a variable x in the specification is represented by a collection of variables
in the model such that an instantiation of x corresponds to multiple instantiations of. for example  if x is of type set  size 1   its explicit representation is a matrix of three variables  x1..1 . an instantiation of x corresponds to 1! instantiations of x1..1 . the matrix x1 has index symmetry   which can broken by the symmetry-breaking constraint x1 ≒ x1 ≒ x1.
﹛since certain rules always introduce symmetry  such a rule can tag the refined expression with a description of the symmetry. for example   though not shown in fig. 1  sizedsetequality1 tags 耳 with  symmetry indexsym 耳  1    which indicates that 耳 has symmetry in its first index. once a model has been generated  the symmetry tags can be used to add appropriate symmetry-breaking constraints  or to guide a
﹛symmetry-aware search method such as sbds or sbdd.
﹛detecting symmetryas refinement introduces it is a considerably cheaper operation than symmetry detection on a finished model. in future  we intend to extend our system of symmetry tags to include other types of symmetry  such as partial index symmetry and value symmetry.
1 generating models with channelling
as we have seen  essence expressions have multiple possible refinements. if the same expression appears multiple times in a specification  then  different refinements of it may appear in an essence1 model. sometimes these concrete representations have a different name but they are equivalent. in those cases conjure automatically unifies them into a single representation. however  conjure often produces distinct concrete representations for the same abstract symbol. at first sight  this may appear to be a weakness. on the contrary  some of the most effective models in the literature take this approach  since some representations allow certain constraints to be modelled more easily than others. to maintain consistency among the different representations  channelling constraints are used .
﹛to facilitate channelling   though not shown in fig 1  the refinement rules add represent tags to the refinements to recordthe relationship between essence identifiers and their representations in the concrete model. for example  when refining a decision variable s of type set size n ofint it is possible for s to be represented by both occurrence and explicit representations in the same model. if that is the case the modelwill contain the tags  represents by expset s1   and  represents by occset s1    connectings with its concrete representations s1 and s1. by following the chain of tags it is possible to connect each concrete object to the original entity it is representing  and from these it is possible to construct channelling constraints.
1 experimental results
this paper makes an empirically testable conjecture: it is possible to develop good constraint models for combinatorial problems by specifying the problem in essence and refining this specification with conjure. at this point we can test the conjecture up to certain limits. the first limitation is that we currently are concerned only with the kernel of the model  which lacks channelling constraints and symmetry-breaking constraints and which has not had any transformations applied. the second limitation is that the implementation of conjure currently has rules for only certain types: integers  integer ranges  booleans  bounded and fixed-size sets  bounded and fixed-size multisets  and all compositions of these. the implementedrules can generate essence1 models with occurrence and explicit representations and with variables whose domains contain sets of integers.
﹛we test this conjecture by identifying problems that can be specified using only the supported types  and checking whether conjure generates the kernel of all reasonable models  particularly models appearing in the literature. most problems in the literature cannot be specified abstractly with the supported types since they involve associating together elements from two or more sets  which requires types such as functions or relations. we have found seven problems in the literature that can be specified abstractly with only the supported types: schur's lemma  sl   balanced incomplete block design  bibd   steiner triple systems  sts   sonet  sonet   social golfers problem  sgp   rl design  rld   and balance code generation  bcg . though we know of no published models for rld and bcg  both come from    we have included them simply to test whether conjure can generate reasonable  correct models.
﹛the results of running conjure on essence specifications of these seven problems are summarised in the table 1.
problem#choicesyesnobibd1dv: mset of sets  1 -sl1dv: mset of sets  1 rld1dv: mset of sets  1 --sts1dv: mset of sets  1 -bcg1dv: mset of sets  1 --sonet1dv: mset of sets  1  in: set of sets  1 1℅1℅sgp1dv: mset of set of sets  1 table 1: results of running conjure on seven problems.
to see how to interpret the table  consider the row labelled
sonet. this indicates that conjure generated 1 models for this problem. the choices it had to make were how to represent each of the two occurrences of the decision variable  whose type is set of set  and the one occurrence of the input parameter  whose type is set of sets . our survey of the literature uncovered four published models  all in   that were among those generated by conjure and four  all in   that were not. the entry for sgp indicates that conjure generated two of the three models that we found in the literature. though some models appear in multiple published papers  the table cites only one.
﹛examining the results of the experiments  we observed that all of the models generated by conjure were correct. the kernels of many models found in the literature were generated by conjure; that is  the models use the same decision variables and the same problem constraints  as opposed to implied or channelling constraints .
﹛it is more enlightening to consider the models not generated by conjure. the four models of sonet not generated by conjure arise straightforwardly by considering the decision variable to be a relation between rings and nodes. the rules for refining a relation in this way could be expressed easily in the framework of conjure and would enable the generation of these four additional models. this illustrates that there are important issues involved in writing specifications in essence  which in this case are also intertwinedwith the detection of symmetry; all of this is outside the scope of this paper.
﹛the missing model of sl could be generated easily from the most natural expression of the problem  which takes the decision variableto be a partition. again  it would be straightforward to add to conjure the necessary rules for partitions. finally  the model of sgp not generated by conjure uses a novel modelling technique that was created through insight into the structure of the problem. we have not yet considered whether that technique can be generalised and then captured in conjure rules.
1 related work in modelling support
opl   a modelling language similar to essence1  has been extended by esra  to provide relation variables and by f  to provide function variables. esra currently compiles to only a single representation  but f can produce alternative models  some with multiple representations and channelling. other work has extended constraint languages to support a single representation of both sets  and multisets . however our work is unique in providing nested types.
﹛other languages have been used to specify combinatorial problems. np-spec  uses existential second-orderlogicto express executable specifications of every np-complete problem. renker et al.  discuss representing abstract specifications in z  an expressive abstract language that is supported by automatic type-checkers and interactive tools. however  refinement and transformation of the z specification is manual.
﹛multi-tac  and cacp  1; 1  are systems that perform small-scale transformations of constraint specifications and use heuristics and search to try to improve the search strategy used in the solving of csps. these and similar systems are important steps towards automating the solving of csps  and complement our work on conjure  which at present is only concerned with refining of high-level specifications and not the search strategy to be used  and does not implement transformation rules as of yet.
﹛the area of automatic program refinement is a longstanding and mature area of computer science. kids  and specware  are among the many domain-independent systems that support the interactive or automatic refinement of formal specifications into imperative programs. our work on conjure operates in a simpler setting of transforming specifications into finite-domainconstraint models  which are declarative. because our setting is simpler  we can be more ambitious about the extent of automation achieved.
1 conclusion
this paper has made two major contributions towards realising the possibility of formalising and automating the generation of constraint models. first  the paper has presented a language that enables combinatorial problems to be specified at a level above that at which modelling decisions take place. second  the paper has shown how a system of formal rules could refine such a specification into model kernels at the level of abstraction supported by existing constraint solvers. we have also outlined an approach to integrating other aspects of model generation-channelling and symmetry breaking-into the existing system.
﹛a rigorous account of model generation would be valuable in several ways. it could make our study of modelling more systematic  revealing gaps in our understanding. it could also guide the study of model selection by identifying the decision points and the set of alternatives available at each. furthermore  it would be useful in teaching and presentingmodelling and in constructing a catalogue of modelling constructs.
﹛the automation of model generation offers further opportunities. conjure currently uses its rules to generate all possible models; but the rules could also be used within an interactive system  which  like an interactive theorem prover  allows the user to chose from among the alternatives available at a decision point. our ultimate dream is that the automation of model generation takes us one step closer to automating the entire modelling process.
acknowledgements ian miguel is supported by a uk-royal academy of engineering/epsrc postdoctoral fellowship. we thank adam bakewell for contributing to an early version of this work  and brahim hnich and toby walsh for useful discussions.
