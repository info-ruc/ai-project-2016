 
knowledge compilation is an emerging research area that focuses on  compiling  a problem solver's inefficient  explicit knowledge representation into more efficient  implicit forms. this paper presents a technique that transforms a declarative problem description  specifying the problem but not how to solve it  into a reasonably efficient  generate-and-test problem solver. our technique performs constraint incorporation  modifying the parameter generators so they only generate values that satisfy the problem constraints. successful constraint incorporation depends upon choosing the right solution representation  i.e.  the set of parameters . having expressed a constraint in terms of a particular set of parameters  incorporation fails if the constraint is not factorable into constraints on the individual parameter generators. rick  a refinement-based constraint incorporator for compiling knowledge  is a prototype program that compiles a problem specification into a problem solver using least commitment  topdown refinement to achieve constraint incorporation. rick refines an abstract solution representation to avoid premature commitment to representations that hinder constraint incorporation. rick is able to incorporate local constraints that constrain relatively small portions of the entire solution. we have tested these ideas by having rick automatically construct a house floor planning problem solver. 
   *the research reported here was supported in part by the defense advanced research projects agency  darpa  under contract number n1-k-1  in part by the national science foundation  nsf  under grant number dmc-1  and in part by the center for computer aids to industrial productivity  caip   rutgers university  with funds provided by the new jersey commission on science and technology and by caip's industrial members. the first author has also received support from ibm. the opinions expressed in this paper are those of the authors and do not reflect any policies  either expressed or implied  of any granting agency. 
* currently on leave at ibm watson research center. 
1 	introduction 
many ai systems perform run time evaluation of explicitly represented domain knowledge to find a solution to a problem. such systems make a particular tradeoff between the  explicitness of the representation and the efficiency of the computation   dietterich  ed.   1 . explicitly represented knowledge is easier to gather  but more costly to evaluate. this observation has spawned a research area called knowledge compilation  which includes methods for  compiling  an inefficient  explicit knowledge representation into more efficient  implicit forms. the work described in this paper is being conducted within the context of the kbsde project  tong  1 . the purpose of the project is to develop compilation techniques whose input is a declarative problem description that does not specify how to solve the problem. the problem description includes a set of problem constraints that must be satisfied by a solution. the compilation techniques we are developing produce a generateand-test problem solver. such a problem solver must generate a solution that passes a set of tests  one for each problem constraint. we have attempted to develop a compilation method that places as few requirements as possible on the domain  so that the method is broadly applicable. thus  we have made the very weak requirement that the problem be solvable using a generate-andtest algorithm. in addition to insisting that our compiler be general  we have also required that it produce reasonably efficient algorithms. 
   like computer language compilers  knowledge compilers can use optimization techniques to improve the performance of the resulting problem-solving system. one optimization technique for a generate-and-test architecture is test incorporation  dietterich and bennett  1 . test incorporation involves test movement  constraint incorporation  or both. test movement regresses tests back into the generator process to achieve early pruning without affecting the correctness of the problem solver. constraint incorporation  tappel  1  modifies the generator so that it enumerates only those values which satisfy a particular problem constraint; we will call such a generator a constrained generator. the test corresponding to the incorporated constraint can be removed from the generate-and-test problem solver. constraint incorporation reduces the size of the problem solver's search space and results in a more efficient problem solver. con-
	braudaway and tong 	1 

straint incorporation makes use of explicitly represented domain knowledge  e.g.  specifications for system components   thus distinguishing it from more conventional code optimization approaches which rely solely on syntactic knowledge  e.g.  data dependencies among system components . 
   this paper focuses on constructing constrained generators of hierarchical solutions  i.e.  solutions that have parts  e.g.  a house w i t h rooms . hierarchical solutions can be generated using correspondingly hierarchical generators  e.g.  figure 1 . that is  solution parts are generated by sub-generators  and primitive solution parameters are assigned values by parameter generators. a particular solution representation is defined by a set of primitive parameters. to incorporate a constraint into a hierarchical generator requires that it be localizable to and incorporated in one or more of the  primitive  parameter generators. incorporating constraints is difficult when the solution representation is  inappropriate . a 
   constraint expressed in terms of a particular solution representation can have a structure that does not  match  that of the generator; that is  the constraint may not be factorable into constraints on the individual parameter generators. we will call this difficulty the structure mismatch problem. this paper demonstrates a system which incorporates the constraints while avoiding this structure mismatch problem. r i c k   a refinement-based constraint incorporator for compiling knowledge  is a prototype program that compiles a problem solver using least commitment  top-down refinement to achieve constraint incorporation. the least commitment approach helps to avoid a premature commitment to a representation that may lead to the structure mismatch problem. 
   section 1 of this paper defines the class of domains for which our method applies and illustrates an example from this class: the house floor planning domain. section 1 illustrates the structure mismatch problem in the house floor planning domain. the fourth section discusses the concepts behind our approach and illustrates their implementation in r i c k . we compare our work with related research in section 1. finally  section 1 summarizes the paper and some of the limitations of our approach. 
1 	the problem domain 
p a r a m e t e r i n s t a n t i a t i o n 	design 	p r o b l e m s . 	the 
k b s d e project has focused on design domains where the problem solver constructs an artifact that satisfies a set of problem constraints. many design problems can be viewed as parameter instantiation problems. the hierarchical structure of the artifact is usually pre-determined 
for a class of parameter instantiation problems; for instance  all house floor plans consist of rectangular rooms  which  in t u r n   consist of sides and corners. the design task remaining for the problem solver is to  fill i n   and  interconnect  the structure by assigning values to the unspecified artifact parameters in a way that is consistent with the problem constraints. r i c k constructs a problem solver for parameter instantiation problems whose solutions are composite objects  e.g.  house floor plans . the problem constraints are presumed to be 
machine learning 

hard constraints that define feasible solutions  rather than soft constraints that define the relative optimality of feasible solutions . we also presume that the design problem is not over-constrained: a solution that satisfies all the constraints can be found. 
   a h o u s e f l o o r p l a n n i n g d o m a i n . to illustrate our ideas  we will use the parameter instantiation problem of constructing  house floor plans . a house floor plan is a two-dimensional  rectangular house placed at the origin of an x-y grid and having rectangular rooms as parts; such a floor plan is abstractly depicted in figure 1. all lengths and coordinates are multiples of 1 foot. the solution is a floor plan that contains a problem-specific number of rooms  and satisfies all of the problem constraints shown in figure 1. constraints s c i   sc1 and sc1 are  local  constraints since they constrain each individual room. constraints sc1 and sc1 are more  global   constraining pairs of rooms  and all rooms  respectively. our examples will focus on the incorporation of the local constraints. 
1 constraint incorporation and representation shift 
a s i m p l e b u t i n e f f i c i e n t g e n e r a t e - a n d - t e s t . a simple  hierarchical  generate-and-test problem solver for the floor planning domain is shown in figure 1. the generator creates a candidate solution containing descriptions for each of the n rooms specified by a particular problem. each room is generated by assigning values to its parameters using the initial representation:  x y   location of the sw room corner   /  length in the x direction   and w  width in the y direction . the generators are invoked in a particular sequence  e.g.  x  --  y --  / --  w after all the generators have been invoked  the testers evaluate the candidate solution for 

this constraint implies that a room must either have its west side on the west side of the house  or its north side on the north side of the house  etc. because this constraint refers to all the room parameters  and is a disjunction  when expressed using this room representa-

satisfaction of the problem constraints. a failure of any test results in chronological backtracking through the generator sequence so a new candidate solution can be generated. 
   for a 1 foot house with 1 rooms  this problem solver  figure 1  has a generation space containing 1 candidate solutions  1 rooms  each having 1 parameters that each range over 1 values . only a small number of these are acceptable solutions  that satisfy constraints s c i sc1 . in a solution for this problem  each room is in a 
   house corner; one room has 1 possible sizes  / - 1 | 1 and w = 1 | 1 ; its two adjacent rooms have only two possible sizes  w = 1 | 1 for one  / - 1 | 1 for the other ; the final room fills the remaining area. thus there are 1 = 1 x 1 x 1 x 1 different room configurations. these rooms can be labelled r1 ... r1 in 1! different ways. thus the total number of acceptable solutions is 1 x 1 ! = 1. 
   assuming a uniform distribution of acceptable solutions in the space of candidate solutions  the generateand-test problem solver will generate roughly 1/ 1 = 1 * 1 1 candidates before finding a solution. 
this problem solver is very inefficient. 
   t h e s t r u c t u r e m i s m a t c h p r o b l e m . we use constraint incorporation to improve the efficiency of the problem solver. for example  constraint sci is easily incorporated by changing the lower bounds of the length and width generators from 1 to 1. the candidate solutions that violate sci will not be generated; this leaves a search space of roughly size 1 x 1 candidate solutions  1 rooms  each having 1 parameters  1 ranging over 1 values  and 1 ranging over 1 values . 
   unfortunately  incorporating a constraint can be difficult when the problem constraint on the entire solution cannot be partitioned into constraints on individual parameter generators  as we have just done. this case can occur when an inappropriate solution representation is chosen. for example  representing rooms by the four pa-
　　the hl  the house length value in the x direction  and hw  house width value in the y direction  are parameters whose values are problem-specific. 
tion   there is no easy way to factor it into constraints on the individual room parameters. because of the structure mismatch problem in this case  incorporation fails. 
   constraint incorporation as representation shift. note  however  that the constraint refers to the containment  segmentof  of a room side within a house side. a more appropriate solution representation would have represented a room rectangle by two perpendicular  side objects   each  side object   in turn  having a location and a length . given this representation  we could incorporate the  side adjacency  constraint by simply modifying the generator of one room side so as to place it along one of the four house sides. 
　our example suggests an obvious method for incorporating a constraint: shift the representation of either the constraint  the generator or both  until incorporation succeeds. unfortunately  the space of alternative representations is rather large. also  the need to incorporate multiple constraints into a single generator means that the method must find a single representation that enables incorporation of all the constraints. problem reformulation is a difficult research problem with many unresolved issues  korf  1 . in the next section  we present an alternative approach for knowledge compilation that reduces the combinatorial explosion when searching a space of representations. 
1 knowledge compilation as incremental constraint incorporation 
1 viewing constraints as generators of partial solutions 
construction of the inefficient  generate-and-test problem solver depicted in figure 1 was based on viewing a problem constraint as a test on complete solutions. in contrast  our constraint incorporation approach  implemented in the rick program  is based on viewing a constraint as a constrained generator of partial solutions. for example  the  side adjacency  constraint  sc1 : 

	braudaway and tong 	1 


in contrast  a generator of complete rooms would construct complete 1-sided rooms. generator gp sc1  is constrained since it only generates  partial  solutions 
that satisfy the side adjacency constraint. 
　generator gp sc1  is expressed in terms of abstract objects such as room sides and house sides  instead of 
primitive parameters such as x  y  1  or w. this formulation of the generator is motivated by the constraint itself  which only specifies these abstract objects  and makes no commitment to their primitive parameter representation. several representation alternatives are usually possible; to unnecessarily commit to a particular one might make incorporation of other constraints difficult or impossible  due to the structure mismatch problem . 
　in short  to facilitate a least commitment approach  the constraint should be re-expressed as a  partial solution generator  that is: 
  partial. it only generates those parts of the  hierarchical  solution specified in the constraint. 
  abstract. the generated parts are expressed in terms of abstract objects. 
　which constraints can be re-expressed in this way  almost by definition  in order for a constraint to be reexpressible as a generator of partial solutions  it must be a  local  constraint; that is  it must constrain only a part of the solution. this paper summarizes how rick incorporates the three constraints sc1-sc1  figure 1  that are local to individual rooms. 1 extending this idea into a complete method 
the following observations will help motivate the extension of this idea into a complete method: 
   partial  by construction  the partial solution generator gp c  only generates solutions that satisfy the constraint c. 
   extend  any consistent extension of gp c  into a generator of complete solutions will also only generate solutions that satisfy c  thereby completely incorporating the constraint. in a similar manner  if a constrained generator of partial solutions is guaranteed to satisfy a set of constraints  then so will any consistent extension. 
we will call such extensions refinements of the partial solution generator. for instance  the  single room side  generator g p  1  generates room sides on the house boundary  thus creating partial rooms that satisfy sc1 . 
1
　　the notation gp c  specifies a partial solution generator whose generated values always satisfy the constraint c. 
machine learning 
g p  1  can be extended into a complete room generator that generates rooms with  at least  one side adjacent to the house boundary. thus the  side adjacency  constraint sc1 is still guaranteed to be satisfied. 
　to represent the hierarchical structure of the artifact  e.g.  a house with rooms   rick uses an object hierarchy to organize the knowledge needed for constructing partial solution generators and their refinements. the hierarchy contains two types of relations between ob-
jects:  subclass    isa   and  part-of . the hierarchy economically  and modularly  represents an entire set of alternative solution representations  at differing levels of abstraction. this hierarchy also contains the relevant structural constraints common to rectangular ob-
jects  e.g.  the west room side is perpendicular to the 
north room side.  
　we have described the first and third steps of a complete method for incorporating constraints by refinement. the three steps are: 
step1. re-express each constraint c as a partial solution generator gp c   see partial . 
step1. merge each partial solution generator into a single solution generator g m  {c i }  which is guaranteed to satisfy the set of constraints 
{cii} 
step1. refine generator gm {ci}  into a generator of complete solutions  expressed in terms of primitive parameters   see extend . 
for a more complete description of the method  refer to  braudaway  1 . 
   by representing partial solution generators  we have fulfilled the major requirement of a least commitment approach for designing constrained generators. that is  when rick incrementally constructs the generator  it only adds more detail when necessary. since rick constructs a partial solution generator from the problem constraint  achieving incorporation during construction   it avoids the structure mismatch problem described in section 1. we have replaced the structure mismatch problem with the new problem of merging several partial solution generators into a single consistent solution generator. 
1 	merging partial solution generators 
in our floor planning example  rick creates three partial solution generators  one for each of the local constraints sc1-sc1  figure 1 . from constraints sci and sc1  rick produces two  room side  generators  and from constraint sc1 it produces a generator pair for the diagonally opposed room corners  sw and ne. merging these partial solution generators is complicated by the interactions that occur between them. for example  each room must both be inside the house  sc1  and have at least one side on the house boundary  sc1 . 
　when  simulated   a partial solution generator creates  values  that are either abstract objects from the object hierarchy  e.g.  corners sw and ne for a room r   computable functions on such abstract objects  e.g.  corner sw ♀ points lcft house boundary    or both. to 

say that generators interact means that at least one combination of generatable values is inconsistent. 
   this suggests a simple approach for solving the interaction problem: 
  systematically generate all combinations of values of partial solution generators  testing each combination  an abstract  partial solution  for consistency. 
  construct the merged generator by caching only the consistent solutions. 
figure 1 illustrates r i c k ' s application of this method to the floor planning domain. each combination of values is depicted as a different path in a search tree. for example  the left most path in the tree is constructed when the partial solution generators produce values:  hs=house west side  rs=room west side ; the next left most path corresponds to  hs- house west side  rs- room east side ; etc. 
after generating a particular path in the search tree 
 a particular value combination   a corresponding set of constraints  implied by the value combination is collected. for example  the value combination  hs=house west side  rs = r o o m east side  implies that the east room side must be placed on the west house side: xcoord secorner rs   = xcoord swcorner hs  . 
   because all the constraints in this domain are linear  algebraic constraints  r i c k uses a linear program  the simplex method  to determine their consistency  i.e.  the existence of a feasible solution to these constraints . 1 
   the linear program discovers that the above constraint is inconsistent w i t h  sc1   the  inside house  constraint: 
xcoord swcorner hs     xcoord swcorner rs    and a constraint associated with rectangles in general: 
xcoord swcorner rs     xcoord secorner r1  . the inconsistency of these constraints follows by transitivity. intuitively  this indicates that the abstract solution has forced the sw room corner outside the house. 
   if an abstract solution is consistent  r i c k caches it into a unified generator description. as illustrated in figure 1  four out of eight abstract solutions are found to be consistent  the ones in the figure that have not been crossed out   and are cached into a single  unified generator description: 
1
　　 we realize in retrospect that we should use an integer programming method to guarantee the soundness of the answer. we can also extend this approach by using routines that check the consistency of other classes of  nonlinear  constraints. note that this floor planner cannot be implemented as a linear program  primarily because some of the constraints sc1-sc1 are expressed as disjunctions. 
select a house side hs  from { w   n  e  s} 
generate a r o o m side  rs  f r o m { w   n  e  s} u sidescorrespondingto ffs  1 w i t h corners e points hs  
　the merge process has thus resolved the interaction between the  side adjacency   sc1  and the  inside house   sc1  constraints. 
   by using a  good  abstraction hierarchy  only relatively abstract value combinations need to be tested. furthermore  there are a relatively small number of these abstract solutions. the pruning of inconsistent abstract solution candidates removes entire equivalence classes of inconsistent solution candidates produced by a complete solution generator. 
1 	refining into primitive representations 
after merging the partial solution generators  step1   the resulting unified generator must be refined into a complete generator  which consists of a set of primitive parameter generators. constraint incorporation has been completed in the merging step. thus all complete generators refined from the merged generator  step1  will have the same generation space  even though it will be represented differently . since rick only distinguishes between alternative algorithms based on the size of their constrained generation spaces  it views all of the refinements as equally  good   and constructs all of them. in the floor planning example  these alternative refinements correspond to the various alternatives for representing a rectangle in terms of primitive parameters  e.g.    x y l w   . 
　in actuality  the alternative problem solvers are not equally good; differences in data and program structures cause differences in space and time complexity. ideally  selection should be based on criteria for data and program structure optimization. in the current prototype system  the user selects the  best  alternative  which is then translated into lisp. 
　when applied to the floor planning example  our method incorporates the three local floor planning constraints sc1-sc1  figure 1 . the resulting problem solver  figure 1  generates each room by picking a room location  x y  from a point on a house side. the room specification is completed by generating length and width values  starting from the required minimums  that place the room inside the house with respect to the room's location  x y . 
   this problem solver generates roughly 1 x 1 candidate solutions for a 1 house with 1 rooms  see figure 1 . for each of the 1 rooms  there are 1 ways to pick a house side  hs; for each of these cases  there are 1 ways to pick a room side that is a subsegment of that house side; also  there are 1 ways to pick the perpendicular magnitude. thus the total number of candidate solutions is  1 x 1 x 1. 
　this is a reduction in complexity of 1 orders of magnitude from the inefficient  generate-and-test problem 
1
　　a mapping that associates west room side with west house side  north room side with north house side  etc. 
	braudaway and tong 	1 

solver previously shown. further research will attempt to extend rick  allowing it to also incorporate necessary constraints. a  necessary constraint  that is not satisfied by a partial solution will not be satisfied by any extension of the partial solution. for example  the constraint that  no rooms overlap  is a necessary constraint in the floor planning domain  since  if rooms overlap in a partial solution  they continue to overlap in all extensions of that partial solution. the problem solver resulting from incorporation of this constraint will have a generation space of 1 candidates  1 of which are solutions  for this 1 example. 
1 	related work 
k n o w l e d g e c o m p i l a t i o n as a design process. to facilitate the comparison of our work with related work in knowledge compilation  it is useful to view knowledge compilation as a design process that designs a problem solver from the specification for a class of problems. we contrast three approaches according to their model of the design process and the manner in which domain knowledge is used to produce reasonably efficient algorithms. 
k n o w l e d g e c o m p i l a t i o n as i t e r a t i v e re-design. 
tappel  defi nes test and constraint incorporation as modifications to a data-flow graph representing the components of the algorithm to be synthesized. a test refers to certain solution components; hence these solution components must be generated before the test can be run. tappers approach moves a test backwards in the algorithm's data-flow graph until it is placed just after the generators of these referenced solution components. an attempt is also made to modify the generator so only values that satisfy the test will be enumerated. 
machine learning 
tappel's approach takes a generate-and-test algorithm as input and iteratively re-designs it by incorporating constraints. 
   the strategy used by d i o g e n e s  mostow  1  is similar to tappeps but uses a transformational approach to modify an initial generate-and-test algorithm  for possibly over-constrained problems  into a more efficient heuristic search algorithm. this approach uses domain knowledge that has been procedurally embedded in some or all of the transformations. however  the design knowledge for controlling the compilation process is supplied by the user of the d i o g e n e s system  who selects among applicable transformations . the model of design used by both of these strategies is essentially hillclimbing that iteratively re-designs a problem solver to improve its efficiency  though some steps do not directly improve efficiency but have the purpose of enabling other optimization steps . 
   k n o w l e d g e c o m p i l a t i o n a s s c h e m a i n s t a n t i a t i o n . k i d s  smith  1  focuses on mapping declarative knowledge into a global search algorithm. a global search algorithm splits a set defining all candidate solutions of a problem into subsets and extracts solutions from the subsets when possible. this approach uses declarative domain knowledge in the form of procedural schemas. for example  one global search schema enumerates all bounded sequences over a finite set. the method finds the domain-specific schema that best matches the problem domain  and then instantiates it into an efficient algorithm  using information drawn from the problem specification . constraints are formulated and incorporated during instantiation of the procedural schema. k i d s is able to reason about problem specifications that include functional constraints  constraints on i/o behavior  and optimality criteria. 
   k n o w l e d g e c o m p i l a t i o n a s t o p - d o w n refinem e n t . r i c k constructs constrained generators of solutions whose feasibility is defined by problem constraints. in contrast w i t h the iterative re-design approaches  which incorporate constraints after a complete problem solver has been created  r i c k refines the problem constraints into partial solution generators  which are then merged   thus simultaneously designing the problem solver and incorporating constraints. in contrast with k i d s   r i c k designs the problem solver by refining the problem description into a correct data representation  i.e.  a representation of the generated solution  rather than choosing the proper procedural representation for the problem. by using a least commitment approach for representation selection  r i c k decouples the issues of incorporating constraints and representing generated solutions. 
   d i f f i c u l t i e s in d e s i g n i n g a r e p r e s e n t a t i o n . expressed in terms of a particular solution representation  some constraints are local constraining relatively small portions of the entire solution  while others may be global constraining the entire solution or interrelating several parts of the solution. therefore  whether a con-
     the case statement defines a conditional generator range that depends on the value of h s .  a b  is the generation sequence from a to b  incremented by 1. 
straint is local or global is a function of the solution representation. to incorporate as many constraints as possible into a more constrained problem solver  rick must use a representation which maximizes the number of local constraints  the type of constraints rick can incorporate during compilation . however  the odds are that no single representation language exists in which all the constraints are local. in other words  not all problem constraints can be incorporated using the method described in this paper. another research effort within the kbsde project  voigt  1  focuses on the problem of procedurally embedding the  left over   unincorporated  global constraints. 
   other w o r k . other related work includes the discussion by steier and kant  on  developmental evaluation   a framework which could be said to include our abstract  symbolic simulation approach; cohen's program   which translates a declarative specification into a generate-and-test algorithm; and van baalen's program   which iteratively designs useful  analogical problem representations  for solving verbal reasoning problems such as those found on college admissions tests  built from a library of standard data structures. 
1 	conclusions 
complete incorporation of a constraint into a generator is a difficult task  especially when the constraint  expressed in terms of the generated parameters  has a structure that is not factorable into constraints on the individual parameter generators. this paper has described and illustrated the results of the rick program which avoids this structure mismatch problem by viewing problem constraints as generators of partial solutions. rick incorporates a problem constraint by refining it into a generator of partial solutions that are guaranteed to satisfy the constraint. these partial solution generators are then merged into a single abstract generator. during merging  interactions between partial solution generators are resolved by  simulating  the generators and caching only those generated combinations of values that are proven to be consistent. since the constraints are fully incorporated into the merged generator  further refinement of the merged generator into a complete generator of primitive parameters will not create a structure mismatch problem. rick produces problem solvers that solve parameter instantiation problems for design domains. thus  rick incorporates constraints defining structural relationships  but does not currently incorporate constraints that restrict i/o behavior  or specify optimization criteria. in particular  rick currently incorporates local constraints that are linear  algebraic constraints on composite objects. 
   further work will attempt to extend the type of constraints that rick can incorporate  and to extend the structural representation of the hierarchical solution. this includes generalizing rick to handle a hierarchical solution containing multiple objects and necessary constraints on multiple objects  i.e.  some global constraints . experiments are being conducted to test whether rick is insensitive to changes in the object hierarchy representation and constraint predicate definitions. the goal of this study is to determine the power and generality of this approach to algorithm synthesis. 
acknowledgements 
we would like to thank the members of the kbsde group and the knowledge compilation seminar. we are also grateful to the members of the rutgers ai/design project for the stimulating environment they provide. 
