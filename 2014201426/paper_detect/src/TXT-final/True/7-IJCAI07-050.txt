
this article falls under the problem of the symbolic monitoring of real-time complex systems or of video interpretation systems. among the various techniques used for the on-line monitoring  we are interested here in the temporal scenario recognition. in order to reduce the complexity of the recognition and  consequently  to improve its performance  we explore two methods: the first one is the focus on particular events  in practice  uncommon ones  and the second one is the factorization of common temporal scenarios in order to do a hierarchical recognition. in this article  we present both concepts and merge them to propose a focused hierarchical recognition. this approach merges and generalizes the two main approaches in symbolic recognition of temporal scenarios: the store totally recognized scenarios  strs  approach and the store partially recognized scenarios  sprs  approach.
1 introduction
symbolic scenario recognition arises in monitoring of dynamic systems in many areas such as telecommunications networks supervision  gas turbine control  healthcare monitoring or automatic video interpretation  for an overview  refer to  cordier and dousson  1  .
모such scenarios could be obtained among other things by experts  by automatic learning  fessant et al.  1; vautier et al.  1  or by deriving a behavioral model of the system  guerraz and dousson  1 . due to the symbolic nature of those scenarios  the engine performing the recognition is rarely directly connected to sensors. there is often  at least  one dedicated calculus module which transforms the  raw  data sent by the system into symbolic events. typically this module can compute a numerical quantity and sends symbolic events when the computed value reaches given thresholds. in cognitive vision  this module is usually a videoprocessing which transforms images into symbolic data.
모often those scenarios are a combination of logical and temporal constraints. in those cases  symbolic scenario recognition can process the scenarios uniformly as a set of constraints  like the event manager of ilog/jrules based on a modified rete algorithm for processing time constraints  berstel  1   or separate the processing of temporal data from the others like in  dousson  1 . this article mainly deals with this second approach where temporal constraints are managed by a constraint graph between relevant time points of the scenarios. there are two approaches for dealing with temporal constraints: strs recognizes scenarios by an analysis of the past  rota and thonnat  1  and sprs which performs an analysis of scenarios that can be recognized in the future  ghallab  1 . two main problems in the sprs approach are the fact that scenarios have to be bounded in time in order to avoid never expected ending scenario  in practice  when working on real-time systems  it is difficult to exhibit scenario which cannot be bounded in time ; and  second  that sprs engine has to maintain all partially scenarios which possibly leads to use a large amount of memory space. to partially avoid those drawbacks  the implementation of sprs algorithms in  dousson  1  introduces a clock and deadlines which are used to garbage collect the pending scenarios. on the other hand  the main problem with strs algorithms is to maintain all previously recognized scenarios. to our knowledge  no work has been published on how long such scenarios should be maintained. in addition  strs does not provide any kind of  prediction  as sprs does.
모a first attempt to take the benefits of both approaches was made in  vu et al.  1 . it consists of a hierarchization of the constraint graph of the scenario. it deals only with graphs where all information about time constraints can be retrieved from a path where temporal instants can be totally ordered. the hierarchy constructs an imbricated sequence of scenarios containing only two events at a time. the principle of the recognition is  at any instant  to instantiate elementary scenarios and when an event is integrated in a high-level scenario  looking for previously recognized elementary scenarios. the purpose of this article is to generalize this method; the starting point will be an sprs approach and the generalization mixes reasoning on past and future. as a byproduct  strs and sprs methods appear as two extreme kinds of the propose focused hierarchical recognition.
모the next section presents the used sprs approach and details some aspects which are relevant to this paper. the section 1 is dedicated to the temporal focusing which enables the system to focus on uncommon events prior to others. events could be not only basic events coming directly from the supervised system but aggregated indicators. so the temporal focusing could be used in order to control the computation of such indicators on particular temporal windows and to avoid useless computation. as such indicators could be themselves scenarios  section 1 presents how the hierarchical recognition deals with common subscenarios. finally  we show that both concepts could be merged and experimentally lead to good improvement of performances. this will be the object of the section 1.
모we conclude in section 1 by experimentation on detecting naive servers in a reflected distributed denial of service  rddos  attack.
1 chronicle recognition system
our approach is based on the chronicle recognition as proposed in  dousson  1  which falls in the field of sprs methods. a chronicle is given by a time constraint graph labeled by predicates.
모an instance of event is a pair  e t  where t is the date of the event and e is its type. when no ambiguity results  we sometimes do not distinguish between an event and its type. figure 1 shows a chronicle which contains four events: the event e  if instantiated  must occur between 1 and 1 units of time after an instantiation of f  the event g must occur between 1 and 1 units of time after e and between  1 and 1 units of time after e.

figure 1: a chronicle.
모note that the complete formalism is based on a reified logic  a chronicle is a conjunctive formula  and introduces also predicates on persistency or event absence. in this article we choose to present in details the focusing from the time constraint graph point of view  other predicates are also taken into account but not discussed here.
1 recognition algorithms
let crs  chronicle recognition system  denote the algorithm of recognition. basically the mechanism of crs is  at each incoming event  to try to integrate it in all the pending  and partial  instances of the chronicle model and/or created a new instance and calculating  using constraint propagation  dechter et al.  1   new forthcoming windows for all the forthcoming events of each instance. an instance of a chronicle model is then a partial instantiation of this model and forthcoming windows fc e  of a non-instantiated event e is the  extended1  interval where the occurrence of an event could lead to a recognition1.
모figure 1 shows the mechanism of the recognition algorithm on a small example: when crs receives f at 1  it creates the new instance i1 and updates the forthcoming window of the node e. when a new f occurs at 1  instance i1 is created  the forthcoming windows of i1 is updated  using  a clock tick set at 1 . when e occurs  i1 is created  from i1  and i1 is destroyed as no more event e could from now be integrated into  instance i1 is not destroyed  waiting for another potential e between 1 and 1 . as all events of i1 are instantiated the chronicle i1 is recognized.

figure 1: created instances of a chronicle by the incoming event stream  f 1  f 1  e 1 .
1	from clock to  assertnomore  event.
in first implementations of chronicle recognition  a clock was introduced in order to discard  impossible  instances when the clock goes past one of their forthcoming windows  see behavior of i1 in figure 1 .
모in order to take into account some jitter in data transmission a possible delay 붻 can be taken into account. this delay bounds the maximum difference observed at reception between two events sending at the same time by the  possibly distributed  system. basically  the event integration algorithm could be written as following:
integrate  e t  ; setgarbageclock t   붻 
모the main drawback is that it implies that events arrive roughly in a fifo manner  the allowed jitter is bounded by 붻 : so  when the fifo hypothesis should be relaxed  and it is often the case when the monitored system is distributed   붻 should be increased and the garbage efficiency decreases 1.
모in order to avoid this  instead of a clock  we define a new input message:  assertnomore e i    where e is an event type and i an extended interval. it specifies to crs that  from now on  it will not receive more events of type e with an occurence date in i. this mechanism is implemented in crs by managing one forthcoming window for each event type which is updated when receiving an  assertnomore  message.
모we do not describe here how crs deals with this assertion as it is very close to the previous crs. intuitively  all the forthcoming windows of e are reduced  fc e    i   these windows are propagated according to the constraint graph of the

incremental and some strs mechanism where integration is made by block in a backward manner. 1
모모in case of focusing  an other side effect of using clock is the creation of  false  instances. this will be explained in section 1.
chronicle and  if a forthcoming window becomes empty  the instance is discarded. the previous garbage collect of crs could be emulated by the following:
integrate  e t  ;
  event type e  assertnomore
it illustrates that the previous clock management forces all the event types to be synchronized: in other words  if one kind of event could be widely jittered  then all event types are supposed to be the same. notice that  as we allow the use of extended intervals  more complex garbage management could be easily implemented: it could be different from     clock  and non chronological: we could process 
 for instance   assertnomoreassertnomore e  1   .  e  1  뫋  1    and  then 
모this point of view changes slightly the manner the engine works: the progress of time is no more driven by the observations coming from the supervised system but by an  internal  control  this control could be given by the knowledge of the temporal behavior of the system. we will see in the next section how this new feature is essential for an efficient temporal focusing.
1 the temporal focusing
1 general description
in some cases  not all events have the same status: in example on figure 1  event f could be very frequent and event e extremely uncommon. due to this difference of frequency  the recognition of the chronicle could be intractable in practice  indeed each event f potentially creates a new instance of the chronicle waiting for other events: if a thousand f arrive between 1 and 1  a thousand instances will be created. as event e is extremely uncommon most of those instances would be finally destroyed. in crs  the number of creation of instances has a great impact on performance of the recognition. in order to reduce this number  we focus on event e in the following manner: when events f arrive  we store them in a collector and we created new instances only when events e occur  then we will search in the collector which f could be integrated in the instances. potentially the number of created instances will be the number of e and not the number of f. in order to be not limited to uncommon events  we order the recognition process by introducing a level for each event type. the principle of the temporal focusing is then the following:
temporal focusing: begin the integration of events of level n + 1 only when there exists an instance such that all events of level between 1 and n had been integrated.
so  if level e  뫞 level f   the engine will integrate e at t = 1 then it will search in the collector all events f between t = 1 and t = 1. the collector finds  f 1  and sends it to the engine  this leads to the creation of the instance i1. technically we made the choice of sending f not only to instances waiting for events of same level but to all the pending instances. as the number of f sending from the collector to the engine is small  only a small number instances are created. this also ensures that the collector sends an event one and only one time. so  in our example   f 1  leads to the creation of instance i1 with fc e  =  1 .
모in addition to the recognition engine  we developed some modules  see figure 1 : an event router which routes the events coming from the supervised system to either the engine or the collector; a module named finished level detector which detects when a particular instance of chronicle has finished to integrate all events of level lesser than n  then looks at the forthcoming windows of events of level n+1 and sends them  through a  focus  message  to the collector as a request for events. at last  a module called no need window calculator  which computes for all current instances the windows where they do not need events of greater level and sends this information to the collector via a  discard  message. in order to make the buffer management easier  the collector itself is split into buffered streams: one for each event type.

figure 1: architecture of the focused recognition.
모at this stage  we have defined two messages for a feedback control on the production of event of high level: crs is able to focus on specified time windows  by sending a  focus  message  but also could discard events in irrelevant time windows  by sending a  discard  message .
1 the buffered streams
the collector is composed of many buffered streams  each of them is dedicated to one event type. this section presents how it works: each buffered stream manages three particular temporal windows  see figure 1  :
i  the assert no more window  nm  which contains all the occurrence dates for that no more event will be received from now 

figure 1: the 1 control windows used to manage the buffer. or  focus   updates also the buffered stream:
 assertnomore f w   : it updates the windows  see fig. 1  nm 뫹 nm뫋w  fil 뫹 fil w and foc 뫹 foc w and sends to crs  assertnomore f w 뫌 foc  .
 discard f w   : it destroys all events in w  then updates the windows : fil 뫹 fil 뫋  w nm   foc 뫹 foc w and sends back to crs  assertnomore f w  1.
 focus f w   : it sends all events in w  then updates the focused window: foc 뫹 foc 뫋  w  nm 뫋 fil  and sends back to crs  assertnomore f w 뫌  nm 뫋 fil   .
so  during the recognition process  the following properties are always true : i  the windows nm  fil and foc are mutually exclusive. ii  there is no buffered event in the filtered and the focused windows. whatever the levels in a chronicle  this mechanism performs exactly same recognitions as crs with no focusing; only the performances are affected.
1 partial order and relative event frequencies
in figure 1  if e is much more frequent than f  there is no need to define level  as  if no f was arrived  no e initiates new instances  thus the number of partial instances equals number of f. so relatively to an other event e  event f  very frequent  should be leveled only if  in the partial order induced by the constraints   in particular when e and f are not ordered  for example if e    1뫸 1  f. we can decompose instances into two categories: the instances where f is before e for which the focusing will be particular efficient and the figure 1: behavior of a buffer when it receives one control message   assertnomore    discard  or  focus  .
other part where f is after e  in this case f should be directly sent to the recognition engine which is done by the use of the maintained focus window. an other case where focusing is
 a b 
useful is when f  뫸 e  with a b 뫟 1  with e fifo but f having a jitter delay greater than b. to sum up  setting a level to an event is based on an a priori knowledge of its incoming frequency and on its position in the constraint graph.
모the focusing must be combined with hierarchization in the case where one can identify uncommon sub-patterns or when more than one occurrence of a frequent event is required for the recognition  see section 1 and 1 for an example .
1 hierarchical chronicles
a hierarchical chronicle is a pair  c {h1 ... hn}  where c is the base chronicle and hi are the sub-chronicles; we assume that events involved in c can take value in the set of sub-chronicle labels {h1 ... hn}. we treat only deterministic hierarchical chronicles1  i.e. we do not allow two sub-chronicles having the same label  so  in the following  we make no distinction between the chronicle and its label. moreover we suppose that each hi has a distinguished event bi. the hierarchical chronicle c will be recognized if it is  classically  recognized with integrated events labeled by a sub-chronicle hi have the date of an integrated event bi in a recognized instance of hi. in other words  when a subchronicle hi is recognized  it  sends  to all chronicles the event  hi date of bi .
모in figure 1  the hierarchical chronicle h =  c {h k}  possesses two sub-chronicles h and k  the chronicle k is composed of two types of events: a basic one  f  which comes from the supervised system  and one from the sub-chronicle h. the distinguished events are respectively e and h.

figure 1: the hierarchical chronicle  c {h k} .
모let c be a chronicle with constraint graph g and with an event h  where h is a subchronicle with distinguished element b and with constraint graph v . expanding the chronicle c  or its graph  is replacing the node h 뫍 g by the graph v   specifying that the constraints between b and g v are the constraints of h 뫍 g. let the relation hi 뫸 hj be defined if hj contains the event type hi. the hierarchical chronicle is structurally consistent if. in this case the expansion of a hierarchical chronicle is well defined  the graph of the figure 1 is the expansion of  c {h k}  . a hierarchical chronicle c is consistent if there exists a set of events s.t. c is recognized. it is straightforward that a  structurally consistent  hierarchical chronicle is consistent iff when expanding sub-chronicles the obtained constraint graph is consistent.

figure 1: the expansion of the hierarchical chronicle c.
모hierarchical chronicles can come from two ways: the first one is that the chronicle is initially specified in a hierarchical manner  for example if the architecture of the system is itself hierarchical; the second one is  starting from a flat chronicle  we identify identical patterns inside this chronicle. the next proposition is a necessary and sufficient condition to the hierarchization of a  temporal  pattern and shows we have to take care in pattern factorization: two subgraphs could be identical  with same constraints  but one of them can satisfy the condition and the other not.
proposition 1 let g be a minimal constraint graph and u   g a subgraph. let b 뫍 u be a  distinguished  node and h the hierarchical chronicle defined by
and h = u  where has the same constraints as node b. then h and g recognize the same events iff
	 a 뫍 u  c 뫍 g u dac = dab + dbc	 1 
where dxy is the time constraint between nodes x and y in the graph g.
1 focused hierarchical recognition
in this section  we present how focusing and the hierarchization could be mixed. we need to add a module which transforms the windows of high level events representing subchronicles into those of the different buffered streams representing the events in the sub-chronicles.
모we only present the formula for updating the filtered window: when the collector receives a  discard  message for f  it transforms it into a  discard  message for all events of the sub-chronicle f  but needs also to take into account other high-level events. in order to do that  we also introduce a filtered window for all high level events representing a subchronicle.
   so  the window of the  discard  message receives by the buffered stream of event type e  included in f  is given by: where de bi is the time constraint from e to the distinguished node bi of fi and where:
 b
with natural extension to the set of extended intervals.
remark: an example of gain of focusing vs. techniques presented in  vu et al.  1  is that for subgraphs with  1  constraints  co-occurrence   we don't have to explore combination of partial instantiation but only store events and wait for an event in the future in order to extract from the collector events with the  good  parameters; thus all the combinatorial explosion of elementary scenarios is avoided.
1 experimentation
this experiment was done on real data coming from the real case application which motivates this work: the detection of rddos  reflected distributed denial of service  attacks in ip networks.
모in such attack  machines with the spoofed ip address of the victim send syn messages to naives servers. then  those servers will reply by sending to the victim syn/ack messages generating a massive flooding. characteristic of the attack is that syn traffic to naive server is low  persistent and  taken alone  do not trigger an alarm. we want to identify the naive servers. in our experiment  information on the global traffic are sent way up by dozens of core routers. preprocessing is done by a particular numerical algorithm which computes throughput between pairs of ip addresses and sends alarms when this throughput is greater than two thresholds: a low one  l events  and a high one  h events .
모so crs receives two kinds of events: h ip dest  and l ip scr  ip dest  where variables are ip addresses of the source and of the destination. to identify the ip addresses of the naive servers  the focused hierarchical chronicle to recognize is :

figure 1: the focused chronicle to detect naive servers.
모where event h is of level 1 and synlow of level 1. we do not discuss here the choice of threshold nor the relevance of the chronicle  our aim is to present performance of focusing face to huge amount of data. the log contains 1 events  l and h   its period is equal to frequencies are 1 l/sec and 1 h/sec. due to a lack of synchronization of routers the jitter delay is set to 1s. we compare processing time1 for 1 different cases: on one hand  using previous crs with clock management  clk   dousson  1  or using crs with  assertnomore  extension  anm   and on the other hand by using a hierarchical chronicle with focusing  fh  or the corresponding flat chronicle.
processingcreatedmaximaltimeinstancescollector's sizecrs+clk1 min.1n.a.crs+anm1 min.1n.a.fh-crs+clk1 min.1fh-crs+anm1 s.1모considering only the anm extension  the processing time decreases a little since the garbage collect is more efficient: partial instances have a shorter lifetime in memory. the amount of created instances is considerably reduced when using focusing. the difference between number of instances when using clock  1  and when using anm  1  is explained on this example: for the leveled chronicle of figure 1  when f arrives at t = 1  we store it and the clock is set to 1; but when  e 1  arrives  the clock can not be set to 1 otherwise all current instances would be discarded; so  even if in the fifo hypothesis  it is necessary to set the delay to 1  the upper bound of the constraint between f and e . by this artifact  a  possible large  number of  false  instances are uselessly created. the introduction of this delay has also an incidence on the collector's size.
1 conclusion
this paper presents two improvements of chronicle recognition. the first one is the focusing on particular events which allows the system to reason on the past and on the future in a homogeneous manner. the second concerns the hierarchical recognition based on subpatterns. we also showed that mixing both improvements increases the efficiency and also fills the gap between sprs and strs approaches which are completely covered. in practice  our approach is sufficiently adaptive in order to fine-tune the recognition system. for instance  the order of event integration could be different from their arrival order. moreover  focused events could postpone some expensive numerical computations to generate events and avoid useless ones.
모future works will take two directions: the first one is to define a more flexible way to factorize common patterns - condition 1  proposition 1  is too restrictive for many practical cases. as dealing with the event frequency substantially increases the efficiency of crs  the second direction will be focused on online analysis of event frequency in order to adapt dynamically the hierarchical temporal focusing.
