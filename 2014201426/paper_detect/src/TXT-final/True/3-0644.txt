
compilability is a measure of how effectively compilation  or preprocessing can be applied to knowledge bases specified in a particular knowledge representation formalism; the aim of compilation is to allow for efficient  on-line query processing. a theory of compilability has been established for organizing knowledge representation formalisms according to a scheme of  compilability classes   and bears strong analogies to the classical theory of complexity  which permits the organization of computational problems according to complexity classes. we develop a novel theory of compilability  called parameterized compilability  which incorporates the notion of parameterization as used in parameterized complexity and permits for refined analysis of compilability.
1 introduction
compilability. many computational reasoning problems involve deciding whether or not a query is entailed by a knowledge base  or database . such reasoning problems are often computationally intractable. a methodology for coping with this intractability is compilation  also called preprocessing   which involves translating a knowledge base into a form that allows for more efficient query processing. compilation is appropriate for knowledge bases that remain stable over time and will be queried numerous times  even if the compilation itself cannot be performed efficiently  since the cost of the compilation will be amortized by the speed-up in query processing. although recent years have seen many interesting results on compilation  the basic idea of simplifying a sequence of computations by preprocessing a set of useful values is as old as mathematics  as discussed in  cadoli et al.  1 .
a systematic theory. a number of results in the nineties demonstrated non-compilability results  which show  for instance  that the knowledge bases of a particular knowledge representation formalism are not compilable to those of another formalism in which query processing can be performed in polynomial time. the initial results of this type  including  cadoli et al.  1; 1; 1; gogic et al.  1   were based on ad hoc proofs that did not explicitly use a unified proof technique.
¡¡in  cadoli et al.  1   a robust theory of compilability was developed that made it possible to systematically organize knowledge representation formalisms according to their compilability  much in the way that classical complexity theory made it possible to systematically organize languages according to their  in tractability. in particular  the theory of compilability provides a way to define  for every classical complexity class c  an analogous compilability class comp-c; the theory also provides a notion of reduction for use with the compilability classes comp-c. the compilability class comp-p  which is the analog of p  those languages decidable in polynomialtime   contains those formalisms that are compilable to a second formalism in which query processing can be performed in polynomial time. in saying that a formalism is compilable to a second formalism  we mean  roughly  that for every knowledge base x of the first formalism  there is a knowledge base f x  in the second formalism having the same answers to queries as x and such that the size of f x  is always polynomial in the size of x. this  polynomial size  requirement models the intuition that compilation is only useful if it does not greatly increase the size of a knowledge base.
¡¡demonstration that a formalism is in comp-p is a positive compilation result  analogous to demonstration that a language is in p  a positive tractability result. likewise  demonstration that a formalism is comp-np-hard is a negative compilation result and implies that the formalism is not in comp-p  under a complexity-theoretic assumption   just as demonstration that a language is np-hard implies that the language is not in p  under the standard assumption that p 1= np .
¡¡first in  cadoli et al.  1; 1  and later in other papers including  liberatore  1; liberatore and schaerf  1; liberatore  1; 1   the theory of compilability presented in  cadoli et al.  1  was applied successfully to classify knowledge representation formalisms that have appeared in the artificial intelligence literature. in particular  a multitude of formalisms  including propositional logic  circumscription  and default logic  have been demonstrated to be contained in comp-p or complete for the analog comp-c of a standard complexity class c. the downside of these classification results is that many of them are negative  showing that a formalism is complete for the compilability version of an intractable complexity class  such as comp-np or comp-co-np.
parameterized complexity. the abundance of negative compilability results mirrors a state of affairs in complexity theory: although many problems of interest can be classified according to the developed scheme of complexity classes  p  np  co-np  etc.   there is an abundance of negative results that show completeness or hardness for classes believed to be strictly larger than p. because such generally intractable problems do need to be dealt with in practice  a number of theoreticalframeworkshavebeen developedto providea finer analysis of hard problems than that offered by standard complexity theory. examples of such frameworks include the theory of approximation algorithms and average-case analysis. a relatively recent alternative framework is parameterized complexity  downey and fellows  1b .
¡¡parameterized complexity is a theory that  as with classical complexity theory and compilability theory  provides classes and a notion of reduction for categorizing objects. in the case of parameterized complexity  the objects categorized are parameterized languages: languages with instances consisting of two parts  a main part and a parameter. many languages that have been classically studied can be viewed naturally as parameterized languages. for example  each instance of the vertex cover problem can be viewed as consisting of a graph g as the main part  and a natural number k as the parameter; the question is to decide whether or not the graph g has a vertex cover of size at most k. similarly  the inde-
pendent set problem may be viewed as a parameterized language: an instance is again a graph g paired with a natural number k  and the question is to decide whether or not the graph g has an independent set of size at least k.
¡¡the parameterized flavor of tractability is called fixedparameter tractability; formally  a parameterized language is fixed-parameter tractable  or  in the class fpt  if there exists a constant c such that for every k  instances with main part of size n and parameterk can be solvedin time o nc . as an example  vertex cover can be solved in time o rkk1+kn   where r is a constant  k is the parameter  and n is the size of the main part; consequently  for any fixed k  instances of vertex cover with main part of size n and parameter k can be solved in time o n   and so vertex cover is considered to be fixed-parameter tractable. because the running time of fixed-parameter tractable languages exhibits a restricted form of dependence on the parameter  such languages are often solvable in practice when the parameter falls into a limited range.  in fact  one can see from the given time bound for vertex cover that this problem can be solved in polynomial time when the parameter k is o logn .  on the other hand  independent set is believed to require time where the main part exhibits an exponential dependence on the parameter - that is  a time of form similar to   nk . indeed  independent set is complete for a parameterized complexity class believed to properly contain fpt  and accordingly is believed to be outside of fpt.
¡¡viewed classically  these two example languages are both np-complete  and hence demonstrate that parameterized complexity is somewhat orthogonal to classical complexity; moreover  the example of vertex cover indicates that parameterized complexity can provide tractability results where classical complexity does not. indeed  the allowance of a non-polynomial dependence on the parameter of an input instance in fixed-parameter tractability permits the use of algorithmic ideas not utilized in proving standard polynomialtime tractability results  and the field of parameterized complexity has developed a rich and mathematically deep suite of algorithmic techniques.
parameterized compilability. the contribution of this paper is parameterized compilability  a new theory of compilability incorporating the notion of parameterization as used in parameterized complexity. our theory provides a novel set of concepts for proving compilability results  allowing the use of the sophisticated toolkit that has been developed for proving fixed-parameter tractability and intractability results  and provides an avenue for refining the many negative non-compilability results that have been proved using the established theory of compilability. as articulated in  downey et al.  1   one benefit of using a parameterized notion of computational tractability is that it becomes possible to engage in an extended dialogue with a single problem  by the investigation of a variety of parameters. we thus provide a theoretical framework in which we anticipate that the formulation and exploration of interesting parameters in the context of parameterized compilability will lead to refined analysis of compilability results.
¡¡the results in this paper are as follows. for every parameterized complexity class c  we define a compilability variant par-comp-c. we also define a notion of reduction for use with the par-comp-c classes  and demonstrate its robustness - in particular  that it is transitive and compatible  in a formal sense  with the classes par-comp-c. we also develop a general method for demonstrating hardness of a formalism for a class par-comp-c  and study the structure of the classes par-comp-c  relating this structure directly to the structure of non-uniform versions of parameterized complexity classes c.
1 preliminaries
while we have attempted to make this paper as self-contained as possible  some familiarity with the basic notions of complexity theory  including non-uniform complexity classes   parameterized complexity  and compilability theory will be helpful; we name  balca¡äzar et al.  1    downey and fellows  1b   and  cadoli et al.  1  as references for these topics  respectively. we also recommend the surveys  downey and fellows  1a; downey et al.  1  on parameterized complexity.
1 definitions and notation
strings. we assume ¦² to be a fixed finite alphabet that is used to form strings. the length of a string x is denoted by |x|. we will at times assume that pairs of strings  that is  elements of ¦²  ¡Á ¦²   are represented as strings  that is  elements of ¦²   via a pairing function h¡¤ ¡¤i. we make standard assumptions about this pairing function  namely  that the length of hx yi is linear in |x| + |y|; hx yi can be computed in time polynomial in |x| + |y|; there are polynomial-time computable projection functions ¦Ð1 ¦Ð1 : ¦²  ¡ú ¦²  such that ¦Ð1 hx yi  = x and ¦Ð1 hx yi  = y; and h¡¤ ¡¤i is lengthmonotone  that is  if |y| ¡Ü |z| then |hx yi| ¡Ü |hx zi| and |hy xi| ¡Ü |hz xi|. we also assume that there is a tripling function h¡¤ ¡¤ ¡¤i for representing triples of strings as single strings  for which similar assumptions hold.
functions. as usual  we consider a function p : n ¡ú n to be a polynomial if there exists a constant c ¡Ê n such that p n  is o nc . a function p : n ¡Á ¦²  ¡ú n is a parameterized polynomial if there exists a constant c ¡Ê n and a function h : ¦²  ¡ú n such that for all  n k  ¡Ê n ¡Á ¦²   p n k  ¡Ü h k  n + 1 c. in other words  p : n ¡Á ¦²  ¡ú n is a parameterized polynomial if there exists a constant c ¡Ê n such that for each k ¡Ê ¦²   the function pk : n ¡ú n defined by pk n  = p n k  is o nc .
¡¡a function f : ¦²  ¡ú ¦²  is polynomial-size if there exists a polynomial p : n ¡ú n such that for all x ¡Ê ¦²   |f x | ¡Ü p |x| . similarly  a function f : ¦²  ¡Á ¦²  ¡ú ¦²  is parameterized polynomial-size if there exists a parameterized polynomial p : n ¡Á ¦²  ¡ú n such that for all  x k  ¡Ê ¦²  ¡Á ¦²   |f x k | ¡Ü p |x| k .
¡¡a function g : ¦²  ¡ú ¦²  is polynomial-time computable if there exist a polynomial p : n ¡ú n and a turing machine m such that for all x ¡Ê ¦²   the turing machine m  on input x  produces output g x  in time less than p |x| . similarly  a functiong : ¦² ¡Á¦²  ¡ú ¦²  is parameterized polynomial-time computable if there exist a parameterized polynomial p : n¡Á ¦²  ¡ú n and a turing machine m such that for all  x k  ¡Ê ¦²  ¡Á ¦²   the turing machine m  on input hx ki  produces output g x k  in time less than p |x| k .
¡¡a function h : ¦²  ¡ú ¦²  is recursively computable if there exists a turing machine m such that for all x ¡Ê ¦²   the turing machine m  on input x  produces output h x .
languages and complexity classes. a language is a subset of ¦²   that is  a set of strings. a parameterized language is a subset of ¦²  ¡Á ¦²   that is  a set of pairs of strings. a  parameterized  complexity class is a set of  parameterized  languages. when c is a  parameterized complexityclass and ¡Ü is a reduction  we say that c is compatible with ¡Ü if for all  parameterized  languages a and b  a ¡Ü b and b ¡Ê c imply that a ¡Ê c. also  when c is a  parameterized  complexity class and ¡Ü is a reduction  we say that b is hard for c  alternatively  is c-hard  under ¡Ü reductions if for all a ¡Ê c  a ¡Ü b; and  we say that b is complete for c  alternatively  is c-complete  under ¡Ü reductions if b ¡Ê c and b is c-hard.
¡¡when c is a complexity class  the non-uniformversion  or  advice  version  of c  denoted by c/poly  contains those languages a such that there exists a polynomial-size function f : 1  ¡ú ¦²  and a language b in c such that for all x ¡Ê ¦²   x ¡Ê a if and only if hf 1|x|  xi ¡Ê b. when c is a parameterized complexity class  the non-uniform version of c  denoted by c/ppoly  contains those parameterized languages a such that there exists a parameterized polynomialsize function f : 1  ¡Á ¦²  ¡ú ¦²  and a language b in c
¡¡such that for all  x k  ¡Ê ¦²  ¡Á ¦²    x k  ¡Ê a if and only if  hf 1|x| k  xi k  ¡Ê b.
¡¡when l is a parameterized language  define l to be the set.
knowledge representation formalisms. a knowledge representation formalism  krf  is a subset of ¦²  ¡Á ¦² . a parameterized knowledge representation formalism  pkrf  is a subset of ¦²  ¡Á ¦²  ¡Á ¦² .
conventions. we view a ternary function f : ¦²  ¡Á ¦²  ¡Á ¦²  ¡ú ¦²  as a binary function g : ¦²  ¡Á ¦²  ¡ú ¦²  by pairing together the first two arguments  that is  g hx yi z  = f x y z . for example  a ternary function f : ¦²  ¡Á ¦²  ¡Á ¦²  ¡ú ¦²  is considered to be parameterized polynomial-size if there exists a parameterized polynomial p : n ¡Á ¦²  ¡ú n such that for all  x y k  ¡Ê ¦²  ¡Á ¦²  ¡Á ¦²   |f x y k | ¡Ü p |hx yi| k . similarly  a pkrf f is viewed as a parameterized language by pairing together the first two strings of each triple  and so is considered to belong to a parameterized complexity class c if the language l = { hx yi k  :  x y k  ¡Ê f} belongs to c.
¡¡for readability  we at times use a natural number m ¡Ê n in place of its unary representation 1m.
1 compilability
in this subsection  we review the theory of compilability; the definitions and theorems of this subsection are all from  cadoli et al.  1   on which our presentation is based. throughout this subsection  the following two assumptions concerning complexity classes and languages are in effect  just as in  cadoli et al.  1 .
assumption 1 every complexity class c is compatible with and has complete problems under the polynomial-time manyone reduction ¡Üpm.
assumption 1 in languages  suffixed blanks are considered to be irrelevant  that is  a string x is considered to be in a language a if x is in a.
¡¡for a krf f  we will refer to each x ¡Ê ¦Ð1 f  as a knowledge base; a knowledge base x is considered to represent the knowledge {y ¡Ê ¦²  :  x y  ¡Ê f}. roughly speaking  a krf is considered to be compilable to a complexity class c if following a preprocessing of each knowledge base x  posing a query y to the knowledge base x - that is  deciding if  x y  ¡Ê f - can be performed in c. the formal definition of those krfs compilable to a complexity class c includes two ingredients. the first is a preprocessing function f; because preprocessing of a knowledge base is not useful if it greatly increases the size of the knowledgebase  f is requiredto be of polynomial size. the second is a  target  krf f 1  mandated to be inside the class c  to which the krf f is translated via the function f.
definition 1  comp-c  let c be a complexity class. a krf
f belongs to comp-c if there exist
  a binary polynomial-size function f : ¦²  ¡Á 1  ¡ú ¦²   and
  a krf f1 in c
such that for all pairs  x y  ¡Ê ¦²  ¡Á ¦²  
 x y  ¡Ê f if and only if  f x |y|  y  ¡Ê f1.
¡¡one can obtain a compilability class comp-c from any complexity class c. hence  the comp-c classes offer a rich scheme by which one can classify krfs  just as conventional complexityclasses offer a rich scheme by which one can classify computational problems. upon a first reading of definition 1  it may be conceptually easiest for one to take the complexity class c to be equal to p  polynomial-time . in this case  the requirement that f1 is in c means that queries  x y  posed to f1 can be processed efficiently  so f translates each f-knowledge base x - which is not necessarily in a form that allows for efficient resolution of queries  x y  - into a f1-knowledge base f x  - which is in a form that allows for efficient resolution of queries  x y .1
¡¡the following notion of reduction  associated with the comp-c classes  allows one to compare the compilability of different krfs.
definition 1  comp reducibility  a krf f is comp reducible to a krf f1  denoted by f ¡Ücomp f1  if there exist
  binary polynomial-size functions f1 f1 : ¦²  ¡Á1  ¡ú ¦²  and polynomial-time computable function g : ¦²  ¡Á
¦² ¡ú ¦²
such that for all pairs  x y  ¡Ê ¦²  ¡Á ¦²  
 x y  ¡Ê f if and only if  f1 x |y|  g f1 x |y|  y   ¡Ê f1.
theorem 1 for every complexity class c  the comp reduction is transitive and is compatible with the class comp-c.
¡¡the structure of the compilability classes comp-c can be directly related to the structure of the complexity classes c/poly.
theorem 1 let c and c1 be complexity classes. the containment comp-c   comp-c1 holds if and only if the containment c/poly   c1/poly holds.
¡¡when c and c1 are complexity classes that obey the proper containment c   c1  theorem 1 gives strong evidence that the corresponding compilability classes comp-c and comp-c1 obey a similar propercontainment: comp-c   comp-c1. note that in making this observation  we appeal to the widely held belief that relationships between  standard  complexity classes c  c1 are not affected by non-uniformity  that is  c is properly contained in c1 if and only if c/poly is properly contained in c1/poly.1
1 parameterized complexity
parameterized complexity is a theory for the classification of parameterized languages - languages whose constituents have two components. in classical complexity theory  the base complexity class modeling feasible computation is p  which is defined using the notion of polynomial-time; in parameterized complexity theory the base complexity class is fpt   fixed-parameter tractable    which is definable using the notion of parameterized polynomial-time.
definition 1  fpt  a parameterized language l belongs to the parameterized complexity class fpt if there exists a parameterized polynomial-time computable function g : ¦²  ¡Á ¦²  ¡ú {1} such that for all pairs  x k  ¡Ê ¦²  ¡Á ¦²    x k  ¡Ê l if and only if g x k  = 1.
¡¡roughly speaking  a parameterized language l is in the class fpt if there exists a constant c ¡Ê n such that each
def
 k-slice  lk = {x :  x k  ¡Ê l} of l is computable in polynomial time via a polynomial of degree c. the degree of the polynomials bounding the time for lk must be a  universal  constant c and cannot depend on k; on the other hand  the coefficients of these polynomials may have arbitrary dependence on k.
¡¡the following notion of reducibility may be used to compare the complexity of parameterized languages.
definition 1  parameterized reducibility  a parameterized language l is parameterized reducible to a parameterized language l1  denoted by l ¡Üpar l1  if there exist
  a parameterized polynomial-time computable function f : ¦²  ¡Á ¦²  ¡ú ¦²   and
  a recursively computable function h : ¦²  ¡ú ¦²  such that for all pairs  x k  ¡Ê ¦²  ¡Á ¦²  
 x k  ¡Ê l if and only if  f x k  h k   ¡Ê l1.
¡¡we now define two parameterized complexity classes. in contrast to the class fpt  each of these two classes is defined directly as those languages reducible to a particular language.
definition 1 we define the following parameterized languages; the weight of a truth assignment is defined to be the number of variables it maps to true.
  weighted formula satisfiability input: a boolean formula f.
question: does f have a satisfying assignment of weight at most k 
  weighted circuit satisfiability input: a boolean circuit c.
question: does c have a satisfying assignment of weight at most k 
definition 1 we define the following parameterized complexity classes.
  w sat  is the class of all parameterized languages that are parameterized reducible to weighted formula satisfiability .
  w p  is the class of all parameterizedlanguages that are parameterized reducible to weighted circuit satisfiability .
¡¡it is straightforward to verify that the parameterized complexity classes defined here  fpt  w sat   and w p   are compatible with the parameterized reduction. throughout this paper  we will assume that all discussed parameterized complexity classes have this property  and also that they have complete problems.
assumption 1 every parameterized complexity class c is compatible with and has complete problems under the parameterized reduction ¡Üpar.
1 parameterized compilability
1 classes and reductions
as with the theory of compilability  the starting point for the theory of parameterized compilability is the definition of compilability classes. whereas a compilability version of each non-parameterized complexity class was defined  definition 1   here we define a compilabilityversion par-comp-c of each parameterized complexity class c.
¡¡as with the definition of comp-c  the definition of par-comp-c includes a translation function f with a space bound  as well as a  target  pkrf f 1  which is required to be inside c.
definition 1 let c be a parameterized complexity class. a pkrf f belongs to par-comp-c if there exist
  a parameterized polynomial-size function f : ¦²  ¡Á1  ¡Á ¦²  ¡ú ¦²   and
  a pkrf f1 in c
such that for all triples  x y k  ¡Ê ¦²  ¡Á¦²  ¡Á¦²  and natural numbers m ¡Ý |y| 
 x y k  ¡Ê f if and only if  f x m k  y k  ¡Ê f 1.
¡¡an implication of the containment of a pkrf f inside par-comp-c via the function f and the pkrf f 1 is the following. define  for each k ¡Ê ¦²   the  k-slice  of a pkrf
define
k : ¦² ¡Á1 ¡ú ¦² to be the function k 	  =	 	 .
notice that for each k ¡Ê ¦²   the krfs fk  fk1 and the binary function fk satisfy the condition of definition 1. that is  each k-slice fk of f is compilable to the corresponding k-slice fk1 of f1 by the function fk. because the size of f is bounded by a parameterized polynomial  for k falling into a limited range  the functions fk will behave polynomially; likewise  when f1 ¡Ê fpt  for k falling into a limited range  the krf slices will have time complexity behaving polynomially.
¡¡upon initial acquaintance  definition 1 may appear to be complex. however  we believe that the classes par-comp-c unify the classes comp-c with parameterized complexity classes in a natural way. we substantiate this claim by considering two special cases of definition 1  which may lend some intuition to the reader.
¡¡first  consider the case where the preprocessing function f simply returns as output its first argument  that is  f is equal to the projection ¦Ð1. it follows that f must equal f1; consequently  a pkrf f is containedin par-comp-c via such an f if and only if f is contained in c itself. intuitively  the function f does not perform any preprocessing  so the compilability class par-comp-c simplifies out to the original class c. next  consider the case where the pkrf f has the property that for all strings x y k k1 ¡Ê ¦²   it holds that  x y k  ¡Ê f if and only if  x y k1  ¡Ê f; that is  f  ignores  the third component  the  parameter   of its strings. in this case  the pkrf f naturally induces a krf f   defined to be
{ x y  :  k. x y k  ¡Ê f} = { x y  :  k. x y k  ¡Ê f}.
such a pkrf f is contained in par-comp-fpt if and only if the induced krf f  is contained in comp-p.1 in  ignoring  the parameter of the pkrf f  the compilability class par-comp-fpt simplifies out to its non-parameterized variant  namely  comp-p. we mention that by imposing the restrictions discussed in the two cases simultaneously  we effectively obtain the class p. thus  one can think of fpt and comp-p as two different generalizations of p which are unified together in and can be obtained as specializations of par-comp-fpt.
¡¡we have the following notion of reducibility for comparing the compilability of pkrfs.
definition 1  par-comp reducibility  a pkrf f is parcomp-reducible to a pkrf f1  denoted by f ¡Üparcomp f1  if there exist
  parameterized polynomial-size functions f1 f1 : ¦²  ¡Á
1  ¡Á ¦²  ¡ú ¦²  
  a parameterized polynomial-time function g : ¦² ¡Á¦² ¡Á ¦²  ¡ú ¦²   and
  a recursively computable function h : ¦²  ¡ú ¦²  such that for all triples  x y k  ¡Ê ¦²  ¡Á¦²  ¡Á¦²  and natural numbers m ¡Ý |y| 
.
¡¡we note that our definition of par-comp reducibility is not a direct analog of the definition of comp-reducibility;in definition 1 the  preprocessing phase  f is given an upper bound m on the size of the query y  as opposed to the length of the query |y|  as in definition 1. we believe that our notion of reduction is preferable because an assumption like assumption 1 is not necessary to establish transitivity  and also because it allows for a simpler proof of transitivity. our proof of transitivity can be specialized to a proof of transitivity for an  upper bound  variant of definition 1 by removing the parameter k.
theorem 1 the par-comp reduction is transitive.
theorem 1 for every parameterized complexity class c  the par-comp reduction is compatible with the class par-comp-c.
1 completeness and structure
we now study the notion of completeness for the classes par-comp-c  as well as the structure of the classes par-comp-c. first  we make a simple observation about the relationship between c/ppoly and par-comp-c which will aid us in our study.
proposition 1 let c be a parameterized complexity class. if the parameterized language a is in c/ppoly  then a is in par-comp-c.
¡¡the following theorem  which will be of help in proving hardness of pkrfs  demonstrates that we can easily obtain complete languages for the class par-comp-c from complete languages for the underlying class c.
theorem 1 let c be a parameterized complexity class. if the parameterized language b is complete for c  under ¡Üpar reductions   then b is complete for par-comp-c  under
¡Üparcomp reductions .
¡¡the next theorem is an analog of theorem 1  and correspondingly provides strong evidence that the structure of the compilability classes par-comp-c reflects the structure of the parameterized complexity classes c.
theorem 1 let c and c1 be parameterized complexity classes. the containment par-comp-c   par-comp-c1 holds if and only if the containment c/ppoly   c1/ppoly holds.
