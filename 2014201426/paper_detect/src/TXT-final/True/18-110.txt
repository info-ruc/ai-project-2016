ly and in pictures they draw to help them design while executing the proposed algorithm difficulties  missing steps  inconsistencies between parts of the algorthm may arise  leading the designer to further refinements thus  we say that the designer's refinement process is difficulty driven. 
 d1  in dvs algorithm a difficulty arose when the test involving line segments was combined with the generator of points and d1 had to modify the algorithm to accommodate this. 
here one assertion propagated by the execution process  that a point is produced by generating over the input set  contradicts another assertion  that a line segment should be the input to the test rather than the point it is handed . 
 d1  d1 eventually changed the kernel idea from generate and test to a greedy algorithm that attempted to generate the hull points in the order they occurred on the hull polygon  using backup to handle guessing failures. 
	e.kant 	1 
the algorithm execution also can expose opportunities for improvement or modification of the algorithm. 
 d1  after working on a sample problem  d1 realized that the merge step would be easier if the two subsolutions shared a common point and went back and modified the divide step to ensure that that would happen. 
most people draw example figures during algorithm design. the examples are used initially for understanding the problem  and for reasoning about the task domain  using visual reasoning in the geometric domain  as well to help try out the partially developed algorithms in test-case execution. often  the designers notice things about the sample figures that they were not looking for when what the designers notice turns out to be useful in developing their algorithm  we say that they have made a discovery. 
 d1  in looking at figure 1 d1 realized that if a line segment had points on both sides of it. that segment could not be on the convex hull d1 was executing an algorithm with a test for points being on the hull or not; the line segment in the figure was recording the fact that the points a and b had been generated so far 

 d1  d1 created figure 1 in attempting to find a merge step by considering all segments between vertices of the two hulls and testing which were in the merged hull. d1 knew that this brute force search would be too expensive  but had no other ideas. the picture reminded d1 of another unrelated algorithm  the traveling sales representative  in which a shorter path replaced two adjacent segments. d1 then applied a similar idea to the merge step  replacing segments ad and d-e by segment a.e  d1's picture was not actually labeled . the generalization d1 made was that convex angles in the merged hulls were to be replaced by a segment connecting the two end points. 

figure 1. d1 s discovery of a merge operation 
do you have enough information yet to guess the algorithms  
 the discoveries are described in more detail in cite kant1b .  
some other observations the designers made would have allowed only small optimizations. 
 d1  d1 noticed that points are always on the same side of the  directed  line segments of the hull. 

while discovery is not a voluntary process that can be planned as a design step  it does arise from the process of making observations. the discoveries in our study all occurred when the designer was looking at a sample figure created for one reason and recognized a geometric property  or key step from another algorithm  that would solve an outstanding goal. that goal was not the one the designer was currently worrying about  finding a test for a point being on the hull  finding a way to tell if a segment was on the merged hull   but it was usually not completely unrelated  finding a segment test rather than a point test: finding a different type of merge step  thus  discovery could be characterized as serendipidously satisfied goals 
both key observations in the problem domain and knowledge of design principles are usually necessary for clever design most algorithms published in papers  or given as exam problems have at least one good observation or trick that is novel at the time of the design otherwise we would probably say the algorithm is  obvious  or is  just  a brute force algorithm. each of the trick:  must be stumbled upon as a discovery unless it is already - nown to the designer good tricks are eventually refined into principles but everything is a trick the first time each designer encounters it 
although there is an element of chance in the discoveries there is no lack of readiness on the part of the designer the designer can be prepared both with immediate goals to exploit the observations and with a good understanding of design principles to fit the discovery into an overall algorithm. i he more experienced and disciplined the designers  the better prepared they are for the discovery an  experienced  designer is one with knowledge not only about algorithm design but also about problem domains. domain knowledge can be derived either from past attempts at the problem or from experience with similar algorithms and domains  or different domains but the ability to reformulate problems in terms of other domains . 
e. verifying correctness 
our designers determined whether their algorithms were correct primarily by testing them on specific examples and observing whether there were any difficulties. symbolic execution car  in fact be made to do the job of full formal verification. to do this  the algorithm is executed on symbolic objects and all assertions are propagated to determine whether the results of the algorithm  and its subparts  match the specifications. if a specification includes performance constraints  then verification must also include an evaluation  see section iif  to determine whether the solution is efficient enough  in time or space complexity  according to the expectations 
during the initial algorithm design  the designers ignored  details  such as base cases or initialisations  boundary conditions degenerate inputs or unresolved notes to themselves  but they were more careful about this if they were attempting to determine if the algorithm was complete or correct. 
 d1  when d1 was asked for an algorithm summary during a pause  the response was that it wasn't an algorithm yet because the ca.se of the first point not being on the hull had not yet been tested 
the heuristic is to get an algorithm for the general case first then worry later about modifying it to take the exceptions into account although some methodologies claim to eliminate the concern with special cases  tor example.  1    they require that the specification or invariant be precisely stated before design begins. this is often difficult to accomplish. for more complex algorithms handling the exceptions can itself require a major problem solving activity and may yield new insights into the problem or solution. 
f. evaluating plans  refinements  and solutions the descriptions of the processes used in design did not detail how plans  refinement steps  and overall solutions are evaluated. evaluation can be based on specific knowledge about the algorithm design principles being applied or on an analysis of the cost of the algorithm and its subparts. 
if the designer has the appropriate rules about the algorithm design principle and the domain  then the refinement process can be smooth and top down. for instance the appropriateness of the kernel ideas selected by the designers depends on the quality of their knowledge of algorithm design principles one can really observe here what expert systems researchers call domain specific knowledge. generate and test is usually the fall back idea  which is sometimes very efficient  linear in the input size  and sometimes not. after an algonthm based on a kernal approach was sketched out  or after the approach seemed to be failing  some designers went on to an alternative approach 
 d1| after completing the revised algorithm for generating segments and testing whether they were on the hull. d1 determined that the run time of the algonthm was proportional to the cube of the number of input points declaring that this algonthm was only a  first shot d1 went on to consider a dynamic programming approach and eventually to try divide and conquer 
 d1  in another problem involving finding intersections of line segments another designer d1. noted that there was a straightforward approach having to do with considering all pairs of segments  which was n squared however. d1 felt that there ought to be some way to use sorting in the solution to get an nlogn algorithm 
when experts  people with a strong background in algorithms and m the subiect matter of the problem  design  they consider a variety of alternative refinements  select the best  remembering the rest for possible later use   and apply it to advance the design with one more level of detail in the refinement process. what is  best  is based on efficiency in the cases of algorithm design we studied  but is based on ease of implementation or modification in other cases. in expert design  the breadth first process tends to be followed for all aspects of the design at a given level  with interactions between the different parts of the design predicted and taken into account 
in contrast  if the designer's only idea is naive  use sorting somehow   then the technique of executing hypothesized algorithm parts is more likely to be followed in a depth first search from which the designer may never successfully return  the idea may not have been wrong  but the designer may not have had the knowledge to carry it through.  fxperts as well as novices are prone to a satisficing style of design when they are under pressure and don't have time for more exploratory design of course they are better at it since they have more experience  can make better predictions  and guess right more often 
even when performance constraints are not explicitly specified the designer often evaluates an algorithm or algorithm stop's performance relative to other alternatives or to known or estimated lower bounds. extreme cases of inputs may be tested to estimate worst case performance. complexity analysis may be earned out in parallel with execution and verification by more experienced designers  or may be an explicit subtask of a conscious evaluation. 
 d1  after discovering the way to merge by removing convex angles  d1 estimated the run time of the divide and conquer algorithm by arguing that even for the worst possible input  the merge time was linear in the number of points on the two subhulls and therefore the overall run time was acceptable. 


figure 1. a worst case input for divide and conquer 
d1's final algorithm had a prepass step to sort all the points according to their x coordinate. the basic algorithm was to divide the input through the point closest to the median  recursively find the convex hulls of the two resulting point sets  and merge the solutions back together by eliminating concave angles  starting from the shared point  1 the base case is that two or three point input sets can be made into convex hulls immediately. 
g. control issues 
the design processes described in the preceding sections do not always run to completion and do not take place in any fixed order evaluations within each step  as described above  may cause the designer to terminate one approach and go on to another the ordering of the design processes  including when they begin and end  seems to arise naturally out of the mechanism of trial execution. 
selecting a problem to work on is a natural consequence of the problems exposed by symbolic and test-case execution the character of the elaboration process appears to be an progressive deepening that takes each of the constructs in the algorithm a little further  sometimes backing up to higher levels to keep the overall picture in mind however  the development of the different parts of the algorithm is not always even. if one aspect of the algorithm is a potential problem  i.e.  other parts of the design depend on it and the outcome is uncertain   then it is more likely to be expanded to ensure that the algorithm as a whole is feasible. if it has an obvious solution or refinement and the implications of that decision seem well understood  at least at the current level of detail  it is not considered further.  of course the assumptions may be wrong.  new components of the design are refined in the order they are executed  subject to the two previous considerations. 
verification and complexity analysis also seem to be achieved in part by propagating assertions during execution. thus  other processes that contribute to control fit in nicely with this basic mechanism and can occur at the same time. 
in short  design processes are applied as appropriate. control is not a special source of intelligence. it comes out of responding to the data and out of the problems and opportunities arising during execution. 
iii. 	locating the problem-solving power 
an important question to ask about any agent that exhibits intelligent behavior is where the knowledge and problem solving power lie. knowing the loci of intelligence gives us some clues for how to produce similar behavior automatically. thus  we have 
	e.kant 	1 
attempted to formalize the problem-solving behavior we observed in our designers in terms of concepts that lend themselves to automation 
one common view of problem-solving behavior is that it is basically search in a problem space  with knowledge used to limit search knowledge is carried by the problem spaces themselves  in what objects and operators they have available and in the heuristics they have for when and how to apply the operators in this view  problem solving is a process of repeatedly changing a context by selecting a goal to achieve  a problem space to work in to attack that goal  a at ate within that space to work on. and an operator  and instantiations of its arguments  to transform the state . different types of knowledge can be identified with the selection process for each element of the context 
a. the power of search 
in design as in most tasks requiring intelligence  both search and knowledge are needed search is the backup for missing knowledge and can never be completely eliminated it can take place at the very high level  such as searching for a kernel idea for an algorithm or at the very low level  such as deciding how to instantiate an operator argument. although at any level knowledge limits search when possible and gives clues about how to explore the problem spaces in a reasonable way  the ability to search is  in itself a source of power. 
in design  for example  search permits the creation of algorithms by trial and error in the absence of complete knowledge algorithm components can simply be hypothesized and then the algorithm as a whole tested to see it it satisfies its specifications. if only the objects and operators that formally specify and manipulate algorithm descriptions are available  i.e.  there is no other model of the problem domain   then designing an algorithm requires the use of formal definitions of the concepts used in the problem specification and  recursively  of its subcomponents. however  more power than this is available to human designers and can be made available for automated design through the use of multiple problem spaces. 
b. the power of multiple problem spaces 
from our observations we conclude that each designer works in several different problem spaces during design  similar observations are described for other tasks in  . the details of the problem spaces differ from designer to designer  but there is a remarkable consistency in the types of problem spaces used. 
we observed our designers working in four spaces  two of which are extensions of another space. the two main spaces were  1  an algorithm design space that carries the knowledge of what is achievable in standard computer systems and of domain independent algorithm design principles  and  1  an application domain space  such as one for geometric and visual reasoning  the algorithm design space is also a domain space relative to design as a whole   the two extension spaces have the same obiects as the first two spaces plus additional objects and/or different sets of operators.  1  an algorithm execution space is an extension of the algorithm design space that has as new objects data items that carry information in the form of assertions about their execution history and has new operators that execute components in the design.  1  an example generation space is an augmentation of a task domain space in which figures are marked as standard examples  degenerate cases  counter examples and the like  and in which there are new operators to produce the examples. 

the necessity for different problem spaces is a result of the requirements of different types of knowledge. for example  what is possible or efficient in the domain  problem space  of algorithms for conventional digital computers is sometimes quite different from the way people reason visually or from what can be done with analog devices.  consider solving the convex hull problem by pounding nails into a board to represent the input points and then stretching a rubber band over the nails and letting go.  the problem spaces that express such knowledge differ in the objects and operators included  the properties of objects or relationships between objects  and heuristics for how to control the applications of operators. 
having knowledge represented in a domain space as well as in an algorithm space gives the designer the power to create algorithms even in the absence of formal axioms about specification concepts such as polygon containment  the problem can be solved by generating constructs in the algorithm space and testing the proposed algorithms on examples to see if they work. this technique relies on the ability to generate examples to use as test cases. example generation depends on knowledge of the domain space as well as knowledge of the goals in the algorithm space  say to determine whether a typical or degenerate example is desired  if a domain concept is not formally axiomatized  the designer cannot do any formal symbolic reasoning such as full verification or correctness-preserving derivation. however  by making some conjectures about the domain and validating them with test case execution  the designer can reason formally about the rest of the algorithm 
 d1  having knowledge from the domain space of what line segments were on the merged hull allowed d1 the hope of finding an operation that would test where proposed segments were correct. 
for each of the problem spaces relevant to design  we can ask what knowledge is available for recognizing when context elements should change: how does a system recognize when goals are satisfied or when new goals should be attempted  when the problem space should be changed to work on the different type of goals  what state to expand within a problem space  and what operator to apply and how to instantiate the operator. examples of the different types of knowledge contained in problem spaces will be given in sections iii.f through iii.i 
first  some aspects of problem-solving power that cut across problem spaces are discussed. this power can be cast as knowledge that allows the designer to avoid search. 
c. knowledge in recognition 
the ability to recognize objects and to recognize the applicability of operators is a major source of power in problem solving. the search process is not driven by an algorithm that selects context elements in a fixed order but rather by recognition rules that observe when some context element should change: for example  when a goal has been satisfied or when an operator would help change state in a desired way. the conditions for recognition can be symbols in the algorithm design space or visual images from the domain space. these dues can involve goals  points of view or other objects in the problem-solving context whose inclusion as a clue was only accidental to the formation of the recognition rule a very large number of recognition rules may be present however  the conditions that are monitored must be computationally simple  involving only straightforward matching. 
an example of the role of recognition is its use in discovery  a key process in algorithm design. discovery depends on generating examples to work with and then noticing properties about them or reasoning about them. the recognition processes usually take place in the domain space  but what is noticed depends on the goals of the problem solving  and the content of the recognition knowledge . 
recognition is also important in example generation  which is constrained by the goals of the problem solving  is it to be an average case  degenerate case  initial or base value  counter example  used by efficiency analysis  etc.   but depends on knowledge of the domain and recognition of successful construction of the example in terms of domain properties. 
 d1  d1 first generated points a. c  d  and e in figure 1 as an initial test-case example but then noticed that the example was degenerate since all points were on the hull and added a fifth point  b  in the center to remedy the difficulty. the points were not labeled at that time. 
non-symbolic recognition and processing  such as visual reasoning  is clearly important in designing computational geometry algorithms  but is it really important in all domains  such as that of algebraic problem solving  at least for some people  it is. built in visual operators are better at some types of processing and provide another perspective on a problem. they may suggest approximations or fortuitously counterpose objects that would not be related by a general symbolic reasoning process. 
d. knowledge in execution 
trial execution in algorithm design serves the purpose of controlling the order of the refinement process  see section ii.c  and limiting the inferences made as well as its more common functions of debugging and verification  see section ii.e and  . 
the nature of creative algorithm design requires some mechanism for inference  whether it is a full theorem prover small set of simplification rules  or something in between. making all possible inferences during algorithm design would be very expensive computationally. execution is a way to focus attention on certain assertions in the algorithm description space and certain parts of pictures in the domain space so that inference and recognition only have to take place over a smaller set. the execution techniques limit the inferences and constraint propagations to those most likely to be useful for the current stage of the design. avoiding the extensive search of theorem proving or uncontrolled inferencing through execution is a form of knowledge about design. this topic is discussed more thoroughly in other papers 
    
e. knowledge in efficiency information 
efficiency knowledge serves as an evaluation function throughout the algorithm design process  not just as an evaluation of complete designs. information about potential run time or space use serves as a rough guideline in the selection of a kernel idea and during refinement  d1 knew that the merge step had to be linear to get the desired overall performance  d1 *  as well as after an algorithm sketch is complete  d1 decided that cubic performance was probably not the best possible  d1  . 
　*ln the remainder of this paper  labels following descriptions of bits of knowledge refer back to parts of the design story where they are used efficiency knowledge can take many forms  including assertions about the run time of specific operations or algorithms  assertions about the intrinsic complexity of problems  rules for how to analyze algorithms  and rules for setting constraints on what performance must be reached on a subpart of an algorithm to guarantee overall performance. 
efficiency knowledge is generally contained in the algorithm design space in fact  some heuristics in the algorithmic problem space depend on the cost model for the target architecture  efficiency knowledge can be applied in selecting a plan  d1   in evaluating refinements for steps of the algorithm  1   or in evaluating the algorithm as a whole  d1 . 
f. the algorithm design space 
in algorithm design  it is sometimes difficult to come up with any reasonably effective solution * although some problems have simple brute force solutions  consider the problem of finding the closest pair of points in a point set you can probably see a simple algorithm for solving the problem immediately   since algorithm design involves searching in a space not dense in solutions  dead ends are a serious problem  and knowledge of what design principles and domain facts are relevant is almost a necessity  as is the ability to reason and recognize in other spaces . such knowledge can help decompose the problem or select and instantiate operators in the problem space. 
designers have variants of the algorithm design space that depend on their assumptions about the target architecture as well as on their overall knowledge of design principles. if the algorithms were to be programmed on an architecture with pipelined or distributed processing or associative retrieval  the representations for algorithms and heuristics for how to design might be greatly different. some designers make  at least implicit  assumptions about the target architecture from the beginning of algorithm design  although it is preferable to stay independent of the target as long as possible. 
the knowledge in the algorithm description space includes facts about mathematics  logic  arithmetic  or algorithm design principles. the knowledge can be in the form of both object descriptions and operators on those objects. other knowledge can be represented by rules about when to change the problem solving context. 
1. objects and operators 
the basic objects for describing algorithms in the algorithm design space are components that specify basic types of processing. these components may test whether a property holds  generate the elements of a set one at a time  achieve an input/output relationship  apply a domain operator  select a subpart of a compound object  or modify a memory of objects 
the algorithm components are connected by links that allow flows of data and/or control and may be augmented with assertions about their properties or about their relationship to other objects or operators in any of the problem spaces. for example  a selection criterion might be to pick the bottom left point from a set of points new components can be defined in terms of old ones by adding additional standard inputs or outputs or by adding assertions  or a component can be defined as configuration of other components. 
　*see section iv.e or  for a comparison with the search problem in program synthesis 
e.kant  1 
the assertions associated with components may include information about the types of data obiects expected as inputs or outputs or other preconditions or postconditions of processing  the ordering constraints on a generator  the criteria tor selection  the initialization of a memory  expectations or conclusions about the time complexity of the algorithm  component   constraints on the order of execution of the algorithm components  notes about the algorithm  such as it has not yet been tested for the initial point lying inside the hull . 
since algorithms usually manipulate some sort of data  there are also representations of the common mathematical concepts such as numbers or symbols and of sequences or sets of other obiects assertions about these objects can be attached to descriptions of the obiect type or to item-  that represent specific data /1/e number ot cuintnnat'ons of pan:  from  -j set o/ elements n; 
{ rof ortion;ii to n -.injured  d1 | 
divide rind conau -t .＊ ;.＊  .'-/f1/m.s an often have run tune of n/ogn.  d1./  ol.ll| 
the operators  m the algorithm description space are simple  syntactic  editing operations that add or modify components. links between components  and assertions i he knowledge is all located in the rules that suggest instantiations of the type of components to create  the specific components to link  and the details of the assertions to be added. 
1 operator selection 
selecting an operator  and instantiating it by selecting values tor its arguments  can be made more effective through the use of knowledge about general algorithm design principles and about algorithms in a particular domain of application. this knowledge will be expressed here as rules. other such knowledge  such as how to handle specific problems raised during execution  the equivalent of a difference table for means ends analysis  also limits the amount of search necessary for operator selection. 
the following set of rules about operator selection and instantiation is merely a representative sample of the knowledge that an algorithm designer  human or otherwise  might have  not every designer has the same knowledge  of course  many other rules would add their suggestions and vetoes about what to do. if there is no consensus about what operator to apply  the fall back is search through the suggested possibilities. 
if a component needs to be refined and its output is a subset ot its input  refine the component to an element generate and test algorithm.  d1  
if a component needs to be refined and its output is a structure that must satisfy certain constraints  refine it to an algorithm that builds a minimal structure and then adds units of structure until the constraints are satisfied.  d1   an instance of this rule is suggested in .  
if an algorithm looks at part of the input many times to do the same kinds of tests  try saving information rather than recomputing  say with dynamic programming.  d1  
if the characteristics of subproblems produced by the divide step of a divide and conquer algorithm are unknown  then add the assertion that they are two equal sized subproblems 
if the characteristics of subproblems produced by the divide step ot a divide and conquer algorithm are unknown  and if the set being divided is a set of points in two dimensions  then refine the divide step to be a sort of the points and a division into the points on ettrier side of the median a line through the median.  d1| this has a bit ot domain specific knowledge although it is in the algorithm space 

1 e.kant 
/f a component is missing a link to a required input  look for a component that has an output with the same type  or having that type as a subpart or superpart  and connect the two components. 
1. changing state 
the state in the context of a problem space changes primarily as a direct result of the successful application of an operator that modifies the algorithm description. if the operator application fails  and if there were competing suggestions about what operator to apply  then alternative operators still apply and another will be tried in addition to either failing or succeeding  an operator may return a difficulty or opportunity. this becomes another goal to be worked on  perhaps in a different problem space. after processing of the new goal is complete  which may change the state in the algorithm description problem space   the rules that caused the original operator to be selected may or may not be retriggered. if they are  the operator application can be retried. 
1. changing problem spaces 
one of the benefits of having multiple problem spaces is the ability to reduce search by working on the same goal in a different space. some examples of rules that can cause space changes are: 
obiects that are manipulatable in the geometric domain include points  lines  segments  angles  and polygons. special properties of object types or of specific objects may also be recorded. for example  the degenerate case of the object type polygon could be a point or line-segment  and a triangle would be the boundary case. for a specific geometric object  properties would include being convex or being above or below a line. 
the operators in the geometric domain include accomplishing such functions as drawing a line segment between two points and recognizing that a polygon is convex. 
any symbolic descriptions of the objects in a figure and assertions about the objects or their relationships are available to the other spaces. for example  in the algorithm space  assertions may serve as test predicates  comparison or ordering relationships  or criteria for extraction from compound object. operators are available for execution  say to build a polygon in the example generation space or as an operator applied by a component in the algorithm space that can be run during test-case execution  but their internal workings are not available. 
the domain space also includes recognition knowledge  expressed here in the form of rules  that if applied to a figure in the current focus of attention may cause recognition and/or the 

if a component needs to be refined  and its output is a construct in space x  create examples of it and notice their properties. if construction of a new object just as an operator application might. this rule is applied  it will cause a transfer first to the example for example  
generation space and then to the domain space x.  d1  if two line segments share a common endpoint. perceive the figure defined by that pair of segments as an angle.  d1  it a configuration of components has not been shown to achieve the specifications of the component of which it is a h. the execution space refinement  then symbolically execute it.  d1  
the configuration on a concrete example.  d1  
1. goal satisfaction and creation 
recognition of when goals have been achieved  or nearly achieved  of when to give up on a goal and declare failure  of when to create new goals  and so on is crucial to enabling discoveries. strict enforcement of hierarchical subgoaling would not allow the same flexibility and creativity. goal change knowledge can also serve as design heuristics. some rules that express this knowledge are: objects   a point  . items can be augmented by properties that are known to be true of them at a given point in the algorithm execution history - that a point is known to be on or off the hull or that it is the one most recently added to a memory. 
the operators in this space control the sequencing of component execution and carry out component execution. if assertions needed to carry out the operators are missing  a difficulty is returned and a new goal to handle the difficulty is created. 
some instances of rules that suggest new goals to work on are: 　　　　　　　　　　　　　　　　　　　　　　　　　　　the problem space in which execution occurs is an augmentation if a configuration of components has not been shown to of the algorithm description space. it uses the object type item to achieve the specifications of the component it is a refinement represent the data processed by the algorithm that flow over the of  and if symbolic execution has already been tried or is known links between components. the items can represent either in advance to be too complex to be informative  then execute specific objects from the domain space  point a  or symbolic 
// an exponential algorithm is created  try to improve it or find an if the input for test-case execution is uninstantiated  set up a alternative unless it can be shown that the problem is itself goal to get an example input. this will cause a transfer to the exponential.  d1  example generation space. a particular point set would be an 
/f all obiects added to a set have a common assertion  	example for the convex hull problem.  d1  
hypothesize that that property holds for all elements in the set 	if test-case execution shows that applying some operation will 
and try to substantiate the hypothesis  make progress toward a solution of the problem but not solve it if a component is defined by assertions that are appropriate for completely  try modifying the description in the algorithm the level of detail currently desired  however that is design space to apply the operation repeatedly  inside a loop . determined1   then consider the component acceptable. i. the example generation space 
level of detail  then create a goal to refine it. 
g. the application domain space 
algorithm designers need knowledge about their task domain as well as about algorithm design in general. as an example of a problem space describing a task domain  consider the knowledge about geometry that can be used in solving the convex hull problems. space  the domain space. objects must be augmented by properties that describe their typical instances  degenerate instances  boundary cases  and so on  if such information is not already present in the domain space. for instance  sequences consisting of repeated copies of the same element are not typical some sample operators are those that add and remove elements from examples. some sample rules are 
if creating an input to a generate-and-test algorithm ana all if a component is not considered to be refined to an acceptable the example generation space is also an augmentation of another 
elements in the input satisfy the test  then add another element  d1  

// creating an example for test case execution of an algorithm that has not yet been checked for correctness  pick non degenerate objects and constructors 
	iv. 	design a u t o m a t i o n strategies 
this section summarizes the model of human design and compares it to some of the other approaches suggested for fully or partially automating algorithm design and for automatic programming. it also discusses how the methods might be extended to handle the problems in other contexts  such as interactive design. 
a. summary of human design 
several of our designers succeeded in creating convex hull algorithms the algorithms and key discoveries of designers d1 and d  have already been described. dvs generate and test algorithm had a disappointing worst case run time proportional to the cube of the number of input points but d1 would never have been able to design the anticipated linear algorithm it can be shown that the problem of finding a convex hull is related to the problem of sorting  so under conventional assumptions it must be an nlog/v problem eventually 1 went on to try a divide and conquer approach that  with a little help from the experimenters became a successful nlog/v algorithm similar to d1's. some other designers successfully recreated some convex hull algorithms that they had heard or read about but did not remember very clearly  many interesting convex hull algorithms have been described in the literature   1    still other designers failed to find any algorithm at all. we also gave our designers some other problems. they were asked for algorithms to find the closed pair of points from a given set or the intersection points of a set of vertical and horizontal lines. most designers quickly suggested brute force algorithms  which have a worst case run time that is the square of the size of the input  but were unable to find any of the taster algorithms. 
the methods observed in human design are quite varied. 
selecting and sticking with a kernel idea provides a necessary focusing of attention  and using execution as an assertion propagation mechanism continues that focus and avoids the extensive search process that unlimited inference or search through the network of all refinements would entail. of course if specific knowledge about the domain or algorithm design is available  it can be used to limit search by suggesting refinements directly. a powerful source of creativity is the use of visual reasoning about specific examples  which paves the way for discoveries about key concepts in algorithms. although our current set of studies of human designers has provided many good ideas for a model of design  we would like to do more studies on other types of algorithms and on even more expert algorithm designers 
in general  the designers' success was highly correlated with their interest in and background in algorithm design some problems that they had stemmed from an incomplete  or totally absent  understanding of design principles such as divide and conquer  which is very relevant to the examples we gave . other problems seemed to be due to impatience with methodically following a design strategy in some cases  the designers tried to mix aspects of the design from two different approaches. this typically failed when they tried to mix subparts of different types of principles but succeeded when they tried to reuse facts or theories from the geometric domain that were learned in an earlier design 
	e.kant 	1 
b. automatic programming 
automatic programming is that ever receding goal of automating the programming of everything the user wants with a minimal amount of specification. automatic programming encompasses  1  algorithm design   1  program synthesis  and  1  the problem of managing complexity in programming in the large. algorithm design has been defined in section i.a as the process of producing a computationally feasible program sketch  that is relatively complete and consistent  from a specification of what is to be accomplished. we refer here to the hour level form of algorithm design  not research design. this routine design often precedes program synthesis. program synthesis is the process of choosing data structures and access functions to transform a given algorithm specification into concrete code in a conventional programming language. like algorithm design  program synthesis requires intelligence  especially to produce extremely efficient code  but it probably can be achieved with more straightforward techniques 
as has been pointed out by others |1 . full fledged automatic programming requires the incorporation of domain knowledge as well as detailed coding knowledge furthermore  programming in the large must be supported by effective bookkeeping. there are tew concrete results in this area  however 1 he notion of working in multiple spaces  and in a domain space in particular  may prove valuable in automating the entire programming process. 
c. formal derivation 
1 he formal derivation approach has been proposed for both algorithm design and program synthesis  1. 1. 1i. formal derivation methods share with the design methods described here a refinement strategy based on a few. largely syntactic  transformations  but differ in that the transformations preserve correctness. it is assumed that the specifications are correct and complete  and since the transformations require and guarantee correctness  then the intermediate states and the result are also correct and internally consistent. the operations of the transformations - defining new constructs  expanding definitions   unfolding    noticing instances of definitions that have arisen after rearrangement and simplification of the algorithm constituents   folding   - are similar to the processes that we have noted in human design  
one way that the formal approach differs from the model of design described here is that it requires that terms be defined by axioms or equations and does not allow the use of terms defined only in a domain space. also  in the formal approach  transformations are instantiated via axioms about the domain or algorithmic constructs  in the model of design described here  they can be instantiated by similar knowledge based on formal definitions  by arbitrary selection  or by guesses based on observations of the domain as discussed earlier  people can sometimes derive algorithms even if they do not have formal definitions of all the concepts. they need only have operators in the domain space that recognize the concepts  more primitive operators in the domain space that can construct the structures they want to recognize and techniques for implementing the constructive operators m the algorithm space. in contrast  the formal derivation approaches often have problems with controlling the search process and with creating useful auxiliary definitions - the  aha  or  eureka  steps are often definitions inserted by human interaction. these problems result from there being no clues in the formal approach about how to introduce the right interesting knowledge 
another way the formal approach  with its requirement for consistency and completeness  differs from human design is in the handling of boundary conditions and base cases the formal 1 e.kant 
approach requires that these be defined early on  almost the opposite of the human approach getting the details of the boundary conditions right is one cause of the search problem in formal systems - there are many ways to define these conditions  and selecting the precise specifications or introducing conditionals and filling out the details adds complexity. 
for some people  the discipline of taking care of details with a standard methodology releases their creativity. on the other hand  many people find it difficult to state invariants precisely if they must be absolutely correct. getting the main idea of the invariant is crucial to solving the problem  but stating it formally to avoid such problems as fencepost errors makes it tedious and not obviously productive. for these people  getting the details right immediately is extremely difficult; the overhead of internalizing this methodology is prohibitively high. 
formal derivation systems are being augmented with more detailed knowledge about design techniques so that the search control can be more goal oriented  and also with knowledge about example generation . however  this still doesn't postpone settling all the details  having a domain space lets you finesse formalizing them  or say where the creative definitions come from  cross fertilization from domain spaces and other algorithms . 
d inductive inference 
inductive inference from examples is another technique that has been explored  but more for the construction of small programs than for the design of algorithms or large systems. 
unambiguously specifying the input/output behavior of algorithms with examples is easier than so specifying the behavior of large programs. however  the inductive approaches usually rely on problem solving using a small set of schema  with little ability to improvise if none of the schema match if the target language is logical equation based language with a search mechanism built into the interpreter  then this approach may work   but it is unlikely to produce clever algorithms in conventional languages. 
e. program synthesis by refinement 
the program synthesis problem is complementary to that of algorithm design  although we would expect that many of the same problem solving techniques are used the stage at which the algorithm design process stops - when an algorithm is  understood  - should provide an appropriate specification or starting place for program synthesis 
the standard refinement paradigm in program synthesis  1. 1j is to apply knowledge-based rules and search over that knowledge; no creativity is introduced the search problem is a bit different since once an algorithm is well defined  the program synthesis problem is usually to find a more detailed program in a standard programming language selecting concrete data structures and accessing operations. usually the search space is dense in correct solutions that vary in efficiency  reliability  modifiability. and so on  1 . past research has investigated the control of the search by efficiency  for example   . such control is not a definitive solution  but many approaches have been prototyped fairly successfully. 
as in most expert systems  it is assumed that all the knowledge about how to refine programming constructs is present in the refinement rules. in contrast  the hypothesize and test technique in the design model presented here allows the discovery of new programming techniques. the price paid  of course  is that more search at the lower levels is required  and this search is not as easily controlled by efficiency rules. 
f. program synthesis by design 
we hope that algorithm design research will result in aids for program synthesis that avoid hand coding of all the refinement rules. the initial knowledge base requirements should be simplified considerably as a result of the more generic problemsolving abilities such as trial execution  with its low-level means ends analysis and search  and domain space reasoning. putting in more of this creativity should make the automatic programming process more flexible and robust and may even produce better programs 
g. interactive tools 
an interesting question to ask is. does this knowledge suggest any other tools to aid in the design process1 are there some interactive tools that might help people in the design process1 or is there some novel mix of human and machine power that could lead to even better design1 
the conventional wisdom is that people have better insight and machines are better at the details. following this wisdom  the machine could suggest the full range of possible approaches at any one step and the person could decide which to follow  providing the search control 
we could augment this plan by observing that execution is a powerful technique in design. programs are good at methodically following algorithms for execution  but people frequently see what they expect and miss some of the problems. this would suggest machine support for execution of designs. the execution would expose problems and inconsistencies that people might skip over and the people could suggest some solutions to the problem or suggest new directions to follow. 
in addition  the machine support could include a set of rules that continuously monitor simple features of the design  providing a check that preserves almost-correctness but does not guarantee a complete validation. in effect  this makes the machine a sounding board for human design  just as colleagues act as sounding boards. people explain their ideas to colleagues so that they are forced to look at their design from other perspectives  with different assumptions  and go through the design one more time in explaining it. a machine might serve the role of a colleague 
building the human/machine communication interface is the hard part of following through with these plans. the two agents must speak the same language and each must be able to track what the other is doing. this may turn out to be even harder than full automation. 
h. other design tasks 
there are a variety of other design tasks  such as engineering design or vlsi design. although each of these tasks has its own unique characteristics  we may hope that some of the concepts discussed in this paper may be relevant to these tasks. 
v. conclusions 
the essence of the model of design presented here lies in its informality and its use of multiple problem spaces  including example generation and trial execution based on both the domain space and an algorithm design space. these techniques provide a focus of attention to limit search and enable the discovery of key concepts. the model shares problem-solving techniques with many of the other approaches  but rather than having a single monolithic plan of attack  it shifts techniques depending on the knowledge available. 

several areas need further formalizing and testing the models of the processes of discovery and visual reasoning must be extended learning and database issues should be explored further for example  what are the appropriate organization and retrieval techniques for large amounts of information so that key ideas in algorithms and derivations are accessible when relevant1 being able to learn automatically depends on appropriate accessing and on general problem solving techniques  
the interactions between search  domain knowledge  and programming knowledge seem important in tasks of any appreciable difficulty  including automatic programming and the next generation of expert systems  but several questions about these interactions are still unresolved. for example  it is not well understood how to determine when to stop refining at a given level  how problem spaces are created from problems 
descriptions  and so on 
understanding the design process impacts other branches of al i hose that include design tasks  discovery  visual reasoning  the use of examples  and interaction between different types of knowledge could be compared to algorithm design in their organization of knowledge and use of problem solving techniques. answering the questions posed for design should shed some light on the general issues in other domains. a side effect of automation  the formalization of algorithm design  analysis  and optimization principles  could also be useful in teaching. our observations of human design show that examples are useful in the absence of knowledge and therefore probably necessary to teach the knowledge  but having explicit principles is more efficient for the designer 
in summary  the model of design presented here is a good start on understanding algorithm design. the attempt to formalize the model lays a substantial part of the foundation for automation. 
a c k n o w l e d g m e n t s 
the research described here is joint work with allen newell and david steier. mary anne wolf recorded and transcribed many of the protocols. thanks to jon bentley for helping to instigate these studies i hanks are also due to the designers who participated in the experiments for their interest and cooperation; they shall remain anonymous for obvious reasons programming support for the implementation and additional input has been provided by brigham bell  lisa covi. billy kim  roland kovacs. deepak kulkarny  david marshall. jim muller. ed pervin. eric schwabe. 
mark taylor  and ross thompson as well as wolf and steier allen newell  david barstow  david steier. and sol greenspan made valuable comments on earlier versions of this paper 
