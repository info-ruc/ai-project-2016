
although recent years have seen a surge of interest in the computational aspects of social choice  no attention has previously been devoted to elections with multiple winners  e.g.  elections of an assembly or committee. in this paper  we fully characterize the worst-case complexity of manipulation and control in the context of four prominent multi-winnervoting systems. additionally we show that several tailor-made multi-winner voting schemes are impractical  as it is np-hard to select the winners in these schemes.
1 introduction
computational aspects of voting have been the focus of much interest  in a variety of fields. in multiagent systems  the attention has been motivated by applications of well-studied voting systems1 as a method of preference aggregation. for instance  ghosh et al.  designed an automated movie recommendation system  in which the conflicting preferences a user may have about movies were represented as agents  and movies to be suggested were selected according to a voting scheme  in this example there are multiple winners  as several movies are recommended to the user . in general  the candidates in a virtual election can be entities such as beliefs or joint plans  ephrati and rosenschein  1 .
모different aspects of voting rules have been explored by computer scientists. an issue that has been particularly well-studied is manipulation. the celebrated gibbardsatterthwaite theorem implies that under any reasonable voting scheme  there always exist elections in which a voter can improve its utility by lying about its true preferences. nevertheless  it has been suggested that bounded-rational agents may find it hard to determine exactly which lie to use  and thus may give up on manipulations altogether. the first to address this point were bartholdi  tovey and trick  1a ; bartholdi and orlin  later showed that manipulating single transferable vote  stv  is an np-complete problem. conitzer  lang and sandholm  studied a setting where there is an entire coalition of manipulators. in this setting  the problem of manipulation by the coalition is np-complete in a variety of protocols  even when the number of candidates is constant.
모another related issue that has received some attention is the computational difficulty of controlling an election. here  the authority that conducts the elections attempts to achieve strategic results by adding or removing registered voters or candidates. bartholdi  tovey and trick  analyzed the computational complexity of these  and other  methods of controlling an election in the plurality and condorcet protocols.
모the above discussion implies that computational complexity should be considered when contemplating voting systems that are seemingly susceptible to manipulation or control. on the other hand  taking into account computational costs can also lead to negative results. some sophisticated voting systems  designed to satisfy theoretical desiderata  may be too difficult to use in real-world settings. in other words  there are voting systems where even determiningwho won the election is an np-complete problem. previously known examples include voting schemes designed by charles dodgson1and kemeny  bartholdi et al.  1b .
모settings where there are multiple winners are inherently different from their single-winner counterparts. a major concern when electing an assembly  for example  might be proportional representation: the proportional support enjoyed by different factions should be accurately represented in the structure of the assembly. in practice  this usually means that the percentage of votes secured by a party is roughly proportional to the number of seats it is awarded.
모some simple multi-winner rules do not guarantee proportional results; these rules include single non-transferable vote  sntv   bloc voting  approval  and cumulative voting. more recently  intriguing theoretical voting schemes have been devised with the goal of guaranteeing proportional representation. two such schemes that have received attention were proposed  respectively  by monroe   and by chamberlin and courant .
모in this paper  we augment the classical problems of manipulation and control by introducing multiple winners  and study these problems with respect to four simple but important multi-winner voting schemes: sntv  bloc voting  approval  and cumulative voting; we find that cumulative voting is computationallyresistant to both manipulationand control. in addition  we characterize the computational complexity of winner determination in some of the intriguing voting schemes that have been suggested in recent years by political scientists.
1 multi-winner voting schemes
in this section we discuss several multi-winner voting systems of significance. although the paper is self-contained  interested readers can find more details in  brams and fishburn  1 .
모let the set of voters be v = {v1 v1 ... vn}; let the set of candidates be c = {c1 c1 ... cm}. furthermore  assume that k 뫍 n candidates are to be elected.
모we first present four simple voting schemes; in all four  the candidates are given points by the voters  and the k candidates with the most points win the election. the schemes differ in the way points are awarded to candidates.
  single non-transferable vote  sntv : each voter gives one point to a favorite candidate.
  bloc voting: each voter gives one point to each of k candidates.
  approval voting: each voter can approve or disapprove any candidate; an approved candidate is awarded one point  and there is no limit to the number of candidates a voter can approve.
  cumulative voting: allows voters to express intensities of preferences  by asking them to distribute a fixed number of points among the candidates. cumulative voting is especially interesting  since it encouragesminority representation and maximizes social welfare  brams and fishburn  1 .
1 fully proportional representation
we now describe two theoretical voting schemes that attempt to achieve the ideal of fully proportional representation.
모we begin by specifying monroe's pure scheme  monroe  1 . for each voter v and candidate c  a misrepresentation value 뷃vc is known;1 this value characterizes the degree to which candidate c misrepresents voter v.
모let s = {s   c : |s| = k}  the set of all possible subsets of k winners. let s 뫍 s  and let fs : v 뫸 s be a function that assigns voters to candidates in s. the misrepresentation score of voter v under fs is 뷃vfs v . the total misrepresentation of assignment.
모monroe requires that fs be restricted so that a similar number of voters be assigned to each candidate in s. in other words  each candidate in s must be assigned at least voters. we say that such an assignment is balanced. the misrepresentation score of s is the misrepresentation score of fs  where fs : v 뫸 s is the assignment with the minimal misrepresentation  subject to the aboverestriction. the k winners are the set s 뫍 s with the lowest misrepresentation score.
모chamberlin and courant  adopt a similar approach; as before  one considers sets s 뫍 s and assignments fs. however  chamberlin and courant impose no restrictions on the assignments. therefore  each set s is associated with the assignment fs : v 뫸 s that minimizes misrepresentation among all possible assignments. to maintain proportionality  chamberlin and courant compensate by using weighted voting in the assembly.
1 manipulation
a voter is considered to be a manipulator  or is said to vote strategically  if the voter reveals false preferences in an attempt to improve its outcome in the election. settings where manipulation is possible are to be avoided  as many voting protocols are designed to maximize social welfare  under the assumption that voters reveal their intentions truthfully. therefore  computational resistance to manipulation is considered an advantage.
모in the classical formalization of the manipulation problem  bartholdi et al.  1a   we are given a set c of candidates  a set v of voters  and a distinguished candidate p 뫍 c. we also have full knowledge of the voters' votes. we are asked whether it is possible to cast an additional vote  the manipulator's ballot  in a way that makes p win the election.
모when generalizing this problemfor the k-winner case  several formulations are possible. for example  one can ask whether some candidate can be one of the k-winners  or whether it is possible to ensure that a complete set of k winners be elected. we adopt a more general formulation.
definition 1. in the manipulation problem  we are given a set c of candidates  a set v of voters that have already cast their vote  the number of winners k 뫍 n  a utility function u : c 뫸 z  and an integer t 뫍 n. we are asked whether the manipulator can cast its vote such that in the resulting
  where w is the set of winners 
|	=	.
remark 1. we make the standard assumption that tiebreaking is adversarial to the manipulator  conitzer and sandholm  1; conitzer et al.  1   i.e.  if there are several candidates that perform equally well in the election  the ones with the lower utility will be elected.
proposition 1. manipulation in sntv  bloc voting  and approval is in p.
proof. simple and efficient algorithms exist for manipu-
lation in these three protocols; omitted due to lack of space.	
proposition 1. manipulation in cumulative voting is np-complete.
모the proof relies on a reduction from one of the most wellknown np-complete problems  the knapsack problem.
definition 1. in the knapsack problem  we are given a set of items a = {a1 ... an}  for each a 뫍 a a weight w a  뫍 n and a value 뷊 a   a capacity b 뫍 n  and t 뫍 n.
we are asked whether there is a subset such that while.
proof of proposition 1. the problem is clearly in np.
모to see that manipulation in cumulative voting is nphard  we prove that knapsack reduces to this problem. we are given an inputof knapsack  and construct an instance of manipulation in cumulative voting as follows.
모let n=|a|. there are 1n voters: v = {v1 ... v1n}  1n candidates: c = {c1 ... c1n}  and n winners. in addition  each voter may distribute b points among the candidates. we want the voters in v to cast their votes in a way that the following three conditions are satisfied:
1. for j = 1 ... n  cj has b   w aj  + 1 points.
1. for j = n + 1 ... 1n  cj has at most b points.
1. for j = 1n + 1 ... 1n  cj has exactly b points.
모this can easily be done. indeed  for i = 1 ... n  voter vi awards b   w ai  + 1 points to candidate ci  and awards its remaining w ai    1 points to candidate cn+i. now  for i = 1 ... n  voter n + i awards all its b points to candidate 1n + i.
we define the utility u of candidates as follows:

모the transformation is clearly polynomial  so it only remains to verify that it is a reduction. assume that there is a subsetwith total weight at most b and total value at least. the manipulator awards w aj  points to each candidate  raising the total score of these candidates to b+1. since initially all candidates have at most b points  all candidates are among the n winners of the election. the total utility of these candidates is:
  since for all j = 1 ... n 
모in the other direction  assume that the manipulator is able to distribute b points in a way that the winners of the election have total utility at least t. recall that there are initially at least n candidates with b points and utility 1  and that ties are broken adversarially to the manipulator. therefore  there must be a subset of candidates that ultimately have a score of at least b + 1  such that their total utility is at least t. let a be the corresponding items in the knapsack instance  i.e. . the total weight of items in a is at most b  as only b points were distributed among the candidates in c by the manipulator  and each initially has b   w aj  + 1 points. it also holds that the total utility of the items in a is exactly the total utility of the candidates in c  namely at least t. 
1 control
some voting protocols can be controlled by the authority conducting the election  which we refer to as the chairman  in the sense that the chairman can change the election's results. some types of control available to the chairman are adding  spoiler  candidates  disqualifying candidates  registering new voters  or removing voters that were already registered. a study of these issues in the context of two wellknown voting protocols was reported by bartholdi  tovey and trick   who found that control by adding and deleting candidates is np-hard even in the simple plurality1 protocol. moreover  in most cases the complexity of deleting voters is identical to that of adding voters. therefore  we focus hereinafter on control by adding voters.
모the following formulationof the control by addingvoters  problem appeared in  bartholdi et al.  1 : we are given a set c of candidates and a distinguished candidate p 뫍 c; a set v of registered voters  and a set v  of voters that could register in time for the election. we are also given r 뫍 n  and have full knowledge of the voters' votes. we are asked whether it is possible to register at most r voters from v  in a way that makes p win the election.
모as in the case of manipulation  we generalize this definition for our multi-winner setting:
definition 1. in the control problem  we are given a set c of candidates  a set v of registered voters  a set v  of unregistered voters  the number of winners k 뫍 n  a utility function u : c 뫸 z  the number of winners we are allowed to register r 뫍 n  and an integer t 뫍 n. we are asked whether it is possible to register at most r voters from v  such that in the resulting election   where w is the set of winners  |w| = k.
remark 1. again  we assume that ties are broken adversarially to the chairman.
proposition 1. control in bloc voting  approval  and cumulative voting is np-complete.
proof. by reduction from max k-cover;1 omitted due to lack of space.	
proposition 1. control in sntv is in p.
proof. we describe an algorithm  control-sntv  that efficiently decides control in sntv. informally  the algorithm works as follows. it first calculates the numberof points awarded to candidates by voters in v . then  at each stage  the algorithm analyzes an election where the l top winners in the original election remain winners  and attempts to select the other k   l winners in a way that maximizes utility. this is done by setting the threshold to be one point above the score of the  l + 1 -highest candidate; the algorithm pushes the scores of potential winners to this threshold.
모a formal description of control-sntv is given as algorithm 1. the procedure push works as follows: its first parameter is the threshold thr  and its second parameter is the number of candidates to be pushed  pushnum. the procedure also has implicit access to the input of controlsntv  namely the parameters of the given control instance. push returns a subsetto be registered. we say that the procedure pushes a candidate c to the threshold algorithm 1 decides the control problem in sntv.

1: procedure control-sntv c v v  k u r t  1: s c  뫹 |{v 뫍 v : v votes for candidate c}|
1: sort candidates by descending score  break ties by ascending utility
1:	let the sorted candidates be {ci1 ... cim}
1:	for l = 1 ... k do	 top winners
1:	pushselect other winners; see details below
1: ul 뫹 utility from election where v  are registered
1:	end for
1:	if maxl ul 뫟 t then return true
1:	else
1:	return false
1:	end if
1: end procedure

if exactly thr   s c  votersthat vote for c are registered. in other words  the procedure registers enough voters from v  in order to ensure that c's score reaches the threshold. push finds a subset c of candidates of size at most pushnum that maximizes  under the restriction that all candidates in c can be simultaneously pushed to the threshold by registering a subset. the procedure returns this subset v .
모now  assume we have a procedure push that is always correct  in maximizing the utility of at most k   l candidates it is able to push to the threshold s cl+1  + 1  while registering no more than r voters  and runs in polynomial time. clearly  control-sntv also runs in polynomialtime. furthermore:
lemma 1. control-sntv correctly decides the control problem in sntv.
proof. let w = {cj1 ... cjk} be the k winners of the election that does not take into account the votes of voters in v   the original election   sorted by descending score  and for candidates with identical score  by ascending utility. let  be the candidates that won the con-
trolled election with the highest utility  sorted by descending score  then by ascending utility; let s  c  be the final score of candidate c in the optimal election. let min be the smallest index such that cjmin 뫍/ w   w.l.o.g. min exists . it holds that for all candidates c 뫍 w   s  c  뫟 s cjmin . now  we can assume w.l.o.g. that if c 뫍 w  and s  c  = s cjmin  then c 뫍 w  and consequently  c = cjq for some q   min . indeed  it must hold that u c  뫞 u cjmin   as tie-breaking is adversarial to the chairman   and if indeed c /뫍 w even though c 뫍 w   then the chairman must have registered voters that vote for c  although this can only lower the total utility.
모it is sufficient to show that one of the elections that is considered by the algorithm has a set of winners with utility at least that of w . indeed  let; all other k   min + 1 candidates  have s c  뫟 s cjmin  + 1. the algorithm considers the election where the first min   1 winners  namely  remain fixed  and the threshold is s cjmin +1. surely  it is possible to push all the candidates in to the threshold  and in such an election  the winners would be w . since push maximizes the utility of the k   min + 1 candidates it pushes to the threshold  the utility returned by push for l = min 1 is at least as large as the total utility of the winners in w . 
모it remains to explain why the procedure push can be implemented to run in polynomial time. recall the knapsack problem; a more general formulation of the problem is when there are two resource types. each item has two weight measures  w1 ai  and w1 ai   and the knapsack has two capacities: b1 and b1. the requirement is that the total resources of the first type used do not exceed b1  and the total resources of the second type do not exceed b1. this problem  which often has more than two dimensions  is called multidimensional knapsack. push essentially solves a special case of the two-dimensional knapsack problem  where the capacities are b1 = r  the number of voters the chairman is allowed to register   and b1 = pushnum  the number of candidates to be pushed . if the threshold is thr  for each candidate cj that is supported by at least thr   s cj  voters in v   we set w1 aj  = thr   s cj   w1 aj  = 1  and 뷊 aj  = u cj . the multidimensional knapsack problem can be solved in time that is polynomial in the number of items and the capacities of the knapsack  kellerer et al.  1   via dynamic programming  for example . since in our case the capacities are bounded by and | |  push can be designed to run in polynomial time.	
1 winner determination
some complex voting schemes are designed to be theoretically appealing in the sense that they satisfy some strict desiderata. unfortunately  it might be the case that an attractive voting scheme is so complicated that even identifying the winners is an np-hard problem. this is a major issue  especially when one considers using such a protocol for real-life elections  as elections of this kind might always need to be resolved within a reasonable time frame.1 notice that in sntv  bloc voting  approval  and cumulative voting  it is clearly easy to tell who the winners are. in this section  however  we focus on the complex schemes introduced in section 1.
definition 1. in the winner-determination problem  we are given the set of voters v   the set of candidates c  the number of winners k 뫍 n  misrepresentation values 뷃vc 뫍 {1 ... m}  and t 뫍 n. we are asked whether there exists a subset s   c such that |s| = k  with misrepresentation at most t.
remark 1. determining the set of winners is clearly harder than the above decision problem  as the set of winners minimizes misrepresentation.
remark 1. for ease of exposition  we shall assume that n/k is an integer. this does not limit the generality of our results  as otherwise it is possible to pad the electorate with voters v such that 뷃vc = 1 for all c 뫍 c.
theorem 1. the winner-determination problem in monroe's scheme and in the chamberlin-courant scheme is np-complete  even when the misrepresentation values are binary.
proof. by reduction from max k-cover; omitted due to lack of space.	
모our hardness results relied on the implicit assumption that the number of winners k is not constant  in the previous sections as well . in the context of the winnerdetermination problem  we are also interested in a setting where the number of winners is constant  as this is sometimes the case in real-life elections: the electorate grows  but the size of the parliament remains fixed.
proposition 1. when the number of winners satisfies k = o 1   the winner-determination problem in monroe's scheme and in the chamberlin-courant scheme is in p.
proof. clearly the winner-determination problem in the chamberlin-courant scheme can be solved efficiently when k = o 1   as the size of the set s  the set of subsets of candidates with size k  is polynomial in m. for a given s 뫍 s  finding the assignment fs that minimizes misrepresentation in this scheme is simple: each voter v is assigned to
argminc뫍c뷃vc.
모in monroe's scheme  by a similar consideration  it is sufficient to produce a procedure that efficiently computes the misrepresentation score of every s 뫍 s  i.e.  finds a balanced assignment that minimizes misrepresentation in polynomial time.
모we analyze a procedure that maintains at each stage a balanced assignment  and iteratively decreases misrepresentation.1 changes in the assignment are introduced by cyclically right-shifting  c.r.s.  sets of voters: each voter in a set a = {vi1 vi1 ... vil} is shifted to the candidate that is assigned to its successor; the assignment remains balanced as the last voter is assigned to the first candidate. in more detail  if the current assignment is fs  the algorithm singles out a set of voters a = {vi1 vi1 ... vil}  l 뫞 k  and modifies the assignment by defining the next assignmentas follows:
		 1 
모the procedure is formally described in algorithm 1. it terminates after at most nm repetitions of the iterative step: at each iteration  the total misrepresentation decreases by at least 1  since the 뷃vc are integers. on the other hand  the total misrepresentation cannot decrease below 1  and is initially at most n 몫 maxv c 뷃vc 뫞 nm. moreover  the iterative step of the algorithm can be calculated efficiently: since k is algorithm 1 finds a balanced assignment that minimizes misrepresentation.

1: procedure assign s 
1: fs 뫹 arbitrary assignment of n/k voters to each candidate in s
1:	loop
1: if  a   v s.t. |a| 뫞 k 뫇 c.r.s. a strictly decreases misrepresentation then
1:	update fs by performing the shift	
according to equation  1 
1:	else 1:	return fs
1:	end if
1:	end loop
1: end procedure

constant  the number of possible cycles of length at most k is polynomial in n. we have that the complexity of winnerselection in monroe's scheme is polynomial - provided we are able to show that the procedure works!
lemma 1. assign returns an optimal assignment.
proof. consider a scenario where the procedure reaches the iterative step  but the current assignment is not optimal. we must show that the algorithm does not terminate at this point.
indeed  letbe a fixed optimal assignment. we consider the voters v such that fs v  = fs  v  to be placed  and the other voters to be misplaced. assume without loss of generality that fs  minimizes the number of misplaced voters among all optimal assignments.
모we claim that there is a set of l 뫞 k voters that can be cyclically right-shifted in a way that places all l voters. let vi1 be a misplaced voter. in order to place it  it has to be assigned to the candidate fs  vi1 . thus  one of the voters that fs assigns to must be misplaced  otherwise fs is not balanced; call this voter vi1. vi1 can be placed by uprooting a voter vi1 assigned to. iteratively repeating this line of reasoning  there must at some stage be a voter  such that for some; this is true  since there are only k distinct candidates in s. hence  the voterscan be cyclically right-shifted in a way that places allvoters.
모for any set of voters that can be placed by cyclic rightshifting  the shift must strictly decrease misrepresentation. otherwise  by cyclically left-shifting the same set in fs   we can obtain a new optimal and balanced assignment  in which more voters are placed compared to fs ; this is a contradiction to our assumption that fs  minimizes the numberof misplaced voters.
모it follows that there must be a set of at most k voters such that cyclically right-shifting the set strictly decreases the misrepresentation. therefore  the procedure does not terminate prematurely.	
	the proof of proposition 1 is completed.	
in...manipulationcontrolsntvppblocpnp-capprovalpnp-ccumulativenp-cnp-ctable 1: the computational difficulty of manipulation and control in multi-winner protocols.
1 conclusions
table 1 summarizes the complexity of manipulation and control 1 with respect to four protocols: sntv  bloc voting  approval voting  and cumulative voting. of the four protocols  the only one that is computationally resistant to both manipulation and control is cumulative voting. this protocol also has other advantages: it allows voters to express the intensities of their preferences  and encourages proportional results  albeit  without guaranteeing them . therefore  cumulative voting seems especially suitable as a method to aggregate agents' preferences.
모one must remember in this context that np-hardness may not be a good enough guarantee of resistance to manipulation or control: an np-hard problem has an infinite number of hard instances  but it may have many more easy instances. indeed  procaccia and rosenschein  show that a specific family of voting protocols is susceptible to coalitional manipulation in the average-case  although the problem is hard in the worst-case. nevertheless  np-hardness of manipulation or control should certainly be a consideration in favor of adopting some voting protocol.
모while high complexity of manipulation or control in a voting scheme is interpreted positively  high complexity of winner determination is a major consideration against the scheme  and may in fact preclude its use in real-life settings. winner determination is np-complete with respect to the theoretical voting schemes proposed by monroe  and by chamberlin and courant. monroe's scheme has received some attention in recent years. in particular  it has been shown that an election can be resolved with integer programming  potthoff and brams  1 . unfortunately  solving an integer program is still difficult; this formulation does not even guarantee an efficient solution when the number of winners is constant. such a solution is  however  given by proposition 1. this implies that it is perhaps possible to use the scheme in settings where the size of the assembly is very small compared to the size of the electorate.
1 acknowledgment
this work was partially supported by grant #1 from the israel science foundation.
