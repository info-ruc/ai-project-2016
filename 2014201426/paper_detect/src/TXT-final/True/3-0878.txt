
in games such as kriegspiel chess  a chess variant where players have no direct knowledge of the opponent's pieces' locations  the belief state's sizes dwarf those of other partial information games like bridge  scrabble  and poker-and there is no easy way to generate states satisfying the given observations. we show that statistical sampling approaches can be developed to do well in such games.
we show that it is not necessary for the random sample to consist only of game boards that satisfy each and every one of a player's observations. in fact  we win 1% more often by beginning with such completely consistent boards and gradually switching  as the game progressed  to boards that are merely consistent with the latest observation.
this surprising result is explained by noting that as the game progresses  a board that is consistent with the last move becomes more and more likely to be consistent with the entire set of observations  even if we have no idea what sequence of moves might have actually generated this board.
1 introduction
one of the biggest difficulties in using game-tree search algorithms in imperfect-information games is that the game trees have huge branching factors. usually the belief-state size  the number of current states that are consistent with everything a player knows about the game  is combinatorially large. hence the number of moves that the opponent might be able to make  and the number of states that these moves might lead to  are also quite large.
모the best known way to circumvent this problem is to do statistical sampling: to generate a set of random game boards consistent with the current belief state  do a perfectinformation game-tree search on each of those game boards  and average the minimax values. this has worked well in games such as bridge  smith et al.  1; ginsberg  1   scrabble  sheppard  1   and poker  billings et al.  1 .
모the success of statistical sampling in the above games relates  at least in part  to several conditions that do not hold in various other imperfect-information games  such as kriegspiel chess  civilization  starcraft  quake1  counterstrike  and freeciv. more specifically:
  belief-state size. bridge  poker  and scrabble have relatively small belief states. at the start of a bridge hand  the size of each player's belief state is about 1 1 after the dummy's cards have been exposed; and this number decreases exponentially as the game proceeds. although 1 1 may seem like a large number  it is dwarfed by the belief-state sizes in several other games. for example  in kriegspiel chess 1 the size of each belief state at midgame is well above 1; and in the small world map for freeciv  the belief-state size is about 1.
  uncertainty model. the uncertainty in bridge  poker  and scrabble is due to external factors that can easily be modeled stochastically: the random deal of the cards in bridge or poker  and the random choice of a tile in scrabble. thus it is easy to tell whether or not a state s is consistent with a belief state b  and to assign a probability to s given b.
in games such as kriegspiel chess  the uncertainty arises from lack of observability of the opponent's actions. this uncertainty has no simple stochastic model. instead  telling whether a state s is consistent with the current belief state b means checking whether there is a history  i.e.  a sequence of moves  that is consistent with b and leads to s. in the average case  this takes exponential time.
  simplifying approximations. in bridge and poker  usually the statistical sampling is not done on the game itself  but on a simplified approximation in which the state space and belief states are much smaller. in bridge  the approximation is done by treating various sets of states as if they were equivalent  a technique that was first used in the game of sprouts  applegate et al.  1 . in poker  a linearprogramming approximation has been used  billings et al.  1 . in kriegspiel chess  it is unclear how or whether such an approximation could be constructed.
to summarize  our objective is to determine how to make game-tree search work successfully in imperfect-information games that have huge belief states  no simple stochastic model of uncertainty  and no obvious way to construct a simplified approximation of the game. our results are: procedure choose-move s  m 뫹 {moves applicable to states in s} for every s 뫍 s and every m 뫍 m do vs m 뫹 evaluate-board 붺 s m  
return argmaxm뫍m ps뫍s vs mp s 
figure 1: abstract statistical-sampling algorithm for move evaluation. evaluate-board is a perfect-information search algorithm such as alpha-beta.
1. we describe several algorithms for generating the random sample of game boards used in the tree search. aosp generates game boards that are consistent with the entire sequence o of observations that a player has made during the game. los only requires consistency with the last observation oi. hs behaves like aosp at the beginning of the game  but as the game progresses it gradually switches over to behaving like los.
1. we analyze the performance of our algorithms theoretically. surprisingly  our analysis suggests that there are cases in which los will play well and hs will do better than aosp.
1. our experimental tests in the game of kriegspiel chess confirm our analysis' hypotheses. in our experiments  timed los  los with a time limit  did much better than random play  timed aosp did much better than timed los; and timed hs did much better than timed aosp.
1 game-tree search with statistical sampling
to describe how statistical sampling is used for game-tree search in imperfect-information games  we need an abstract model for the kinds of games where it is used. for simplicity  we assume the game is zero-sum and there are two players p1 p1 who move in alternation.
모as the game progresses  the players' moves will generate a sequence of states si = hs1 s1 ...i called the game history. at each state si  each player pj will be able to make an observation oij of si; usually oij will include complete information about pj's position and partial information about the other player's position. at si  player pj's observation history is oij = ho1j o1j ... oiji  and pj's belief state is bij = {all states that satisfy oij}.
모our sampling algorithms will be based on the following properties of a state s: s is last-observation consistent if it is consistent with oij  and all-observation consistent if it is consistent with oij.
모figure 1 shows an abstract version of statistical game-tree search. s is the sample set of states  붺 s m  is the state produced by performing move m in state s  evaluate-board is a perfect-information game-tree-search algorithm such as alpha-beta  and p is a probability distribution over the states in s. some additional code must be added to handle the case where a move m is applicable to some states but not others; this code tends to be game-specific and we discuss it further in section 1.
모we now can define four different sampling algorithms that provide input for choose-move. in each case  k is the desired number of states in the statistical sample  and i is how many moves the players have played so far.
  los  last observation sampling  if there are fewer than k last-observation consistent states  then let s contain all of them; otherwise let s contain k such states chosen at random. return choose-move s .
  aos  all observation sampling : let s =  . generate a random history hs1 ... sii. if the history satisfies oij  then add si to s. do this repeatedly until |s| = k. return choose-move s .
  aosp  all observation sampling with pool : aosp returns both a move and a set of states  a pool  for pj to use as input to aosp next move. every state in the pool is to be consistent with oij  though we do not assume that all such states are in the pool. let s1 be the pool aosp returned last time  and m = {all of the other player's possible responses to pj's last move}. let
s1 = {붺 s m  | s 뫍 s1 m 뫍 m  m is applicable to s  and 붺 s m  satisfies oij}. if |s1|   k  then let s1 = s1; otherwise let s1 contain k states chosen at random from s1. let m = choose-move s1 . return  m {붺 s m  | s 뫍 s1} .
  hs  hybrid sampling : like aosp  hs returns a move and a set of states. compute s1 and s1 same as in aosp. if |s1|   k then let s1 be a set of k   |s1| random lastobservation consistent states; otherwise s1 =  . let m = choose-move s1뫋s1 . return  m {붺 s m  | s 뫍 s1} .
모analyzing the performance of these algorithms is impossible without making simplifying assumptions  but there is more than one set of assumptions one might make. below we do two analyses  based on two different sets of assumptions. the differing assumptions lead to differing conclusions about which algorithm will do better.
analysis 1: suppose each state has exactly b children  for some constant b. suppose that we know all of pj's moves but not the other player's moves. if the number of states is very large  e.g.  1 or 1 as described earlier   then during the early stages of the game  the number of states grows exponentially  with roughly bi/1 possible states at the i'th move. suppose that for each state s where it is the other player's move  the observation history oij eliminates  on the average  some fraction 1/c of that player's possible moves  where c   1. then the number of possible states at the i'th move given oij is  b/c i/1. thus the probability of any individual state at depth i being consistent with oij is  1/c i/1  which approaches 1 at an exponential rate as i increases.
모thus  if the game continues to grow as a tree with a branching factor of b  then our analysis suggests the following:
  aos will be computationally intractable. the probability of a random history being consistent with bi is likely to be something like 1/ci/1. thus  in order to produce a sample of size k  aos will probably need to generate k 몫 ci/1 histories  taking exponential time.
  aosp is much more efficient computationally than aos  but its sample set s1 will decrease in size as the game progresses. the probability of a state s's successors being consistent with bi is 1/c  since s is already known to be consistent with bi 1. hence the amount of time needed to generate k states for s1 does not increase as quickly as it would if we generated the states from random histories like aos does. it is still the case  however  that as the game progresses  s1 will soon become too small for the results to have much statistical significance and aosp's play will begin to resemble random play.
  each board generated by los is unlikely to be consistent with the current belief state; thus the values computed by los are likely to be close to random.
  at the beginning of the game  hs will behave identically to aosp. as the game proceeds and the size of s1 decreases  hs will put more and more randomly generated boards into s1  thus making the results more noisy. thus hs's quality of play is likely to be worse than aosp's.
analysis 1: if there are n possible states in the game  then the number of moves at each level cannot continue to grow exponentially  but will eventually flatten out. the game  tree  will be a graph rather than a tree  with n nodes  at most  at each depth  one for each possible state. there will be b edges from each node at depth i to nodes at depth i + 1  1/c of which are consistent with any given observation; suppose these edges go to a random set of nodes. then for each state s  the probability  under certain independence assumptions  that it is reachable in i moves is about min 1  n   1 i 1  b/c / n   1  i 1 . in other words  the probability that a randomly chosen state s has a history consistent with oij approaches 1 at exponentially. this suggests the following:
  as the game proceeds  the amount of time needed by aos will eventually level off; its upper bound will be n times the amount of time needed by each call to the classical game-tree search algorithm.
  rather than degrading to random play as in analysis 1  aosp's quality of play will eventually level off at some level above that  depending on the number of states available in the pool.
  as the game proceeds  the probability of a randomly generated board being consistent with the current belief state will increase toward 1; thus los will produce increasingly good quality of play. however  its play will be limited by the fact that it has no good way to assign relative probabilities to its randomly generated boards.
  at the beginning of the game  hs will behave identically to aosp. as the game proceeds and aosp's sample size decreases  hs will fill up the rest of the sample with randomly generated boards-but as the game proceeds  it will become increasingly likely that these randomly chosen boards are consistent with the current belief state. thus hs's quality of play is likely to be better than aosp's.
summary. with the first set of assumptions  aosp is likely to perform much better than los  and somewhat better than hs. with the second set of assumptions  it is unclear which of los and aosp will be better  but hs is likely to perform better than aos  aosp  and los.
모since both sets of assumptions represent extremal cases  our hypotheses are that in many games the actual performance is likely to be somewhere in between  such that hs will perform somewhat better than aosp. in other words  we hypothesize that in many games  if last-observation consistent boards are included in the statistical sample later in the game  this will help rather than hurt the evaluations. section 1 describes our experimental test of that hypothesis.
1 kriegspiel chess
as our test domain  we chose the game of kriegspiel chess  li  1; 1 . this game is like chess except that neither player can see the other's pieces. when player x captures one of player y's pieces  a referee announces that he/she has made a capture but not what piece was captured  and the referee removes the captured piece from y's board but does not say what piece captured it. when x tries to make a move that is illegal  an attempted pawn take  or moving into check  or attempting to jump an opponent's piece   the referee announces that the move is illegal but not why. when x puts y's king in check  the referee tells both players that y's king is in check  and gives them partial information about how the check occurred  namely by rank  file  long diagonal  short diagonal  knight  or some combination of the above . both players hear all referee announcements.
모twenty moves into a kriegspiel chess game  a conservative estimate is that at each node of the game tree  the current sequence of observations is consistent with more than 1 board positions. because of this uncertainty  kriegspiel chess is a notoriously difficult game to win  li  1; 1 ; most games end in draws.
1 implementation of the algorithms
for choose-move's evaluate-board subroutine  we took the gpl'ed chess program provided by gnu and modified it to return a minimax value for a particular board. note that for each s 뫍 s we call the evaluation function |m| times  where |m| is the number of applicable moves  1 in kriegspiel . the only exception to this is the case where a move m 뫍 m is not legal in some state s 뫍 s; in this case we omit s when computing the average value for m. as shown in figure 1  we then return the move with the highest average value.
1 algorithms with time limits
in order to make fair comparisons among los  aosp  and hs  they cannot be implemented in the exact way described in section 1. they must be modified so that one of the inputs to the algorithm is t  the amount of time available to decide on a move  so that the algorithm can do as well as it can in that amount of time. the modified algorithms-timed los  timed aosp  and timed hs-are described below.
모we have implemented all three of these algorithms  using a combination of c and c++. in the next few months  we intend to make our implementations publicly available  both as open-source software and as a kriegspiel-chess game server running on our web site.
모timed los: rather than taking the set s as input as shown in figure 1  timed los generates the members of s one at a time and evaluates them as they are generated  so that it can generate and evaluate as many boards as it can during the time available. once the time is up  it returns the move whose average value is highest  as shown in figure 1.
모timed aosp: timed aosp maintains a pool of states p = {s1 ... sp} that are known to be consistent with the current belief state b. using an estimate of how long evaluate-board will take on each board  it calculates some number of boards kt that it can evaluate during the available time t. the estimate is deliberately a little low  to try to keep timed aosp from running overtime and to ensure that there will be time left over to attempt to generate more consistent boards. there are three cases:
  if p 뫟 kt then timed aosp calls choosemove {s1 ... skt}   and returns the recommended move.
  if 1   p   kt then timed aosp calls choose-move p   and returns the recommended move.
  if p = 1 then timed aosp returns a random move.
during whatever remains of the available time  aosp tries to generate more histories that are consistent with b; and for every such history  it adds the resultant board to the pool  see section 1 below .
모each time the referee makes an announcement  timed aosp must update the pool to be consistent with the announcement. this can cause the pool to either shrink  when timed aosp is told a move is illegal  or to grow  when timed aosp is told that the opponent has moved . this computation occurs at the beginning of aosp's turn.
모if the pool were allowed to grow unchecked  it could potentially get quite large; hence we limit its size to 1 boards. if the number of boards in the pool ever goes higher than this  we remove enough boards to get to the number of boards down to 1. because the 1 second time limit allows only enough time to call choose-move on a set about 1 boards from the pool  this is believed adequate.
모timed hs: timed hs works the same as timed aosp  with one exception. if 1 뫞 p   kt  then timed hs generates a set r of p   kt random boards that are consistent with oij  called last-observation consistent boards   and calls choose-move p 뫋 r . this rules out the possibility of ever having to make a random move. it also restricts the amount of time that timed hs can spend generating additional boards to put into the pool.
1 consistent history generation
the algorithm for generating additional histories consistent with b does a depth first search through the space of game histories. at each node  the known game history  oij  specifies the possible branches. whenever the algorithm reaches a node with multiple branches  corresponding to an opponent's hidden move in the game history   it randomly orders the branches and proceeds searching according to that order.
1 experiments
our experimental hypotheses  based on the analyses in section 1  were that  1  timed los would perform better than random play   1  timed aosp would perform better than timed los  and  1  timed hs would perform somewhat better than timed aosp. the third hypothesis caused some controversy because it was based on a notion that not all of the authors believed: that the computation time spent introducing and evaluating last-observation consistent boards would not be better spent trying to find and evaluate more all-observation consistent boards.
모to test our hypotheses  we played all three algorithms against each other and against a player who moved at random. each player plays approximately half of the games as white and half of the games as black. all experiments were run on xeon 1ghz chips with 1 mb ram  running linux. each player was allowed to spend 1 seconds deciding each move  including moves which are decided after an attempted illegal move.
모figure 1 shows the results for the algorithms versus the random player  figure 1 shows the results of head-tohead tests of the three algorithms. the results include the wins/losses/draws  and each player's average material value at each move of the game  using the standard chess value for each piece . we observe the following:
1. all three algorithms played much better than the random player  confirming our first hypothesis. the large number of draws is unsurprising  since kriegspiel chess is a notoriously difficult game to win.
1. timed aosp and timed hs both played much better than timed los  confirming our second hypothesis.
1. timed aosp and timed hs played about equally well versus a random player  but timed hs did significantly better than timed aosp when the two were played headto-head. furthermore  as shown in figure 1  timed hs did this using a substantial number of last-observation consistent boards as the game progressed.
the third observation is very interesting  because it suggests that our hypothesis about last-observation consistent boards is correct: they become more useful as the game progresses  because they are more likely to be consistent with the current belief state. even though we do not know what probabilities to assign to them in the last line of choose-move  they still provide useful information.
1 related work
the best-known work on imperfect-information games includes work on the games of bridge  smith et al.  1; ginsberg  1   scrabble  sheppard  1   and poker  billings et al.  1 ; we discussed this work in section 1.
모the existing literature on kriegspiel chess is rather small  and we believe ours is the first attempt to create a kriegspiel chess program capable of reasonable play throughout the entire game. two books have been written on how to play kriegspiel chess  li  1; 1 .  wetherell et al.  1  have implemented a program to act as the referee who sees the entire kriegspiel-chess game board and tells each player the information described in the second paragraph of section 1.  sakuta et al.  1  have implemented a search strategy for some imperfect-information games that are simpler than



algorithmswin  % loss  % draw  % runslos v rand11111aosp v rand11111hs v rand11.11 11figure 1: wins/losses/draws percentages plus or minus a 1% confidence interval and average material value at each move  in games between timed los  timed aosp  timed hs  and a random player. material value is a heuristic measure of a player's ability. we assign material value as follows: queen is worth 1  rook 1  bishop 1  knight 1  and pawn 1. the sum of all a player's pieces material value after a particular move is the player's material value for that move.



algorithmswin  % loss  % draw  % runsaosp v los111111hs v los11.111hs v aosp11 11 111figure 1: wins/losses/draws percentages plus or minus a 1% confidence interval and average material value at each move  in headto-head comparisons of timed los  timed aosp  and timed hs.

figure 1: the average percentage of last-observation consistent boards that timed hs used at each move in its games against timed aosp.
kriegspiel  and  bolognesi and ciancarini  1  and have developed search strategies for kriegspiel-chess endgames.
1 conclusion
in games such as kriegspiel chess  the belief states are huge compared to those in bridge  scrabble  and poker. furthermore  there is not a simple uncertainty model from which to generate boards consistent with a belief state. our results demonstrate that statistical sampling approaches can nevertheless be developed that do well in such games.
모our results also show that to play well  it is not necessary for the random sample to consist only of game boards that satisfy all of a player's observations. in fact  we were able to win 1% more often by starting out with such boards  but gradually switching over  as the game progressed  to boards that merely are consistent with the latest observation.
모the reason for our surprising result is that as the game progresses  a board that is consistent with the last move becomes more and more likely to be consistent with the entire set of observations  even if we have no idea what sequence of moves might have actually generated this board.
1 future work
the biggest limitation of our work is that we have not yet been able to evaluate play against human opponents. to do so will take some effort: we know of no rating system for kriegspiel chess players  hence it is difficult to tell whether a human player is good or bad. to overcome this obstacle  we are currently building a kriegspiel-chess game server which we will run on the web and will make available as opensource software.1 the server will include a ranking system so that we may compare our algorithms against humans.
모we have yet to attempt any opponent modeling. for example  we intend to extend our algorithms to assign a weight to each game board by estimating how likely the opponent was to make all of the moves leading to that board.
모a well-known deficiency of statistical-sampling approaches is that they do not take into account the informationgathering value of illegal moves  frank and basin  1 . we have ideas for how to modify our algorithms to overcome this deficiency  and intend to test these ideas in the near future.
모it would be worthwhile to examine different search strategies and evaluation functions. we currently rely on gnuchess for both  but it is not entirely clear whether this is the best approach for a game like kriegspiel chess.
acknowledgments
this work was supported by the following grants  contracts  and awards: aro grant daad1  arl grants daad1 and daal1  the arl ctas on telecommunications and advanced decision architectures  nsf grants iis1  1 and iis1  uc berkeley contract number sa1  subcontract from darpa's real program . the opinions expressed in this paper are those of the authors and do not necessarily reflect the opinions of the funders.
