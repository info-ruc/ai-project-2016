
recently  strong equivalence for answer set programming has been studied intensively  and was shown to be beneficial for modular programming and automated optimization. in this paper we define the novel notion of strong equivalence for logic programs with preferences. based on this definition we give  for several semantics for preference handling  necessary and sufficient conditions for programs to be strongly equivalent. these results provide a clear picture of the relationship of these semantics with respect to strong equivalence  which differs considerably from their relationship with respect to answer sets. finally  based on these results  we present for the first time simplification methods for logic programs with preferences.
1	introduction
during the last decade  answer set programming  asp   gelfond and lifschitz  1  has become an increasingly acknowledged tool for knowledge representation and reasoning. a main advantage of asp is that it is based on solid theoretical foundations  while being able to model commonsense reasoning in an arguably satisfactory way. the availability of efficient solvers has furthermore stimulated its use in practical applications in recent years. this development had quite some implications on asp research. for example  increasingly large applications require features for modular programming. another requirement is the fact that in applications  asp code is often generated automatically by so-called frontends  calling for optimization methods which remove redundancies  as also found in database query optimizers. for these purposes the rather recently suggested notion of strong equivalence for asp  lifschitz et al.  1; turner  1  can be used. indeed  if two asp programs are strongly equivalent  they can be used interchangeably in any context. this gives a handle on showing the equivalence of asp modules. if a program is strongly equivalent to a subprogram of itself  then one can always use the subprogram instead of the original program  a technique which serves as an effective optimization method.
모on a different line of asp research  many extensions of the basic formalism have been proposed. perhaps the most intensively studied one is the modeling of preferences in asp  cf.  delgrande et al.  1 . strongly rooted in the research of nonmonotonic formalisms  the ability to specify preferences is acknowledged to be particularly beneficial to asp  since they constitute a very natural and effective way of resolving indeterminate solutions. for example  preferences have been successfully used for timetabling  auctioning  configuration  and other domains. a sophisticated application for information site selection has been described in  eiter et al.  1 . the emergence of such applications thus also calls for optimization methods  as for standard asp.
모in this paper we tackle this issue and generalize the notion of strong equivalence to asp with preferences. since a plethora of formalisms and semantics has been introduced for extending asp by preferences  we have to limit ourselves in this paper to a few concrete approaches. a basic classification of preference handling is  i  over which elements the preference is defined and  ii  the way how preferences are interpreted  and in particular how they are aggregated. in this work we focus on ordered programs  where preferences are defined among rules  which semantically act as filters over answer sets. in particular  we consider the three semantics defined in  delgrande et al.  1; wang et al.  1; brewka and eiter  1   referred to as d-  w-  and bsemantics  respectively. the reason for this choice is that these semantics seem to be widely accepted and their properties and interrelationships are fairly well-understood.
모the contributions of this work are as follows. we define the notion of strong equivalence for ordered programs. it turns out that the definition for standard asp cannot be straightforwardly extended for two main reasons:  1  the  union  of ordered programs needs to be defined properly  and  1  not any  union  of ordered programs yields a valid ordered program. to overcome these problems  we define the notion of admissible extension  which provides a general method for defining strong equivalence for arbitrary structures. we show several properties of strong order equivalence  providing necessary

and sufficient conditions for programs to be strongly order higher priority than ri. formally  an ordered  logic  program equivalent. we also explore the relationship of strong order  olp  can be understood as a quadruple  붫 n n     where equivalence between the three semantics studied in this paper  붫 is a logic program  n is a bijective function between 붫 and and the relationship to strong equivalence of standard logic the set of names n  and   is a set of preference relations programs. based on these results  we study the applicability over 붫. whenever possible  we leave n and n implicit and of program simplification rules  known from standard asp  just write  붫    for olps. moreover  we write  =   if no in the presence of preferences. we obtain that most of these partial order is given that is  붫    denotes a logic program. simplifications can be applied only in particular contexts. the the interpretation that one rule has higher priority than an main results of this work are that the relationship between the other rule can be made precise in different ways. in what folthree preference semantics is changing under strong equiva- lows  we consider three such interpretations: d-  delgrande lence and that preferences cannot be  compiled away  in a et al.  1   b-  brewka and eiter  1   and w- prefermodular fashion. we omit all proofs due to the page limit. 1 ence  schaub and wang  1 . given  붫     all of them use   for selecting preferred answer sets among the standard
1	background	mantics.answer sets1 of 붫. we now recall the definitions of these se-
nsuchanswer뫟 asm psets.뫟1 뫹1  aandp1logic ... peachprogrampmi not  plpm+1  is ... a finitenot setpn ofwhererules definition 1of 붫. then  x letis   붫d-preserving     be an olp andif an enumerationx be an answer sethriii뫍i such a rule r  we let head r 1  denote뫞 i 뫞thenhead  is an  p1atom  of .r andfor of 붫 exists s.t. for every i j 뫍 i we have
body r  the body  {p1 ... pm  not pm+1 ... not pn}  1. if ri   rj  then j   i  and of r. let body+ r  = {p1 ... pm} and body  r  = 1. if ri 뫍 r붫 x  then body+ ri    {head rj  | rj 뫍 {pm+1 ... pn}. for a set of rules 붫  we write head 붫  = r붫 x  j   i}  and
{forheadall itsr rules.| r 뫍the붫}reduct. a program  붫x  ofisabasicprogramif body붫 relative  r  =to  a 1. if ri 뫍 붫   r붫 x  then set x of atoms is defined by 붫x = {head r  뫹 body+ r  |  a  body+ ri  1  x or
r 뫍 붫 body  r  뫌 x =  }. a set of atoms x is closed  b  body  ri  뫌 {head rj  | rj 뫍 r붫 x  j   i} =1  . under a basic program 붫 if for any r 뫍 붫  head r  뫍 x if
body+ r    x. the smallest set of atoms being closed un- cond.1 stipulates that the enumeration of 붫 is compatible der a basic program 붫 is denoted by cn 붫 . then  a set x with  . cond.1 makes the property of supportedness explicit. of atoms is an answer set of a program 붫 if cn 붫x  = x. although any answer set is generated by a supported sewe use as 붫  for denoting the set of all answer sets of 붫. in quence of rules  in d-preferences  rules cannot be supported what follows  an important concept is that of the generating by lower-ranked ones. cond.1a separates the handling of unrules of an answer set. given a set x of atoms from 붫  define supported rules from preference handling. cond.1b guaranr붫 x  = {r 뫍 붫 | body+ r    x body  r  뫌 x =  }. tees that rules can never be blocked by lower-ranked ones.
모strong equivalence. under the answer set semantics  two definition 1 let  붫    be an olp and x be an answer set lps 붫1 and 붫1 are regarded as equivalent  denoted 붫1 뫖 붫1  of 붫. then  x is  w-preserving  if an enumeration hriii뫍i iff as 붫1  = as 붫1 . two lps 붫1 and 붫1 are strongly of 붫 exists s.t. for every i j 뫍 i we have equivalent  denoted 붫1 뫖s 붫1  iff  for any lp
grams 붫1 뫋 붫 and 붫1 뫋 붫 are equivalent  i.e.	뫖
붫1 뫋 붫. as shown in  lifschitz et al.  1   strong equiv-	1. if ri 뫍 r붫 x  then
alence is closely related to the non-classical logic of here-	 a  body+ ri    {head rj  | rj 뫍 r붫 x  j   i} or
and-there  which was adapted to logic-programming terms byturner  turner  1 : let 붫 be an lp  and let x y   a  b  head ri  뫍 {head rj  | rj 뫍 r붫 x  j   i}  and such that x   y . the pair  x y   is an se-model of 붫  over 1. if ri 뫍 붫   r붫 x  then a   if y |= 붫 and x |= 붫y . by sea 붫  we denote the  a  body+ ri  1  x or set of all se-models over a of 붫. usually the set a is left  
implicit and one just writes se 붫 . then  for any lps 붫1  b  body  ri  뫌 {head rj  | rj 뫍 r붫 x  j   i} 1=   or and 붫1  붫1 뫖s 붫1 iff se 붫1  = se 붫1   turner  1 .  c  head ri  뫍 {head rj  | rj 뫍 r붫 x  j   i}.
모preferences. a logic program 붫 is said to be ordered if we for w-preference  the concept of order preservation from have a set n of terms serving as names for rules and a pref- d-preferences is weakened in condition 1 and 1 for suspenderence relation    n 뫄 n as a strict partial order among ing both conditions  whenever the head of a preferred rule is rules  where we write s   t for the names s t 뫍 n of rules derivable in an alternative way. in 붫. furthermore  we assume a bijective function n .  as-
signingsimplify our notation  we usually writeto each each rule r 뫍 붫 a nameri instead ofn r  뫍nn ri.  forto definition 1of 붫. then  x letis   붫b-preserving     be an olp andif an enumerationx be an answer sethriii뫍i some ri 뫍 붫. given ri rj 뫍 붫  ri   rj states that rj has of 붫 exists s.t. for every i j 뫍 i we have
	1. if ri   rj  then j   i  and 1a version of the paper including proofs can be found at http: 
//www.wfaber.com/research/#publications	1in the following  i is an index set i = {1 ... n} for |붫| = n.

1. if ri 뫍 붫   r붫 x  then
 a  body+ ri  1  x or
 b  body  ri  뫌 {head rj  | rj 뫍 r붫 x  j   i} 1=   or
 c  head ri  뫍 x.
b-preference drops cond.1; thus decoupling preference handling from the order induced by consecutive rule applications.
모for  뫍 {d w b}  we define as  붫     as the set of all  -preserving answer sets of olp  붫   . as shown in  schaub and wang  1   the three strategies yield an increasing number of preferred answer sets. that is  d- preference is stronger than w-preference  which is stronger than b-preference  which is stronger than no preference.
more precisely  we have asd  붫       asw  붫       asb  붫       as 붫  and  in addition  as  붫     = as 붫  for  뫍 {d w b}.
1	strong order equivalence
in this section we define variants of equivalences for olps. defining  standard  equivalence  two programs permit precisely the same answer sets  is straightforward by considering the respective preferred answer sets.
모however  concerning the notion of strong equivalence  there are some caveats. for standard programs  strong equivalence for 붫1 and 붫1 holds if for any program 붫  붫1 뫋 붫 and 붫1 뫋 붫 are equivalent. if we now take preferences into account  for any  붫      붫1  1  and  붫1  1  would be strongly equivalent if  붫1 뫋 붫  1 뫋    and  붫1 뫋 붫  1 뫋    are equivalent. the problem is that  붫1 뫋 붫  1 뫋    is not necessarily an olp  because of two issues: 1. rule label clashes  and 1. partial order clashes.
모rule label clashes  i.e. two different rules have the same name or one rule has two different names  can be resolved by a renaming. we say that  붫 n  n      is a renaming of  붫 n n    if n  is a new set of names of rules  n  .  is a bijective function assigning each rule of 붫 an unique name of n   and n  r     n  r1  holds iff n r    n r1   for all r r1 뫍 붫. the union of two olps is then defined as follows. definition 1 let  붫 n n    and  붫1 n1 n1  1  be olps where n n1 are disjoint sets of rule names.
	n	1 n1	1
as
  붫  = 붫 뫋 붫1
  n  as new set of names of rules 
  n  r  for r 뫍 붫 뫋 붫1 as a bijective function assigning each rule of 붫 뫋 붫1 an unique name of n   and
     as   뫋  1  where for r r1 뫍 붫 뫋 붫1  n  r     n  r1  holds whenever n r    n r1  or n1 r   1 n1 r1  holds.
again  we usually leave n  and n  implicit. sometimes we write  붫 뫋 붫1   뫋  1  for the union of  붫    and  붫1  1 .
모we next observe that the union of olps is not necessarily an olp. for this  consider

then  we have
 붫      = {r1 : a 뫹  r1 : b 뫹 a  r1    r1  r1    r1}
where    is not a strict partial order. hence   붫      is not an olp. to avoid this  we define the notion of admissible extensions of an olp.
definition 1 let  붫    and  붫1  1  be olps. then   붫1  1  is an admissible extension of  붫    if  붫뫋 붫1   뫋  1  is an olp.
모we remark that the notion of compatibility for orderings  as defined in  brewka and eiter  1   is similar in spirit to admissible extensions  but concerns only the order relation and not the rules in the program.
모analogously to  normal  logic programs  we can define the notion of equivalence of olps.
definition 1  order	equivalence 	let	 붫1  1 	and
 붫1  1  be olps and  뫍 {d b w}. then   붫1  1  and  붫1  1  are  -equivalent  denoted  붫1  1  뫖  붫1  1   iff as  붫1  1   = as  붫1  1  .
모since the definition of strong equivalence for logic programs can be interpreted as having the same answer sets in any extension  we employ the notion of admissible extensions for defining the analogon for olps.
definition 1  strong order equivalence  let  붫1  1  and  붫1  1  be olps and  뫍 {d b w}.
모then   붫1  1  and  붫1  1  are strongly  -equivalent iff for all admissible extensions  붫    of  붫1  1  and
 붫1  1  it holds that  붫1 뫋 붫  1 뫋    and  붫1 뫋 붫  1 뫋    are  - equivalent.
abbreviatory  we write whenever two olps are strongly  -equivalent.
1	properties and relationships
next  we want to characterize which conditions two olps must fulfill s.t. they are strongly order equivalent.
모the next theorem states that strong order equivalence implies strong equivalence of the underlying logic programs.
 and  뫍  붫1  뫖s  붫1  붫1 뫖s 붫1.
intuitively  if the logic programs are not strongly equivalent  one extension of them admits an answer set a  which is no answer set of the extension of the other program. if the corresponding ordered extensions have the same answer sets  this means that a is inhibited by the preferences. but then one can always construct a further extension  which regenerates a for one program  but not for the other. for example  programs
 붫1   	= {r1 : a 뫹}
  붫1  1  = {r1 : a 뫹 not b  r1 : b 뫹 not a  r1  1 r1} have both the preferred answer set {a}  whereas 붫1 has additionally the answer set {b}. taking  붫    = {r1 : b 뫹 y  r1 : y 뫹} yields {a b y} as preferred answer set of  붫1뫋붫     but {b y} as preferred answer set of  붫1뫋붫  1 . note that one can create such a  compensating  program for any answer set which is inhibited by the preference relation. for this  we use new symbols and new rules  which are not involved in the preference relation  to  repair  this answer set. therefore strong equivalence is a necessary condition for strong order equivalence.
next  we turn our attention to the set of generation rules.
for this  consider the following olps:
 붫1    = {r1 : a 뫹  r1 : b 뫹}
            붫1    = {r1 : a 뫹  r1 : b 뫹 a} we observe that 붫1 뫖s 붫1  but taking
    붫      = {r1 : b 뫹 a  r1 : y 뫹 not b  r1    r1} yields {a b} 뫍 as  붫1 뫋붫       but as  붫1 뫋붫        =   for  뫍 {d w b}. they are not strongly order equivalent because they do not coincide on their set of generating rules.  붫1    contains r1 and  붫1    rule r1 to derive the atom b. adding r1 and the preference that r1 is higher preferred to r1 entails that  붫1뫋붫      has no preferred answer set since r1 is blocked by the lower preferred rule r1  while  붫1 뫋 붫      has a preferred answer set since r1 allows to block r1 in an alternative way. this allows us to suppose that strong order equivalence enforces that the olps must coincide on all rules which can become applicable. for this  we say that a rule r 뫍 붫 contributes to an answer set x  if there exists an 붫  such that x 뫍 as 붫뫋붫   and r 뫍 r붫뫋붫  x . rules which are not contributing to answer sets  are never applicable  e.g. body+ r 뫌body  r  1=  . for b-preferences  we obtain that two strongly order equivalent programs must coincide on their rules contributing to answer sets.
theorem 1 let  붫1  1  and  붫1  1  be olps. if  붫1  1  뫖bs  붫1  1   then for all 붫 and for all x 뫍 as 붫1 뫋 붫  = as 붫1 뫋 붫  we have r붫1뫋붫 x  =
r붫1뫋붫 x .
interestingly  for d- and w-preferences  these conditions have to be weakened.
theorem 1 let  붫1  1  and  붫1  1  be olps and  뫍
{d w}. if	  	뫖	  	  then for all	and for all
                               1	r붫1뫋붫 x  {r 뫍 붫1뫋붫 | head r  뫍 body+ r } = r붫1뫋붫 x  {r 뫍 붫1뫋붫 | head r  뫍 body+ r }.
since d- and w- preferences couple rule application with preference handling  answer sets can be inhibited by preferences because applied rules are not enumerable in an order preserving way  see condition 1 in definition 1 and 1 . but one can always find an extension such that those answer sets are regenerated. for applied  loop  rules  i.e. head r  뫍 body+ r   another rule must always exist which derives the head in an order preserving way. hence  such loop rules are redundant wrt. d- and w- preferences as long as they are not involved in the preference relations. in contrast  b- preferences decouple preference handling from rule application and hence  one can always find an extension  where those loop rules regenerate a non-preferred answer set to a preferred one in one program but not in the other one. for example 
  붫1    = {r1 : a 뫹}  붫1    = {r1 : a 뫹  r1 : a 뫹 a} are not strongly  b- equivalent. taking
 붫    = {r1 : a 뫹  r1 : y 뫹 not a  r1   r1}
yields asb  붫1 뫋 붫     =   but asb  붫1 뫋 붫     = {a}. here  rule r1 can be used to block r1. for d- and wpreferences  however  r1 has to be ordered after r1  hence it can not be used to block r1.
모in the following we will concentrate on the preference relations. for this consider the program
붫 = {r1 : a 뫹  r1 : b 뫹 a}
and the preference relation r1   r1. we obtain that  붫    뫖  붫    holds for all  뫍 {d w b} and  붫    and  붫    coincide on their set of rules. for  붫     rule r1 must be considered before rule r1 in d- and w-preference  since the derivation of the positive body of r1 depends from r1. thus  adding the preference relation r1   r1 to  붫    has no effect on  d- and w- preferred answer sets. surprisingly  this does not hold when considering strong order equivalence. taking

yields as  붫 뫋 붫1  1   = {{a b x z}} while as  붫 뫋 붫1   뫋  1   =  . for  붫   뫋 붫1  1  we get the transitive preference r1   r1  implying that r1 is blocked by a lower preferred rule  which we don't obtain for  붫    뫋  붫1  1  . since one can always construct such a program  observe that the relevant rules contain new symbols   it follows that two olps can never be strongly equivalent if the preference relations do not coincide.
and  뫍
	 붫1  1  뫖s  붫1  1 	 1= 1.
as a special case we obtain that  holds for any program 붫  any non-empty preference relation on 붫  and any  뫍 {d w b}. moreover  for every olp  붫     1=
   there exists no strongly order equivalent program  붫1   .
corollary 1 let  붫    be an olp such that  1=   and  뫍 {d w b}. then  there exists no logic program 붫1 such that  붫    뫖횹  붫1   .
interestingly  this tells us that no transformation from an olp with a non-empty preference relation to a logic program exists such that the transformed program is strongly order equivalent to the original one. the results given above are sufficient for characterizing strong order equivalence.
theorem 1 let  붫1  1  and  붫1  1  be olps. if 붫1 뫖s
붫     =    and for all 붫 and for all x 뫍 as 붫	뫋
붫 	r붫1뫋붫 x  = r붫1뫋붫 x  then
 붫1  1  뫖bs  붫1  1 .
theorem 1 let  붫1  1  and  붫1  1  be olps and  뫍 {d w}. if 붫1 뫖s 붫1   1= 1  and for all 붫 and for all x 뫍 as 붫1뫋붫  = as 붫1뫋붫  we have r붫1뫋붫 x  {r 뫍
붫1뫋붫 | head r  뫍 body+ r } = r붫1뫋붫 x  {r 뫍 붫1뫋붫 | head r  뫍 body+ r }  then  붫1  1  뫖횹  붫1  1 . for example 

are strongly order equivalent in all three semantics  whereas
  붫1    = {r1 : a 뫹}  붫1    = {r1 : a 뫹  r1 : a 뫹 a} are only strongly  d-  and  w-  equivalent  but not strongly  b- equivalent. with these results we can formalize the following characterization of strong order equivalence. corollary 1 let  붫1  1  and  붫1  1  be olps. then   for all
붫 and for all x 뫍 as 붫1 뫋 붫  = as 붫1 뫋 붫  we have r붫1뫋붫 x  = r붫1뫋붫 x .
corollary 1 let  붫1  1  and  붫1  1  be olps and  뫍 {d w}. then   붫1  1  뫖횹  붫1  1   iff 붫1 뫖s 붫1   1= 1  and for all 붫 and for all x 뫍 as 붫1 뫋 붫  = as 붫1 뫋붫  we have r붫1뫋붫 x  {r 뫍 붫1 뫋붫 | head r  뫍 body+ r } = r붫1뫋붫 x    {r 뫍 붫1 뫋 붫 | head r  뫍 body+ r }.
regarding preferred answer sets  the different strategies for preference handling yield an increasing number of preferred answer sets. interestingly  the above given theorems show that there is no difference in the behavior of d- and w- preferences when considering strong order equivalence. in contrast  fewer programs are strongly order equivalent in the b-semantics  since preference handling is decoupled from rule application.
theorem 1 let  붫1  1  and  붫1  1  be olps. then
 a  if  붫1  1  뫖bs  붫1  1  then  
 b   붫1  1  뫖ws  붫1  1  iff  붫1  1  뫖ds  붫1  1 .
considering answer sets  each  d-preferred answer set is
 w-preferred and each  w-preferred is  b-preferred. interestingly  regarding strong order equivalence we obtain that
  so the differences between the d- and w- semantics can be compensated by extending the program in a suitable way. moreover  since implies and implies 뫖ds   the b-semantics imposes a strictly stronger criterion for programs to be strongly order equivalent. the reason for this is that b-preference decouples preference handling from rule application  and in addition  these differences cannot be compensated by adding suitable extensions.
1	program simplifications
corollaries 1 and 1 show that two olps which are strongly order equivalent  differ in rules which are not involved in the preference relation and which are never applicable. additionally  for d- and w- semantics  strongly order equivalent logic programs may differ in loop rules  in which the head is contained in the positive body. these results allow us to formalize the following results concerning transformations on olps. in the following  we say that a rule r is involved in a preference relation   if there exists an r1 such that r   r1 or r1   r holds.
corollary 1 let  붫    be an olp such that for r 뫍 붫  which is not involved in    for all 붫1 and x 뫍 as 붫 뫋 붫1  we have r 1뫍 r붫뫋붫1 x . then   붫    뫖횹  붫 {r}    holds for  뫍 {d w b}.
this corollary expresses that a rule  which is never applicable and not involved in    is redundant regarding strong order equivalence. the next corollary concentrates on loop rules.
corollary 1 let  붫    be an olp and  뫍 {d w}. furthermore  let r 뫍 붫 s.t. head r  뫍 body+ r  and r is not involved in  . then   붫    뫖횹  붫   {r}   .
모in  eiter et al.  1; osorio et al.  1  transformations on logic programs are reported  which can be used for simplifying a program. for those modular transformations a program must be strongly equivalent to the transformed one. considering olps  we observe that these transformations in general do not guarantee strong order equivalence. transformation taut expresses that for all logic programs 붫 and all r 뫍 붫 where head r  뫍 body+ r  we have 붫 뫖s 붫   {r}.
corollary 1 implies that the analogon for olps only holds for the d- and w- semantics as long as r is not involved in  . transformation red  expresses that for a logic program 붫 and for rules r1 r1  where head r1  뫍 body  r1  and body r1  =    we have 붫 뫖s 붫   {r1}. since r1 is always a generating rule  regardless which rules we add to 붫  r1 never contributes to an answer set. hence  red  is feasible for olps unless r1 is involved in  . for r 뫍 붫  where body+ r 뫌body  r  1=   we have that 붫 뫖s 붫 {r}  transformation contra . since such a rule is never applicable  this result can be carried over to olps whenever this rule is not involved in  . transformation nonmin states that for r1 r1 뫍 붫  where head r1  = head r1  and body r1    body r1   we have that 붫 뫖s 붫   {r1} holds. since there is no information whether r1 can become applicable or not  this transformation can only be made on olps whenever r1 is not involved in   and never becomes applicable. for example  consider the program:
 붫1    = {r1 : a 뫹  r1 : b 뫹  r1 : c 뫹 a  r1 : c 뫹 a b}
here we have that head r1  = head r1  and body r1    body r1   hence  붫1 뫖s 붫1 {r1}. since r1 is applicable  the simplified program is not strongly order equivalent. taking
    붫      = {r1 : c 뫹 a  r1 : y 뫹 not c  r1    r1} yields {a b c} 뫍 as  붫1 뫋 붫       but as   붫1  
{r1} 뫋붫       =    for  뫍 {d w b}. thus   붫1    뫖1 횹  붫1   {r1}   . similar considerations apply for the transformation s-imp  where for all r r1 뫍 붫 such that there exists an a   body  r1  such that head r  뫍 head r1  뫋
a body  r    body  r1    a and body+ r    body+ r1  we have 붫 뫖s 붫 {r1}. this transformation can only be carried over to olps whenever r1 is not involved in   and never becomes applicable. for example  taking
           붫 = {r1 : a 뫹 b not c  r : a 뫹} and a = {c} yields 붫 뫖s {r}  where r1 is applicable wrt {a b} 뫍 as 붫 뫋 {b 뫹} . but  붫    뫖1s  {r}     since for
states
for a rule r1 뫍 붫  where a 뫍 body+ r1   ga = {r1 뫍 붫 | head r1  = a} and ga 1=   that 붫 뫖s 붫 뫋 g1a holds where g1a = {head r1  뫹  body+ r1    {a}  뫋 not body  r1  뫋 body r1  | r1 뫍 ga}. as with the other transformations obtained for strong equivalence  this one is transferable to strong order equivalence if the rules from ga become never applicable and are not involved in the preference relation. e.g.  for
붫 = {r1 : b 뫹 a  r1 : a 뫹}
we have that 붫 뫖s 붫 뫋 {b 뫹} holds. by taking
    붫      = {r1 : b 뫹 a  ry : y 뫹 not b  ry    r1} we obtain  has no  - preferred answer set while  붫뫋{b 뫹}뫋붫      has  - preferred answer set {a b}  for  뫍 {d w b}.
1	conclusions and future work
we have presented the notion of strong order equivalence for asp with preferences. we have provided an extensive analysis of this novel notion  and studied the relationship between different preference semantics for it. we have also analyzed the conditions for certain simplification methods to guarantee strong order equivalence  hence applicability to modules .
모we could show in corollaries 1 and 1 that two programs are strongly w- and d-equivalent  if  and only if  the preference relation is equal  their standard asp programs are strongly equivalent  and their  non-looping  generating rules are identical for all answer sets of any extension of them. for b-preference  also the  looping  generating rules must be identical in any answer set.
모 from theorem 1 we obtain that exactly the same pairs of programs are strongly  d- and  w- equivalent  while not all of them are strongly  b- equivalent. that is  the semantical differences between d- and w- preference have no longer any effect when considering strong order equivalence. on the contrary  for b- semantics the differences to d- and wpreferences are strengthened under strong order equivalence  since it decouples preference handling from rule application  which can not be compensated by suitable extensions.
모we have furthermore studied possibilities to simplify ordered programs. in corollaries 1 and 1 we have given abstract conditions for simplifications  and have assessed under which circumstances simplification rules from standard asp can be applied on asp modules with preferences.
모the reader may have noted that we did not define a notion which would correspond to se-models in standard asp strong equivalence. indeed there seem to be considerable difficulties: se-models can only express statements on atoms  and not directly on rules. however  as demonstrated e.g. in theorem 1  strong order equivalence depends heavily on the rules involved in the program. we therefore conjecture that  se-models  for d-  w-  and b- preferred answer sets must include a means for stating relationships among rules  and leave this topic for future work.
모another way of analyzing strong order equivalence could be offered by a compilation of the programs  as done e.g. in the plp-system  delgrande et al.  1; plp  1 . there  ordered programs are compiled into logic programs such that their answer sets directly correspond to the preferred answer sets of the original ordered program. since the compilation is a logic program  one could suppose that two ordered programs are strongly order equivalent if the compilation of them possess the same se-models. however  the compilation introduces additional symbols. hence  the answer sets of two compiled programs  which represent the same preferred answer set  are in general incomparable because of these additional symbols. one would therefore have to consider strong equivalence under a projection of the answer sets. furthermore  for an exact notion one would also have to take into account that compiled programs have a particular  rather than arbitrary  structure. such a notion of strong equivalence has  to the best of our knowledge  not been studied so far. therefore  we leave this kind of analysis for future work.
모corollary 1 shows that no transformation from an ordered program  붫    into a logic program 붫1 exists such that  붫    is strongly order equivalent to 붫1. also  corollaries 1 and 1 describe rigorous conditions on ordered programs being strongly order equivalent under the considered preference semantics. hence  further work could be to define and study weaker notions of order equivalence.
references
 brewka and eiter  1  g. brewka and t. eiter. preferred answer sets for extended logic programs. artificial intelligence  1 :1  1.
 delgrande et al.  1  j. delgrande  t. schaub  and h. tompits. a framework for compiling p