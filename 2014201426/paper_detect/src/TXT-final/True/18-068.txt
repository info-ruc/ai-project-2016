 
   most parallel planners are sensitive to the order in which goals and activity preconditions are specified. a  wrong  ordering can easily cause a solution to be missed. permuting goals and preconditions on failure in hopes of finding a soluble order is in general computationally unacceptable. plan splicing is a solution to this problem. splicing is a violent conflict resolution procedure which involves the cutting of assertion dependencies  recursive demotion or excision of selected activities around the cut  and reinsertion of deachieved goals back into the middle of the planner's goal stack so that they can be replanned later to mend the plan around the splice. in a temporal planner  after an excision it is further necessary to relieve the  temporal stress  induced on surviving activities by the activities which were excised. this is an important capability for two reasons: first  because the order of achievement can of course not always be known in advance  and secondly because it is desirable to be able to present goals in priority order. 
i introduction 
   ai planners are beginning to reach the maturity required for real world applications. deviser i  vere  1  has been successfully applied to generating command sequences for the voyager spacecraft. deviser i is on the evolutionary path of noah  sacerdoti  1  and nonlin  tate  1 . noah was the first planner to deal with parallel activities. nonlin is an improved parallel planner which is able to recover from bad decisions and which implements a more sophisticated treatment of goal protection. a recent version with a consumable resource management capability  tate and whiter  1  has been demonstrated on a naval replenishment problem. deviser i extended the mechanisms of the 1 nonlin to permit planning in time  with arbitrary time constraints on activities  preconditions  and goals. it also 
   *this paper presents the results of one phase of research carried out at the jet propulsion laboratory  california institute of technology  and sponsored by the national aeronautics and space administration under contract no. nas-1. 
handles events  scheduled events  and inferences in a uniform manner. temporal planning has also attracted the attention of a number of other researchers within the last few years  allen and koomen  1; cheeseman  1; dean  1; 
mcdermott  1 . however  time is largely orthogonal to the issue of goal order and splicing  which is the focus of this paper. sipe  wilkins  1  is another contemporary planner derived from noah which has special resource handling features. it has been applied to planning activities on an aircraft carrier. 
   a common difficulty experienced with most planners is the phenomenon i will call goal protection deadlock  in which the achievement and subsequent protection of an earlier goal can block the achievement of a later goal  dreussi  1  pg. 1 . for example  suppose a robot is in front of a closed door leading into a room. it's goals are to be inside the room with the door closed. goal protection deadlock is experienced if it first tries to achieve  door closed   with a null action   and then attempts to achieve  in robot room . to enter  it must plan to open the door  but this would violate the first goal   door closed   which is achieved by the start state and is now protected. the problem is that the goals have been attempted in the  wrong  order. previous parallel planners have avoided this problem by requiring goals to be presented to the planner in an order in which they can be achieved. this problem applies both to the original conjunctive goal set as well as to the ordering of the preconditions of an activity  which become subgoals during plan synthesis. in complex domains it may be impossible to know the correct order in which to attempt goals  and it is oomputationally unacceptable to try every possible permutation of goals and preconditions. 
   there are reasons other than ignorance for wanting a planner to be insensitive to goal ordering. a greedy person may try to give a planner many more goals than are logically achievable  due to time or resource limitations. if goal deadlook can be avoided  it then becomes attractive to order the goals by decreasing priority. the most important goals can be planned first and allowed first claim to the finite resources. if possible  activities to achieve goals lower on the list are fitted into the plan later. otherwise the lower priority goal is discarded. in this way the planner is able to generate a partial solution for insoluble goal sets 
   
instead of just just giving up. 
   it is for these two reasons  to avoid goal deadlock and to allow goal prioritization and discard  that i have investigated and implemented splicing in a new version of my planner designated deviser i i i . 
   for tutorial purposes  the plan splicing process will be illustrated in this paper on blocksworld and abstract examples. however  splicing has been applied in practice on large plans constructed with a very detailed knowledge base for the voyager spacecraft consisting of 1 lines and describing about 1 different actions  inferences  and events. 
ii plan splicing 
   plan splicing may be regarded as a new variety of conflict resolution in a parallel planner. figure 1 illustrates a prototypical conflict situation. during parallel plan synthesis  a conflict is said to occur when two parallel nodes  such as node a and node b  assert contradictory literals  represented by p and  p.  you are cautioned not to confuse this usage of  conflict  with the completely unrelated notion of  conflict sets  in forward chaining production rule systems such as 1ps1 . the dashed lines show that node c depends on the assertion p from node a  and node d depends on the assertion  p of node b. these will be called assertion dependencies. they indicate that the truth of the assertion must be protected in the region of the plan between the two nodes. tate calls these dependency relationships the goal structure. of course there may be many nodes like node c depending on p in node a and many nodes like node d. 

s. vere 1 
violated  neither of these two conflict resolutions can overcome the problem of goal protection deadlock. 

	figure 1a. 	one non-violent conflict resolution 

   
figure 1. 	a conflict situation in a plan 
   
figure 1b. 	the other non-violent conflict resolution 
   
   there are two possible conflict resolutions  as performed in nonlin  and deviser i : either d must be ordered before a  or c must be ordered before b  so that the assertion dependencies are respected and preserved. this is illustrated in figures 1a and 1b. because assertion dependencies are never plan splicing is a violent form of conflict resolution which is only tried as a last resort  after nonviolent conflict resolution has failed. there are two possible splicings for every 1 s. vere 
conflict  just as there are two possible ordering resolutions. figures 1a and 1b illustrate these two alternatives. because of symmetry! only figure 1a will be discussed. there the assertion dependency between a and c has been cut  and b has been ordered between a and c. simultaneously  c has been  demoted.  node demotion is a generic term for an involved process whose details depend on whether c is a phantom or an activity.  a phantom node is a null action which signifies that a precondition has  already'' been achieved above in the plan; an activity node is everything else-an action  an inference  or a  forward chaining  event . thus splioing literally cuts the gordian knot in a goal deadlook situation. the  reoursive  demotion prooess is responsible for ensuring that the plan will mend properly around the splice. at one extreme  demotion may involve simply changing a phantom node back to a goal. at the other extreme  demotion may trigger the erasure of large sections of the plan around and below the splice  with many goals being inserted at a variety of positions within the goal staok for later replanning. most of this paper is in fact concerned with the details of the demotion process. 
   

figure 1b. 	the other possible splice 
   
   loosely speaking  one or more goals below the splice were achieved too early. demotion sends these back into the goal stack in exactly the position which allows interfering later goals a chance. a solution is then obtained as though the goals had originally been attempted in the right order. in effect  interfering goals are dynamically reordered during plan synthesis  and this is accomplished without erasing any more of the existing plan than is logically necessary. 

   the advantage of splioing is that it renders the planner insensitive to goal and subgoal ordering. however  a certain penalty is incurred. the size of the planner's search tree is enlarged  since there are now four possible resolutions to every conflict situation rather than two. in deviser this is mitigated by discarding the two splicing alternatives if one of the two nonviolent resolutions is successful. otherwise  in 
   
figure 1a. 	one conflict resolution by splicing 
   
backtracking the two splicing alternatives can lead into irrelevant sections of the search tree and 
waste time. 
   as already mentioned  the details of demotion depend on whether the demoted node is a phantom or an aotivity. these two oases will now be 
investigated in turn. 
i l l demoting a phantom node 
   demotion of a phantom node is potentially the simplest case. if the assertion of the phantom is p  we simply oonvert the node baok to a goal  and enter p at the  appropriate place  in the planner's goal staok. the appropriate place is generally not the top of the goal stack  but somewhere in the middle. details of the procedure for entering a goal baok in the goal staok will be presented later  in section v. 
   this simple picture is complicated if a substitution was applied at the time the phantom node was created. for example  suppose the goal assertion was  on .x c . in creating the phantom node  suppose that the substitution {b/.x} was applied to oause the goal assertion to match  on b c  asserted by an earlier action. this means that to demote the phantom we must restore the goal assertion to its original unlnstantlated form   on .x c . 
   
s. vere 1 
a 	further  	more 	serious 	complication 	is 
   
encountered if the substitution was in fact also applied to other literals in the plan. if we cannot somehow restore these literals to their uninstantiated state  existing parts of the plan may remain unnecessarily constrained  preventing us from finding a solution plan when in fact one exists. however  in deviser it is effectively impossible to deinstantiate an arbitrary literal. suppose the instantiated literal is  p a a  and the substitution was {a/.x}. restoring the literal to  p  x .x  can be incorrect if the original literal was actually  p a  x . the alternative of  rememberingn precisely which terms were replaced for each substitution application was judged to be unacceptable. the approach i have adopted is to demote all plan nodes having a literal instantiated by the substitution. this only requires 
 remembering   for each phantom  the list of nodes affected by the substitution  if any  applied when that phantom is created. thus the demotion of one phantom may in turn call for the demotion of several additional  affected nodes   i.e.  those affected by that phantom's substitution. if an affected node is also a phantom it is in turn treated in the manner just described. if the affected node is an activity  it is demoted as described in the next section. 
iv demoting an activity node 
   as seen above  splicing may require the demotion of an activity node n back to a goal  either because n is node c in figure 1a  or because n was affected by the substitution of a demoted phantom. this in turn calls for the excision  erasure  of selected nodes above n in the plan. the nodes which must be excised are those which exist in the plan exclusively to satisfy preconditions of n. these will be called the activity pyramid above 
n. 
   consider the blocksworld plan in figure 1. assertion dependencies are not shown to avoid cluttering the diagram. this plan was generated to achieve the goals  ontable c   on b c   given the initial state  clear c   on c a   ontable a   clear b   ontable b . n1 aohieves the first goal; n1 achieves the second. suppose that in the course of planning to achieve other additional goals  not shown   we wish to do a splice and demote n1. should we excise all the nodes above n1 in the plan  no. nodes n1  n1  and n1 exist to enable the putdown action of n1   and should be retained. we should excise only nodes n1  n1  n1  and n1. 
these were backchained into the plan to enable the stack action of n1. nodes n1  n1  n1  and n1 constitute the activity pyramid above node n1  because they form an inverted pyramid of nodes backchained above n1  with n1 at the apex. similarly  n1  n1  and n1 form the activity pyramid above n1. consequently  to demote n1 we must first excise n1  n1  n1  and n1  and then convert n1 back to a goal and insert it into the goal stack. 
   one 	key aspect of activity demotion is then the excision of all nodes in the activity pyramid above figure 1. 	a blocksworld plan illustrating activity pyramids 
the demoted node. excision of a set of nodes involves erasure of the nodes from the plan by modification of the successor and predecessor lists of nodes which will remain  removal of the assertions of the excised nodes from the assertion database  and similar bookkeeping activities. note that this erasure must be reversible  so that if the planner must backtrack  these excised nodes are  unerased  and restored to the plan. in addition  all phantom nodes outside the pyramid which depend on an assertion of an excised node must be demoted  because that assertion is going to disappear. 
   having excised the activity pyramid above an activity node  that node is converted back to a goal. side effect assertions of the activity are deleted  and any nodes below it which depend on one of these side effect assertions must be demoted too. the original goal assertion must be restored as the single assertion of the goal node  and the node must be inserted back into the goal stack as in the case of phantom demotion. also  as in phantom demotion  other nodes affected by substitutions applied to the activity node or its pyramid must be demoted too. 
   one minor problem with splicing is that the planner may occasionally go into a search loop consisting of demotion  replanning  demotion  replanning  etc. in my implementation this was cured by keeping a record of demoted nodes and and the activity which caused the demotion. if the demotion subroutine is about to try to demote a node a second time for the same reason  this information causes the demotion to fail  breaking the loop and forcing the planner to backtrack. 
1 s. vere 
   finally  in a temporal planner it is necessary to relieve the temporal stress induced on remaining nodes by those which have been excised. the situation is like a crowded elevator: when some people get off  those that remain can space themselves out more comfortably. in the same way  in a temporally crowded plan the start time windows of many nodes are compressed by the durations of adjacent activities. when some nodes are excised  the remaining nodes may be able to expand their start time windows. one possible approach would be to simply open the windows of all remaining nodes to the maximum interval  and then recompute all the start times based on the ordering and consecutivity constraints. however  this is unacceptable because excisions will be done frequently  and in practice only a small percentage of the nodes in a plan will be under stress from a set of excised nodes. a much more efficient technique is to follow stress chains from nodes on the boundary of the excised pyramid. two sequential nodes  na and nb  in a plan are temporally stressed if: 
1. they are constrained to be consecutive  cf.  vere  1    or 
1. the earliest finish time of na equals the earliest start time of nb  or 
   

figure 1. 	a temporal stress chain 
   
1. the latest finish time of na equals the latest start time of na. 
   for cases 1 and 1 above it seems natural to say that their windows touch. figure 1 illustrates a stress chain for an abstract plan. suppose that node 1 is an activity node to be demoted. an activity pyramid with 1 at its apex is indicated by the dashed lines. thus nodes 1  1  1  1  and 1 are going to be excised. nodes 1  1  1  1  and 1 are on the boundary of the pyramid  i.e.  they are adjacent to nodes not in the pyramid. the bold lines connect temporally stressed nodes leading away from the pyramid and beginning at boundary nodes. note that a zig-zag pattern is possible  since nodes 1  1  1  1  and 1 may be a chain of nodes with touching windows. the chain can continue in another direction since nodes 1 and 1  and 1 and 1 are assumed to be consecutive. the  c  label on the arcs indicates a consecutivity constraint. the subgraph connected by the bold lines is the stress chain in this diagram. it is only necessary to recompute start time windows for nodes in this stress chain. the windows of all other nodes outside the pyramid  such as 1  are not affected by the excision of the pyramid nodes. of course it is possible for a stress chain to exist below the pyramid as well as above i t   as in this example. 
v inserting a deachieved goal into the goal stack 
   we have seen that demotion of both phantoms and activities leads to the creation  or  more accurately  the recreation  of one or more goals  which must then be inserted into the goal stack of the planner. how should such a goal be positioned relative to the existing goals in the stack  the answer is found in an analysis of why a node is demoted: it is demoted to  give another goal a chance.'' stated differently  the planner decides that  in effect  the order of two goals must be reversed. referring back to figure 1a  node c was demoted because of node b. from the diagram we can infer that the goal of c was attempted first and then later the goal of b. if we are compelled to attempt a splice  it means that the goal of b should be  completely achieved  first before going back to work on the goal of c. by completely aohieved i mean that all backward chaining above b must be completed before going back to work on c. this can be ensured if the goal of c is inserted into the goal stack just below the lowest goal node in the activity pyramid above b. 
   figure 1 illustrates with an example. it shows figure 1a redrawn with an activity pyramid above b  as well as the associated goal stack. gc is the goal node created by demoting c. g1 and g1 are goal nodes in the pyramid above b.  here the pyramid serves for analysis  and is not excised . g1 happens to be the lowest in the stack. if we insert gc just below g1 in the stack  then the planner will have completed the section of the plan above node b before it starts to work on gc. 
   
s. verc 1 
    dreussi  j. f. the detection and correction of errors in problem-solving systems. ph.d. dissertation  univ. of texas at austin  1. 
    mcdermott  d. a.  a temporal logic for reasoning about processes and plans.'' cognitive science  vol. 1  1  1. 
    sacerdoti  e. d. a structure for plans and behavior. elsevier north-hoiland  1. 
    tate  a.  generating project networks  in proc. ijcai-1f 1. 
    tate  a. and a. m. whiter   planning with multiple resource constraints and an application to a naval planning problem  in proc. 1st. conf. ♀n. ai applications  1  1. 
    vere  s. a.  planning in time: windows and durations for activities and goals.  ieee trans. pattern analysis and. machine intelligence  vol. pami-1  no. 1  may 1  1. 
    wilkins  	d. 	e. 	 domain-independent 
　　　　　　　　　　　　　　　　　　　　　　　　　　　planning: representation and plan generation.  figure 1. goal insertion during demotion artificial intelligence  april 1  1. 
vi summary 
   planning is inherently sensitive to the order in which goals are accomplished  with failure the possible result of attempting goals in the wrong order. splicing is a way  in effect  to reorder goals  on the fly  as planning proceeds. it is attempted only when normal conflict resolution fails. a portion of the plan which accomplishes an earlier goal is erased  and the earlier goal is put back into the planner's goal stack in a position 
which allows the later goal 	to 	be accomplished without interference. 	through the stack mechanism  the 	planner's 	attention 	later 	returns 	to 
achievement of the demoted goal. the result is that actions to achieve the later goal are spliced into the middle of the plan  and some activities around the splice are replanned. this permits a solution to be found in goal protection deadlock situations where the planner would otherwise fail. 
