deadlock-free parallel processing 
a . o . h i l l   m.r.c. brain metabolism u n i t   u n i v e r s i t y of edinburgh  edinburgh. 
h.r.a.townsend  machine i n t e l l i g e n c e research u n i t   u n i v e r s i t y of edinburgh  edinburgh  scotland. 
i n t r o d u c t i o n 	systems of cooperating p a r a l l e l processes 
     
     recent developments in programming languages f o r a . i . such as manner   1     popler  1  and conniver  1  have mainly been concerned w i t h p a t t e r n matching techniques applied to a r e l a t i o n a l database. consequently l i t t l e a t t e n t i o n has been paid to the problems of multiprocessing required to operate in a r e a l - t i m e environment. 
     consider the problem of manipulating a p i l e of blocks. if some accident or deus ex machina happens to move a block a f t e r a   p i c t u r e   is taken then t h i s w i l l only he noticed if and when the next   p i c t u r e   is taken. what we would r e a l l y l i k e is to be able to monitor the external environment and to roport back if any s i g n i f i c a n t a l t e r a t i o n o c o u n . 
     we are interested in the analysis of the electroencephalogram  eeg  where there is an extremely high rate of c o n t i n u a l l y changing data. this r a t e is so high that even w i t h the current generation of computers the processing speed is the major l i m i t a t i o n and the sheer volume of data requires that it should be processed reasonably e x p e d i t i o u s l y . 
     fortunately the problem is much less d i f f i c u l t than would at f i r s t appear. only a few patterns are of l n t e r o s t   or at l e a s t are known to be u s e f u l . many of these pattorns are t r a n s i e n t   and in some eegs they may be absent  a f a c t which is o f t e n r e l o v a n t   . tho presence of some of the   i n t e r e s t i n g patterns'* can be detected in r e a l - t i m e but the d e t a i l e d d e s c r i p t i o n of the s t r u c t u r e of a short segment of eeg u t i l l s e s a much larger amount of processing time. 
     this problem is very s i m i l a r to the r e a l - t i m o blocks problem. we cannot stop monitoring the external world since we might miss some relevant event but we can pass information over to a c o l l e c t i o n of p a r a l l e l processes which  r e l i e v e d 
     of the necessity to monitor the data can then b u i l d up a database and perhaps plan somo a c t i v e i n t e r v e n t i o n . 
     in t h i s paper we s h a l l examine the problems of w r i t i n g programs f o r cooperating p a r a l l e l processes   especially tho problems of the deadly embrace  1  where a set of processes cannot proceed because of mutual i n t e r f e r e n c e . we s h a l l not at t h i s stage consider the problems of maintaining a r e l a t i o n a l database which can be a l t e r e d by several processes. 
     we have been developing methods f o r constructing systems of p a r a l l e l processes which w i l l not have deadlock problems. one major requirement is that it should not matter whether the processes are s i t u a t e d in the one area of common core under tho c o n t r o l of the same processor or whether they are d i s t r i b u t e d over several processors w i t h communicating data l i n k s . each process is considered to be completely autonomous and is w r i t t e n a* a self-contained module which has a number of   p o r t s   through which it can communicate w i t h the outside world and other processes. a system ts constructed by connecting p a i r s of ports and communication is achieved by the sending and receiving of messages along the routes. 
     in the simplest version each route can only store one message and a message can only be sent i f the route i s f r e e . i f i t i s occupied then the process sending the message is held up u n t i l the route becomes f r e e . s i m i l a r l y a message can only be received if there is a message on the route and any process t r y i n g to receive a message from an empty route is held up u n t i l a message ia a v a i l a b l e . in more complicated vorsions it would be possible f o r a route to store more than one message but so f a r no great need f o r t h i s has a r i s e n . 
     the equivalent of d i j k s t r a ' s p and v operations  1  appears in the f a c t that sending and receiving a message must be i n d i v i s i b l e operations but the advantage is that since these operations are common to a l l processes thay can be handled by the system thus r e l i e v i n g the programmer from any need to become involved in the conceptually d i f f i c u l t d e t a i l s . 
analysis of the complete system 
     it would be u s e f u l if a system of processes could be checked and any possible deadly embraces discovered. under the formalism presented here t h i s becomes a r e l a t i v e l y simple procedure. 
     each process can be modelled as a  possibly non-deterministic  f i n i t e - s t a t e machine with the states as the stages between message passing and the t r a n s i t i o n s occurring when messages are sent or received. since each process only communicates w i t h the outside world by means of these messages the d e t a i l s of the code of the process become i r r e l e v a n t . 
	this 	f i n i t e - s t a t e 	d e s c r i p t i o n 	can be coded 
1 
     
i n t o a simple f i n i t e - s t a t e language to provida 	a more succinct representation of the process. 
e . g . bending a message:- put 1 -   l ; describes the a c t i o n of sending a message on route 1 and going from state 1 to s t a t e 1. 
s i m i l a r l y s- get l 1- 1; describee the a o t i o n of r e c e i v i n g a message on route 1 and going from s t a t e 1 to s t s t r 1. 
     therefore a simple system of two processes in which the f i r s t sends a message to the second and gets a r e p l y can be w r i t t e n as 
process one 
put 1 -   l 
get 1 l -   1 ; 
process two get 1 -   l 
put 1 l -   1 ; 
     as w l t h other methods f o r investlgating deadly embraces  1  the graphs of the processes can be joined to form one composite graph. the v e r t i c e s of t h i s graph are the states of the processes and also of the routes. if we r e s t r i c t the t r a n s i t i o n s so that only one process may change s t a t e at a time then the edges that leave a vertex represent a l l the c u r r e n t l y allowable t r a n s i t i o n s . 
for the system described above: 
process 	route 
one two 	1 	1 
in t h i s example there is no branching. 
     it is a simple matter to examine the coding f o r each i n d i v i d u a l process and to discover i t s t r a n s i t i o n s . the compound states can then be automatically generated. there is no t h e o r e t i c a l reason why several processes should not change etate at the same time but in p r a o t i c e t h i s increases the complexity of the graph and has not as yet been implemented. 
d e f i n i t i o n of a  deadly embrace  
     by convention each process s t a r t s in state 1 and may have i n i t i a l i s a t i o n stages followed by a recurrent sequence of s t a t e s . if there were no i n i t i a l i s a t i o n stages then a d e f i n i t i o n s i m i l a r to that given by l l w e l l y n  1  would be appropriate. a deadly embrace e x i s t s if and only if from any s t a t e  simple or composite  another s t a t e oan be reached from which it is impossible to r e t u r n to the o r i g i n a l s t a t e . with the a d d i t i o n of i n i t i a l i s a t i o n stages however t h i s no longer remains true since the program never r e t u r n s to them under normal f u n c t i o n and the d e f i n i t i o n of a deadly embrace muat be t a i l o r e d 
     to take t h i s i n t o account. 
     another p o i n t which emerged in t e s t i n g multi-process systems is the else of the composite graph   1   . if the system is correct the t o t a l number of states of the composite process is usually q u i t e small  but when there are errors a inn- e f f e c t is that the graph becomes so big that it cannot be atored. we therefore require some method of analyaing the graph without necessarily generating and s t o r i n g it completely in order to discover whether we have a complex but c o r r e c t system or to locate any deadlock s t a t e s . 
     this can be done by f a c t o r i n g the graph i n t o i t a strong components  a strong component being a aet of v e r t i c e s which are mutually reachable  t i l l s factored graph la very much smaller than the unfactored graph and oan more e a s i l y be stored. 
     tarjan's algorithm  so supplies a technique f o r f i n d i n g the strong components and oan be modified ao that deadlock states oan be detected without necessarily generating the complete graph. it also has the m e r i t that computation increases l i n e a r l y w i t h the number of v e r t i c e s . the graph is explored in a depth f i r s t tree search c o l l e c t i n g information on the way. it is not intended to give a formal proof of the algorithm but merely to p o i n t out the main features of relevance to the d e t e c t i o n of deadly embraces  
     the algorithm s t a r t s w i t h a l l nodes unranked and a l l strong components zero. as the e x p l o r a t i o n proceeds the nodes are ranked in the order in which they are f i r s t met and values assigned to the strong components where possible. a l l nodes which have been ranked but as yet have no strong component assigned to them are held on a stack. the strong component of a node x la assigned as the minimum rank of any node y which can be reached from x where the strong component of y has not yet been assigned. there is no need to s t a r t o f f w i t h the complete graph  since the neoessary nodes oan be developed as the search proceeds. 
     this algorithm was implemented using the method described by knuth  1  and has indeed proved to be very e f f i c i e n t in f i n d i n g strong components. there are however greater b e n e f i t s to be had in the discovery of possible deadlock s t a t e s . 
     if there are no i n i t i a l i s a t i o n stages in any prooeaa then aa mentioned above there w i l l be the p o s s i b i l i t y of deadlock if there is more than one strong component in the graph. in order to allow f o r i n i t i a l i s a t i o n stages the strong components can be claased as e i t h e r terminal or non-terminal i . e . whether it is ever possible to get out of that group of states. thus whether there arc i n i t i a l i s a t i o n atages or not there e x i s t s the p o s s i b i l i t y of deadlock if there are two or more 
terminal strong components. 
1 
     we are now l e f t with the problem that although it 1is feasible to check for deadlock states in a multiprogramming  y tem  this has to be done as a separate analysis and not concurrent with systora operation. while this has proved very useful in some eeg applications  1  it has considerable disadvantages in complex programs where processes may be continually added and deleted and wo have found it necessary to restructure the problem in order to obviate continual reanalysis. 
　　one factor which often led to considerable d i f f i c u l t y was the existence of cycles where one process sent a message to a second process and this second process could either reply directly or send a reply via a third process. the system was restructured to avoid this problem. 
a practical implementation 
	the 	current 	version is implemented on a gec 
1 computer which is a mini-computer very well suited to multiprocessing. the basic structure is that communicating processes arc connected as a tree  there being separate trees for non-communicating systems. kach process may own any number of dependent processes but n process may have only one owner. 
     message passing is as described above except that the massages must always be paired i . e . if a message in sont to a process then at some stage a 
     roply must be received and certainly before another message is sent on the same route. 
     in ordor to accommodato messages of variable longth the actual signalling of a message takes only 1 b i t of 1torago while the buffer for the mossage is located in the dependent process and contains i t s size. 
     this storage is then unusual in that the variables located there only have v a l i d i t y at restricted stages of communication between the processes. in the resting state they are valid for the owning message u n t i l the put flag is set at which time their v a l i d i t y ceases. when the message is received by the dependent process the storage buffer becomes valid for that process and remains so u n t i l the roply is sent. the buffer then becomes available for the owning process after the reply is received. 
     the tree is dynamic in that a process may ask for another process to be attached to it if either that procoss is froo and in core or is held on disc. similarly when a process has f1ni shod wi th a dependent process i t may disconnect i t . if the dependent process is not finished then it becomes the root of a new tree and there is a now completely independent parallel system. if it has finished then it bocomos available for garbage collection when more processes require to bo loaded. 
　　a cyclic structure cannot be created beoause a process cannot become attached unless it is currently unattached  a process may only have one  owner  at a time. an informal proof that the tree structured system w i l l not suffer from 
deadlock states is as follows:* 
     if there are separate non-interacting tree systems then deadlock in one w i l l be independent of the states of the other trees. 
     each tree has a root with no  owner . if a message is sent by this root process to a 
     dependent process then a reply must be received even if this reply only signifies that an error has occurred. this implies that the root process can never be held up trying to send a message. deadlock states w i l l therefore appear as the absence of a reply  i . e . the deadlock must be produced by the dependent process and not by the root. 
     consider a dependent process. the rules are that if a message is received from an owning process then a reply must be sent  perhaps after the procoss in i t s turn has sent messages and received the replies. the reply may signify that an error has occurred giving information about the procoss that found the error and the type of error  a reply w i l l only f a l l to be sent if there is an irrecoverable software error in that process which is not by d e f i n i t i o n a  deadlock . the structure is so arranged that a message exchange is always originated by an owner and completed by the reply  the  principle of politoness  . since the system is tree-structured this argument can be continued by induction u n t i l th c  tips of the branches are reached. thus there w i l l only be deadlock if it is produoed by the terminal processes. 
     the terminal processes however simply receive a roeshage from their owner  carry out some computation or input/ouput and then reply. since the owning process is always expecting the reply the terminal process can never be hold up i . e . the system is deadlock free. 
     furthermore since these rules are structural they can be checked syntactically for each process as it is compiled i . e . a dynamic parallol processing system which does not have deadlock states can be constructed. 
limitations 
     parallel processing may be achieved in our system by 
a  an owner  after instructing a slave to carry out some procedure  continuing to compute in parallel for some time before expecting a reply. 
b  an owner issuing several messages to slaves  which w i l l carry out their computations in p a r a l l e l   and then collecting the replies seriatim. 
c  a mixture of these two mechanisms. 
	the 	order 	in 	which 	computations 	w i l l 	be 
1 
     
completed must be specified in advance aa no mechanism la provided tor accepting replies in unspecified order or for abandoning a computation which la going on for too long  e.g. if the answer has been found by a different parallel branch . we think however that auch mechanisms can be incorporated wlthout destroying the desireable tree structure. 
     a more fundamental limitation is that resource deadlocks can s t i l l occur due to competing independent process systems  perhaps because there is not enough core available for the next process that either system requires  or e.g. aa in the claaaic situation whore one owns the reader and wants the lineprinter while the other owns the llneprinter and wants the reader. 
     in the completely dynamic case a system of processes may not  know  what resources w i l l be required u n t i l a considerable tree structure has been created and there may be l i t t l e option but to terminate one of the competing systems  even in this event a properly designed error reply should be able to l i m i t the damage to part of the tree  and permit recovery . 
     where requirements can be predicted in advance a static analysis can be undertaken. any set of interconnected processes forming a system  perhaps dynamic  known to be deadlock-free may be replaoed - as far as the non-deterministic model of the whole set of systems is concerned by a single composite prooess. this process can claim a resource by placing a message on a route  which la equivalent to setting a semaphore  and relinquish it by picking up the message. this new model can be analysed by the methods discussed in the e a r l i e r section to discover if deadlock states are possible. 
conclusion 
     constructing p a r a l l e l processing systems out of modular processes which coranunicato by passing messages provides a simple and e f f i c i e n t structure to expand a r t i f i c i a l intelligence techniques to the real-time world. static systems can be checked for deadlock by means of tarjan's algori thm and by imposing structure on the message passing dynamic deadlock-free systems can be created. 
acknowledgements 
 we should l i k e to thank dr.n.burstall for pointing out tarjan's algorithm. 
