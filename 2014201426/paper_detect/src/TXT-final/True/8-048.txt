 
     this paper presents a computer program that simulates situations  called  mikrokosms   in which severl entities  called  organisms   wander around in an environment that includes one another plus other  apparently simpler  entities  called  objects  . the program has a rather simple set of  laws  of objects  which can be thought of as the laws of physics of the mikrokosm. it also has other specifications for organisms - their input and output functions  called  perception  and  response    their reward functions  called  motivation  or  needs    and their mechanisms for building up internal memories  called  learning  and  hypothesis formation   that will'help them to recognize objects in the future  and respond appropriately to them  for example  in order to maximize expected rewards . this program lays bare the processes that are needed to handle interactions among simulated organisms and objects  including the learning of hypotheses that will 
guide future action. the present program has only the simplest of pattern recognition  hypothesis formation and need-satisfaction capabilities. its purpose is to make clear and concrete how such things can be interrelated in a complete system. descriptors: robots  mikrokosms  computers  integrative systems  pattern recognition  learning  hypothesis-formation. 
background 
     several relatively simple and special-purpose precursors to mikrokosms have been reported in the literature. toda1 discussed the decisionmaking problem of organisms that move at some cost in energy in order to get energy-giving  mushrooms.  doran1 also examines very simple simulated organisms moving through a space. travis' simulation and discussion of problem-solving in the form of a chess knight moving in order to cover a board can be thought of from this point of view1. indeed  all game-playing and theorem-proving programs can be thought of as simulating the pieces of the game or the expressions of the logistic system as they move about the environment of the gameboard or the proof tree.  for examples  think of samuel's checker player1  greenblatt's chess player1  zobrist's go program1  gelernter's geometry theorem prover1  newell and simon's logic theorist1 . these programs become more pertinent when they attempt to be general over several games  for example  newell and ernst's general problem solver1  pitrats1 and newman and 
uhr's1 	to-some-extent-general game players.  but none of the above seem to be exploring the issues for which the mikrokosm programs 
were developed  kochen and uhr1 . they do not try to tear apart what we mean by environments  objects  organisms  hypotheses  learning  and so on. they do not try to vary  and to generalize about  these things. rather  they look at relatively peculiar and rigid spaces  a checker board  a logistic system   and their  organisms   which contain little in the way of perceptual systems  memory  or learning abilities  are rather a d hoc to their space  e.g.  chess pieces  logical expressions . 
     during the past few years four large  robot  projects have been developed  pingle et al1 ; minsky & papert1 ; raphael1; sutro & kilmer1  and there turn out to be certain similarities between robots and mikrokosms. robots are real physical objects that wander around in our real physical world. movies can be made of them; when they bump into walls or people they can leave scars. the objects in a mikrokosm are computer simulations that consist of internal representations of numbers and letters  of bits  or of magnetic or electrical impulses - whichever you prefer. they can indeed be photographed if a program monitors them onto a scope; and still another equally trivial program could monitor them by having plastic and metal physical objects moving around through a room  just as the scope monitor has grades of light moving around over a phosphorescent screen. the differences of  reality    of physical  hardness  and ability to bump and scar  are differences that we had best leave to the ontologists. but there are important differences that we can understand. mikrokosms force us to understand  or at least to code  our environments and their interfaces with our organisms  which simulate robots ; whereas the robot researchers simply stick their real robots into the real world  and thus 
1
  for people partial to acronyms  mikrokosm might stand for:  models of inductive knowledge in responding organisms konstructed  from chaos by concept-formation  heuristics and adaptation to organization sensed  from only sensation  memory  and sweat. 
1
  robots 	on their way to the moon might be thought of as real orbiting bits of ostensible things. 
1
  this research was partially supported by nih grant  1. 

-1-

 potentially  get all the advantages of real-world complexity into their environments. 	the cost they pay is the cost and the trouble of building robots  which is something that has turned out to take several years  several people and several hundreds of thousands of dollars . 	this cost w i l l go down and disappear. 	they may also pay the more important costs of reduced complexity of the organisms they can handle  and rigid behavior on the part of these organisms. or at least this seems to be the case to date. finally  they have not yet actually taken advantage of the complexity of the real world into which they can put their robots. we w i l l return to these issues in the discussion at the end of this paper. 
mikrokosms described 
     we w i l l now give a brief description of mikrokosms in the following way: i  an actual running computer program  called  mikro-l   will be discussed. this program is presented in the appendix  along with an english-language  precis  that gives a detailed statement-by-statement description of its processes and its flow of control. 1  comments will be made about the general function embodied in each section of the program  with special emphasis on how it might be simplified to a bare-bones minimum. 1  we will discuss and suggest ways in which the function might be made more powerful. 
     the mikrokosm programs  at least as we conceive of them at present  break down into the following sections: 
i. 	initialize parameters. 
i i . 	generate the initial state of the mikrokosm. a. generate objects  and put them into the space. 
b. generate organisms  and put them into the space. 
i i i . compute environment-organism interaction  for each organism . 
a. print out the present state of the mikrokosm. 
b. present its updated view to the organism. 
c. let the organism process this view: 
1. recognize objects . 
1. conjecture pertinent hypotheses. 
and the characteristics of the organisms and the objects. this might be done in a very general way  by parametrizing all of these characteristics and having the program choose random values for the parameters. or it might be done with precise descriptions of all the pertinent details. 
     mikro-l is a simple mixture of easily parametrized and built-in characteristics. the basic parameters  params  for a space are taken to be its row and column size  all spaces are 1-dimensional   the number of organisms and the number of objects in the total space  and the distance that each organism can see. the program is given a set of standard values for these parameters  1 rows  1 columns  1 organisms each seeing 1 columns in either direction  and 1 objects . but the program will attempt to read a data card at run time  on which new parameter values can be given to it. 
     the objects that will be placed into the space will be exact copies of the general object types  genobjs . these are descriptions of the set of points   that is  the shape  of the objects  and of the physical qualities  such things as color  breakability  motion  weight  and caloric value . 
     whereas information about the space is parametrized  and information about objects is stored in tables  information about organisms is embodied in code.  this probably reflects the relative simplicity of the space  and the relative complexity of organisms. e  t it probably also reflects the primitive stage of this program: a better program would have better reasons for using parameters  tables  or code.  essentially  an organism is some calls to subroutines that a  take a look  b  pattern recognize  c  test hypotheses  d  choose acts  and e  generate and learn new hypotheses. 
generation of the initial state of the mikrokosm 
1. choose the most highly valued hypothesis. 
	objects. 	objects are generated first  by 
iv. 	update the mikrokosm to advance to the next making one specific object from each general ob-     the program uses ihe parameters that define the space to compute the average distance between objects and between organisms  and then generates and places the specified number of each. mikro-l makes several simplifications to shorten the code and speed up processing time. some of these lead to peculiar characteristics  but all could be coded properly - in most cases with very little trouble. 

time interval. 
a. compute and effect physical law changes. 
b. compute and effect changes resulting from organisms' acts. 
c. have the organism learn as a function of feedback from eating 
d. go to step iii  advancing time by 1 unit. 
initialization of parameters 
     the program must first be given a picture of the kind of mikrokosm space it should generate. this includes the dimensions of the space  the number of organisms and of objects in the space  ject  in turn  until the specified total number of objects has been made. to avoid any need to check whether several objects are put into the same place  though in fact in mikro-l space this 
w i l l happen later  causing peculiarities but no fata  problems   all objects are put into the top row of the space  at distances computed so that the specified total number of objects w i l l be equally distri-
buted. initially  all specific objects of each general type w i l l be identical  except for position in the space. but as time passes objects may move  bounce  break  and in other ways change in value. 

-1-

     organisms   mikro-i now generates the specified number of organisms and distributes them uniformly along the bottom row of the space. an organism is simply a name that contains a set of lists with that organism's qualities  energy level  location  direction and force of motion   its hypotheses  after it has learned some   its present view of the space  and some memory as to its own acts and changes it has noted in its environment. 
     organisms resemble objects in that they both have physical characteristics; but they differ in that only organisms store and learn hypotheses  view the environment  and have some memory. at present these differences reflect our own primitive thinking on the subject; it will be of great interest to see what differences remain when we have tried to force as much similarity as possible. 
     there are several major peculiarities to the space of objects and organisms generated up to this point. there is insufficient space to describe discuss  and justify them all in detail  but briefly: although objects have shapes in 1-dimensions  they are stored as though at points. this avoids the necessity of detecting and computing overlap between objects  which would either force us into 1-dimensional space  which would be expensive of memory and processing time  or a peculiar physics of objects occupying the same point at the same time. the proper way to handle the space would be for all objects to reside  properly positioned  in a background of emptiness or noise  chaos . but this would introduce a number of processing steps that would make this aspect of the program far more sophisticated than needed for the low level of sophistication of the rest. so we store objects and organisms on lists  and designate their positions explicitly by the coordinate numbers  rather than implicitly by their actual positions in the framework of the space. 
computation of environment-organism interactions 
     printout. the program outputs the present state of the mikrokosm before it begins the set of object-organisms interactions that will lead to change  and before each subsequent time period. this printout draws a picture of the current space  with its organisms and objects  and also exhibits the present state and innards of all objects and organisms. 
     organism views its environment. that part of the total space that lies within its field of view is presented to each organism  in turn. only the externally-visible shape of objects  including the viewing organism  can be seen  and the position of each object is computed and given to the organism relative to its own position. changes in these relative positions are also detected and given to the organism. 
pattern recognition and hypothesis-testing. 
the organism now begins to apply its set of hypotheses to its seen view.  specific hypotheses might be coded in advance into each organism's hypotheses table  but the alternative procedure that we prefer is to rely upon the organism's learning abilities to form these hypotheses through experiences gained in interaction with the environment.  tor each object in its view  the organism checks to see if there is an hypothesis in its memory with that object as one of its premises. it is here that the program does a very primitive kind of  pattern recognition    in which the description of the object must match a template representation stored in the organism's memory. 
   the interesting thing about this process is the structure of an hypothesis  even in its overly-simplc present form. an hypothesis is a statement about what the organism should do  and subsequently expect  when a certain thing s  is recognized in the environment and the organism is in a certain state s . at present the thing recognized is one of our simple and undeviating objects  recognition is effected by a perfect template  the acts are simple built-in sequences of code  and the expectations are of a certain amount of positive or negative change   pleasure  or  pain  . but we feel justified in suggesting that it is fine to keep pattern recognition as simple as possible  when we have so many other problems in the total system  and we know a great deal about how to make more sophisticated pattern recognizers. an especially appropriate type of pattern recognizer will be the sort of flexible heirarchical compound learning program discussed in uhr1 . we should also note that the recognition of more complex compounds of varying internal states within the organism can be handled in exactly the same way as external recognition  for these are merely two  sets of  premises of an hypothesis. the issue of  planning  is captured in the setting up and learning ot sequences of acts for the organism to do  which form the consequences of an hypothesis  and also sequences of hypotheses that the program might act upon over time. it is in the individual hypothesis and the methods for choosing among hypotheses  that much of what we call  pattern recognition     planning    and  problem-solving  lie. mikro-i handles these problems in the grossest and most primitive ways  but it also makes painfully and hopefully clear how our mechanisms for hypothesis-application and hypothesis-formation can be improved. 
     an hypothesis is conjectured to apply because something in the environment was found to be one of its premises  and hence implied it  and then the organism found that its own present state satisfied 
the internal state premised by the hypothesis  and finally computed a positive expected value of this hypothesis  which is a function of expected return from the object involved  the object's distance: a rough measure of difficulty of applying the hypothesis  and the weight of assurance with which this hypothesis is held . after the program has found all such pertinent hypotheses  it chooses the one with the highest positive weight.  a better program would 

-1-

allow an organism to do more than one thing at a time  to decide what to do before it had spent all the time needed to examine everything  and to make decisions as a function of sets of mutually complementary hypotheses. a simpler program might ignore internal states  and merely choose a single act as a function of a single recognized object. such a program would be doing straightforward pattern recognition. the program might merely have one act  rather than sequences of acts  stored as the consequence of each hypothesis. it would then be incapable of building up coherent strategies or plans. it is at this point  when a program is given the ability to build up sequences and compounds of characterizers of environments and of internal states  and of acts and expectations  that it begins to build up the capability of doing interesting pattern recognition  concept formation  serial prediction  problemsolving  and planning.   
up-dating the mikrokosm to advance to the next time interval 
     after all organisms have been given the chance to interact with their perceived environments  the update routines change the mikrokosm  as indicated by two lists: a  the physical qualities of all the organisms and objects  and b  the update list of the organisms' chosen acts. 
     physical changes. the only physical quality that is examined by mikro-i is the object's motion. the object is moved as indicated and  if it has hit a border of the space  is kept at that border .  a better program would allow objects to accelerate in their motion  and to change directioa for example after hitting one another. the program should also compute other changes in objects  for example decay and cracking over time  and changes that are a function of interactions between objects  for example breaking or fading.  
     organisms' acts. the acts that the organisms chose to put into update are now carried out. an act is a sequence of one or more things to do  and each such thing names a subroutine that does it. at present  the program has subroutines that allow the organism to: 1  get  move l step toward the specified object   1  destroy  wipe out the specified object if it is at the same location as the organism   1  flail  move l step in a randomly chosen direction   and 1  eat  wipe out the specified object  and also add the object's specified caloric content to its own internal energy level . this is a rather arbitrary set of primitive acts  chosen primarily to get mikros started doing something. but note that some are binary  destroy  eat  and some unary  flail  get   and that string of acts can be compounded together. 
     learning. 	eat is of special interest because only here is there real feedback to the organism  when its energy level is changed as a function of the object's caloric value  which can be negative  denoting a noxious object . it is therefore here  and here only  that the organisms in mikro-1  learn.   a more sophisticated program would have learning occur from a wider variety of feedback information - for example  from noting that objects are getting closer  or that a certain sequence of acts  as stored in the organism's running memory of past-done things  resulted in desirable or undesirable consequences. in mikro-i there is only one overall  energy level    which is changed when an object is eaten and its  caloric content  adds to or subtracts from that level. there might be several components of proper functioning - eg. protein  fat  water  oxygen  touching - and there might now be a need to develop characterizers about the self's patterning of these components  a n d
 changes in this patterning.   
     when the organism's energy level is changed as a function of eating an object  the program hunts through the past done acts of that organism to find an hypothesis that led to acts with the eaten object as their object. 	two types of hypothesis are stored on the organism's past-done list: the single hypothesis chosen at each time interval  
and the rest of the hypotheses conjectured. if no chosen hypothesis turns out to be about the object eaten  the organism goes through its conjectured hypotheses and  if one is found about that object  raises the value of that hypothesis  so that  since it is pertinent  it will more likely be chosen the next time.  this is a rather arbitrary thing to do  and should not be taken very seriously; it merely demonstrates how easy it is to program in variant types of learning.  
     the first pertinent hypothesis that is found is then up-weighted or down-weighted  depending upon whether the object eaten was positive or negative  noxious  in caloric content.  a better program might change the weight as a function of the actual caloric value  as well as its sign.  if down-weighted  the new weight is examined to see if it has fallen below some acceptable minimum. if it has  the hypothesis is discarded.  mikro-1 arbitrarily sets the initial weight of an hypothesis at 1  and discards the hypothesis when its weight goes below i. a more sophisticated program might keep a better record of the good and bad consequences of an hypothesis  and run more sensitive statistical tests to see whether the hypothesis has proved itself good or bad over a sufficiently large sample.  
     mikro-l generates a new hypothesis a  when an hypothesis is discarded and b  after each time period. 	 it would be better to keep some count of the amount of space available for the organism's hypotheses - its memory size - and then eliminate the least valued hypotheses when there was not enough room for everything. alternately  the 

-1-

organism's level of functioning and improvement rate on this level might be stored  with hypotheses being discarded and generated as deemed best to improve further. a number of extremely interesting aspects of learning pop up at this pointj 
     the variety of new hypotheses mikro-l can generate is limited. if the caloric content of the eaten object was positive  the consequent acts of the hypothesis will be  get  eat:  if negative  they will be  get  destroy.  the object's description is stored as one premise  so that the simplest kind of whole-template pattern recognition is learned and used. the initial expectation and weight of all hypotheses are set at the same level1 and 1. the program checks whether a newlygenerated hypothesis has already been discarded in the past; if it has  it doesn't bother to generate it again.  this is a subtle issue; if the mikrokosm were noisy or changed over time  organisms should be able to try hypotheses again. on the other hand  if there is a large set of possible hypotheses  learning might be slowed dangerously if the organism tried again hypotheses' it had a l ready found worthless.  
printout 
     the program listing ends with the code that prints out the state of the mikrokosm after each time period. this printout is cumbersome  and need not be described in detail. essentially  the actual z-dimensional representation of the mikrokosm is printed as a matrix  all organisms and objects that still exist are listed  and the contents  the internal states  of these organisms and objects are given. 
discussion 
     mikro-l is already too complex to lay bare the minimal structure of a mikrokosm  yet it is far too simple to be very convincing or interesting. our intent is that this is the first in a continuing series of more complex and more sophisticated programs. these will look into each of the aspects of a mikrokosm separately  pattern recognition  hypothesis formation  heirarchical compounding  planning  inductive learning  discovery  and so on . it should also be instructive to simplify  to try to get at the essence of  mikrokosms by: 
a  getting at their bare bones  and b  generalizing  eliminating as much as possible of the built-in. 
motivation 
     there are a number of reasons why mikrokosms seem interesting things to worry about and to simulate. 
     a  they force those of us interested in modeling intelligent processes  whether  artificial  and/or  natural   to take into account all aspects of our problem  and to contend with the central issue of integrating into a visible whole the various functions that we typically study separately. on the one hand many of us  including the authors  argue that our problem is far too big  so that we should simplify as much as possible; and that  further  not until we have far larger computers will 
our models exhibit diverse  flexible  and interesting behavior  which we feel may to a great extent be a function of size of memory. so we separately study  pattern recognition  or  concept formation  or  verbal learning  or  problem solving   e.g.   game playing    theorem proving    serial prediction   or  decision functions  or  responding   moving a  hand  or an  arm  or a  robot  . this is  we hope  right and proper. but we should also begin to combine these various functions. they are merely pieces of a total program  and we had better start worrying about whether we can ever get those pieces working efficiently together. 
     b  by putting the different functions together at the precise level of computer code  we gain the opportunity to generalize across them. we should force ourselves to do so. one gets the impression from papers and talks about some of the  robot  projects that they intend to take a pattern recognition program  and a question-answering program  and a concept formation program  and a theorem proving program  and maybe a few other programs  and put them together into a frankenstein monster. on the contrary  we should use this opportunity to tear apart and try to understand our code and the functions we are trying to compute  so that generalpurpose routines are achieved. for example  almost certainly most if not all of  pattern recognition  and  concept formation  should be performed by a single subroutine. those aspects of pattern recognition that involve deductive inference should have subroutines in common with problem-solving. and so on. we must confront ourselves with general criteria for theory-building: keep the set of constructs as simple  elegant  non-redundant  powerful  and insight-producing as possible. 
     c  the mikrokosm situation raises some extremely interesting new questions of generality. tor example  when we work with typical pattern recognition or artificial intelligence programs the patterns or other external objects with which they interact are merely presented to them. but now we must describe objects in the same kind of computer code with which we describe our perceiving  problem-solving organisms. we can now try to describe both objects and organisms with the same subroutines and the same tables  and we can begin to ask how they are similar  and how they differ. this focuses us on the fascinating issue of what turns an object into an organism. it prepares us to wonder about how a self-organizing system of objects might begin to evolve some organisms . it forces us to think about what must minimally be given to a mikrokosm for it to contain  or evolve  objects 

-1-

among which w i l l be organisms. 
     d  we can hold one or more parts of the total mikrokosm constant or trivially simple  vary the rest  and examine the resulting behavior. 
     e  we can ask a number of questions about learning that cannot be so clearly asked in any other situation. we can ask what is a minimal organism that will learn; what kinds of environmental experiences must this organism undergo; what kinds of information must this organism store. since we have close control over both environment and organism  at least until they start to interact and to learn   we can constantly think about one with respect to the other  and we can continually try to simplify both. 
     f  we can ask two closely related questions that have simply not been asked before at the precise level of computer modelling: l  how do two or more organisms learn to talk  including the development of vocabulary  grammar  and semantic reference  and the development of the mutually understood convention that these things should be developed  and should have common meaning to all organisms belonging to that linguistic community  
1  how do two or more organisms come to compete  and to cooperate; and what is the relation of such social behavior to a  their basic needs and ways in which they can be satisfied on the one hand  and b  their development of language on the other hand  
     g  we can try to simplify to the point where we may pinpoint what is absolutely essential. for example  it is not clear whether such a mikrokosm must have a motivating force in the form of the organisms' internal needs. we keep being forced back to such a beginning  or some close equivalent  such as a diffuse curiosity or a neural itch  despite the fact that this somehow  in a very vague way  feels a d hoc and intuitively unsatisfying. 
mikrokosms and robots 
     the stanford university robot project  pingle et al     has developed a robot that  at least so far  can do the following: if several large wooden blocks are scattered on a table  a robot hand with several fingers will zero in to hover above each block  close its fingers around that block  pick it up  and put it on top of a tower of like-sized blocks it is building. it thus perceptually sorts out the blocks by size  positions itself to pick up a block  and then places the block very carefully  so that it sits square enough on top of its tower so that the tower does not too often come tumbling down. this involves some extremely complex matters of precise positioning of fingers around blocks  and of blocks on top of other blocks. these problems may well be horrendous  if not impossible; but unfortunately this may be the case because they are being handled with several built-in strikes against the robot. for it gets no feedback about  and has no ability to adapt to  slight variations in position; it is in the same unfortunate position as a guidance system that must compute its trajectory to hit the moon without any opportunity for subsequent self-correction from feedback as to its deviations. 
       the stanford research institute robot  rosen  nillson  raphael; see raphael1  can wander through a room that has irregularly shaped objects placed in it  and learn through experiences of bumping into objects how to avoid them  and finally wander through the room without bumping into these objects. but its methods appear to be rather rigid and ad hoc - essentially  it stores a graphpaper representation of the room  and it fills in squares as  containing object  so avoid  whenever either its tv camera  eye  or its bumpers find a block covering the corresponding section of the room. 
　　　　both of these robots do things that mikrokosm organisms do riot do  and they force the researcher to contend with problems that mikrokosms avoid. it is up to the individual researcher's interests and tastes which he decides to be the more important problems  or the problems most central to modelling of intelligence. robot projects must contend with the noises introduced by tv camera inputs 	and by mechanical contraptions that can't move around without joggling their tv eyes  stop suddenly without randomly overstepping their intended stopping-point  or place one finger on an object without moving that object slightly so that the computed position for the next finger is no longer correct. new and interesting pattern recognition problems are confronted when the images of possibly interposed 1-dimensional objects on a table or in a room  with their shadows and gradations of intensity  must be recognized. these are problems the real world environment forces upon one  and it is good to be confronted by the real world. 
       a mikrokosm simulation could be expanded to handle 1-dimensional partially-viewed  shaded patterns  and these are large problems of pattern recognition on which research should be done. but most pattern recognition researchers would  we think  agree that such research should be done with computer programs and special-purpose pattern recognition computers  not with robots. in fact the actual pattern recognition programs incorporated into these robots are at a very low level of sophistication compared with existing pattern recognition research  see  e . g .   uhr1  nagy1 . 
       it would be more difficult to simulate problems of bouncing objects and falling towers; but it is hard to judge their centrality. 
-1-       the above is intended to suggest that robot researchers may be tackling difficult problems that are not really their central problems - the mechan-
ics of putting a robot together; the issues of illumination  contrast  color  and noisiness of patterns input; and the mechanical problems of exact motion and placement - andare simplifying the artificial intelligence aspects of their robots to the point where they are actually less sophisticated 
than existing computer simulations  including func-
tions  	that 	have 	been 	put 	i n t o 
our simple mikrokosm organisms. but it is not at all intended to criticize the intent of robot research  which we take to be to confront artificial intelligences with the enormous and  intriguingly  inexhaustible and infinite complexity of the real 
world. 
     on the contrary  it seems to us crucial to at some point put our simulated organisms into the real world. the complexity of the real world may be necessary for adequate learning; there may even be something to the infinite variety of the real world that is fundamentally unprogrammabie  and we will never know and benefit from this until our learning programs are hooked into the real world.  we assume that good artificial intelligences will be learning programs - they must be able to adapt  and they will be far too complex for anyone to succeed in formulating  or programming.  
     but there is a lot to discover about our organisms before they are ready to be put into the real world. people who don't have the mechanical bent skills  or money to build robots can still play an important role in this aspect of robot research. the interfaces between our organisms and the real world almost certainly should be richer than those developed so far in the robot projects . for example  the lack of ability to continually monitor feedbacks and modify behavior accordingly puts existing robots at a tremendous disadvantage. and the   real world   has to be an interesting part of the  real world.  to what extent is a robot confronting the real world when the room it is in contains two sizes of blocks  sufficiently illuminated so that they can be psrfectly resolved through the input device used  this is merely a world of blocks and positions  even simpler than the simulated worlds of mikrokosms . 
summary 
     this paper describes and discusses a simple program   mikro-l   that simulates the interaction between a set of  objects    some of which are  organisms    wandering around within a little  mikrokosm  space'. this is the first of what we hope will be a series of programs to explore complex intellectual processes by combining the various functions  pattern recognition  concept formation  problem solving  decision making  remembering  learning  and hypothesis formation  that have typically been studied separately. 
     the basic structure of a mikrokosm appears to be the following: it must include a set of objects  some of which are organisms  that interact within some space. there must  therefore  be ways of describing or generating objects and organisms  and placing them in interrelations. both objects and organisms must have qualities that are interpreted according to  physical laws  of the mikrokosm; among these will be n-ary qualities that are functions of interactions  e.g.   breaking    eating   . organisms must be able to generate acts as a function of interactions. in particular  sensory interaction  seeing at a distance  and hypothesizing and learning  generating and storing sets of premises as to the states of the external environment and of the internal characteristics of the organism  seem necessary for any interesting variety of organism behavior. the mikrokosm must be able to collate all the changes of organisms and objects  and up-date itself to the next time period. 
　　　mikro-l contains a special kind of object  a  shout    that is located everywhere. this we take to be the basis of future language learning. but mikro-l makes no use of shouts. nor does it have a very sophisticated set of basic acts  eat  get  flail  destroy   reasons for learning  the positive or negative caloric content of an eaten object   or pattern recognition ability  whole-template matching . it has rigid methods for forming hypotheses  and it has no ability to put anything hypotheses  pattern characterizes  or acts - into interesting compounds or heirarchies . but mikrokosms make painfully apparent the need for such improvements  and we think that they are an especially good test-bed within which to construct and examine more sophisticated processors. 
　　　　　　　　　　appendix  abstract for mikro-l . 
a get params: rows  cols  norgs  vieworg  nobjs  objdescriptions. generate specified number of objects  spread across row l . 
generate specified number of organisms  spread across row n. 
b print out the mikro  changes  and the organism's internal states. 
c present the next organism with the view of what it can sense  building up a changes list from last time. 
when no more ogranisms  go to d. 
this organism finds all hypotheses 
implied by what's in view  computes 
a value for each hypothesis  chooses the single most highly valued 
hypothesis  and places it in update and in its own pastdo list. 
go to c. 
d l/pdate the mikro for the next time period: 
move each object  including the organisms  as specified in their dxy  change* of-location  value. 

-1-

for each organism  do the string of acts 
specified:  include moving - flailing  getting -   eating  destroying.  
reweight the acted-upon hypothesis up or down. 
if weighted down test whether it should be thrown out. 
if yes  put it on discards list  
and try to generate a new hypothesis for this organism. when all organisms are done  go to b. 
end go to a. 
*precis mikro-l. simplest 1-dim. statement environ. objs put in row l . number 
**initialize the program's parameters. 
go 	1 
let generateobjects  genobjs  contain a list of the prototype objects and their descriptions. 
	let each prototype object contain a list 	1 
of its physical qualities. 
	define the function bord  which keeps 	1 
objects within borders . 
	define the function putout  which 	1 
outputs information about the state 
of the mikrokosm after each time 
period . 
let parameters contain a standard set 
of parameters. 
	read in a different set of parameters 	1 
for this run  if given  
	get from params the individual 	1 
parameters: rws  rows of space ; 
	cls  columns of space ; norg 	1 
 number of organisms ; osee 
 organism's-seen-view ; nobj 
 number of objects . 
	let randombackground  rback  contain 	1 
a random list of symbols. 
	let random contain a random list of 	i i 
i  1  - i . 
	let shout contain the physical 	1 
qualities of shouts. 
	let objecttypes contain the names 	1 
of the prototype objects . 
	let primdo contain the primitive acts 	1 
an organism can do before learning. 
**begin to generate objects. 
begin 	1 
let the average distance-between-
objects  disto  equal the number 
of columns  cls  divided by the 
number-of-objects. 
b1 
	is the number-of-objects-generated 	1 
 no  greaterthan the number-of-
objects-to-be-generated  nobj   
yes - go to b l . 
statement number 
no - let 1 equal i.  puts all 1 objects in row 1 . 
from genobjs  get the first type of 	1 object and its description  and put it after the rest  at the end 	of genobjs  so will generate one example of each type of object in turn . 
add 1 to the number-of-objects-generated 1  no . 
let the column where the next object will 1 be put equal the present put  which is 1 initially  plus disto  the distance-between-objects  
*note that here and elsewhere the random numbers can be used to vary positions. 
add to objs  the list of all objects- 1 generated  this object's name  obi  ob1  . . .ob no   followed by its type  description  and row  1  and column  put  locations. 
let this object's name  ob no   contain 1 its location   i1*put  and a description of its physical qualities  stored in type . 
bl 
let distance-between-organisms  disto  equal the number-of-columns divided by the number-of-organisms . 1 let the column where the first organism will be put equal i disto. 1 if put equals 1  set it equal to i  so 1st organism will be inside . 1 b1 
add i to no. 1 add to orgs  the list of all organisms- generated  this organism's name  org  no    where no are the integers that follow the integers used for objects   the number of this organism  norg   this organism's name again  and row  rws  the last row  and column  put  locations.  == indicates organism; =* indicates object.  1 let this organism's name  org no   contain its attributes  energy  initial location  rws*put   and an initial description of its physical qualities and its past memory  initially blank  . 1 subtract i from the number-of-organisms  norg -to-be-generated. 1 is norg lessthan i   yes - go to b1. 1 no - a d d the distance-between- organisms  disto  to put  for placing the next organism. go to b1. 
**present its view to each organism. 1 -1-     go to b1  to generate the next object. **place organisms. 

statement number 
b1 	1 
add the list of organisms to the end of the list of objects. 
tnext 	1 
 after each time-next  putout the present state of the mikrokosm. 
	advance time by i . 	1 
is time greaterthan 1   yes - end this 	1 run. 
tni 	1 
no - make a copy-organisms  corgs  of organisms  orgs  list. 
b1 	1 
get the next name-of-organism from 
corgs.  if no more  go to updater  
from norg  get this organism's state  1 hypotheses  pastdone acts  view  and oldchanges. 
from state  get this organism's 
	location=  row  col . 	1 
let the left border of this organism's 1 view be its column minus osee 
　 dis tance -in-one -direction-of organism's -seen-view . let the right border be its column plus 1 osee. 
bio 	1 
make a copy-objects  cobjs  of objects 
 objs  list  
	blank out  erase  lview and changes. 	1 
 list for this organism the objects in its view  including itself. 
bl 1 
from cobjs  get the next name-of-
object  no   its type  tp   and 
description.  if no more  fail to b1 . 1 for this named-object  no   get its location  row * column . 1 is this object of type 'shout'   yes - go to b1. 1 is this object's column greaterthan the leftmost column viewed  no -
go to bl 1  it's not in this organism's field of view . 1 yes - is co lessthan the rightmost 1        column viewed  no - go to bl 1.  get and use distances from organism to objects. 
	let ro  row-of-object  equal row 	1 
　 row-of-organism  minus ro  to get row distance from organism to object . let co  column-of-object  equal col 1  column-of-organism  minus co. 
	blank out roa  coa. 	1 
b1 	1 
from this organism's view  get the type  tp   description  name-of-object  no   and its location  roa * coa .  if no more  statement 
number 
fail to b1  
add this type  description  name-of- 
object and its location  ro * co  to lview  the left-view . 1 do the old locations  roa  coa  of this object equals the new  computed locations  ro  co    yes - go to bl 1  no changes . 1 is this object of type  shout* 	 which 1 is located everywhere    yes - go to bl i . 
	b1 	1 
to changes  add this object  its type  description  name-object  and its changes in location  ro-roa  co-coa  . 
go to b1 . 
	bl1 	1 
to the beginning of lview  add this new object  its type  description  name-ofobject  and location  ro* co . goto b1. 
   this organism now applies its learned hypotheses to the view presented it. 
	bl 1 	1 
let view contain what lview contains. let maydo equal primdo  those acts 1 primitively-done . 
	bl 1 	1 
from lview  get the next object's type  description  name-of-object  and location  ro  co .  if no more  fail to b1.  
if this type and its description are found 1 i on the list oi this organism's hypotheses  get the acts-to-do  state-of-self  
expectations  and weight.  if not found  
fail to b1.  
does this organism's state contain the 1 self-state specified for this hypothesis  
 no - go to bl 1.  
let value equal the expected-need- 1 change times the weight of this hypothesis  divided by the row plus column distance plus 1. 
get the absolute value  delete any minus 1 sign  -  . 
add this hypothesis to the list of things 1 the organism maydo: value  acts-to-dq name-of-object  location  ro * co   what to expect  the object's type and description  and the self state found. go to b1. 
  chooses to do as most highly valued 
hypothesis on maydo suggests. 
	bl 1 	1 
blank out vala  xxa  lm. 
from maydo  get the first valuea and the 1 rest of the information  xxa  about this hypothesis.  if none fail to b1.  
-1-
statement number 
b1 	1 
from maydo  get the next value  valb  and the rest of the information  xxb  about that hypothesis.  if no more hypotheses  fail to b1.  
	is valb greaterthan vala    if yes  	1 
go to b1.  
no - add to lm  lesser-maydo  valb 1 and xxb  the less valued hypothesis . 
go to b u . 
b1 	1 
add to lm vala and xxa  the less valued hypothesis . 
let vala equal valb  which has a higher value . 1 let xxa equal xxb. go to b m . 1 b1 
add to update this organism's name  norg   location  row* col  and the information about its most highly valued implied hypothesis  xxa  1 from pastdone  erase the act-done farthest in the past  xx  which is first on this inverted list   and add the chosen hypothesis  vala  xxa  followed by all less-valued-maydos  lm . 1 re-store under this organism's name 1  norg  its updated state  hypotheses  pastdones  view  and changes. go to b1  to start processing for the next organism. 
**update the mikrokosm for the next time period. 
updater 	1 
   let copy-objects contain what objects contains; erase objects. **update objects according to physical laws. 
u1 	1 
from cobjs  get the next object's nameobject  type  description  the first symbol after the '='  call it ox   and the rest  yy .  if no more objects  fail to u1 .  
in this named-object  get its motion  dxy  in x  dx  and y  dy  directions. 1 in no  get  and erase  its location  ro*co . 1 border this object  computing from its 1 location  ro and co  and motion  dx and dy  whether it will remain within the space  so that it will be made to stick to the border  - a function that starts with the statement labeled bordi. 
in no  put the newly-computed location 1  newrow-column . 
statement number 
   add to objects this object: name-of- 1 object  type  description  what's in ox  and its new location  newrc . add to repl this object's location 1  ro*co  and type. go to u1. **function that computes new location and keeps object within borders. 
bordi 
let nro = rw + dr  new-row = row + delta-row . 1 let nco = cl + dc  new-column = column + delta-column . 1 if nro is lessthan l  let nro equal i . 1 if nro is greaterthan rws  the last rows   let nro equal rws. 1 if nco is lessthan l  let nco equal i . 1 if nco is greaterthan cls  the last columns   let nco equal cls. 1 subtract l from column 1 in the designated row of the picture of the space  replace the ssymbol where this object used to be  cl symbols from the left  by a period  .   which indicates empty space . 1 let newrow-column equal nro * nco. 
return from this function. 
**update as a function of organisms' chosen acts. 1 ul 1 from update  get the next chosen-actto-do  name-of-organism  row  column  acts-to-do  name-of-object  and the rest  xx  .  if no more  fail to tnext.  
get the location  ro * co  of this named-object. 1 erase wash1 from no. 1 u1 
put lobjs back at the left of objects. 1 erase  wash  lobjs. 1 u1a 1 from do  get the next specific do-x. if succeed  go to the statement whose label is stored in dox; if fail  go to u l . 
	**the routines that effect 	the specific 
acts follow. 
	get 	1 
bl nk out dx and dy. 
print out ' / / / g e t s / / / '  to inform that 	1 acting . 
does the organism's row equal the 	1 object's row  yes - go to g l . no - if the organism's row is greater- 	1 than the object's row  let dx  change in the x direction  equal -1 and go to g1. 
	or let dx equal +1  and go to g1. 	1 
-1-
statement number 
gl 	1 
does the organism's col equal the 
object's column  yes - go to g1. 
	no - if the organism's col is 	1 
greaterthan the object's co 1  let 
dy  change in the y direction  equal 
-1 and go to g1. 
	or let dy equal +1 . 	1 
g1 	1 
from objects  get this norg's row 
and col. 
	border this organism  calling the 	1 
function bord  which will move it 
and keep it within the borders . 
	on objs  find norg  and add its new 	i 1 
location  newrc . 
	add this location  newrc  and name-	1 i 1 
of-organism to repl. 
	change the location stored under 	1 
this name-of-organism to newrc. 
go to u1  to get and do the next act. 
destroy 	l 1 
get the next object from objects.  if 
no more  fail to u1.  
	add this object to left-objects. 	i 1 
	from next  if the location is newrc  	i 1 
immediately following ' =*'  get 
name-object  type  and description. 
 if fail  go to destroy.  
	succeed - add this name-of-object  	1 
as 'destroyedby' the name-of-
organism  to goneobjs. go to u1. 
flail 	i 1 
from random  get the first two  pseudorandom  numbers  called dx and dy   and put them at the end of random. go to g1  where these will be used to randomly move and flail the organism. 
eat 
get the next object from objects.  if no more  fail to u1.  
add this object to left-objects. 
from next  if the location is newrc  immediately following the ' = *'  get name-of-object  type  and 
description.  if fail  go to eat  succeed - print out ' / / / e a t / / / ' . 
for this name-of-object  get its caloric value. 
from this name-of-organism  get its 
energy level  and add the object's 
caloric value to this energy level. 
add this name-of-object as 'ateby' i 1 
1 1 
1 
1 
1 this name-of-organism to goneobjs. 
**re-weights learn hypotheses as a 
　function of feedback from eating. **finds an hypotheses about this eaten object. 
statement number 
	bl nk out past  opast  and dex 	1 
	from this named-organism  get its 	1 
state  hypotheses  pastdone  view  and ochanges  get  but don't erase them.  
l1 	1 
from pastdone  get the next chosenact's value  dz  name-of-object-i  noi   location  roi*coi   expectations  and the rest of the conjectured hypotheses for that time period.  if no more  fail to l1.  
from expect  get expect  typel  des- criptionl  and self. 1 add 1 to past. 1 add the rest to other-past 1    does the named-object equals the named-objecti  no - fail to l1. **re-weights an hypothesis about the object eaten. 1 l1 
yes - on the organism's hypotheses  if typel and descriptioni are found  get and remove doy  self  expect  and weight. i 1 add delta-expectation  dex  to expect. i 1 wash  erase  dex. 1 is the caloric content negative  -   yes - go to l1. 1 no - add 1 to weight. 1 l1 1 put back on hypothesis the components of the hypothesis that was taken off by statement l1 and reweighted. go to u1. 
l1 	1 
lower weight by 1  this was a noxious object that the organism should learn not to eat . 
   is the weight now lessthan i   no - go 1 to l1  to put this down-weighted hypothesis back onto hypotheses . **discard an hypothesis whose weight has gone below 1. 
   add to the list of discards the typel  1 descriptioni  doy  self  and expect of this discarded hypothesis. go to l1. *if none of the hypotheses acted upon was pertinent  check all others on opast. 
l1 	1 
from other-past  get the next hypothesis 
 value  doy  name-of-objecti  location  rowi*coh   and expectation .  if no more  fail to l1  
	from expect  get expect  typel  	1 
　description  and self. does namea-object equal named* 1 
objecti  no - fail to l1. 
	yes - let delta-expectation  dex  	1 

-1-

statement number 
       equal 1  so that this hypothesis will have a higher expectation  and w i l l more likely be chosen and acted upon  in the future . go to l1. **a new hypothesis is generated 
l1 	1 
is the caloric content of the eaten object negative  -   yes - go to l1. no - let new-do  nd  equal  get  eat. . go to lio. 1 l1 
let the new-do  nd  equal  get. 
destroy. . 1 lio 
see if discards already has this new hypothesis' type  description  and 
new-do.  if yes  go to u1.  1 add this newly-generated hypothesis to the organism's hypotheses: its type  description  new-do  and initial expectation-level  1   and weight  1 . 1 u1 
erase information about this eaten or destroyed named-object. 1 put the left-objects back onto the start of the objects list. 1 wash  erase  left-objects. 1 erase this  eaten or destroyed  named- 1 object from the objects list. go to u1a. 
**function follows to print out information about mikro at each time period. 
bibliography 
1. doran  j.e.  experiments with a pleasure seeking automaton. in: machine intelligence 1   ed. michie  d.  edinburgh: university press; 1a  pp. 1. 
1. doran  j.e.  a simulated robot/environment system: progress and problems  1b. 
1. gelernter  h.  realization of a geometry theorem proving machine. proc. international conference on information processing  paris: unesco  1. 
1. greenblatt  r.d.  eastlake  d.e.  & crocker  s.d.  the greenblatt chess program. 
	proc. fall toint computer conf.  	1. 
1. kochen  m. and uhr  l.  a model for the process of learning to comprehend. in: information science  m. kochen  ed.  new york: scarecrow press  1. 
1. minsky  m. and papert  s.  discussion of mit robot project. presented at int. pattern recognition conf.  puerto rico  1. 
1. nagy  g.  state of the art in pattern recognition  proceedings of the ieee  1  
vol. 1  no. 1. 
1. newell  a. and ernst  g.  the search for generality. proc. ifip congress 1. new york  1  pp. 1. 
1. newell  a.  & shaw  j.c.  & simon  h.a.  empirical explorations of the logic theory machine. proc. west. joint comp. conf.  1  1. 
1. newman  c. and uhr  l.  bogart: a discov-ery and induction program for games. proc. 1th annual meeting of the acm  1. 
1. pingle  k.k.  singer  j. a. & wichmann  w.m .  computer control of a mechanical arm through visual input. proc. ifip congress 1  edinburgh  1  pp. h1-h1. 
1. pitrat  j.  realization of a general gameplaying program. proc. ifip congress 1  edinburgh  1  pp. h1-h1. 
1. raphael  b.  programming a robot. proc. ifip congress 1  edinburgh  1. pp. h1. 
1. samuel  a . l .   some studies in machine learning using the game of checkers . ibm j. res  and develop.  1  1. 
1. sutro  l.l. & kilmer  assembly of computers to command and control a robot. proc. spring joint comp. conf.  1. 
1. toda  m .   the design ot a fungus-eater: a model of human behavior in an unsophisticated environment  behav. sci.  1  l t 1. 
1. travis  l.e.  experiments with a theoremutilizing program. proc. spring joint computer conf.  1. 
1. uhr  l.  ed.  pattern recognition  new york: wiley  1. 
1. uhr  l.  pattern recognition  problem solx/ing and learning. i 1  in preparation . 
1. zobrist  a.  a model of visual organization for the game of go. proc. spring joint comp. conf.  1. 

-1-





