 
a knowledge representation server is described which provides a fast  memory-efficient and principled system component. modeling the server through intensional algebraic semantics leads naturally to an openarchitecture class library into which new data types may be plugged in as required without change to the basic deductive engine. it is shown that the operation of an existing knowledge representation system  classic  may be implemented through one data type supporting sets with upper and lower set and cardinality bounds. the architecture developed is cleanly layered by complexity of inference so that fast propagation of constraints is separated from potentially slow modelchecking search. client programs may obtain estimates of the complexity of a request  and may control the resources allocated to its complete solution. 
1 introduction 
one of the basic technologies that may be factored out of virtually all artificial intelligence systems is some form of knowledge representation service. theoretical foundations have been developed for such technologies in recent years 
 brachman and levesque  1; ait-kaci  1; nebel  1 . these foundations make it possible to develop general-purpose knowledge representation services that are well-principled  space and time efficient  and embeddable as sub-systems in a wide variety of applications. 
   since complexity analyses shows that knowledge representation systems with even minimal features are able to represent intractable problems  brachman and levesque  1; nebel  1; schmidt-schaub  1   it has been suggested that the representation and deduction capabilities of knowledge representation services should be limited  levesque and brachman  1 . the reasons for and against this have been surveyed by doyle and patil  who conclude that  while there are sound arguments for such limitations  the capabilities of the resultant systems will often fail to satisfy reasonable application requirements. one impact of this is that system designers may add functionality that provides the missing capabilities in ways that arc less principled than those of a general server. a second is that problems may have to be represented in unnatural ways that are conducive to poor performance. a third is that the effect of the limitations on deductive capabilities may not be apparent to users  leading to errors. 
1 	knowledge base technology 
   this motivates an open-architecture server design to which functionality may be added in a principled fashion  implemented as a class library with well defined interfaces to new classes for additional data types. the inherent intractability of some representable problems  contrasted with adequate practical performance of existing knowledge representation systems  vilain  1   suggests that services need to be layered. some deductions can be carried out in low-polynomial time and space whereas others may involve a search whose lower bound is at least exponential in the size of the problem. an architecture which separates these deductions into separate layers of service is desirable in applications  particularly if the computationally expensive ones can be carried out asynchronously in the background  provide useful partial results  and can be terminated before completion if appropriate. to allow users to estimate the cost of using a service  it is important to instrument the complexity of knowledge structures to provide metaservices that estimate the tractability of a problem. 
   this paper describes the design and implementation of an open architecture knowledge representation server  krs  as a class library in c++. the server was originally modeled on classic  borgida  brachman  mcguiness and resnick  
1   and designed to be the kernel of a new family of interactive knowledge acquisition tools  and its architecture and applications as an artificial intelligence tool have already been described  gaines  1a   as have the associated rule system  gaines  1b   visual knowledge representation language  gaines  1c   and its application to organizational modeling and problem solving  gaines  1id . this paper focuses on the underlying principles and the way in which they determine an architecture for term subsumption knowledge representation systems. 
1 theoretical and practical framework 
the most widely used framework for the formal analysis of knowledge representation has been the standard model and proof theory of first order logic. however  there are alternative algebraic models for first and higher order logics that are becoming increasingly used in programming language semantics because they represent abstract data types simply and naturally. ait-kaci  1  1  has given a lattice-theoretic model of knowledge base languages with operational semantics through term rewriting that resolves many of the issues of complexity and deduction algorithms for term subsumption knowledge representation. 
   
   the merits of algebraic  type-theoretic semantics for knowledge representation are that they provide formal models and complexity analyses that relate closely to the features and issues of existing knowledge representation systems. for example  they provide simple accounts of common constraints  such as cardinality  extensional inclusion and numeric ranges. clearly  these are questions of naturality rather than logical power  since accounts of set theory and arithmetic can be developed in first order logic  and algebraic feature constraint logics may be translated into first-order formulae  smolka  1 . however  natural models giving minimal formulations of representational requirements are valuable in both the software engineering of knowledge representation servers  and the effective presentation of the services offered to those using them. 
   the model for term subsumption knowledge representation used in the development of krs is that the computational units arc: for the tbox  concepts  identified with collections of constraints indexed by roles; and for the abox  individuals represented as unique identifiers  each of which has associated conceptual variable whose value in any particular state of the knowledge base is a concept. this has the normal semantics for kl-one systems that concepts are precisely a composition of constraints- changing the constraints changes the identity of the concept  whereas individuals are precisely identities of objectschanging the associated constraints changes the state of the individual  not its identity. in zalta's  1j terminology  abstract objects  concepts  encode properties whereas concrete objects  individuals  exemplify them. 
   thus  the computational structure of both theory and implementation is modeled as an algebra of constraints  but the nature of the constraints is left undefined. any data type can be used in representation and deduction provided it can be modeled as a constraint algebra. in krs the data types and their operations arc implemented as separate classes  and 'plugging in' new data types involves adding a new class with four associated operations  composition  subsumption test  input and output . the kernel deduction systems for constraint propagation  for rule  inverse role and coreference application  and for model checking search  remain unchanged. 
1 constraint algebras 
the semantics of constraints may be developed directly from informal requirements to a formal model. the key notions are that the composition of two constraints should be a well-defined constraint  binary function   that it makes no difference to compose a constraint with itself  idempotency   that grouping of multiple constraints in resolving them to binary compositions makes no difference  associativity   and that the order of application of constraints makes no difference  commutativity . without these requirements  one would have the semantics of general operators rather than constraints. together they imply that composition generates a semi-lattice in which it is the join operation. there is a natural order relation of subsumption of constraints  defined as one constraint subsumes another if their composition equals the second constraint. the semilattice can then be extended to be a full lattice by defining a dual  order-inverting meet operation  which  as a side effect  adds the lattice adsorption identities  gratzer  1 . a unique lowest element  or zero  can be defined in the lattice corresponding to the composition of incompatible constraints. a unique greatest element  or unit  can be defined corresponding to a universally applicable constraint. 
   thus  the lattice structures common to all knowledge representation systems arise out of the basic primitive of a constraint. any mathematical or logical formulation is a 
   representation of the properties of this primitive  and any representation schema with reasonably normal semantics will have a constraint algebra interpretation. 
   formally  a constraint algebra is defined as a pair of binary operations upon a set   composition  and  minimum common generalization   unique greatest and least elements  universal and incoherent constraints   defined ideal sub-lattices  types   defined order and incompatibility relations    subsumption  and - 
 disjoint   and defined atomic elements  values   satisfying the following: 

   the semantic notions of knowledge representation can now be modeled formally by taking any bounded lattice as a constraint algebra in which the atoms arc values  other elements are constraints upon those values  ideals are types of values  the order relation is one of constraint subsumption  the incompatibility relation as one of disjoint constraints  the unit element as a universal constraint and the zero element as an incoherent constraint. the next section defines types for record structures as constraint algebras giving a complete account of the semantics of term subsumption knowledge representation schema. 
1 constraint algebras for the t-box and a-box 
to develop the semantics for concepts in the  and worlds of individuals in the a-box  take any constraint algebra  l  and consider an indefinite product of such algebras  indexed by a set of projections  such that 	the arity of an element of x is defined to be the number of non-1 
projections. there is a natural constraint lattice formed by x under the definitions: 
	gaines 	1 
   

   that is  the lattice operations operate on a component by component basis  and any projection becoming zero implies that the product is itself zero. the order relation of  l1  may also be computed on a component by component basis: 
		 x1  
¡¡the base algebra l may be treated as a sublattice of x by defining a specific 
 x1  
    x1  through  x1  construct one constraint lattice as the indefinite product of another such that the original lattice may be mapped to a sublattice of the product. this construction may be iterated indefinitely to construct a wellfounded sequence of constraint lattices of increasing order corresponding to the well-founded construction of sets in classical set theory. the order of an element of one of the lattices is defined to be the position in this sequence of its initial definition. the complexity of an element is defined recursively as its arity plus the arities of each of its non-unit projections-this corresponds to the number of non-unit modes in its expansion or graph. 
1 t-box representation 
   if the projections are defined to be roles and the lattice elements concepts  this construction is adequate to account for representation and deduction in the t-box of term subsumption systems. concept subsumption is the order relation of  x1  and individual classification is the same relation if the a-box is taken simply to associate an individual with a concept asserted of it. 
   some issues relating to the complexity of subsumption and classification are now apparent. the subsumption of  x1  for elements of a given order in a system that stores only non-unit projections and caches precomputcd lower order subsumptions involves only n cache accesses where n is the minimum of the arities of the elements being compared. this model of subsumption computation gives an upper bound that makes it appear highly tractable. however  there are a number of reasons why this result is misleading. 
   first  the subsumption relation in the base lattice will generally not be cached because the space complexity will be high even if the time complexity is not  and the time complexity could also be high in an open architecture system in which arbitrary lattices can be plugged in  including the product lattices just defined . in practice  the base lattices currently used in systems such as classic are such that subsumption computation is tractable as will be shown in the next section. 
   second  the composition of concepts may generate large numbers of additional  anonymous  concepts such that the caching assumed may itself become intractable in space and time. nebel  has given a simple construction of a series of related concepts where the number of anonymous concepts grows exponentially with the number of originally defined concepts. in krs the number of anonymous concepts generated by a given concept definition is reported as an auxiliary complexity measure. 
   third  it is unrealistic to implement assertions about individuals in a caching scheme. individual classification may involve a complete expansion of the concepts testing each node at the base lattice level. the number of tests is then the complexity defined above which can also grow exponentially with the number of concepts defined. 
   fourth  the subsumption relation defined in  x1  is intensional. it docs not take into account the constraints that may be propagated in the a-box to ensure that the concepts associated with individuals cannot become incoherent. extensional subsumption taking into account such constraint propagation is consistent with  but a stronger partial order  than intensional subsumption. this is how intractability may be shown in classic by representing satisfiability of a restricted cnf formula  lenzerini and schaerf  1 . 
1 a-box representation 
   if the projections are defined to be individuals and the lattice elements worlds  the construction   xi  through  x1   is adequate to account for representation and some aspects of deduction in the a-box of term subsumption systems. world subsumption through the order relation of  x1  corresponds to monotonic reasoning  that the subsumed world can be reached from the other by a series of assertions about individuals. however  there are additional modes of reasoning in the a-box that make its analysis more complex. 
   first  classic-like systems implement rules as pairs of concepts such that if an individual is classified as falling under the first then the second is asserted of it. 
   second  individuals may participate in base lattice constructions  for example through extension and cardinality constraints on sets of individuals  and hence assertions of a concept as applying to one individual may imply that other concepts apply to other individuals. in particular  cardinality constraints may imply the existence of  skolem  individuals not previously created. 
   third  there may be assertions about individuals that  while they do not lead to incoherence directly  do so indirectly through the previous two mechanisms. taking into account these implicit constraints may involve a search over possible worlds that may grow exponentially with the number of individuals involved. 
   the first two modes of reasoning do not in themselves lead to intractability but  taken together with the third  they allow intractable problems to be represented in the a-box that go beyond those already discussed for the t-box. 
1 base algebras for classic-like systems 
specific base lattices for classic-like systems may be constructed from a four element constraint algebra as shown on the left of figure 1 in which is the zero element  
the unit element  and are complementary elements distinct from them. the semantics of this lattice is that of role constraints: 
¡¡the semantics of this lattice are those of constraints upon the subsets of s with the first projection of the product being a lower bound corresponding to f i l l   the second projection being an upper bound corresponding to oneof  unsatisfiable constraints in which the lower bound is not contained in the upper bound mapping to zero  and the lattice operations corresponding to complementary pairs of intersections and unions of lower bounds and upper bounds. the atoms of this lattice are elements in which the lower and upper bounds coincide. they provide the semantics for close in corresponding to a set constrained to consist precisely of its specified members. 
   the same-as constraint corresponds to an equality assertion between nodes of a concept structure. it is simply implemented in the a-box by indirect addressing. the figure 1 example type lattice for set valued roles 
   primitive and disjoint-primitive constraints are implemented through a hidden role filled by elements of a p lattice based on the set of concepts rather than that of individuals. a concept defined to be primitive stores its own name as fills in this role. a concept defined to be disjoint to another stores the other's name as not in this role. this results in the proper semantics for primitive concepts. 
	gaines 	1 
thus  the capabilities of classic arc implemented in 
krs through a single data type which is a set with upper and lower bounds and cardinality constraints. it is a an unusual data type compared with those of conventional programming languages  but it is readily implemented and optimized for fast and memory-efficient operation. 
a principled implementation of some applications of the 
test constraint used to extend classic is made available in krs by direct support of data types such as integers  time intervals  strings  and so on  through the lattice constructions of figure 1. this allows general abstract data types to be integrated in classic-like systems. what it does not support is operations upon them that do not correspond to the lattice joins and meets  and the use of side-effects to communicate with other subsystems. 
1 architecture of krs 
the krs architecture is shown in figure 1. it supports the normal features of kl-one-like systems in allowing concepts to be defined  and assertions to be made about individuals in terms of these concepts. what is essentially type propagation inference can then be used to deduce the consequences of the assertions through reference to the definitions. krs also supports the rule schema of classic  extended to handle rules with exceptions  such that an individual recognized as satisfying one concept has another automatically asserted of it. this integrates production rule and frame-based reasoning. it also supports model checking  halpern and vardi  1  or  puzzle mode  reasoning in which  if necessary  after propagation of type and rule constraints a search of possible worlds is carried out to determine whether additional conclusions can be drawn because not to do so would lead to absurdity. 

figure 1 overall krs architecture 
   krs supports a wide variety of data types through a data type manager accessing separate modules through a uniform interface such that constraints supported  such as interval bounds on numbers  enter fully into concept definitions  individual assertions and deductive inference. complexity measures are derived from the concept definitions that estimate the probable costs of problem solving in a particular domain. 
1 	knowledge base technology 
   the algebraic model of knowledge representation leads directly to an open architecture implementation as a class library as illustrated in figure 1. the knowledge base class has two main instance variables  one holding individual records and the other holding concept records. the base knowledge base class implements the type lattice on the left of figure 1  having codes for indeterminate  applicable  nonapplicable and overdeterminate values and constraints. it also supports other constraints by reference codes containing a type code and pointer. the type code is used to access a list of data type support objects which is initially empty. for each data type implemented an object is added to the list that supports it by providing storage for values and constraints of that subtype  and methods to compute and support input/output with such values and constraints. 
   figure 1 at the bottom left also illustrates another important feature of the class library construction. type subsumption computation for record structures is simply expressed recursively. however  to attain the known complexity lower bound requires that already computed subsumption relations be cached to avoid duplicate computation. this caching is implemented in a sub-class in krs  allowing the simple recursive computation to be called as an inherited method during debugging as a check on the correctness of the caching algorithm. 
   the utility of the class library construction are also apparent in the implementation of model checking reasoning in krs. this is the mode that exhibits intractability so that it is appropriate to implement it as a separate service. it involves a search of possible worlds once other forms of inference have reached a fixed point. the form of reasoning is that certain further constraints upon existing individuals that appear possible may not be so because their consequences are inconsistent. if one searches all possible worlds resulting from the assertion of combinations of such constraints then constraints which apply in all consistent worlds are necessary and can be deduced. puzzles are usually designed so that there is only one world that is consistent  but real problems usually involve multiple possible worlds as consistent extensions. in krs this mode of reasoning is implemented by making the individual records instance variable shown at the top of figure 1 a pointer to a tree structure of possible worlds. the rest of the reasoning and type system remains unchanged. 
1 conclusions 
   now that the theoretical foundations of knowledge representation servers have been developed in terms of abstract data types  and the demand for embeddablc implementations is growing  it is attractive to investigate the possibility of class libraries supporting efficient  extensible implementations. this paper has specified the requirements  detailed the relevant theory  and shown how this has led to a class library implementation of a fast  principled  open architecture knowledge representation server. 
acknowledgements 
this work was funded in part by the natural sciences and engineering research council of canada. 
   

figure 1 part of knowledge base class lihrarv structure 
   
