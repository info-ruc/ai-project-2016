
we introduce a general setting for information elicitation in multi-agentsystems  whereagents may be approached both sequentially and simultaneously in order to compute a function that depends on their private secrets. we consider oblivious mechanisms for sequential-simultaneousinformationelicitation. in such mechanisms the ordering of agents to be approached is fixed in advance. surprisingly  we show that these mechanisms  which are easy to represent and implement are sufficient for very general settings  such as for the classical uniform model  where agents' secret bits are uniformly distributed  and for the computation of the majority function and other classical threshold functions. moreover  we provide efficient algorithms for the verification of the existence of the desired elicitation mechanisms  and for synthesizing such mechanisms.
1 introduction
information elicitation in multi-agent systems deals with the aggregation of information from agents in order to compute a desired function  conen and sandholm  1; sunderam and parkes  1; parkes  1; boutilier et al.  1; smorodinsky and tennenholtz  1; shoham and tennenholtz  1; mcgrew et al.  1; halpern and teague  1 . in the general setting we consider in this paper there are n agents  players  who hold some private information  secrets . the agents would like to compute  jointly  a function which input is the vector of n secrets.1 in addition  there exist a distinguished reliable agent  aka the center   who may be used for extracting information from the agents. the center's aim is to devise a mechanism that will yield to the desired computation. in this paper we consider a strategic setting. we assume that the agents are selfish and are driven by utility maximization considerations. on one hand  they would like to receive the value of the multi-party computation  but on the other hand they may not want to contribute to this computation  but rather free-ride on other agents' efforts. hence  our setting fits into the context of mechanism design  see  mascolell et al.  1   vol. 1   a subject of great interest to the synergy between ai and game theory  see  monderer et al.  1  .
¡¡the particular  although general  setting we study is the following. each agent has a secret which is accessible only to him. however  access to that secret is costly and agents may choose to access it or not. thus accessing one's own private information becomes a strategic question. this approach generates a natural tension between the socially  and even privately  optimal action  which is to compute the joint function correctly  and agents' incentive to free ride. in order to overcome this tension one may need to design a mechanism to prevent  some or all  agents from free-riding  elicit agents' secrets and execute the desired computation.
¡¡as in previous work in this regard  e.g.  smorodinsky and tennenholtz  1   the class of functions we consider is that of anonymous functions. an anonymous function is one where the function's value does not depend on the identity of the agents but on the secrets only. in other words  a permutation of the agents' secrets will not change the value of the function. this class of functions is quite elementary and often used in models. among the anonymous functions are majority  consensus  average  variance  order statistic  percentile and more.
¡¡previous work has shown the power of sequential information elicitation. by approaching the agents sequentially  we can in some cases incent agents to access their secrets  where they would not do so if approached simultaneously. the basic intuition behind this approach is that some agents may be willing to access their secrets since this is not too costly for them  while others will not agree to access their secrets unless they are pivotal  given that their costs for accessing their secrets is high . sequential mechanisms take advantage of this structure  by carefully selecting the identity of the agent to be approached at each point  given the available information. in this paper we consider a more general approach: agents can be approached both simultaneously and sequentially. that is  we consider sequential mechanisms where at each point a set of agents is approached. the decision on the set of agents to be approached is based on the available information. as it can be shown  and is illustrated in section 1  this kind of mechanisms  which we refer to as sequentialsimultaneous mechanisms  allows more effective information elicitation than either sequential or simultaneous information elicitation. the major aim of this paper is to identify conditions for the existence of successful sequential-simultaneous elicitation mechanisms  and devising algorithms which output the desired mechanism when exist.
¡¡as the reader would notice  our objective is quite ambitious. in particular  a sequential-simultaneous mechanism may be a complex decision tree  which maps any possible history observed to the set of agents to be approached given that history. this gives rise to the idea of considering a particular kind of such mechanisms  which we refer to as oblivious mechanisms. in an oblivious mechanism the ordering of the agents is fixed in advance and does not depend on previous history. naturally  if successful elicitation can be established by such a mechanism  then it is also easy to represent and implement. this leads to two types of fundamental questions:
1. can one provide an efficient algorithm for checking whether  given an information elicitation setting  a desired oblivious sequential-simultaneous elicitation mechanism exist  if one exists  can we provide an efficient procedure which will output the desired mechanism 
1. are there natural and general settings where the restriction to oblivious mechanisms does not prevent us from the desired elicitation 
¡¡the surprising message of this paper is that we can provide highly positive and encouraging answers to both questions! we first prove that if there is an appropriate oblivious mechanism then there is also one which uses a semi-natural ordering  i.e. the mechanism will never approach an agent with cost c before it approaches an agent with cost c1   c  although it may approach them simultaneously . then we show an efficient algorithm for verifying whether a desired  oblivious  semi-natural ordering mechanism exists; if such mechanism exists  then the desired ordering is obtained as our algorithm's output. then  we show that the restriction to  oblivious semi-naturalorderingmechanism does not restrict the power of elicitation in some of the most popular contexts. in particular  we show that this holds for the uniform setting  where each agent's secret bit is taken to be 1 or 1 with probability 1 each   as well as for the classical majority function and for more general threshold functions. together  this provides a most powerful and general approach to information elicitation in multi-agent systems  backed up with efficient and effective algorithms.
¡¡in section 1 we introduce the general model  and general sequential-simultaneous mechanisms. we also briefly illustrate the power that these mechanisms buy us when comparing to previous studies where purely sequential or purely simultaneous mechanisms have been considered. in section 1 we introduce oblivious mechanisms. we then show an efficient algorithm for verifying the existence of an appropriate oblivious elicitation mechanism  and show that a semi-natural ordering mechanism can be computed as the desired result  if such oblivious mechanism exists. we also remark  by means of example  that there are cases where the restriction to oblivious mechanisms may prevent us from obtaining the desired computation; this leads to the study of settings where the existence of a desired elicitation process implies that it can be done by a correspondingoblivious mechanism  which we can efficiently compute. the uniform model is discussed in section 1  and the majority function  as well as extensions to other threshold functions are discussed in section 1. in all cases efficient algorithms are provided.
¡¡the proofs of many of our results are non-trivial  and are based on a series of propositions that are omitted from this version of the paper due to lack of space.
1 the general model
let n={1 .... n}  n ¡Ý 1  be a finite set of agents. each agent j has a private secret sj ¡Ê {1} that he may compute  i.e. access in order to learn its value . let 1 ¡Ü q   1 be the prior probability of sj = 1 and assume these events are independent. agents may compute their own secrets. however  computation is costly and agent j pays cj ¡Ý 1 for computing sj. without loss of generality we shall assume c1 ¡Ü c1 ¡Ü ... ¡Ü cn  in words  agents are ordered by their costs . we will also refer to the agents' costs  ordered from the lowest one to the highest one  as c 1  c 1  ... c n 1 .
¡¡agents are interested in computing some joint binary parameter  e.g.  the majority vote or whether they have a consensus  that depends on the vector of private inputs. let g : {1}n ¡ú {1} denote the desired computation. each agent j has a utility of vj from learning the value of g. we assume vj ¡Ý cj  otherwise the agent face no dilemma.
¡¡it is also possible to use the convention that vj = 1. this is done without loss of generality  as the more general case where vj   cj   1  is equivalent to the case where the value of agent j is 1 but the .
¡¡a central designer  termed the center  elicits the agents' secrets  computes g and reports the computed value of g back to each agent. in this setup each agent faces a dilemma of whether to compute his private secret sj  at a cost of cj  or perhaps to submit a guess to the central designer. the desired property of a mechanism is the correct computation of g  which is done through the elicitation of secrets from sufficiently many agents.
¡¡one should note that the cost of each agent's computation  cj  is lower than the gain from computing g  and therefore the socially optimal outcome is to compute. however  free riding of agents may undermine the ability to reach the social optimum.
1 sequential-simultaneous mechanisms
we now model mechanisms that approach players sequentially  with the possibility to approach simultaneously more than one player each time. we will assume that the communication between the center and the agents is fully revealed to all agents. this can be associated with having broadcast communication.
¡¡a sequential-simultaneous mechanism determines the set of agents to be approached at each stage  as a function of the information provided so far. formally  let hi =

bk+1   bk} where v =  j l  stands for the event where j agents have been approached and l 1's  and j   l 1's  have been reported. hi is the set of histories of length i  for 1 ¡Ü i ¡Ü n. let h1 = ¦«  where ¦« is the empty  null  history. let h = sni=1 hi be the set of all possible histories . a sequential-simultaneous mechanism is a triplet  u g f  where u : h ¡ú {1 ... n} determines how many agents to approach simultaneously  g : h ¡ú 1n determines the agents to be approached  and f : h ¡ú {1  } is a function that expresses a decision about whether to halt and output either 1 or 1  or continue the elicitation process  denoted by * . note that each agent has 1 actions: don't compute and report 1  don't compute and report 1  compute and report 1  compute and report 1  compute and report the true computed value  and compute and report a false value. let us denote by ¦£ the set of actions. a strategy for player j  xj : h ¡ú ¦£  assigns an action to each possible history. let h k  x1 ... xk 1 xk+1 ... xn s  be the history that agent k sees when approached  given that  x1 ... xk 1 xk+1 ... xn  is the vector of strategies of the other agents and s is the vector of secrets. let xk h k   be the strategy of agent k according to the history h k  he sees when approached. let x1k h k   = 1 if and only if the action of agent k according to the history h k  is to compute the secret  otherwise x1k h k   = 1  and let x1k h k   = 1 if and only if agent k reports  1   otherwise x1k h k   = 1. we get that the utility for agent k according to the strategies and the secrets is: uk x1 ... xn  =  prob g x1 h 1   ... x1n h n    = g s      prob x1k h k    = 1  ¡¤ ck 1. an equilibrium for the mechanism a  is a vector of n strategies   x1 ... xn   such that each agent's strategy is the best response against the other agents' strategies. that is  for each agent k and for each strategy x1k of agent k: ui x1 ... xk ... xn  ¡Ý
. we seek mechanisms which can compute the true value of g in equilibrium. in fact  it is required that a mechanism computes g with certainty. therefore we seek mechanisms that induce sufficiently many agents to access and reveal their secrets  in order for g to be computed. note that in many cases g may be computed with partial information. for example  in the case of a consensus function it is sufficient to elicit information sequentially until we get two different replies  which are truthful.
¡¡given a particular q and c1 ... cn  a mechanism a is appropriate for g  if there exists an equilibrium where g can surely be computed for all vector of agents' secrets. such an equilibrium is referred to as a computing equilibrium. an algorithm is appropriate if it induces an appropriate mechanism.
¡¡let g be an anonymous function. consider the directed graph g1 =  v 1 e1  where the set of nodes is v 1 = { i k  : i k ¡Ê z+ 1 ¡Ü k ¡Ü i ¡Ü n 1}  and the set of edges is  e1 = {  i k   i + 1 k   : 1 ¡Ü i ¡Ü n   1 k ¡Ü i}s{  i k   i + 1 k + 1   : 1 ¡Ü i ¡Ü n   1 k ¡Ü i}.
¡¡intuitively  this graph describes the possible states of information  when approaching agents while computing the value of an anonymous function  and the possible state transitions. every state describes how many agents have been approached and how many 1's have been heard so far. let g¡¥ =  v¡¥ e¡¥  be the graph induced by reducing g1 to include only nodes where the value of the function g can not be determined yet. when referring to a node v  we will abuse notation and refer also to v as an event. namely  the event v =  j l  stands for the case that j agents have been approached and l 1's  and j   l 1's  have been reported.
¡¡for every node v in g¡¥ we define the following. let piv v g  = prob zi|v   where zi is the event that agent i is pivotal for the function g. notice that since g is an anonymous function prob zi|v  is the same for each agent i and therefore piv v g  is uniquely defined. when g is clear from the context then denote it piv v . note that if v ¡Ê/ v¡¥  i.e. it is already possible to compute the value of
g  then piv v  = 1. let cmax v  ¡Ô max{c | 1   c ¡Ý piv v  ¡¤ q +  1   piv v   ¡¤ 1}. the left side of the above inequality is the utility for an agent with cost c from approaching his secret assuming all other agents approach their secrets. the right side is the utility for the agent when he doesn't approach the secret  assuming all other agents approach their secrets  and guess  1   which is the best choice for him in this case  since q ¡Ý 1 . this inequality implies that: c ¡Ü 1  1 piv v   q ¡¤piv v . this implies that c ¡Ü  1 q ¡¤piv v . hence we get: cmax v  =  1 q ¡¤piv v . notice that cmax v  is the maximal cost for which it is still rational to access the secret given the information v  assuming the others access their secrets .
¡¡the following example illustrates why is it useful to use sequential-simultaneous mechanisms. consider the following setup. let g be the majority function  n = 1  q = 1  and c 1  = 1  c 1  = 1  c 1  = 1. we can show: given the above setup there exists a sequential-simultaneous mechanism which is appropriate. on the other hand  given the above setup there does not exist a sequential mechanism which is appropriate. it is also the case that approaching all agents simultaneously is not appropriate.
1 oblivious mechanisms
an oblivious mechanism is a mechanism that partition the agents to groups and each time approach the agents from one group simultaneously without dependency on the history. both the groups and the ordering between the groups are determined in advance. that is  the agents are partitioned into groups: a1 a1 ...at. such that: sti=1 ai = {1 .. n}
 	  1 ¡Ü i 1= j ¡Ü t : ai taj =   where the group
a1 of agents is approached first  and afterwards the group a1 of agents is approached  and so on until the group at of agents is approached. however  if after a group of agents is approached and reveal their secrets  the event is such that it is already possible to determine the value of the function  then the mechanism stops.
¡¡given a function g  agents' costs c 1  ¡Ü c 1  ¡Ü ... ¡Ü c n 1   and q  a semi-natural ordering mechanism is an oblivious mechanism  where the agents are also sorted according to their cost for accessing their secrets. that is  a1 =
{c 1  c 1  ... c |a1| 1 } 
 a1 = {c |a1|  c |a1|+1  ... c |a1|+|a1| 1 } ... 
... 
at 1 = {c |a1|+¡¤¡¤¡¤+|at 1|  c |a1|+¡¤¡¤¡¤+|at 1|+1  ...  c |a1|+¡¤¡¤¡¤+|at 1|+|at 1| 1 } 
at = {c |a1|+¡¤¡¤¡¤+|at 1|  c |a1|+¡¤¡¤¡¤+|at 1|+1  ... c n 1 }
¡¡this section deals with the following: first we prove that whenever there exists an oblivious mechanism which is appropriate  there exists a semi-natural ordering mechanism which is appropriate. we then address the problem of existence: we providean efficient algorithm  that given an anonymous function g  the ci's  and q  will decide if there exist an oblivious mechanism which is appropriate. moreover  we provide an efficient algorithm that induces an appropriate oblivious mechanism whenever such a mechanism exist.
¡¡given a function g  agents' costs c 1  ¡Ü c 1  ¡Ü ... ¡Ü c n 1   and q  consider the following algorithm.
the oblivious mechanism algorithm:  oma 
 a  build the graph g1 =  v 1 e1  of the function g
 b  compute for every node v ¡Ê v 1 : piv v  and cmax v .
 c  induce the graph g¡¥ =  v¡¥ e¡¥  by reducing g1 to include only nodes where the value of the function g can not be determined yet.
 d    1 ¡Ü k ¡Ü n 1 : let lk = min{cmax k j | k j  ¡Ê v¡¥} i.e. lk is the minimum cmax among all the nodes with the same depth k in g¡¥.
 e  let i1 = 1. i1 = min{j|i1   j ¡Ü n   1 lj   li1}. i1 = min{j|i1   j ¡Ü n   1 lj   li1}.
... ir = min{j|ir 1   j ¡Ü n   1 lj   lir 1}.
...
ik = min{j|ik 1   j ¡Ü n   1 lj   lik 1} where ik satisfies  j : ik   j ¡Ü n   1 : lj ¡Ü lik
 f  let g1 = i1   i1 g1 = i1   i1 ... gr 1 = ir   ir 1 ... gk 1 = ik   ik 1 gk = n   ik.
 g  sort the agents accordingto their costs of getting to their secrets and get: c 1  ¡Ü c 1  ¡Ü ... ¡Ü c n 1 
 h  check if the following set of conditions  marked as
cond1  is satisfied: c 1  c 1  ... c g1  ¡Ü li1
l
¡¡consider the set of conditions cond1 in step  h  of the oma above. we can now provethe followinggeneral results:
¡¡theorem 1: consider an anonymousfunctiong  agents' costs c 1  ¡Ü c 1  ¡Ü ... ¡Ü c n 1   and q. if there exists an oblivious mechanism which is appropriate then cond1 is satisfied.
¡¡theorem 1: consider an anonymousfunctiong  agents' costs c 1  ¡Ü c 1  ¡Ü ... ¡Ü c n 1   and q  if cond1 is satisfied then there exists a semi-natural ordering mechanism which is appropriate.
¡¡note that given an anonymousfunction function g  agents' costs c 1  ¡Ü c 1  ¡Ü ... ¡Ü c n 1   and q  if there exists a seminatural ordering mechanism which is appropriate then there exists an oblivious mechanism which is appropriate. therefore  combining the above theorems and observations we get:
¡¡theorem 1: consider an anonymous function g  agents costs c 1  ¡Ü c 1  ¡Ü ... ¡Ü c n 1   and q. the three following claims are equivalent:  1  there exists an oblivious mechanism which is appropriate.  1  cond1 is satisfied.  1  there exists a semi-natural ordering mechanism which is appropriate.
¡¡now we can provide a complete efficient procedure that given a function g  agents' costs c 1  ¡Ü c 1  ¡Ü ... ¡Ü c n 1   and q  will check if there exists an oblivious mechanism which is appropriate. moreover  if there exist an oblivious mechanism which is appropriate  this procedure will induce an appropriate semi-natural ordering mechanism. in order to do so we repeat steps  a  -  g  of the oma. then  as in step  h  of of oma we check whether cond1 is satisfied; if cond1 is not satisfied then the procedure will return  there isn't any obliviousalgorithmwhich is appropriate and finish; otherwise  if cond1 is satisfied then the mechanism will approach the agents sequentially  in the following order  where at each phase we approach simultaneously a set of agents as described below  the agents are referred to by their costs :
  c 1  c 1  ... c g1 .
  c g1  c g1  ... c g1+g1 .
  c g1+g1  c g1+g1  ... c g1+g1+g1 .
  ¡¤¡¤¡¤
  c g1+¡¤¡¤¡¤+gk 1  c g1+¡¤¡¤¡¤+gk 1  ...  c g1+¡¤¡¤¡¤+gk 1+gk 1 
  c g1+¡¤¡¤¡¤+gk 1  c g1+¡¤¡¤¡¤+gk 1  ...  c g1+¡¤¡¤¡¤+gk 1  = c n 1 .
¡¡to sum up  given a function g  agents' costs c 1  ¡Ü c 1  ¡Ü ... ¡Ü c n 1   and q  the oma algorithm verifies the existence of an appropriate oblivious mechanism. such a mechanism  if exists  is induced by the above procedure.
¡¡oblivious mechanisms are natural and can be easily implemented. it can be shown  by means of an example; details omitted due to lack of space  that the existence of an appropriate mechanism does not necessary imply the existence of an oblivious mechanism which is appropriate. however  surprisingly  in the next sections we show that there are some important and central setups where oblivious mechanisms are sufficient for efficient and effective information elicitation. given the convenient and tractable structure of these mechanisms  this provides powerful tools for information elicitation. namely  this turned out to be the case for the classical uniform model discussed in section 1  and for the majority function  and moreover in the context of threshold functions  as discussed in section 1.
1 the uniform model
consider the case where q = 1 and g is any anonymous function. the assumption that the distribution is uniform is most standard in many basic studies in this context. consider the following algorithm:
¡¡the uniform semi-natural ordering algorithm  usno :
 a  build the graph g1 =  v 1 e1  of the function g.
 b  compute   v ¡Ê v 1 : piv v  and cmax v .
 c  induce the graph g¡¥ =  v¡¥ e¡¥  by reducing g1 to include only nodes where the value of the function g can not be determined.
 d  denote as ¦´ the following path in vn1  1 where 
 j l  satisfies that vj1 =  j l  has only one son in g¡¥  and . let  suffix from vj1
to the only leaf in g¡¥ reachable from vj1. the existence of such a path is inducedby a series of propositionsomitted from the paper due to lack of space.
 e  along ¦´    1 ¡Ü i ¡Ü n   1 : we will mark ¦·i ¡Ô
cmax vi1 
 f  check which is the first node on ¦´ that satisfies ¦·t   ¦·1
1. that is  t = min{k| 1 ¡Ü k ¡Ü n   1  ¦·k   ¦·1}.
 the fact that t   j is implied by the above mentioned propositions .
 g  sort the agents accordingto their costs of getting to their secrets and get: c 1  ¡Ü c 1  ¡Ü ... ¡Ü c n 1 
 h  check if the following is satisfied: c 1  ¡Ü ¦·1  c 1  ¡Ü ¦·1 ...  c t 1  ¡Ü ¦·1  c t  ¡Ü ¦·t  c t+1  ¡Ü ¦·t+1  ...  c n 1  ¡Ü ¦·n 1. if the above is not satisfied then finish and return  there is no appropriate mechanism for the problem   else continue to phase  i .
 i  first approach simultaneously the t agents with the lowest costs  i.e. c 1  c 1  ... c t 1 . afterwards approach each time one agent with the lowest cost among those left  i.e. first approach c t  then approach c t+1   etc  when c n 1  is approached last.
we can now prove:
¡¡theorem 1: consider an anonymousfunctiong  agents' costs c 1  ¡Ü c 1  ¡Ü ... ¡Ü c n 1   and q = 1  and let ¦·i ¡Ô cmax vi1  for every 1 ¡Ü i ¡Ü n   1 along the path ¦´. let t = min{k| 1 ¡Ü k ¡Ü n   1  ¦·k   ¦·1}. then there exists an appropriate algorithm  if and only if: c 1  ¡Ü ¦·1  c 1  ¡Ü ¦·1 ...  c t 1  ¡Ü ¦·1  c t  ¡Ü ¦·t  c t+1  ¡Ü ¦·t+1 ... c n 1  ¡Ü ¦·n 1.
¡¡theorem 1: consider an anonymousfunctiong  agents' costs c 1  ¡Ü c 1  ¡Ü ... ¡Ü c n 1   and q = 1  if there exists an appropriate mechanism then the usno algorithm induces an appropriate oblivious mechanism.
¡¡corollary 1: consider an anonymous function g  agents' costs c 1  ¡Ü c 1  ¡Ü ... ¡Ü c n 1   and q = 1.
the usno handles the problem of existence  i.e the usno will efficiently compute whether there exists any appropriate mechanism. if such a mechanism exists  the usno will output an appropriate semi-natural ordering mechanism.
1 computing the majority function
the majority function is central to voting theory  and as a result to the related multi-agent systems and distributed computing literature. consider the case where n is odd  and q   1 and the function we would like to compute is the majority function  1 i.e. if or more of the agents' secrets are 1's then the value of the function will be 1  else the value will be 1.
¡¡we will now present an efficient algorithm that induces an appropriate mechanism if such a mechanism exists. the output mechanism will be an oblivious  semi-natural ordering mechanism. denote by ¦£ the following path in the graph associated with the majority function:
v1  =  1  ¡ú  1  ¡ú  1  ¡ú ... ¡ú  n 1  n 1  ¡ú  n 1 +1  n 1  ¡ú  n 1 +1  n 1  ¡ú ... ¡ú  n 1  n 1  = vn 
 sno :
 a  compute:   1 ¡Ü i ¡Ü n   1: piv vi   and cmax vi    along ¦£.   1 ¡Ü i ¡Ü n   1 : we will mark ¦·i ¡Ô
cmax vi  
 b  check which is the first node on ¦£ that satisfies ¦·j   ¦·1. that is  j = min{k| 1 ¡Ü k ¡Ü n   1  ¦·k   ¦·1}.1.
 c  sort the agents according to their costs of getting to their secrets and get: c 1  ¡Ü c 1  ¡Ü ... ¡Ü c n 1 
 d  check if the following is satisfied: c 1  ¡Ü ¦·1  c 1  ¡Ü ¦·1 ...  c j 1  ¡Ü ¦·1  c j  ¡Ü ¦·j  c j+1  ¡Ü ¦·j+1 ...   c n 1  ¡Ü ¦·n 1. if the above is not satisfied then finish and output  there is no appropriate mechanism for the problem   else continue to phase  e .
 e  first approach simultaneously the j agents with the lowest costs  i.e. c 1  c 1  ... c j 1 . afterwards approach each time one agent with the lowest cost among those left  i.e. first approach c j  then approach c j+1   etc  when c n 1  is approached last.
we can now show:
¡¡theorem 1: consider the majority function g  agents' costs c 1  ¡Ü c 1  ¡Ü ... ¡Ü c n 1   and q  and let ¦·i ¡Ô cmax vi   for every 1 ¡Ü i ¡Ü n   1 along the path ¦£. let j = min{k| 1 ¡Ü k ¡Ü n   1  ¦·k   ¦·1}. then there exists an appropriate algorithm  if and only if: c 1  ¡Ü ¦·1  c 1  ¡Ü ¦·1 ...  c j 1  ¡Ü ¦·1  c j  ¡Ü ¦·j  c j+1  ¡Ü ¦·j+1 ...  c n 1  ¡Ü ¦·n 1.
¡¡theorem 1: consider the majority function g  agents' costs c 1  ¡Ü c 1  ¡Ü ... ¡Ü c n 1   and q  if there exists an appropriate mechanism then the sno algorithm induces an appropriate oblivious mechanism.
¡¡corollary 1: consider the majority function g  agents' costs c 1  ¡Ü c 1  ¡Ü ... ¡Ü c n 1   and q  the sno handles the problem of existence  i.e the sno will efficiently compute whether there exists any appropriate mechanism. if such a mechanism exists  the sno will output an appropriate seminatural ordering mechanism.
¡¡the computation of majority when q   1: consider the case where n is odd  and the function that we would like to compute is the majority function where q   1. in this case we can use similar techniques to the ones we used for the computing of majority where q   1. the main difference is that instead of the path ¦£ we will consider the path ¦£1:
1	n	n
. note
that the case where q = 1 is covered by the uniform model section.
1 threshold functions
given an anonymous function g. let g t  be the value of the function g when there are t  1 's and n   t  1 's. g is considered as a threshold function if there exists 1 ¡Ü r ¡Ü n such that: g 1  = g 1  = ... = g r   1  1= g r  =
g r + 1  = ... = g n   i.e. whenever there are less than r
1's among the agents then the function gets a particular value  and where there are r or more 1's the value of the function will be the other value. the majority function for example is a threshold function with where g 1  = 1.
we can now prove the following general theorems: theorem 1: consider an anonymous threshold function
g with threshold r where and agents' costs c 1  ¡Ü c 1  ¡Ü ... ¡Ü c n 1 . there exist an appropriate mechanism if and only if there exist a semi-natural ordering mechanism which is appropriate.
theorem 1: consider an anonymous threshold function
g with threshold r where  and agents' costs c 1  ¡Ü c 1  ¡Ü ... ¡Ü c n 1 . there exist an appropriate mechanism if and only if there exist a semi-natural ordering mechanism which is appropriate.
similarly to theorems 1 and 1  we can also show: theorem 1: consider an anonymous threshold function
g with threshold r where  or q ¡Ý 1 and agents' costs c 1  ¡Ü c 1  ¡Ü ... ¡Ü c n 1 . then there exist an appropriate mechanism if and only if there exist a semi-natural ordering mechanism which is appropriate.
¡¡further discussion about majority: the majority function is a particular case of a threshold function  where r =
. however when n is odd  we get. theorem 1 implies that if q ¡Ü 1 then there exist an appropriate mechanism if and only if there exist a semi-natural ordering mechanism which is appropriate. theorem 1 implies that if then there exist an appropriate mechanism if and only if there exist a semi-natural ordering mechanism which is appropriate. hence when n is odd the above holds for every q  as we have already shown before .
¡¡consider the case where g is the majority function and n is even. this implies that. theorem 1 implies that if q ¡Ü 1 then there exist an appropriate mechanism if and only if there exist a semi-natural ordering mechanism which is appropriate. theorem 1 implies that if
 then there exist an appropriate
mechanism if and only if there exist a semi-natural ordering mechanism which is appropriate. however  when n is large this implies that for almost every q there exist an appropriate mechanism if and only if there exist a semi-natural ordering mechanism which is appropriate.
