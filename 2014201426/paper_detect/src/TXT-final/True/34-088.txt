ideas about management op lisp data bases 
erik sandewall 
massachusetts institute of technology 
artificial intelligence laboratory and 
uppsala university 
sweden 

a b s t r a c t . the paper advocates the need for systems which support maintenance of lisp-type data bases  and describes an experimental system of this kind  called daba in this system  a description of the data base's structure is kept in the data base itself. a number of utility programs use the description for operations on the data base the description must minimally include syntactic information reminiscent of data structure declarations in more conventional programming languages  and can be extended by the user 
t w o reasons for such systems are seen  i  as a.i. programs develop from toy domains using toy data bases  to more realistic exercies. the management of the knowledge base becomes nontrivial and requires program support  1  a powerful way to organize lisp programs is to make them data-driven  whereby pieces of program are distributed throughout a data base a data base management system facilitates the use of this programming 
style 
the paper describes and discusses the basic ideas in the daba system as well as the technique of data-driven programs 
1. focus on the data base. 
in this paper 1 will attempt to say three things at once that stylistic experiment is undertaken not out of choice  but out of necessity the three topics are intertwined  and none of them can be discussed without the context of the others 
the first topic regards the attitude to data bases i shall argue that the current thinking about data bases in a.i has missed an important point  which can be tersely characterized as the separate identity of the data base  independently of the program s  that use it 
work reported herein was conducted partly at uppsala university. 
sweden  with support from the swedish board of technical development  and partly at the artificial intelligence laboratory of the massachusetts institute of technology. support for the laboratory's artificial tntetttgence research is provided tn part by the advanced research prolects agency of the department of defense under office of naval research contract n1-a-1. 
the second topic is a corollary of the first one  namely the design of systems for management of data bases in the new sense  in the context of a lisp or lisp-like programming system a very experimental management system for lisp data bases is described. the system provides utility operations on the data base  such as data entry  prompt the user for contributions to the data base   presentation  nice printouts  and backup  dump a part of the data base on a file  additional utilities are planned all utilities use a description of the data base's structure  which is stored in the data base itself the structure description must minimally contain syntactic information similar to what one finds in data-structure declarations in conventional programming languages. it can however be arbitrarily incremented by the user since it is in the data base  the description must itself have a description  which is also in the data base  and so on until a description which describes itself 
this system  called daba  is motivated partly by the practical problem of maintaining collections of knowledge of non-trivial size  for use in a.i. programs  and partly by my preference for a 
certain programming style  which is here called data-driven programming only a throw-away implementation of d a b a exists currently; the system is described here in order to exemplify various desirable properties in systems for base management  and not as an available tool 
the method of datadrtven programming is the third topic of the paper. that programming technique is frequently used but rarely discussed; the reader who has already used it will recognize it by a common operation in data-driven programs  namely 
	 apply  get . . . 	  	. . .   
in other words  data-driven programs are those where large parts of the program are procedures or program fragments that are stored in the data base  in a less trivial sense than as expr propmes the paper argues for the use of this technique this is relevant to the data base topic because program management tools for data-driven programs have the same requirements at data base management tools in fact  the distinction between 'program' and 'data base' becomes fuzzy and unimportant 
1 the remainder of section 1 attempts to spell out my view of data bases  and the idea that utility programs are an important tool for working with a data base in the new sense section 1 describes the basic description mechanism in the daba system  section 1 discusses data-driven programming in more detail  and section 1 
discusses some simple procedure generation techniques in datadriven programs 
one of the many definitions of 'data base' in the world of commercial computing  is *a collection of data which ts suitable for use by a variety of different programs'. it is implicit in the definition that the data base has an existence of its own  and a non-trivia  life-length  although it may develop and change during its existence  the definition implies a need for separate documentation and separate maintenance of the data base. 
this view of the data base is significantly different from what one finds in a.i in our field  the 'data base* has usually been an appendix to or a scratchpad area for the program  created during the computation  and later garbage collected  or discarded at the end of the run but the separate-identity view of the data base is appropriate also in the at context  in the following cases: - as the user-provided collections of knowledge that programs use. it has been common practice to use minimal knowledge bases when programs are run  for several reasons including memory problems   but the time now seems ripe for working with more exhaustive collections of knowledge. the problems of setting up  debugging  and editing the knowledge base then become non-trivial 
* as knowledge generated by or reorganized by programs. learning programs  in the broad sense of the word  are only useful if the acquired knowledge can be saved for use during later runs as another example  programmer's-apprentice-type programs  see e.g rich and shrobe  1  need to analyze the user's input program  and form a model of it that model has to be maintained between runs 
- as data-driven programs since programs have to be preserved between runs  it only makes sense to say that a program is a special case of a data base if the data base is so preserved. 
let the two kinds of data base be called a 'scratchpad* data base 
 temporary data base during execution of a program  and a ' p e r e n n i a l ' data base  has separate identity  separate documentation  etc.  is maintained between runs  and is designed so that it can conveniently be used by several programs . in fact  the difference is as much in the way of looking at and working with the data base  as in the design of the data base itself 
the 'perennial' or 'separate-identity' view of a data base is very similar to the ordinary lisp programmer's attitude to his program working with a program does not merely involve running it  but also various types of service work; one may take out a part of the program and re-write it  one may take out a piece of another program  adapt it  and insert it in one's own; one uses pretty-print programs  cross-indexers and other tools  to obtain readable listings and documentation for careful study of the program  and so forth the very same operations on a data base come naturally when it develops to non-trivial size. 
the major computational implication of the 'separate-identity' view of the data base is therefore the usefulness of uttuty programs. i.e. programs like pretty-printers and cross-indexers  which serve the user when he works with the data base  and which are usually called directly by the user  rather than as subroutines utility programs for operations on lisp programs are in common use  and can sometimes be used for data bases as well  such as pretty-printers  but a number of additional utilities. as wellras additional options tn existing utilities  are useful for data base operations the following are utility operations which i have often wished i had had  when working with lisp-type data bases  and which exist or are planned in the daba system: 
- i data entry utility that prompts the user for contributions to the data base in a simple case  instead of letting the user type in 
 oefprop boston mass instate  
 in an elementary object-property representation   the system would acquire the information that boston ts a city  and then prompt 
the appropriate properties by typing out for example 
	boston t 	instate -
whereupon the user can answer mass 
t h e difference in convenience and error rate is of course negligible for the extremely small toy bases that often have been used in a.i programs  but significant when one enters more practical volumes of data - in practice  a good data entry utility must allow for higher-level data representations as welt  for mixed-initiative dialogue  and for conversational conveniences such as 'undoing'  teitelman  1*  
- a dumping utility for saving collections of data on files if we again use an example in the elementary object-property representation  the filing utility needs a catalogue of carriers  such as boston above  and information about which properties of this 
carrier shall be saved  and it should generate a file which when read will re-create those properties a basic facility of this kind exists in interlisp  teitelman  1 
- presentation utilities which print out the data base or parts of it in a nice format  so that the user can work with it easily several presentation methods are possible an indentation-oriented layout is reaspnable when one prints properties which are sizable expressions  and when when one wants to print properties of properties recursively to some depth. a tabular layout with several columns is appropriate for atomic properties  and for relation-type data bases where the data base a a set of tuples such presentation utilities are similar to the dumper  except that they could also make use of information about the intended structure of properties. for example  if it is known in a separate declaration that the property under a certain indicator is to be a list which will be used as a set  then an appropriate indentation strategy could be chosen  and one might sugar the printout with curly brackets if it is known that another property is a gtnsjm atom  then one might want to print it in terms of some of its properties  rather than as its printname 
- a checking utility  to check that all properties in a collection of data satisfy the descriptions that have been made one can check against declarations of the intended structure for each property  atom of certain type  list of atoms  etc. . against redundancy rules of a   getpcbji then b   getp a.j . and so on 
- a merging utility suppose that travel cost between cities has been represented as 
gotp boston travelcosti 	 nyc  air 1 bus 1s1 
toronto  air 1 . . .   . . .   
with the obvious interpretation  boston - new york t 1 by air  etc.   and that one wants to merge two files of data with similar structure if both files contain properties for the same carrier/indicator pair such as boston/travelcost  then one must make the obvious merge of the two assigned properties  rather than let one overwrite the other a fairly general utility program could do that if provided with structure declarations for properties 
- an excerption utility the inverse of merging  for obtaining a 
1 
prescribed subset of the data base   but needs the same structure information. 
- a utility for shift of representation. suppose we want to rerepresent the travel cost information above as getpiboston.fllghtcost  -
tnyc  ust 1  toronto  ust 1  . . .   
g tp boston buscost  -  nyc  ust 1s  . . .   
either because of a whim when changing our own primary program  or in order to adapt somebody else's data to our program. such a shift should again be doable by some utility  provided with descriptions of the old and new structure  and their relation. 
the list can easily be continued it is trivial to write programs for such operations  for each application or each data base one has. but it is a bother  and one would prefer to have access to more general utility programs. more general programs are slightly harder to write  since one wants them to be usable for various higher-level data representations besides the elementary objectproperty representation. depending on the desired flexibility of the program  a utility program may range from a hacking exercise to a hard a.i problem 
when a  general  utility program is used  it must be provided with a parameter-type description of the data structure that it is to operate on that description can sometimes be integrated in the data itself  but often it is desirable to write it separately  like a set of declarations for the data representation in the latter case  it is also possible to speed up execution by partially evaluating the utility program with respect to the parameters as described in  beckmln et al  1  
if one has to write out those declarations for each utility program  then that also can be a considerable burden but it seems that the same declarations or structure descriptions could serve several utilities for example  in the elementary representation where properties are assigned to typed objects  one needs information about 
   which properties are carried by each type  used by data entry  dumping  and presentation utilities ; 
* which structure is expected for the property under a certain indicator  can be used by almost all utilities  including those for presentation  checking  merging  excerption  and shift of representation also  it would be reasonable to check for appropriate structure during data entry  
* redundancy rules  for example for property inversion  used by the checker  as discussed above  and could also be checked or generated on data entry ; 
   if higher-level data representations are used  such as contexts  property assignments to non-atomic carriers  or relational storage with pattern-directed retrieval  then all utilities need to know about the storage conventions for that representation. 
furthermore  such a structure description for the data base is also part of the desired user documentation for the data base. it is therefore a reasonable goal to have one common description which can be used by all utilities  and for documentation purposes. 
all points that have been made so far apply not only to lisp data bases  but also to conventional  'bulk* data bases  and are in fact well recognized in the latter environment the lisp environment does however offer some additional possibilities most importantly  the description of the data base can be stored in the data base itself  and still be used by the program that operates on the data base to render this more precise  it is natural to consider the data base as a collection of data blocks  where the description of a data block is a new data block which is also in the data base.  the regress terminates if some data block describes itself  the structure description of a data block will be called its meta-block. utilities can then usually be defined as operations on blocks  which use the meta-block of the argument as parameters. 
t h e idea of data blocks is in fact useful not only for distinguishing data from their description  but also for modularizing the 'primary' data  data which serve the purpose of the system  as opposed to descriptions  in the data base. a data block should then be a chunk of data which have a common structure and/or are closely related by some criterion it could consist of a set of tuples  - relations  which are stored in the data base  or  in the elementary representation  of a set of property assignments  - triples of carrier  indicator  property . 
a word of caution the term 'block' has some connotations in computing which are not intended in this context no recursive nesting of blocks or scope for identifiers is intended. it is in fact often desirable to distribute the properties of an atom to several blocks. the primary intended association of the term 'data block' is to the practice of organizing lisp function definitions into blocks' or ylles* of closely related functions. 
1. servicing utility operations. 
the daba system can be used in at least two modes. in the simplest mode  the user has one program  here called the primary program  which uses the data base a question-answering program is a standard example. as the data base attains nontrivial size  the user wants to use some utility programs on the data base. he therefore has to write down a structure description of the data base he already has daba is a system for representing and maintaining such descriptions in a systematic way  plus a collection of utility programs which use the descriptions. in the case discussed here  the primary program and the data base existed before the daba facilities were called in.  the other mode of using the system is for managing data-driven programs  and will be discussed in the next section . 
let us choose a specific example and then describe how its structure would be described to the daba system. we must here select a very simple example  which uses an object-property representation  in order to concentrate on the description the daba system is however useful for data bases with a richer structure as well. 
consider a block of property-list data about cities in the eastern united states the block is a set of property assignments  or triples  such as 
uboston. instate  r1ass . 
 boston  suburbs   lexington. revere ... i   
    	  
 nycf instate. ny   
  a * 
 mass  hasc1ties  iboston  lexington  . . . 1 . 
1  mass  fullnatle  massachusetts  
which of course says that boston is in the state of massachusetts  and so on  '...' indicates continuation and is not intended to be in the data base . each data block has a name  which may be atomic  but does not have to be  let the atom us-east be the name of the above block 
a qlisp-like notation will be used  with angle brackets     for tuples = lists  curly brackets {...} for sets  and square brackets  ...  for free property-lists a property-list  ii vl 1 v1 .  is a set of assignments of vk to ik  to the square bracket expression is really an abbreviation for 
f 1 vt   1 v1  ... } 
lisp function definitions will be written with round parentheses  ... . all these types of parentheses are assumed to map into ordinary parentheses in the actual implementation. in other words  the knowledge that a certain list represents a set rather than a tuple  is not assumed to be available in that item itself 
it will be more convenient to specify the contents of blocks using the access function dgetp c  i   n l   where c is a carrier  i an indicator  n a block name  and the function returns the corresponding property-value the block contents above can therefore be described as 
dgetp  boston  instate.us-east  = mass dge tp  boston. suburbs  us-east  = 
 lexington. revere  . . . i 
    * 
the description of a block in daba consists of two parts consider a data block  of which us-east is a toy example  and a program which uses the block as a data base for question answering or some similar purpose one could write down several different blocks  using the same conventions  and the program would then presumably be able to use any of these blocks the description of representation shall contain a specification which is common to these blocks  and which therefore encodes some of the conventions that are assumed by the program by contrast  the description of extent contains a catalogue of the contents of each block  and other information which is local to the block there are several reasons for making such a distinction: economy of storage for the shared part of the description is an obvious reason also  the previously mentioned possibility of partially 
evaluating a utility or other parameter-driven program with respect to the data base description  is only worthwhile if the part of the description that is being kept fixed  can be factored out.  there are however also ways of avoiding the distinction  in special cases when one does not want to make it . 
the common denominator for the two descriptions is the sorts. in the present example  one immediately recognizes different sorts of carriers. city  state  etc the description of extent for a block includes a catalogue of the carriers in each of the sorts  represented as: 
	ngetp ius-east.nodes! 	-
        city  boston  nyc... i  state  mass  n y . . . i . . . 1 while the description of structure includes the information of what indicators are used by objects in each sort  for example that objects of type city may carry properties under the indicators 
instate  suburbs  etc 
the function ngetp is used for getting properties of bkxknames  in the description of the blocks extent the function may sometimes simply make an access in the property-list of its first argument  in which case it is synonymous to the interlisp getp  but it may also compute its value by default from an appropriately stored procedure  handle non-atomic block names  etc. 
the description of extent also includes information about the location of the block  for example 'as global property-lists'  'as property-lists local to this block'  or as text file with name ...' the first case is expressed as 
ngetp  us-east  atloc  - global 
the conventions used in the description of extent are to some degree arbitrary one might prefer to split up the nodes property so that the set of sorts is obtained in one access  and the set of carriers in a sort is obtained in one access for each sort. 
such changes would not be significant. 
the meta-block of us-east  - its description of representation  is another btocv  whose name might be cities the relationship is indicated by 
	getp us-east fletaj 	- cities 
some minimally needed information in the meta-block is  first  which indicators are carried by objects in each sort in the described block. thus  since boston and nyc have properties under the indicators instate and suburbs  and since they are in the sort ci ty  one should have 
 dgetplcity.carrprops cities! = unstate suburbs .. i and likewise 
dgetp  state carrprops ci ties  = 
       ihascities.hascapital...i and so on. 
the meta-block should also contain information about the expected structure of properties in our example  we know that properties under the indicator instate shall be atoms of the sort state  that suburbs properties shall be sets of cities  and so on such conventions could be encoded in a straight-forward fashion as 
dgetp  instate propstruc ci ties  -  sort state  dgetp  suburbs  props truc  cities  -  set  sort city   
in our simple example  all names  block names  carriers  indicators  sort names  etc.  have been atoms that is however not necessary  and in descriptions of less trivial representations it is frequently useful to let them be non-atomic 
1 the meta-block contains information which might occur as declarations in some other programming languages  and in the data description language of a management system for large data bases the important difference is that here the meta-description is a new data block  so that  he user can use and extend that information according to his own needs for example  it would be natural to extend the meta-block with information which relates the primitives for this data block  sorts and indicators  in this simple example  to user-oriented concepts in a model of the intended application. 
in the actual system  each block may be associated with a number of 'satellite' blocks which provide additional but optional information user additions ro a meta-block are usually best organized as a new satellite block  rather than as a change in the original meta-block even the propstruc property is actually kept in such a satellite 
very often one wants to define access procedures for properties  which compute the property from other data in the system  looks up default values  stores properties in alternative locations  etcetera the meta-block therefore always contains an access function for each indicator  for example as: 
dgetpunstate.accessfn cities  - xgetp 
where kgetp i% the default access function which does a trivial  explicit  lookup suppose however that one would want to define a block us-east1 as an update of us-east  so that properties in us-east1 use properties in us-east as default the block us-east1 would be described similarly to us-east  with the following amendments 
 1  ngetp us-east1 m1 f1f  - us-east this property assignment belongs to the description of extent of us-east1  1  getp us-east1 metal - citmod. us-east1 needs a 
different description of structure  in practice  its meta-block would have a non-atomic name  but we assume an atomic name here for simplicity  
 1  dgetpunstate.accessfn.citm1 -
 lambda  c i nl  or  xgetp c i nl 
 ogetp c   ingetp n 'mqdifofm ii 
and similarly for every other indicator that was assigned an access function in the old meta-hlock cities this access function takes the same arguments as the function dgetp it first checks if the property exists explicitly in the block that is mentioned as third argument  and otherwise looks it up in the default block  in the actual system  access functions have a fourth argument  and can be used fo 'get'  'put'  'delete'  and 'change' operations . 
the block cities  which is the meta-block of us-east  should also in its turn have a meta-block and a catalogue  description of extent  the sorts in the block cities are sort  containing the carriers city  state  etc  and indicator  containing the earners instate. suburbs. hascities. etc . this structure is correctly described if we have 
getpicities.metal - omega dgetpisort.carrpr1ps.omega1 = icarrpr1ps1 dgetp  indicator carrprops.omega  = 
             iaccessfn propstruci plus the appropriate properties on accessfn and propstruc it ts then correct to define 
g e t p iomega meta1 = omega 
so that o m e g a describes itself 	in general  proceeding from a 
blocks to their met a-blocks  one always eventually reaches omega  but often the path is longer than in this example. - the definition of the nodes properties for cities and omega are straightforward. 
what has been described so far is a basic description system  which might be sufficient for data blocks that use simple representations. in an environment where the user has already designed his primary program and his data base  he has to set up the description of representation as a post factum description of the conventions he has made if he needs non-trivial access functions  he has to write them himself  although with skill and luck he may be able to define them as small interface procedures that call appropriate parts of his primary program similarly  the nodes property  - the catalogue  in the description of extent can sometimes be computed when needed  from information that has already been set up by or for the primary program  and otherwise the user has to create it 
such a basic description is what is needed by utility programs as discussed earlier the intended purpose of the daba system is partly to provide a coordinated set of such utility programs  and partly to provide 'canned' higher-level descriptions. for example  in specifying the block c i t m o d in the last example above  the user should only has to specify that it modifies cities  expressed by an appropriate property assignment to the atom citmod   and that the meta-block of c i t m o d is e.g. modif  where m o d i f would be a meta-meta-block which imposes the 
appropriate defaults for access functions  nodes properties  etc in c i t m o d similar mcta-meta-blocks are or should be available for other common operations inside and between data blocks. 
1 . 	p r o g r a m / d a t a 	b a s e 	i n t e g r a t i o n . 
the d a b a system is not particularly helpful for developing conventional programs it is however believed to be useful when one uses an often used  but little recogniied programming technique that i call data-driven programming in this section i argue that data-driven programming is a significant development  and much more than a hack; and also that a daba-type system 
can facilitate the use of this method 
a common model for a program in lisp  and most other languages  is that the program is a set of procedures which call each other each procedure has a name. a call from a procedure foo to a procedure fie is manifested in that the definition of f o o explicitly mentions the name 'fie' such a textbook model of programs is not always applicable many programs are organized as a collection of procedures each of which is attached to data items in a data base  plus perhaps one part which is an ordinary program. in such a program  a procedure f may sometimes process its input data by calling procedures which are attached to them in the data base this constitutes an indirect or data-driven call from the procedure f to a procedure g. usually the procedures or program fragments are stored as properties of atoms  but they may appear anywhere in the data base 
a data-driven program then consists of some 'ordinary* procedures  and some 'data-driven' procedures which are invoked through data-driven calls in most programming languages it is difficult or impossible to implement data-driven programs  except of the very restricted kind that are obtained in case statements where the driving data are integers  fortran  algol 1  or a set of items that have been explicitly declared in the program  pascal  it is easy and straightforward to implement data-driven programs with full generality in interpreted lisp  but this programming practice is not fully recognized. interlisps makeftie system  teitelman  1  provides a lot of service in keeping track of compiled code  but assumes that it is stored in the function cell' of the atom in maclisp  moon. 1  the compiler has only very recently been provided with an option that allows it to compile functions that are not ex pr or fexpr properties one should not treat datadriven programming as 'hack'  thereby implying that it should be discouraged  or that it lacks research interest it is a powerful programming method and program structuring method for the following reasons: 

1 

----procedures obtain truly m.eaningful names. in data-driven programs  each procedure is identified not by a single name  but by a combination of such. for example  procedures that are stored directly on property-lists are identified by pairs of atoms. therefore  the identifier of a procedure can be more than 
'mnemonic': it can state the purpose of the procedure in a fashion which can be used by other parts of the program. 
for example  mcdonald's bibliography program  mcdonald  1  assumes that each blblio- graphy entry is associated with a number of properties such as author. title  etc.  and each property name has on tts property-list procedures for reading  printing  etc. that property the procedure that is identified as getlauthor.prlnt-up-fn  has such a better-than-mnemonic name the routine which goes through all desired properties of an item and applies the reading procedures of each indicator  uses the meaning embodied in the 'name*. 
- facilitates automatic program gtneration. if program generation is to go beyond the level of toy programs such as trivial sort routines  the generator must use a model of the program that is being generated the task of specifying the model  and even more the task of relating the model to the program  are particularly simple for data-driven programs the actual program generation can then often consist of generating individual data-driven procedures or code fragments. the latter case arises if each data-driven procedure has the form 
¡¡  l a m b d a  x . xfoo  code i   code 1 ...  code n   where each expression  code i  has been generated separately  and where the function foo is the 'glue' between the programs and is responsible for communication between them.  foo may be a built-in function such as or or progn  or a function written for the purpose . the pcdb system  sandewall 1. sandewall 1  haraldson 1  uses this method for program generation. 
- uses tht application languagt. and makes it eastty extensible. t h e notation that is input to a program is or should be a language which is natural to the application of the program. the same holds for the notational conventions that are used in a data base. in both cases  a program which is organized around such an application-oriented notation is likely to have a good structure  and extensions to the program immediately reflect extensions to the application 'language' 
interpreters are a classical example of data-driven programs. interpreters for conventional languages are data-driven with respect to procedure names  i.e. data of the interpreter . recent language features such as pattern-directed invocation and demons also assume that procedures are indexed from data structures  
although in this case the data of the interpreted program. the apparent power of the latest generation of a.i languages  bobrow and raphael  1  is perhaps largely due to the fact that they made data-driven programming available to users who did not think of using it explicitly the claim here is that it is often better for the user to develop his own scheme for organizing his program  in the sense of storing the procedures in the right places  instead of using a single package of high-level devices. there are also several examples of successful data-driven programming around the shrdlu program  winograd  1  can be used in support of many claims  it is also data-driven in several parts. 
the reason why this whole discussion is brought up in a paper about data base description  is that data-driven programs allow procedures to appear in arbitrary positions in the data base. there are often plenty of relationships between procedure items and other items in the data base: procedures may have been generated from other data  and program analysis programs may often generate data about programs that should be stored in the data base  so that it does not have to be re-generated repeatedly it is then natural to use one's data base management system for managing programs and program descriptions as well 
t h e contrast between the situation described here  and the situation described in the previous section  is characterized by figure i. in diagram  a   the large triangle is the primary program  the small triangle the utility programs  and the data base is described by the daba system for the utility programs. in diagram  b   the primary program consists mainly of data-driven procedures which are also managed by daba 

there is also another reason: the data that data-driven procedures are associated with  can sometimes be 'object* data for the system  but very often it is natural to choose them as items that appear in the self-description of the data block  for example indicators or sort names. thus the descriptions of a data block are often an appropriate framework for organizing the program. 
most utility programs can with advantage be data-driven. for example  a presentation utility could be driven by printing procedures associated with property indicators this is a commonplace idea  but raises some practical problems. consider the following scenario: we have acquired a large data base  large by a.i standards  that is   consisting of several blocks with different structures we are also using a number of different utilities  each of which drives specialized procedures for all or some of the blocks. furthermore  descriptions of the data blocks sit around and are directly interpreted by several of the utilities  and are used for generating specialized procedures for some others. suppose now that wc want to move this battleship a bit  for example:  a  modify the structure of some data block   b  delete a data block   c  discard a utility the first operation implies a number of other changes in the system  the other two enable non-trivial garbage collections in a large system with a considerable life-length  such garbage collections are necessary  even if one has infinite memory  he still wants to know what is garbage so it does not have to be updated . 
in order to support such such simple operations  and also in order to support the user who wants to understand the system  so that he can perform more complex operations on it  one needs a model of the structure of the system. mere again the block structure and other concepts in daba are useful 

1 

let us exemplify that  again with a simple example. consider a 
pretty-printing utility program p  which operates on a data block b whose meta-block getp b fteta  - m the program p makes use of specialized printing procedures and other parameters which apply to all blocks which like b have the structure described in ft. these parameters together constitute a data block mp  they might be included in ft itself  but it is not desirable to clobber ft with auxiliary procedures for all utilities  and therefore we prefer to let each utility define its own 'satellite' block to ft . 
the block iip has the same sorts and the same catalogue as ft  but uses different carrprops assignments for example  in our initial geography example  the block ft contained propstruc and accessfn properties  for hascities and other indicators used in b. the block m would contain a printfn property for hascities  which p then uses the relationship between mp and ft should be expressed by a reference such as ngetp  m.describes  - m 
this reference should imply a default value for the nodes property of mp 
t h e meta-block for mp must be a block which describes the structure of the parameters that the program p assumes  i.e it is part of the documentation of p. in the present daba system  utility programs are integrated with their specification  so a datablock p contains both the set of procedures that make up the utility program  and the information that makes p a suitable meta-block for mp. for example  p contains a reference to the knowledge about how to compute the nodes property of ftp from its describes property  actually  that knowledge is conveyed to p by its meta-block  the structure of these blocks is illustrated in figure 1. 

this example illustrates how blocks of data are noi merely clusters with dense internal connections there are also relationships beween blocks  such as the meta relation  the describes relation  the mooifof relation  used in an example in the previous section . several other relations are important  such as the relations between a program  the block of data that was input to it  and the block of data that it produced as result relations between blocks are macro-level.descriptions  which complement the micro-level  declaration-type descriptions such as carrprops or propsthuc properties. 
1. generation of procedures. 
the daba system as such assumes that data base descriptions contains procedures  namely access functions  and specialized procedures for various utility programs in addition  many applications may involve data-driven programs as discussed in the previous section. 
where do these procedures come from  the simplest case is of course where they are always written by the user there are however several ways whereby the user can be relieved of this responsibility  or at least of some of the drudgery involved. 
one obvious method is by default computation. if the procedure does not exist  then it is computed by a procedure which may derive it from other data  ask the user  etc this is accomplished in a simple and uniform fashion in daba through a recursive access-function mechanism the function dgetp which was used in section 1 to obtain data from the block uscities  is defined approximately as 
dgetp tc  i  nl 
	if 	n-omega 	then getptc.il 
else 	apply f dgetp t accessfn getpln.fletall  i i a t i c   i   n l   
in other words  in order to dgetp the hascities property of 
mass. one retrieves and uses the accessfn property of 
hascities in the meta-block 	but for that  he must retrieve the 
accessfn property of accessfn in the meta-meta-block  and so on.  at least theoretically  the recursion is sometimes shortcut . the recursion terminates at the ultimately 'meta' block omega 
this mechanism is a flexible way of defining appropriate access functions. for example  in section 1 we discussed the modified data block us-east1. which modified the block us-east  and where 
getpcus-east fteta  - cities getp us-east1 netal - citmoo ngetp us-east1.n1if1f  - us-east 
here the user should not have to write out the access functions for c! tftoo instead  there should be a data block mod which d e s c r i b e s m o d i f i c a t i o n blocks in general  so that getptcitn1 r1eta  - mod the access functions in citmoo are obtained as dgetp  acces1fn accessfn nooj  and might be the one outlined in section 1. or  improved  the following: go and get the access function for the same indicator in the block cities. try using it in the current block  in this case. useast1 . if no result  then make an access in dgetp  current b l o c k   modifof  
in fact  all other system properties  for example carrprops  are accessed in the same way using dgetp it is therefore not necessary to invent a new atom as a name for cithod. its name is chosen as  mod cities   whereby it is implicitly specified to be a block whose meta is floo and which modifies the block cities  the actual daba notation ts slightly different  in general  the method of defining properties of blocks through access functions in the meta block  complements well the method of using non-atomic  'molecular'  names for blocks  where the contents of the block  or at least some of the contents  are implicit in the name of the block the advantages with non-atomic block names are analogous to the naming advantages of data-driven programs. 
utility programs which use specialized parametric procedures also access them with the function dgetp  which means that the same kinds of default mechanisms can be used for their parametric procedures such as printfn the recursive access mechanism is quite powerful  and enables one to implement a number of desirable facilities with a very small kernel system its major drawback is that higher-order access functions of access functions are usually less than transparent to read and understand efficiency may also be a problem  which hopefully can be 

1 

handled by saving access functions so they only have to be computed once  'memoization'   and ustng automatic simplification of the lower levels of access functions 
sometimes a procedure is to be buitt up and modified in several successive steps u must then be initialized in some way  for example by its meta-level access function   whereupon it can receive advlst which successively modifies it. for example  if a data-driven procedure contains or refers to a set of theorems or demons that are to be triggered by the indexing data  then each advise might contribute one more theorem or demon to the structure. a program for simplifying lisp expressions might associate with each lisp function a simplifler procedure for 
forms where it is the leading function a new simplification rule  such as 
	 car  list sx ssy   -  	ix 
would then be sent as a message to the simplifier for car  the redfun program  sandewall 1  beck man et at 1  works in this fashion  - sometimes the advise that is given to a procedure is less  uniform inter lisp  teitelman 1  contains facilities for user-specified advise to the entry and exit parts of arbitrary user procedures in the daba system  it is frequently desirable to let various items send advise to an access function or class of 
access functions  telling it where to find explicit and default data  whether and how to 'memotze' computed data  and so on. 
several of hewitt's actor ideas  creif and hewitt  1  carry over to this purpose what we have called advise is a kind of message giving advise is like an actor 'handshake1: the receiver of the messages must be the one who knows how to incorporate it into his internal structure. there is a need for actors in the sense of objects which both receive and send messages but chains of messages which trigger each other are here only a secondary purpose; the primary purpose of a message is to modify a procedure or other data item also  it is mandatory in our case to have an option for saving a protocol of which messages were sent where  so that later changes early in a message chain can perpetuate along the chain such a protocol should of course be stored as another data block  in line with the general philosophy of the system. 
this message-sending facility is not intended as some kind of programming system if the daba system is used as in section 1 of this paper  then the facility does not affect the user's primary program at all it is intended as a mechanism for performing and keeping track of updates to the data base  including data-driven procedures   so that later changes in the data base  in the separate-identity sense of the word  obtain appropriate secondary effects. also  messages are only sent 'to procedures'  loosely speaking  for changing them  not for invoking them 
1. o t h e r aspects. 
former. also  the catalogue block of the catalogue block is computed as needed  storing it explicitly would lead to an infinite regress  the resulting structure is powerful  but unfortunately also tends to become fairly complex later generations of the system will attempt to simplify it 
another aspect which has not been covered is the relationship between the description structure of daba on one hand  and problems in the representations of knowledge  such as is-a link problems and frame systems  mtnsky 1  on the other hand. information in daba meta-blocks such as carrprops and 
accessfn information corresponds vaguely to what one needs in those cases  but the correspondance is not trivial 
daba is presently a maclisp program although it should be relatively easy to transfer it to other lisp dialects. it contains simple utilities for data entry  checking  dumping  and presentation the utilities are data-driven and their structure is described within the system  as described above the current system also contains facilities for keeping track of all blocks; and a few general-purpose facilities such as comment blocks  for arbitrary other blocks  and update blocks the message-sending facility for updates of procedures has been specified and is probably the next to be implemented after that  the present implementation will probably have served its purpose  and the next generation of daba will be due 
acknowledgements. 
several members of dlu in uppsala and the mit a.i. group have taken the time to experiment with the daba system  discuss the issues raised in this paper  and look over the manuscript special thanks are due to dave mcdonald  charles rich  and 
gerry sussman of mit  and to anders ha raid son and jaak urml of dlu 
