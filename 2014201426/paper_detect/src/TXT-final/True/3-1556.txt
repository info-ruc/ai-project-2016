
the paper presents and evaluates the power of a new framework for optimization in graphical models  based on and/or search spaces. the virtue of the and/or representation of the search space is that its size may be far smaller than that of a traditional or representation. we develop our work on constraint optimization problems  cop  and introduce a new generation of depth-first branch-and-bound algorithms that explore an and/or search space and use static and dynamic mini-bucket heuristics to guide the search. we focus on two optimization problems  solving weighted csps  wcsp  and finding the most probableexplanation mpe  in belief networks. we show that the new and/or approach improves considerably over the classic or space  on a variety of benchmarks including random and real-world problems. we also demonstrate the impact of different lower bounding heuristics on branch-and-bound exploring and/or spaces.
1 introduction
graphical models such as constraint networks and belief networks have become a powerful representation framework for reasoning with deterministic and probabilistic information. these models use graphs to capture conditional independencies between variables  allowing a concise representation of the knowledge as well as efficient graph-based query processing algorithms.
모optimization tasks such as finding the most likely state of a belief networkor finding a solution that violates the least number of constraints in a constraint network are all instances of constraint optimization problems  cop . they are typically tackled with either search or inference algorithms. search methods e.g. depth-firstbranch-and-bound best-first search  are time exponential in the number of variables and can operate in polynomial space. inference algorithms  e.g. variable elimination  tree-clustering  are time and space exponential in a topological parameter called tree width. if the tree width is large  the high space complexity makes the latter methods impractical.
모in this paper we focus on search. in contrast to inference algorithms  search algorithms are less sensitive to the graph-model structure because they traverse a structureblind search space. to overcome this problem the idea of and/or search spaces was introduced in the past year  and was shown to vividly display independencies encoded in the underlying graphical model  dechter and mateescu  1 . in this paper we develop and/or branch-and-bound  aobb   a general algorithm for solving cops  which explores the and/or search tree in a depth-first manner. its efficiency depends on its guiding heuristic functions. in the past  a class of partitioning-based heuristic functions  based on the mini-bucket approximation and known as static mini-bucket heuristics was shown to be powerful for optimization problems  kask and dechter  1 . we take the idea one step further and introduce dynamic mini-bucket heuristics  which are computed dynamically at each node of the search tree. both schemes are parameterized by the mini-bucket i-bound  which allows for a controllable trade-off between preprocessing and search.
모we apply the and/or algorithms to two common optimization problems: solving weighted csps  bistarelli et al.  1  and finding the most probable explanation  mpe  in belief networks  pearl  1 . we experiment with both random models and real-world benchmarks. our results show conclusively that the new and/or branch-and-bound algorithms improve dramatically over traditional or ones  especially when the heuristic estimates are inaccurate and the algorithms rely primarily on search rather than on pruning.
1 background
a finite constraint optimization problem  cop  is a six-tuple
p = hx d f     zi  where x = {x1 ... xn} is a set of variables  d = {d1 ... dn} is a set of finite domains and f = {f1 ... fm} is a set of constraints. constraints can be either soft  cost functions  or hard  sets of allowed tuples . without loss of generality we assume that hard constraints are represented as  bi-valued  cost functions. allowed and forbidden tuples have cost 1 and   respectively. the scope of function fi  denoted scope fi    x  is the set of arguments of fi. the operators   and   can be defined using the semi-ring framework  bistarelli et al.  1   but in this paper we assume that:  ifi is a combination operator   ifi 뫍 {qi fi pi fi} and  y f is an elimination operator 
 y f 뫍 {maxs y f mins y f}  where s is the scope of function f and y   x. the scope of  y f is y .
모an optimization task is defined by  where z   x. a global optimization is the task of finding the best global cost  namely z =  . for simplicity we will develop our work assuming a cop instance with summation and minimization as combination and elimination operators  and a global cost function defined by.
모the primal graph of a cop instance has the variables x as its nodes and an arc connects any two variables that appear in the scope of the same function.
모in practice  most complete cop solvers follow a depth-first branch-and-boundstrategy which maintains an upper bound  the best solution cost found so-far  and a lower bound on the optimal extension of the current assignment. value pruning occurs as soon as the lower bound exceeds the upper bound.
1 and/or search spaces
the usual way to do search  i.e. or search  is to instantiate variables in turn  following a static/dynamic linear ordering. this process defines a search tree  i.e. or tree   whose nodes represent states in the space of partial assignments.
모one way to exploit the independencies encoded by the graphical model is to introduce and nodes into the search space  which will decompose the problem into separate subproblems. in the past year   dechter and mateescu  1  introduced the concept of and/or search spaces for constraint networks  belief networks  and for graphical models in general. the and/or search space is defined using a back-bone pseudo-tree arrangement of the primal graph.
definition 1  pseudo-tree  given the primal graph g of a cop instance p  a pseudo-tree is a rooted tree with the same set of vertices as g and has the property that adjacent vertices from g must be in the same branch of the rooted tree  freuder and quinn  1 .
definition 1  and/or search tree  given a cop instance p  its primal graph g and a pseudo-tree t of g  the associated and/or search tree st p  has alternating levels of or nodes and and nodes. the or nodes are labeled xi and correspond to the variables. the and nodes are labeled hxi ai and correspond to value assignments in the domains of the variables. the root of the and/or search tree is an or node  labeled with the root of t. the children of an or node xi are and nodes labeled with assignments hxi ai  consistent alongthe path from the root. the children of an and node hxi ai are or nodes labeled with the children of variable xi in t. the path of a node n 뫍 st  denoted pathst n   is the path from the the root of st to n  and corresponds to a partial value assignment to all variables along the path.
모a solution subtree solst of st is an and/or subtree such that: i  it contains the root of st; ii  if a nonterminal and node n 뫍 st is in solst then all of its children are in solst ; iii  if a nonterminal or node n 뫍 st is in solst then exactly one of its children is in solst .
example 1 consider the graphicalmodel in figure 1 a   top  describing a graph coloring problem over domains {1}. an and/or search tree based on the pseudo-tree in figure 1 a   bottom   and a highlighted solution subtree are given in fig-

	 a 	 b 
figure 1: an and/or search tree.
ure 1 b . observe that the and node hb 1 roots two independent subproblems  one represented by variable {e}  and the other by variables {c d f}.
theorem 1   dechter and mateescu  1   given a cop instance p and a pseudo-tree t  its and/or search tree st is sound and complete  contains all and only solutions  and its size is o n몫exp m    where m is the depth of the pseudo-tree.
모any search algorithm that traverses the and/or search tree in a depth-first manner is guaranteed to have a time complexity exponential in the depth of the pseudo-tree and can operate in linear space. in contrast  the time complexityof search algorithms exploring traditional or search trees is exponential in the number of variables. the arcs in st are annotated by appropriate labels of the cost functions. the nodes in st can be associated with a value  accumulating the result of the computation resulted from the subtree below.
definition 1  label  the label l xi hxi ai  of the arc from the or node xi to the and node hxi ai is defined as the sum of all the cost functions values for which variable xi is contained in their scope and whose scope is fully assigned along pathst hxi ai .
definition 1  value  the value v n  of a node n 뫍 st  is defined recursively as follows:  i  if n = hxi ai is a terminal and node then v n  = l xi hxi ai ;  ii  if n = hxi ai is an internal and node then v n  = l xi hxi ai + pn뫣뫍succ n v n뫣 ;  iii  if n = xi is an internal or node then v n  = minn뫣뫍succ n v n뫣   where succ n  are the children of n in st.
모clearly  the value of each node can be computed recursively  from leaves to root. we can show that:
proposition 1 given an and/or search tree st of a cop instance p = hx d f + mini  the value function v n  is the minimal cost solution to the subproblem rooted at n  subject to the current variable instantiation along the path from root to n. if n is the root of st  then v n  is the minimal cost solution to p.
모therefore  we can traverse the and/or search tree in a depth-first manner to compute the value of the root. this approach would require linear space  storing only the current partial solution subtree. the algorithm expands alternating levels of or and and nodes  periodically evaluating the value function of the nodes along the current path. it terminates when the root node is evaluated with the optimal cost.
1 and/or branch and bound
if each node n at the search frontier is assigned a heuristic lower-bound estimate h n  of v n   then we can calculate the most promising extension of the current partial solution subtree and prune the portion of the search space that becomes irrelevant  as part of a branch-and-bound scheme. we call h n  a static heuristic function.
1 lower bounds on partial solution trees
at any stage of the search  the current partial solution is a partial solution subtree  denoted pst . by the nature of the search process  pst must be connected  must contain the root node and will have a frontier containing all those nodes that were generated but not yet expanded. the leaves of pst are called tip nodes. in this section we will define a dynamic heuristic function of a node n relative to the current pst   which yields a more accurate lower bound on v n  than h n . for that we introduce the notions of active path  its inside and outside contexts and the active partial subtree.
definition 1 given the current pst   the active path ap t  is the path of assignments from the root of pst to the current tip node t. the inside context in ap  of ap t  contains all nodes that were fully evaluated and are children of nodes on ap t . the outside context out ap  of ap t   contains all nodes that were generated but not yet expanded and are children of the nodes on ap t . the active partial subtree apt  n  rooted at a node n 뫍 ap t  contains the sub-path between n and t  and all or children of the and nodes on it.
모for illustration consider the partial solution subtree in figure 1 b  based on the pseudo-tree in figure 1 a . the active path ap t  has tip node t = he 1i  namely it is  a = 1 b = 1 e = 1 . the shaded nodes at the left of ap t  are in in ap  and their corresponding subtrees have already been explored. out ap  includes the nodes {c f}  which are also in the search frontier. the active partial subtree apt  b  is highlighted. it contains the nodes {b hb 1i e he 1i} on ap t   the or node d from in ap  and the or node f from out ap .
definition 1  dynamic lower bound  given an active partial tree apt  n   the dynamic heuristic evaluation function of n  fh n   is defined recursively as follows:  i  if apt  n  consists only of a single node n  and if n 뫍 in ap  then fh n  = v n  else fh n  = h n ;  ii  if n = hxi ai is an and node  having or children m1 ... mk then fh n  =
;  iii  if n = xi
is an or node  having an and child m  then fh n  = max h n  fh m  .
모we can prove that fh n  is a lower bound on the optimal solution cost to the subproblem rooted at n  namely fh n  뫞 v n   and also by definition fh n  뫟 h n   indicating that the dynamic lower bound is superior to the static one.

figure 1: a partial solution subtree.
example 1 for the active partial subtree rooted at b in figure 1 b   the lower bound fh b  on v b  is computed recursively as follows: fh b  = max h b  fh hb 1i    where fh hb 1i  = max h hb 1i  l b hb 1i +v d +fh e + h f  . similarly  fh e  = max h e  fh he 1i   = max h e  h he 1i    since fh he 1i  = h he 1i .
1 the branch-and-bound procedure
in the and/or search space  we can calculate a lower bound on v n  of a node n on the active path  by using fh n . in addition  we can compute an upper bound on v n   based on the portion of the search space below n that has already been explored. the upper bound ub n  on v n  is the current minimum cost solution subtree of the subproblem rooted at n.
모in figure 1 b   the upper bound on v b  is ub b  = min  v hb 1i   = v hb 1i   and it represents the current best cost solution rooted at b. the lower bound fh b  on v b  is calculated as seen in the previous example. if fh b  뫟 ub b   then searching below t = he 1i of the active path is guaranteed not to reduce ub b  and therefore  the subtree rooted at he 1i can be pruned.
proposition 1  pruning rule  given the active path ap t  of a current pst   for any node n on ap t   if fh n  뫟 ub n  then pruning the subtree below t is safe.
모a depth-first and/or branch-and-bound  aobb  algorithm that implements this pruning rule is described in figure 1. a list called open simulates the recursion stack. the list path maintains the current assignment  i.e. the active path . parent n  refers to the predecessor of n in path  which is also the parent in the and/or tree  succ denotes the set of successors of a node in the and/or tree and cht xi  denotes the children of variable xi in t. procedure lb n  computes the static heuristic estimate h n  of v n .
모step  1  is where the search goes forward and expandsalternating levels of or and and nodes. upon the expansionof n  the algorithm successively updates the lower bound function fh m  for every ancestor m of n along the active path  and discontinues search below n if  for some m  fh m  뫟 ub m .
모step  1  is where the value functions are propagated backward. this is triggered when a node has an empty set of successors and it typically happens when the node's descendants are all evaluated or when it is a dead-end. clearly  theorem 1 aobb is sound and complete for cop.
algorithm: aobb p  t 
input: a cop p =  x d f + min   pseudo-tree t  root x1.
output: minimal cost solution to p.
 1  initialize open by adding or node x1 to it; path 뫹 뷋;
 1  if  open == 뷋 
return v x1 ;
remove the first node n in open; add n to path;
 1  try to prune the subtree below n:
foreach m 뫍 path  where m is an ancestor of n if  fh m  뫟 ub m   v n  뫹 カ  dead-end 
goto step  1 ;
expand n generating all its successors as follows: succ n  뫹 뷋;
if  n is or node  denote n = xi  v n  뫹 カ
모모foreach value a 뫍 di h hxi ai  뫹 lb xi a ; succ n  뫹 succ n  뫋 {hxi ai}; else  n is and node  denote n = hxi ai 
a 뫹 {cj |  xi 뫍 var cj   뫇  var cj    path  }; v n  뫹 1; l xi hxi ai  뫹 pa cj; foreach variable y 뫍 cht xi  h y   뫹 lb y  ; succ n  뫹 {y };
add succ n  on top of open;
 1  while succ n  == 뷋
if  n is or node  v parent n   뫹 v parent n   + v n ;
else  n is and node  v n  뫹 v n  + l xi hxi ai ;
v parent n   뫹 min v parent n   v n  ;
succ parent n   뫹 succ parent n     {n}; path 뫹 path - {n}; n 뫹 last path ;
 1  goto step  1 ;figure 1: and/or branch-and-bound search  aobb .
모while the time complexity of algorithm aobb is bounded by o n 몫 exp m    the size of the and/or search space  the pruning rule is designed to yield a far better complexity.
1 specific lower bound heuristics
in this section we describe briefly two general schemes for generating static heuristic estimates h n   based on the minibucket approximation. these schemes are parameterized by the mini-bucket i-bound  thus allowing for a controllable trade-off between heuristic strength and its overhead. we also mention a third scheme which is based on the notion of directional arc-consistency and is specific to the wcsp model.
1 the mini-bucket heuristics
mini-bucket elimination  mbe   dechter and rish  1  is an approximation algorithm designed to avoid the high time and space complexity of bucket elimination  be   dechter  1   by partitioning large buckets into smaller subsets  called mini buckets  each containing at most i  called i-bound  distinct variables. the mini-buckets are then processed separately. the algorithm outputs not only a bound on the optimal solution cost  but also the collection of augmented buckets  which form the basis for the heuristics generated. the complexity is time and space o exp i  .
모static mini-bucket heuristics in the past   kask and dechter  1  showed that the intermediate functions generated by the mini-bucket algorithm mbe i  can be used to compute a heuristic function  that underestimates the minimal extension of the current assignment in a regular or search
b f : f f a     f f c  b d : f d b     f d c  	b c :	 f c a     f c b  || d c   f c  
	b e :	 f e b     f e a  
	b b :	 f b a  || e b   c b   e b  
	b a :	  || e a   f a   c a   b a  
	 a 	 b 
figure 1: schematic execution of mbe 1 .
tree. in this paper we extend the idea to and/or search spaces as well. for that  assume that a cop instance p with pseudo-tree t is being solved by aobb search  where the active path ends with some or node xj. consider also the augmented bucket structure {b x1  ... b xn } of p  constructed along the orderingresulted from a dfs traversal of t. for each possible value assignment xj = xj  the static minibucket heuristic estimate h xj  of the minimal cost solution rooted at xj can be computed as the sum of the original functions in bucket b xj  and the intermediate functions 뷂k that were generated in buckets b xk   where xk is a descendant of xj in t  more details in  kask and dechter  1  .
모dynamic mini-bucket heuristics this idea can be pushed one step further. rather than pre-compiling the mini-bucket heuristic information  it is possible to generate it dynamically  during search. therefore  the dynamic mini-bucket heuristic computes a lower bound by the mini-bucket algorithm mbe i   at each node n in the search space  restricted to the subproblem rooted at n and subject to the current partial instantiation. specifically  h xj  is calculated as the sum of the original and 뷂k functions residing in bucket b xj   where 뷂k's are computed in buckets b xk  of xj's descendants in t  conditioned on the current assignment of the active path.
example 1 figure 1 b  shows the augmented bucket structure generated by mbe i=1  for the binary cop instance displayed in figure 1 a   along the ordering  a b e c d f ; square brackets denote the choice of partitioning. assume that during search  the active path of the current partial solution subtree is  a = a b = b  and the tip node is the or node c. the static mini-bucket heuristic estimate h c = c  = f c a +f c b +뷂f  a +뷂f c +뷂d c +뷂d b . the dynamic mini-bucket heuristic estimate h c = c   involves the same 뷂 functions generated in buckets b f  and b d   only that the 뷂's are now computed dynamically  conditioned on the current partial assignment  a = a b = b .
1 directional arc-consistency heuristics
we also adapted for the and/or search space two other successful heuristics generators  reversible dac counts  rdac   meseguer et al.  1  and maintaining full dac  mfdac   larrosa and schiex  1   which proved powerful for solving binary weighted csps  details omitted for space reasons .
1 experiments
in this section we evaluate empirically the performance of our new and/or branch-and-bound approach on two classes of
networks-aombs-aombs-aombs-aombaordac n d c t s-bbmbs-bbmbs-bbmbs-bbmbbbrdac w* h d-aombd-aombd-aombd-aombaomfdacconnectivityd-bbmbd-bbmbd-bbmbd-bbmbbbmfdaci=1i=1i=1i=1timenodestimenodestime	nodestime	nodestimenodes 1 1.1 -1m11m1	1k1	1k11k 1 -1m11m1	1m1	1m11mmedium11k11k1	1.111k11k11k1	1k1	1.1.1k 1 1.1 -1m11m11k1	1k11m 1 -1m11m11m1	1k11mlow11k11k11.111k11k11k11k11.1.1k 1 1.1 11m11k11k11.1k 1 -1m11m11k11k1	1msparse11k11.111.1.1k11k11k11.11	1ktable 1: results on random binary wcsp instances.
optimization problems: weighted csp  wcsp  and the most probable explanation  mpe  problem in belief networks1.
모weighted csp  bistarelli et al.  1; larrosa and schiex  1  extends the classic csp formalism with so-called soft constraints which assign positive integer costs to forbidden tuples  allowed tuples have cost 1 . the goal is to find a complete assignment with minimum aggregated cost. the model has numerous applications in domains such as resource allocation  combinatorial auctions or bioinformatics.
모belief networks  pearl  1  provide a formalism for reasoning under conditions of uncertainty. a belief network represents a joint probability distribution over the variables of interest. a function of the graphical model encodes conditional probability distribution of a variable given its parents in the graph  also viewed as a cost function were each tuple has associated a real cost between 1 and 1 . the mpe problem is the task of finding a complete assignment with maximum probability that is consistent with the evidence. it appears in applications such as speech recognition or medical diagnosis.
모the pseudo-tree was created as suggested in  bayardo and miranker  1   by a dfs traversal of the induced graph. the latter was computedusing the min-fill heuristic. all competing algorithms were restricted to a static variable orderingresulted from a dfs traversal of the pseudo-tree. we reportthe average effort  as cpu time  in seconds  and number of visited nodes  and nodes only for the and/or algorithms   required for proving optimality of the solution. for all test instances we record the number of variables  n   domain size  d   number of functions  c   induced width  w*  and height of the pseudotree  h . a  -  indicates that a time limit was exceeded by the respective algorithm. the best results are highlighted.
1 weighted csp
for this domain we experimented with random binary wcsp problems as well as real-world benchmarks. we consider four classes of and/or branch-and-bound  aobb  algorithms  each using a specific heuristics generator  as follows. classes s-aomb/d-aomb are guided by static/dynamic mini-bucket heuristics  aordac uses rdac based heuristics  and aomfdac maintains full dac. for comparison  we include results obtained with the classic or version of
network n d c w* h bbmfdacaomfdactime  sec nodestime  sec nodescelar1-sub1 1 1 1 1111celar1-sub1 1 1 1 1111celar1-sub1 1 1 1 11 1.1 1celar1-sub1 1 1 1 11 1.1 1celar1-sub1 1 1 1 11 1.1 1table 1: results on celar1 subinstances.
each class of algorithms  denoted here by s-bbmb  d-bbmb  bbrdac and bbmfdac  respectively.
random binary networks
our random binary wcsp class is characterized by a five parameter model hn d c t wi  larrosa and schiex  1   where n is the number of variables  d the domain size  c the number of constraints  and t the constraint tightness defined as the ratio of forbidden tuples. the costs of inconsistent tuples are uniformly randomly distributed between 1 and w.
모table 1 shows results for experiments with three problem classes containing instances with medium  low and very low connectivity. we chose a maximum penalty cost w of 1 and set the constraint tightness to 1% in order to obtain overconstrained problems. for each problem class we generated 1 instances and the time limit was set to 1 seconds. the columns are indexed by the i-boundof the mini-bucketheuristics. when comparing and/or versus or algorithms we notice a considerable improvement in terms of cpu time and number of nodes visited  especially for problems with low and very low connectivity. this observation verifies the theory because a relatively sparse problem is likely to produce a shallow pseudo-tree  which in turn enhances the performance of the and/or algorithms. in terms of the quality of the heuristics  we also observe that the static mini-buckets with a relatively large i-bound represent the best choice. however  if large i-bounds are not possible  dynamic mini-buckets with small i-bounds are preferred  especially for sparse problems. for medium and low connected problems  mfdac proves to be cost effectivewith respect to the other heuristics generators.
radio link frequency assignment problem  rlfap 
rlfap is a communication problem where the goal is to assign frequencies to a set of radio links in such a way that all links may operate together without noticeable interferences  cabon et al.  1 . it can be naturally casted as a binary wcsp where each forbidden tuple has an associated penalty cost. table 1 compares algorithms bbmfdac and aomfdac for solving 1 publicly available rlfap subinstances called celar1-subi  i = 1 ... 1 . we can see that the and/or approach is beneficial for this domain as well. in celar1-sub1  the hardest instance  aomfdac causes a cpu speed up of 1  whereas in celar1-sub1 the speed up is as much as 1. we also compared aomfdac against btd  a recent algorithm introduced in  jegou and terrioux 
1 . btd solves the max-csp version of celar1-sub1  i.e. 1 penalty costs  in about 1 sec.  whereas aomfdac proves optimality in only 1 sec. the performance of the mini-bucket based algorithms was quite poor on this domain  due to the very low quality of the heuristic estimates resulted from approximating subproblems with very large domains  up to 1 values .
networks-aombs-aombs-aombs-aomb n d w* h s-bbmbs-bbmbs-bbmbs-bbmbd-aombd-aombd-aombd-aombd-bbmbd-bbmbd-bbmbd-bbmbi=1i=1i=1i=1time	nodestime	nodestimenodestime	nodesmildew1	1k1	111.1 1 1 	-	1m1	1m11111	1k1	111.11	1k1	111.1barley-1m	-	1m11k11k 1 1 -1m	-	1m-1m-1m-1k1	1k11.1-1m-1k1	1k-	1kmunin1.1.1m11k1	1k1	1k 1 1 -1m-1m	-	1m-	1k11k11k1	1k1	1-1k-1k	-	1k1	1munin1-1m-1m1	1m1	1k 1 1 -1m-1m	-	1k-	1k-1m-1m1 1k1	1k-1k-1k-1k-1kmunin1-1m-1m11k11k 1 1 -1m-1m-1k-1m-1m11k11k11k-1k-1k-1k-1kpigs-1m11.111 1 1 -1m11k11k11k-1m11.1111m11.111table 1: results on bayesian network repository.
1 belief networks
for the mpe domain we also experimented with random networks and real-world benchmarks  but we only report on the latter due to space limitations. we compare the algorithms using the mini-bucket based heuristics generators  namely s-
aomb  d-aomb  s-bbmb and d-bbmb. notice that sbbmb is currently one of the best performing complete algorithms for this domain  kask and dechter  1 
모table 1 summarizes the results for experiments on 1 realworld belief networks from the bayesian network repository1. the time limit was set to 1 seconds. we observe again a considerable improvement of the new and/or algorithms over the corresponding or ones. if we look  for example  at the mildew instance  s-aomb 1  causes a cpu speedup of 1 over s-bbmb 1 . in conclusion  d-aomb is superior for relatively small i-bounds  e.g. barley  munin1   whereas s-aomb dominates for larger i-bounds.
1 conclusion
the paper investigates the impact of the and/or search space for graphical models on optimization tasks. we introduce a general and/or branch-and-bound algorithm and specialize it with several schemes for generating heuristic estimates that can guide the search. we focus on two common optimization problems  wcsp and bayesian mpe  and show empirically that the new and/or algorithms improve dramatically over traditional or ones on a variety of benchmarks including random and real-world problems.
모our approach leaves room for future improvements. for instance  it can be modified to traverse an and/or graph  rather than a tree  via caching. we should consider the effect of dynamic variable ordering. also  we used a rather simple scheme of generating pseudo-tree arrangements  probably having non-optimal height.
related work: aobb is related to the branch-and-bound method proposed by  kanal and kumar  1  for acyclic and/or graphs and game trees. more recently   larrosa et al.  1  extended pseudo-tree search  freuder and quinn  1  to optimization tasks in order to boost the russian doll search for solving weighted csps. the optimization method developed in  jegou and terrioux  1  can also be interpreted as an and/or search graph algorithm  however it is not a linear space algorithm.
acknowledgments
this work was supported in part by the nsf grant iis1 and the muri onr award n1-1.
