 
constraint satisfaction problems are widely used in artificial intelligence. they involve finding values for problem variables subject to constraints that specify which combinations of values are consistent. knowledge about properties of the constraints can permit inferences that reduce the cost of consistency checking. in particular  such inferences can be used to reduce the number of constraint checks required in establishing arc consistency  a fundamental constraint-based reasoning technique. a general ac-inference schema is presented and various forms of inference discussed. a specific algorithm  ac-1  is presented  which takes advantage of a simple property common to all binary constraints to eliminate constraint checks that other arc consistency algorithms perform. the effectiveness of this approach is demonstrated analytically  and experimentally on real-world problems. 
1 introduction 
1 	overview 
constraint satisfaction problems  csps  occur widely in artificial intelligence. they involve finding values for problem variables subject to constraints on which combinations are acceptable. for simplicity we restrict our attention here to binary csps  where the constraints involve two variables. 
¡¡binary constraints are binary relations. if a variable i has a domain of potential values di and a variable j has a domain of potential values dj  the constraint on i and 
j  rij  is a subset of the cartesian product of di and dj. if the pair of values a for i  denoted by  i  a   and b for j  denoted by  j  b   is acceptable to the constraint rij between i and j  i.e. a member of the cartesian product  we will call the values consistent  with respect to rij . asking whether a pair of values is consistent is called a constraint check. 
¡¡constraints can be represented implicitly  where a computation  or a real-world process  is needed to answer constraint check questions  or explicitly  where the 
1 	constraint satisfaction 
answer is already recorded in a data base. implicit constraint checks could be very costly to compute. even if the constraints are represented explicitly in a form that permits quick computation there may be an enormous number to compute  along with associated decisions about which checks to make and how to use the results. as a result much of the work on constraint reasoning has focused on ways to reduce the number of constraint checks required. 
¡¡constraint algorithms often seek to establish support for a value a 1 di  i.e. to find a value for a variable j that is consistent with  i a   or to determine that no such value exists . traditionally constraint checks have been used to establish support. this paper proposes to reduce constraint checks by using metalevel knowledge to infer support. we will demonstrate that one such inference can save many additional constraint checks  ensuring that the benefits of these inferences can more than offset the costs associated with making and exploiting them. 
¡¡we apply this approach to building a schema for arc consistency algorithms. arc consistency is one of the most basic and useful constraint reasoning processes. thus arc consistency algorithms have been the subject of much interest  mackworth and freuder  1 . the new algorithm schema  ac-inference  permits use of inferred support. we identify several properties of constraints that permit such inferences. we hope that ac-inference will permit the exploitation of many other generic and problem domain specific properties of constraints. furthermore  the metaknowledge inference approach should also be extensible to higher order consistency  freuder  1 . 
¡¡we refine the schema to build a specific  new arc consistency algorithm ac-1. ac-1 is a general arc consistency algorithm  since it does not depend on special properties of a limited class of constraints  but simply utilizes the knowledge that support is bidirectional:  i  a  supports  j  b  if and only if  j  b  supports  i a .  it is tempting to assume that a special class of undirected constraints is required here; but a careful reading of  mackworth  1  should demonstrate that this is not the case.  
¡¡ac-1's exploitation of bidirectionality gives it a computational advantage over other general purpose arc consistency algorithms  and restricting attention to bidirectionality also permits an implementation with space efficiency comparable to the best of these algorithms  which is not possible for the ac-inference schema in general. constraint programmers tell us that space can be a major issue for practical applications. on the other hand  ac-inference permits us to obtain additional computational efficiency by taking advantage of knowledge about a restricted class of constraints. we demonstrate each of these advantages experimentally in real-world applications. we also provide analytical evaluation of ac-1  specifically refuting an optimality claim for an earlier algorithm  ac-1  bessiere and cordier  1 . 
1 	relation to previous work 
for some time the state of the art resided in two algorithms  ac-1  mohr and henderson  1   which has optimal worst-case behavior  and ac-1  mackworth  1   which often exhibits better average-case behavior  wallace  1 . two ac-1 algorithms  one by deville and van hentenryck  deville and hentenryck  1  and another by perlin  perlin  1   permit exploitation of certain specific constraint structures  but reduce to ac-1 or ac-1 in the general case. recently bessi1re and cordier have developed ac-1  which retains the optimal worst-case behavior of ac-1 while improving on the average-case behavior of ac-1  bessiere and cordier  1 . the new algorithm schema  ac-inference  owes something to all these predecessors  but permits use of inferred support; ac-1 is most closely related to ac-1. this paper merges and extends previous independent work by the authors  bessiere and regin  1; 1; freuder  1 . 
¡¡the potential redundancy in processing of bidirectional support has been recognized before. when ac-1 removes a value from the domain of variable x because it has no support in variable y  it realizes that this cannot cause a value of y to become bereft of support at x. deeb  gaschnig  1  uses a  revise-both  procedure that more directly anticipates ac-1. after the values for x are checked for support at y  values for y are immediately checked for support at x  but only those y values that have not just provided support for x values are checked. gaschnig points out that this avoids unnecessary checks performed by ac-1 the first time the domains of x and y are checked against each other; but he incorrectly  it seems to us  concludes that deeb also avoids all the checks that ac-1 avoids by utilizing bidirectionality. 
¡¡neither algorithm  however  has any long term memory of inferences based on bidirectionality. for example  suppose that the first value  x1 and last value  x1  among a hundred values for x are found to be supported by a value y for y. if later x  is deleted during the constraint propagation process  neither ac-1 nor deeb will remember that y still is supported by x1- in fact they may need to look at the other 1 values for x before  rediscovering  that y is supported by :x1- more generally  both ac-1 and deeb are  arc revision  oriented  while ac-1 is  support maintenance  oriented  in the spirit of ac-1. as a result  ac-1 will have the same sort of constraint check advantage over ac-1 that has been 

b ac-1 and ac-1 c. bidirectional 

d. 	irreflexive 	c. 	commutative 	f. irretflexive and commutative 
figure 1: making inferences. 
demonstrated for ac-1  plus the additional advantage provided by inferences based on bidirectionality. 
1 inferring support 
1 	principle 
we illustrate the principle of inferring support with a simple coloring problem example. consider a trivial one for illustration purposes. the problem is to assign a color  a  aquamarine   b  blue  or c  coral   to each of two countries  x and y  such that x and y have different colors. as a csp  the countries are the variables  the colors the values. the constraint between the two variables specifics that the two countries cannot have the same color  i.e. it is a not-equal constraint . 
¡¡a value   z a   is arc inconsistent if there is a variable for which there is no value that supports  i a . we achieve arc consistency by removing all arc inconsistent values or in this simple coloring problem by verifying that there are no arc inconsistent values. in general  removing one value may make another value arc inconsistent  so we say that achieving arc consistency can involve a constraint propagation process. however  in this simple example we do not have to worry about that. 
¡¡the ac-1 arc consistency algorithm operates by first checking for all possible support. it stores summary information in support counters  and is later able to implement constraint propagation efficiently when propagation is required  by updating the counters rather than by performing further constraint checks. however  its brute force initial processing is costly; it performs all possible constraint checks twice  this total can be reduced when values are deleted during initial processing . eighteen constraint checks are required for this little problem. these are shown in figure la. the values for country 
x are on the left  for country y on the right. an arrow from a value u for a  to a value v for y indicates that a check of the consistency of  x u  with  y v    denoted by rxy u v    has been computed while seeking support for  a'  u . the double ended arrows indicate that redundant checks were made  while seeking support for both  x u  and  y v . a solid arrow indicates that the check established consistency; a dashed arrow indicates that the check established inconsistency. 
¡¡ac-1 seeks only to establish that each value has a 
¡¡supporting value  at every other variable . this only 
	bessiere  freuder  and regin 	1 
requires 1 constraint checks here  figure lb   but some of them are redundant. in general  ac-1 propagation can involve additional redundant checking  but this does not enter in here. ac-1 can improve on ac-1 by avoiding some redundant checking during propagation. if the support it finds initially is deleted  it proceeds on from that point to look for another support; it does not need to  start over  as ac-1 does. however  in this simple example  ac-1 has no opportunity to exhibit this additional intelligence. it too requires 1 constraint checks. 
¡¡ac-1 may check pairs once  twice  or more than twice. ac-1 checks each pair at most twice. ac-1 was said to be optimal in the sense that it only made necessary checks.  the actual number of checks it makes is still subject to processing order effects.  however  support inference based on the bidirectionality of support can reduce constraint checks further. ac-1  ac-1 and ac-1 as well  checks  for example  that  x  a  is supported by  y  1   and then separately checks that  y  b  is supported by  x a . these algorithms can not say:  oh  i already know  y b  is supported; i just found that out while looking for support for  x a  . 
¡¡the ac-1 algorithm that we propose here can  in effect  say this. after it checks  x a  against  y  b  and finds that the latter supports the former  it infers that the former also supports the latter. this inference is based upon the simple metaknowledge that support is bidirectional. utilizing such inferences  ac-1 only requires 1 constraint checks to establish arc consistency. this is shown in figure lc. large barbed arrowheads are used to indicate inferences. the double-ended arrows here  with a barb on one end  indicate a constraint check in one direction followed by a constraint inference in the other. notice that negative support information can also be inferred: after performing a constraint check to determine that  y  a  does not support  x  a   we can infer that  x a  does not support  y a . 
¡¡moreover  ac-1 is but one instance of the general principal of using constraint metaknowledge to infer or avoid constraint checks. we will illustrate this point with a couple of further examples. suppose we have further metaknowledge of these constraints. suppose we know that they are also irreflexive: rxy v v  does not hold for any v. then the number of checks can be reduced to 1. irreflexivity allows us to immediately infer that  x a  is inconsistent with  y a   making it unnecessary to check this  figure id . suppose we know that the constraints are commutative: rxy u v  = rxy v u . this permits us to reduce the number of constraint checks to 1. for example  after checking rxy a b  we can infer rxy b  a . see figure le. if we know they are irreflexive and commutative  we are down to two checks  figure if. finally  suppose we know that the constraints are inequality constraints. what does it mean to know that they are inequality constraints  well one thing it could mean is that we have an inference rule that says simply: if the constraints are inequality constraints  and the domains contain more than one element  forget arc consistency processing-the problem is already arc consistent. this reduces the processing to zero constraint checks. less dramatically  but potentially of consider-
1 	constraint satisfaction 
able significance  we may have a problem in which some of the constraints appear repeatedly involving different variables. a consistency check involving one of these  repeated  constraints can permit us to infer support information for all these variables  to the extent to which they share common domains . 
1 	schema 
the key to the inference schema  as it is to ac-1  ac-1 and ac-1  is maintaining appropriate information. ac-1 determines which values need to be rechecked to see if they are still supported. ac-1 computes a total support count initially and then updates it as values are deleted. if ac-inference needs to find support for value  i.a  at variable j  it looks through an ordered list of j values for a single supporting value  b. if b is deleted  ac-inference looks for another supporting value later in the list. 
¡¡the schema data structures are something of a hybrid of ac-1 and ac-1. conceptually  for each value  a  for each variable  i  and each other variable j  which shares a constraint with i  ac-inference maintains a support set of values from dj that support  i a   and the unchecked set of values from dj that have not yet been checked to see if they support  i  a .  values that have been checked and found not to support  i a  appear in neither set.  
¡¡maintaining these sets enables the schema to remember inferred constraint check information. positive results are remembered by adding to the support sets. negative results are remembered by deleting from the unchecked sets. like ac-1 we only have to work through the unchecked sets once; unlike ac-1 we can avoid some of those values via inference. 
¡¡the support data structures of ac-1 accept additional support during the initialization phase and can be modified to reflect deletion of support. for the schema  support can be both added and deleted throughout the processing. ac-1 proceeds through the variable domains as necessary looking for support  ignoring deleted values. the schema does the same  ignoring also values whose support status has already been inferred. the number of supporting and unchecked values can be maintained to facilitate deletion decisions. 
¡¡the schema can be expressed as a processor for two streams. 
ac-inference schema: 
initialize the seek-support stream 
establish the initial support and unchecked sets  using any initial inferences repeat until done: 
if process-deletion stream is not empty  process its first element 
else if seek-support stream is not empty  process its first element 
else done 
¡¡the seek-support stream contains value-variable pairs. if a is a value for a variable i and the variable j shares a constraint with i    i  a   j  will appear on the initial seeksupport stream. processing an element of this stream involves looking for support for the value in the unchecked set of the variable. after each constraint check a set of inferences is made  based on the outcome. the specific set of inferences chosen instantiates the schema. the process-deletion stream consists of values whose support and unchecked sets at some variable are both empty. processing a deletion involves removing it  at least conceptually  from the domain of values for its variable  and the support and unchecked sets in which it appears. 
¡¡when both the support and unchecked sets for a value with respect to a variable become empty  that value enters the process-deletion stream. this can happen either as the result of seeking support or processing deletion. when only the support set for a value with respect to a variable becomes empty  that value enters the seeksupport stream. this can happen as the result of processing a deletion. notice that we respond to deletions immediately. furthermore we recommend implementing the seek-support stream as a stack  so that the effects of deletions will propagate immediately. we believe this to be an improvement on the  two-pass  organization of ac-1 and ac-1. 
1 	ac-1 
ac-1 refines the ac-inference schema  while restricting inferences to those based on bidirectionality. since bidirectionality is a general property of constraints  ac-1 is a general purpose arc consistency algorithm. also by restricted our inferences to bidirectionality we are able to maintain a space complexity of the same order as ac-1  namely o ed   for a problem with e constraints and maximum domain size d. ac-inference  and ac-1  space complexity is quadratic in d. in some applications  the size of the problem  number of variables  size of the domains  number of constraints  is so high that it is impossible to store in memory all the support sets and unchecked sets needed by ac-inference. swapping slows down running time. ac-1 avoids the space requirements of ac-lnference by using an ac-1-like data structure to avoid the constraint checks that would be inferred by ac-inference. 
ac-1 has the following desirable properties. ac-1: 
1. never checks riija b  if there exists b' still in dj such that rij a b'  has already been successfully checked. 
1. never checks rij a b  if there exists b' still in dj such that rji b' a  has already been successfully checked. 
1. never checks rij a b  if: 
a  it has already been checked 
or b  rjt b a  has been checked. 
1. has 1 ed  space complexity. 
¡¡ac-1 lacks properties  1    1    1a   and  1b . ac-1 lacks  1    1    1b   and  1 . ac-1 lacks  1   and  1b   the properties resulting from bidirectionality. 
1 	data structure 
every time a constraint check rji b a  is performed  ac-1 needs to store this information to avoid future rij a  b  or rij a  b'  checks forbidden by properties  1b  and  1 . this storage must be done in a careful way to avoid falling into the trap of an 1 ed1  space complexity. ac-1 does this by adding two refinements to the data structures of ac-1. 
¡¡ac-1 assigns an ordering of the values in every di  checks one support  the first one  for each value  i a  on each constraint rij to prove that  i a  is currently viable. when  j  b  is found as the smallest support of  i a  on rij   i a  is added to s j b   the list of values currently having  j b  as smallest support. if  1  is removed from dj then ac-1 looks for the next support in dj for each value  i a  in s j.b . in ac-1  s i a  sets are split into s  i j  a  sets  to support property  1 : each value  i a  has a set of values supported by it per constraint instead of one for all the constraints. b e s  i j  a  implies  i a  is known as supporting  j' b  on rji then  i a  is compatible with  j b . hence  an rija.b  is checked if and only if s  ij  a  = 1  otherwise we know  i  a  has a support on rij without any new constraint check. also  arrays inf-support are added to support property  1b  for negative constraint checks and property  1a 1: inf-support  i  j   a  represents the smallest value in dj which may be compatible with  i a . in more detail the data structure of ac-1: 
  a table m of booleans keeps track of which values of the initial domain are in the current domain or not  m i a =true  =  a € di . in this table  each initial di is considered as the integer range l..|di|. we use the following constant time functions and procedures to handle di lists. last di  returns the greatest value in di if di = 1  else returns 1. if a € di last dl   next a di  returns the smallest value in di greater than a. remove a di  removes the value a from di. remove a  di  can be extended to stop the arc consistency algorithm if a was the only remaining value in di. the csp  indeed  has no solution. 
  for all a in dt  s  i j   a  contains all values b in dj for which  i a  is assigned as its current support. the current support is not necessary the smallest one  as opposed to ac-1. 
  arrays inf-support are updated by ac-1 to ensure that every b in dj compatible with  i a  is greater than or equal to inf-support  i j  a . 
  deletionstream and seeksupportstream have the same behavior as in ac-inference. handling the seeksupportstrearn as a stack seems to be an efficient heuristic because it propagates the consequences of deletions as soon as they appear  and then discovers empty domains earlier. 
1 	algorithm 
the algorithm ac-1  see fig. 1   has the same framework as ac-inference. there are two main operations: processing the deletion of a value  and seeking a new support for a value. ac-1 processes the deletion of a value  j  b  by adding in the seeksupportstrearn all the valuevariable pairs   i a   j  such that  i a  was supported by 
¡¡property  1a  held in ac-1 without inf-support arrays because we knew that  i a  was always the smallest support for values in s i a   in ac-1 we lose this strong property. 
besslere  freuder  and regin 1 


1 	constraint satisfaction 


figure 1: analysis. 
suming the variables are ordered from top to bottom. in this example the number of checks for ac-1 is 1; for ac-1 or ac-1  1  for ac-1  1. 
¡¡this example can be generalized from domain sizes of 1 to domain sizes of d  where 1 d1  checks are saved. observe that it is constructed so that d/1 of the values in the second domain  y1 to y1  must be checked  and fail  against from d/1 to d - 1 of the values in the first domain with ac-1 or ac-1  while ac-1 avoids these checks entirely. thus we have established the following: 
theorem 1 ac-1 can save 1{d1  non-inverse constraint checks for domain size d. 
¡¡notice that we have established this theorem without even considering constraint propagation  where further savings may be realized. bear in mind that inferring non-support and utilizing it immediately can justify the deletion of values. early deletions of values can lead to further savings  as we no longer have to seek support for these deleted values  or consider them as possible supports for other values. it may even lead to early discovery of unsolvability. we would expect ac-1 to show to better advantage on more tightly constrained problems  where one has to look harder to find support  and thus can benefit more when inferences preclude the need to look for support. 
¡¡we would expect ac-1 to show to best advantage on problems with structures such as those above  that can especially benefit from the undirected constraint inferences. changing the order in which values are considered can increase  or reduce  the advantage of ac-1  but since these advantages are tied to the structure of the consistency graph  and since determining consistency graph structure involves performing the very constraint checks we are trying to avoid  it is difficult to argue strongly for or against ac-1 based on such ordering considerations. however  in specific cases  we might be able to utilize metaknowledge of the consistency graph structure for effective value-ordering heuristics. 
¡¡we have been focusing on constraint checks  which are a standard measure of csp algorithm performance. of course  constraint checks alone do not tell the whole story. however  if we either assume a large enough cost per constraint check  or demonstrate a large enough savings in the number of constraint checks  the constraint check count will dominate overhead concerns. ac-1 can even permit us to cope with some situations where some constraint checks cannot be computed at all. 
1 	experimental results 
we tested ac-inference and ac-1 on two real-world problems.  since ac-inference is an algorithm that takes 

¡¡1 the number of constraint checks for mac1 is the same as the number of constraint checks for the first ac-1 call  since all support information is then in the support sets. 
¡¡1 macs was not used because it has a behavior really worse than the other algorithms  except on very easy instances where it can outperform mac1-
¡¡1 because mac1 contains the expensive initialization phase of ac-1  which is only performed at the first call   while mac1+heuristic already benefits from the good behavior of the heuristic. 
	besslere  freuder  and regin 	1 


table 1: results in number of constraint checks  #ccks  and in cpu time in seconds  time  on a sparc 1 machine 

with 1 megabytes of memory. 
rna problem shows the consequences of tackling space complexity: ac-1 and ac-inference could not process sequences larger than  hiv1   1 variables  an average of 1 values per domain  1 constraints   while ac-1 and ac-1 could process  rnasepcoli   1 variables . on the rna problem we can also remark on the small differences in performance between ac-1  ac-1 and acinference  explained by the looseness of the constraints  finding a support is easy . 
1 	conclusion 
metaknowledge about constraints can be used to infer  rather than compute  support information  and to both infer and avoid constraint checks. a variety of basic properties of constraints can be exploited in this way. the ac-inference schema permits exploitation of inferences in establishing arc consistency. ac-1 is a refinement of that schema that exploits only the bidirectionality of support; thus is a fully general arc consistency algorithm. ac-1 can exhibit significant savings over previous general arc consistency algorithms. ac-inference may prove especially useful when constraints have strong structural properties  when some constraints appear repeatedly or when support is costly to compute. 
acknowledgements 
this material is based in part on work supported by the national science foundation under grant no. iri1. we thank thomas schiex and the french centre d'electronique de i'armement for making rlfap available  christine gaspin for providing the rna problem and alan mackworth for a helpful discussion. 
