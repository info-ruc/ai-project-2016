 
the complexity of reasoning is a fundamental issue in 
 ai. in many cases  the fact that an intelligent system needs to perform reasoning on-line contributes to the difficulty of this reasoning. in this paper we investigate a couple of contexts in which an initial phase of off-line preprocessing and design can improve the on-line complexity considerably. the first context is one in which an intelligent system computes whether a query is entailed by the system's knowledge base. we present the notion of an efficient basts for a query language  and show that off-line preprocessing can be very effective for query languages that have an efficient basis. the usefulness of this notion is illustrated by showing that a fairly expressive language has an efficient basis. the second context is closely related to the artificial social systems approach introduced in  mt1 . we present the design of a social law for a multi-agent environment as primarily an instance of off-line processing  and study this problem in a particular model. we briefly review the artificial social systems approach to design of multi-agent systems  introduced in  mt1 . computing or coming up with a social law is viewed as a primarily off-line activity that has major impact on the effectiveness of the on-line activity of the agents. the tradeoff' between the amount of effort invested in computing the social law and the cost of the on-line activity can thus be viewed as an off-line vs. on-line tradeoff. 
1 	introduction 
many activities in the framework of knowledge representation and reasoning are concerned with the following task: an intelligent agent has a given representation of a 
system  or a relevant aspect of the world   and a problem that relates to this representation. its task is to solve this problem relatively efficiently. typical examples include 
*this work was supported in part by a grant from the us-israel 
binational science foundation. the first author is incumbent of 
the helen and milton a. kimmelman career development chair. 
planning and computing whether a query is entailed by a given knowledge base. the reasoning in both of these cases can be thought of as on-line reasoning: when an input is given  our algorithm should reason about the system and about the problem instance  and should find a solution to the problem. in order to handle such problems  researchers often use general schemes of knowl-
edge representation such as first order logic  mh1   logic programs  kow1   semantic networks  qui1   etc. moreover  the reasoning is then carried out using general schemes of reasoning such as resolution for theorem proving  prolog for logic programs  etc. 
   consider the following question: can our agent improve its on-line performance in a case where the model it uses  e.g.  its knowledge-base or representation of the world  is fixed  and we know ahead of time that the agent is to be asked to solve many problems with respect to this model  intuitively  it is clear that the answer should be positive; given a fixed model there should invariably be special-purpose algorithms for solving problems with respect to this particular model  instead of using general schemes of reasoning. this answer  however  is not very useful to the agent  without  our providing the agent with a way in which it can obtain such special-purpose algorithms. our aim in this paper is to consider the problem of how an initial phase of off-line preprocessing can serve to reduce the complexity of the agent's online behavior. we are especially interested in systems where agents might be presented with  perhaps exponentially  many potential problems during the on-line activity. in such a case the agent should be allowed to perform rather extensive preprocessing without increasing the amortized cost per solution significantly. specifically  we shall investigate two central contexts. the first involves an intelligent system that needs to compute whether particular formulas  queries  are entailed by its knowledge base. we present the notion of an efficient basts for a query language  and show that off-line pre-
processing can be very effective for query languages that have an efficient basis. the second context involves dynamic multi-agent activity  and is closely related to the artificial social systems approach introduced in  mt1 . 

1 	knowledge base technology 

   reactive approaches to problems in a i   related especially to planning  have been suggested in a number of works  see  agr1   ac1  . some other works suggested to compile reactive behaviors in advance  see  sch1  . however  the task of improving on-line behavior does not need to concentrate only on  real  reactive behavior. on-line behavior might refer more generally to the behavior of an agent where it faces various problems after the initialization of the system. the main task is to identify areas where off-line processing can be helpful and to suggest a particular type of solution for each such area. this is exactly the objective of this work. 
　this paper is organized as follows. section 1 contains a high-level discussion about how off-line reasoning can be used in two general scenarios. in section 1 we discuss a property of query languages that makes preprocessing of knowledge bases for these languages extremely effective. section   presents a fairly expressive query language with the property described in section 1  and considers additional examples in which off-line preprocessing is useful in the context of knowledge bases. section 1 relates the artificial social systems approach to the on-line vs. offline reasoning paradigm. 
1 	off-line versus on-line reasoning 
consider the well known problem of determining whether queries are entailed by a knowledge base  as discussed for example in  lev1 . we assume that we have a knowledge base kb expressed in some logical language  and a query language ql in which queries concerning kb are formulated. given a query  we are interested in whether kb  this problem is intractable in the generic case. moreover  even for tractable queries  the verification process might be very inefficient. 'there are two main approaches that are discussed in the al literature for overcoming this difficulty: 
1. replacing problem-solving by model checking  hv1 : discuss knowledge bases that represent specific models  so that a query needs only to be checked against a model  rather than computing whether it is logically entailed by a knowledge base. 
1. decreasing the expressive power of the knowledge base and of the query language in order to have more tractable queries. 
　the first  approach is in fact the way in which relational databases are treated in theoretical computer science. the second is concerned with finding good tradeoffs between expressiveness and complexity  as is done in the knowledge base case by  lev1   or in the case of multi-agent activity by  tm1  . 
   another potential way for decreasing complexity is the following. assume that any specific query can be verified in time /  where / might be large but feasible  e.g.  super-linear but polynomial in the size of the knowledge base k b   . the question is whether we can find a subset of a feasible size  verify off-line for each member or of q l ' whether  all of this might take a lot of time   and use this off-line processing in order to make the on-line behavior more efficient. in the next sections we illustrate how this approach can be useful. we point to a general set of queries that can be handled in this way  and discuss specific examples. notice that this approach can be treated as a type of multiple query optimization. however  the context of our query optimization  entailment by knowledge bases instead of retrieval from relational databases   and the actual way in which it is performed  off-line preprocessing instead of clever retrieval of a set of queries after their arrival  will be different from classical multiple query optimization  see  sel1  . 
   another area in which off-line design can improve online reasoning is multi-agent activity. a major issue in rnulti-agent activity is concerned with the coordination of agents' activities  see  bg1  for a collection of papers on this topic and on other topics in multi-agent activity . there are several ways for coordinating activity  such as deals and negotiations  e.g.   rg1    ds1  . here we will concentrate on a specific methodology for coordinating activity called artificial social systems. we will now briefly review the artificial social systems approach to multi-agent activity  see  mt1  and  mt1   and discuss its connection to the off-line vs. on-line idea. 
   consider the following scenario: you are the manager of a large warehouse that treats tens of customers at a time. you have just received a shipment of fifty mobile robots for the purpose of automating your warehouse. clearly  at any given time different robots will serve the needs of different clients  some of them may concurrently perform additional maintenance operations . before you can put the robots to work  you are faced with a major design problem involving how to make effective use of the robots. the artificial social systems approach to this problem  introduced in  mt1  m t 1   ten1   is to allow robots to work individually but force them to obey certain social laws  conventions  etc. the basic thesis of this approach is that the right social laws can significantly simplify both a robot's task of planning to achieve its goals  and the amount of work it needs to perform while actually pursuing the goal. the choice of these laws  however  is a delicate matter. notice that devising appropriate social laws can be considered as off-line processing  while devising a plan for achieving a specific goal in a given situation  while obeying the social order  corresponds to solving a problem on-line. we discuss this issue in greater detail in section 1. 
moses and tennenholtz 

1 	languages w i t h an efficient basis 
in this section we concentrate on off-line reasoning in the knowledge base case. we assume that each query formulated in the query language ql can be verified in time t  generally  t might be a function of the size of the knowledge base and of the size of the current query . for ease of exposition we will assume that the knowledge base kb and every query  are formulas in the language  of propositional logic. let us denote the set of primitive propositions in this logic by 
 we use  to denote the set 
of formulas of c whose primitive propositions are a subset of  as usual  we define the size  of a formula to be the number of symbols appearing in the formula. we will associate with every query language ql an infinite sequence where 
we say that a query language ql' is 
of polynomial size if there exists a fixed polynomial p i   such that denotes the number 
of elements in 
to compute any given 
query a. however  if we expect to encounter exponentially many queries of a certain size  it will be very costly to compute each one of them from scratch. in such a case it would be desirable to identify a small set of queries which  once computed  make computing other queries considerably simpler. if we consider polynormally many queries a reasonably small number  this leads to the following definitions: 
d e f i n i t i o n 1 . 1 : a set  of queries will be called a basis for ql if every query in ql is equivalent to a conjunction of elements of b. a basis is called an efficient basis if its size  as a sublanguage of ql  is polynomial. 
given these definitions  we can now show: 
t h e o r e m 1 . 1 : 	let ql be a query language  and let 
qv be an efficient basis for ql. moreover  let kb be a knowledge base and let  be an integer for which  holds. finally  lei t be an upper bound on the time it takes to compute whether . for an arbitrary  then there exists an off-line 
of complexity 1 t   poly n    after which oncan be performed in time 
　the proof of this result  as well as all other results reported on in this paper  will appear in the long version of the paper. we remark that the size of the knowledge base kb in theorem 1 plays a role only in affecting the parameter t. once the preprocessing is done  the knowledge base can be ignored  and the complexity of 
1 	knowledge base technology 
computing entailment of a query is linear in the size of the query and in logn. 
　notice that  assuming the size of a query is negligible relative to the size of kb  this result shows that in the abovcmentioned case we are able to get on-line reasoning which is much more efficient than what can be achieved without appropriate off-line computations. 
1 	efficient on-line reasoning 
in the previous section we showed that off-line preprocessing can be very effective for query languages that have an efficient basis. one wonders  however  whether this family contains any natural and/or useful query languages that can be used in practice. we now present such a query language. recall that a cnf formula is a con-
junction of clauses each of which contains a disjunction of literals.  a literal is a primitive proposition or the negation of one.  a k-cnf formula is a cnf formula where each clause contains no more than k literals. it is not hard to show: 
proposition 1: for every  the k-cnf query language has an efficient basis. 
recall that every formula of propositional logic is equivalent to a cnf formula. in particular  every formula is equivalent to a k;-cnf formula for a sufficiently large k. moreover  formulas that serve as queries to a knowledge base are likely to be expressible as k-cnf formulas for a rather small k. the language k-cnf is thus a fairly expressive query language in general  for which off-line preprocessing is a useful procedure. 
　we remark that proposition 1 can be extended somewhat beyond the purely propositional case. in particular  it applies to universal formulas of the predicate calculus that have the form where may contain function symbols and relations  but is syntactically of the form of a k-cnf formula.  here we allow as literals not only primitive propositions  but any term of the predicate calculus.  the result and the proof are the same as in the propositional case. the key point remains having a polynomial basis. 
　we now consider a concrete class of knowledge bases for which the preprocessing stage for a basis for kcnf described above can be performed using feasible resources  and can yield considerable amortized savings in the on-line computations. consider the case in which the knowledge base kb consists of a formula in disjunctive normal form  dnf . in this case we can show: 
proposition 1: testing whether a k-cnf formula φ is entatled by a dnf knowledge base kb is linear in 


notice that considering very large knowledge bases and the need for close to real-time response during the on-line activity  the above proposition points to the fact that the on-line reasoning in this case might still be rather inefficient. however  theorem 1 guarantees that with appropriate off-line processing  before any query arrives  testing whether a k-cnf formula is entailed by a dnf knowledge-base is linear in . this is significantly better than what can be achieved without off-line processing. 
   the results presented so far illustrate the fact that off-line reasoning can greatly improve the on-line performance of useful ai applications involving knowledge bases. however  a designer that decides to use such offline reasoning must be careful. a possible drawback of such reasoning might appear when we consider knowledge bases that need to be updated frequently. in such cases the contribution of off-line processing depends on the amount of updates and on the cost of updating the preprocessing performed earlier. suppose that we have two separate knowledge bases kb1 and kb1 that use the same language  that the query language for both of them is k-cnf  and that appropriate off-line reasoning was performed for each knowledge base separately. if we want to combine these knowledge bases  there is no general way for combining the respective off-line data on which much effort was spent. the designer will have to investigate whether it is worthwhile to compute all the off-line queries again  or whether in the specific case it is relatively easy to combine the off-line results. we now show a particular form of systems where the above problem can be handled efficiently. 
   one motivation for discussing knowledge bases that consist of propositions and not of specific models is the need to represent uncertainty  this issue is thoroughly discussed in  lev1  . therefore  it is often reasonable to consider knowledge bases in contexts where updates increase the degree of uncertainty in the knowledge base. for example  a knowledge base might contain a hypothesis about the relationships between x1  . . .  xn  and there might be another knowledge base that represents another alternative for these relationships. combining these alternatives corresponds to taking a disjunction between propositional formulas. in such cases the appropriate off-line computations can be easily combined. if two scientists worked on different knowledge bases  hypotheses  using off-line computations  and would like to combine their hypotheses  to see what is entailed if it might be the case that only one of the hypotheses is true   then they can combine their off-line computations easily in order to answer the on-line queries efficiently. formally  this can be formulated as follows: 
p r o p o s i t i o n 1: let kb  and kb1 be knowledge bases  let ql be a query language  and let be an efficient basis for ql. 	finally  let n 	satisfy 
 then computing the relevant off-line data for ql with respect to  given the data with respect to kb  and the data with respect to kb1 can be done in time linear in 
1 	social laws as off-line design 
the notion of artificial social systems has been suggested as a paradigm for the design of shared multi-agent environments. essentially  when a number of loosely-coupled agents are to function in a shared environment  care must be taken to ensure that the agents do not interfere with one another. conflicts should be resolved  or better yet to be avoided whenever possible. as suggested in  mt1  and  mt1   an effective way for agents to usefully coexist in a shared environment is by having them obey certain general rules  and allowing them to act independently in the context of these rules. we think of these rules as conventions or a social law. 
　the design of a social law can be thought of as an instance of off-line preprocessing whose role is to improve the agents1 ability to better attain their goals on-line. for example  we now consider the case in which agents are modelled by finite state automata  each able to perform a certain set of actions. 
　a system of dependent automata  da  is a tuple  is a set of n 
agents where each agent i is represented by a nondeterministic finite-state machine mi  and t is a state transition function for the system. each mi may be in one of a finite number of different  physical  local states from a set si  we assume that the si's are disjoint . a tuple of states  s1  . . .  sn   where  for all i  is called a configuration of the system. we denote the set of system configurations by c. we assume that at any point in time the system is in a particular configuration. at every step  agent i performs an action taken from a set a of possible actions  notice that the agent can still choose which action it will perform in a given state  since this is not necessarily determined by its state . the set of possible actions an agent can take is in general a function of the local state the agent is in. a tuple of actions  a 1   . . .  an  consisting of the actions the different agents perform at a given point  where agent i is assumed to execute a   constitutes the agents1 joint action there. the next state of every agent is a function of the system's current configuration and the joint action performed by the agents. formally this is captured by the transition function  at any given point  a goal for an agent is identified with one of its states. we assume that an agent can perform computations to plan how to attain its goal  and to determine what actions to take at any given point. 
moses and tennenholtz 
   in such a model  the success of one agent's actions may depend in a crucial way on the actions the other agents take. 	many of the issues that arise in complex multi-agent systems can already be represented in da systems. 
   an agent's plan that guarantees the attainment of a particular goal in a da system amounts to a strategy by which  regardless of what the other agents do  our agent  will attain its goal. computing such plans can be rather complex. moreover  a plan that needs to be able to respond to any possible behavior by the other agents may be very inefficient in the number of steps it takes. indeed  such a plan may often fail to exist! a da system is said to be social if it is computationally feasible for an agent to devise  on-line  efficient plans that  guarantee to attain any of its possible goals. from the point of view of artificial social systems  a number of computational questions are natural at this stage. these computational problems relate to finding a set of restrictions  called the social law  on the actions performed by different agents at different states of the original da. these restrictions will be determined off-line before the initiation of activity and will induce a system where agents are able to  efficiently  achieve their goals during the on-line activity. for example  given a da system s we may be interested in restricting the agents' actions by a social law  to yield a system  so that either: 
1. in  every agent has a plan to achieve each of its goals; 
1. in  every agent has an efficient plan to achieve each of its goals; 
1. the problem of computing plans in  is tractable; or 
1. the system  is social. 
　various assumptions about the structure of the da system  for example regarding the number of local states agents have  or the number of actions an agent can perform in every state  may affect the abovementioned computational problems. these and similar problems will apply to more complex types of systems as well. we now turn to study a particular problem in the context of da systems. let us call a plan simple if it consists of a short sequence of actions  where by short we mean that its length is at most polynomial  in the size of the da system . 1 we say that a social law for a da system s is enabling if in the system resulting from the application of the social law in s  every agent has a simple plan for attaining each of its goals from each of its local states. we can now show: 
p r o p o s i t i o n 1 . 1 : 	let n  1 be a constant. 	given a 
da system s with n agents  the problem of 	finding 	an 
enabling social law for such a system  	if one exists  	is np-complete. 
   notice that although the number of agents is constant in proposition 1  the size of the system  or  rather its representation  may vary. it depends on the number of local states the agents can be in  the number of actions they can perform  and on the number of possible transitions in the system. these parameters may vary considerably even in the case of just two agents. 
   proposition 1 answers a question of the second type in the above list. while np-completeness results are usually interpreted as evidence that a problem is hard  we interpret this result in a slightly different manner here. since social laws will be found off-line before the initiation of activity  we can spend much time in determining a social law. the proof of the proposition shows that the design process of an enabling social law can be supported by an efficient verification of whether we found an enabling social law or where we failed. thus  in generic cases  it  should be feasible to  off-line  construct an enabling social law incrementally. 
   a further restriction can provide us with answers to questions of the third and fourth type in the above list. given a da system  we say that a pair  .s /  of local states for an agent are neighbors if there exist two configurations cs ct of the system and a joint action a such that  i  in cs the agent is in state s and in ct it is in /  and  ii  performing a in cs yields the state ct. given a da system  1  a social law for this system is called determinizing if for every pair of neighbor states of the agent  in the resulting system  the agent has a simple plan 
for getting from s to t. specifically  it has a sequence consisting of a constant number of actions which  when started in s is guaranteed to reach t. notice that a determinizing social law is necessarily an enabling social law  but not vice-versa. a determinizing social law solves the third computational problem stated above  and since enabling social laws solve the second  we obtain that a determinizing social law yields a social system  and hence solves the fourth computational problem . we have: 
p r o p o s i t i o n 1: 	let n  1 be a constant. 	given a 
da system s with n agents  the problem of finding a determinizing social law for such a system  if one exists  is np-complete. 
as before  the fact the problem is np-complete can be interpreted here as relatively good news. given a candidate for a determinizing social law we will be able to efficiently verify whether it is appropriate or where it fails. thus  in generic cases  it should be feasible to  offline  construct a determinizing social law incrementally. we remark that if the local states of the agents have a 

sufficiently simple form  then the problem of finding a determinizing social law for a system of a constant number of agents can be solved in polynomial time  see  ten1  . 
　a particular case study of the design of a social law is presented in  st1 . there  shoham and tennenholtz investigate traffic laws for mobile robots that operate on an n by n grid. they present nontrivial laws that allow the robots to carry out respective tasks without collision at a rate that is within a constant of the rate it would take each of them if it had the whole space to itself. this is an example of how appropriate off-line design of social laws guarantees very effective on-line behavior. 
1 	conclusions 
this paper suggests the use of off-line processing before the initiation of a system in order to improve the online behavior of artificial systems. we investigated this approach in the framework of entailment of queries by knowledge bases  and in the context of multi-agent activity. we presented the notion of an efficient basis for a query language  and showed that off-line preprocessing can be very effective for query languages that have an efficient basis. we also showed that the language of k-cnf formulas  a useful and rather expressive language  has an efficient basis. the second context in which off-line processing is very helpful is multi-agent activity. finding an efficient and computationally tractable social law is the appropriate form of off-line processing in this case. the social law is a set of restrictions on agents1 activities that enables agents to tend to work individually but in a mutually compatible manner. this social law needs to be designed carefully and the design process might be a relatively long trial and error procedure  but when we arrive at the appropriate social law then the on-line activity becomes effective and efficient. we formulated the approach in the framework of dependent automata. in that framework  testing whether a given social law is appropriate or where it fails can be efficiently computed. this can greatly speed up the process of generating an appropriate social law. 
